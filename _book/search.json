[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "Welcome!\nShiny App-Packages covers how to create a Shiny application as an R package."
  },
  {
    "objectID": "index.html#why-this-book",
    "href": "index.html#why-this-book",
    "title": "Shiny App-Packages",
    "section": "Why this book?",
    "text": "Why this book?\nIf you’re comfortable building Shiny applications but aren’t as familiar with writing R packages, this book is for you.\nI started putting this resource together after multiple encounters with Shiny developers who had created impressive, complex apps but struggled to convert them into R packages. This problem often resulted in delays when moving their applications into a production environment.\n\n\nDid you read Mastering Shiny and want to learn more about package development?\n\n\nMastering Shiny is an excellent introduction to the captivating world of Shiny and provides a foundation of best practices for building applications. R packages are introduced in Mastering Shiny, and this chapter is a great place to start. 1 However, to fully understand and appreciate the benefits of developing your Shiny app as an R package, I’ve found it’s helpful to have an example that includes the full suite of the package development tools (loading, documenting, testing, deploying, etc.). That’s what I’ve attempted to do with this book.\n\n\nDid you read Engineering Production-Grade Shiny Apps and decide the golem framework wasn’t a good fit for your application?\n\n\ngolem is an ‘opinionated framework for building production-grade Shiny applications’ introduced in Engineering Production-Grade Shiny Apps (or EPGSA) that offers a robust and standardized way to build, maintain, and deploy production-grade Shiny apps. Whether due to the learning curve, overhead, dependencies, legacy code, or your particular deployment constraints, golem might not be the right fit for your situation.2"
  },
  {
    "objectID": "index.html#connecting-the-dots",
    "href": "index.html#connecting-the-dots",
    "title": "Shiny App-Packages",
    "section": "Connecting the dots",
    "text": "Connecting the dots\n‘Production’ usually means passing the code from your personal development environment into your company’s cloud-based server environment, which typically involves bundling your app in a structure that can be shared, installed, tested, and launched.\n\n\n\n\n\n\nWhat does it mean to ‘put something into production?’\n\n\n\n\n\n\n\n‘I think the easiest way to think about it for me is that we develop a model in one computational environment–think of this as maybe your laptop or maybe you work in a server environment–still, it’s in one place, and it turns out the software that you need to have installed there is about tuning, training, etc. Putting something into production is getting it out of that computational environment and successfully carrying it over to a new computational environment. For many people, this might be like a cloud computing environment. It might be some kind of server your organization has, and we need to take it, lift it, and then successfully have it working.’ - Julia Silge, What is ‘production’ anyway? MLOps for the curious (SatRdays London 2023)\n\nI’ve added emphasis and edited this for clarity.\n\n\n\n\n\nR packages are designed for other users to install and load into their R environment. The package structure offers a standardized way of extending R’s capabilities by adding new functionality (like developing Shiny apps!).\nThis book is a resource to help ‘connect the dots’ between building scalable Shiny applications and writing R packages. Adopting R package development practices in the early stages of your Shiny app will improve the reusability, maintainability, and shareability of all your hard work."
  },
  {
    "objectID": "index.html#what-this-book-is",
    "href": "index.html#what-this-book-is",
    "title": "Shiny App-Packages",
    "section": "What this book is",
    "text": "What this book is\nThe chapters in this book as written as a toolchain walkthrough, 3 or “a Shiny developers’ guide to a collection of computational tools and commands for creating shiny app-packages.”\nFor continuity, I’ve used code and data from the excellent Building Web Applications with Shiny (BWAS) course. The learning modules in BWAS also serve as ‘prerequisites’ for many of the chapters covered here (if you haven’t completed that course, be sure you understand the topics it covers). You’ll find each section in this book also includes a dedicated GitHub repository and branch for you to follow along."
  },
  {
    "objectID": "index.html#what-this-book-isnt",
    "href": "index.html#what-this-book-isnt",
    "title": "Shiny App-Packages",
    "section": "What this book isn’t",
    "text": "What this book isn’t\nThis book isn’t a replacement for R Packages, 2ed or Writing R Extensions. I highly suggest bookmarking both resources to return and read when you’d like to learn more about package development.\nI also won’t be recommending a particular Shiny framework or package, but I’ll cover a few popular choices, show you what they are doing ‘under the hood,’ and let you decide if you’d like to adopt some of their practices."
  },
  {
    "objectID": "index.html#what-i-assume-about-you",
    "href": "index.html#what-i-assume-about-you",
    "title": "Shiny App-Packages",
    "section": "What I assume about you",
    "text": "What I assume about you\nIf you’re reading this, I assume you’re comfortable with R, Posit Workbench, Shiny, and the tidyverse. Maybe you haven’t built a ton of applications, but you understand reactivity, and you’re comfortable with the core Shiny concepts (i.e., the UI, server, *_Input(), *_Output(), and render_* functions, etc.)."
  },
  {
    "objectID": "index.html#other-resources",
    "href": "index.html#other-resources",
    "title": "Shiny App-Packages",
    "section": "Other resources",
    "text": "Other resources\nExcellent resources have been written for Shiny, and it’s also worthwhile to consult the documentation on the core package development tools:\n\n\ndevtools\n\n\nusethis\n\n\nroxygen2\n\npkgload"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "The ‘Converting an existing app’ chapter provides an example of converting a Shiny app into an R Package. However, many of the helpful package development tools aren’t available (i.e., roxygen2 tags, NAMESPACE imports/exports, tests, vignettes, etc.).↩︎\ngolem apps are built as packages. Still, EPGSA assumes the reader is ‘comfortable with building an R package.’ (if you’re familiar with package development, EPGSA is an excellent resource).↩︎\nThe terms ‘toolchain walkthrough’ are borrowed from the excellent paper, code::proof: Prepare for most weather conditions by Charles T. Gray (https://arxiv.org/abs/1910.06964).↩︎"
  },
  {
    "objectID": "intro.html#motivation",
    "href": "intro.html#motivation",
    "title": "Introduction",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nMastering Shiny & golem (a caveat)\n\n\n\n\n\n\nThis book was written because the transition from building Shiny applications to writing R packages is complicated and involves a shift in focus, skill set, and development practices.\nThe Packages chapter from Mastering Shiny gets ‘your toes into the water of package development’, but in my opinion, is probably not enough for you to get your shiny app project into an R package that’s ready to be shipped into most production environments.\nFor example, if you happened to download or clone the monthApp example from the Packages Chapter, you may have notice a few things:\n\nDESCRIPTION contains additional fields that are not addressed.1\nmonthApp.Rproj has been configured to work with package.2\ndevtools::build() (Ctrl/Cmd + Shift + B) has been configured to have additional behaviors.3\nDependency management is discussed briefly but not documented in the application.4\nmonthApp doesn’t have any help files5 or tests.6\n\nNone of the items above make the monthApp example from Mastering Shiny incomplete or incorrect–it’s been written for an audience with a particular experience level and skill-set. Mastering Shiny assumes the reader has relatively minimal experience with R package development,7 while Engineering Production-Grade Shiny Apps and the golem package assumes it’s readers “are comfortable with building an R package.”8\nCreating a resource that covers all shiny app-package considerations while taking into account the particulars of experience level and development environment is impossible. The contents of this book are intended to merely help close the gap between developing shiny apps and writing R packages."
  },
  {
    "objectID": "intro.html#packages-help-you",
    "href": "intro.html#packages-help-you",
    "title": "Introduction",
    "section": "Packages help you",
    "text": "Packages help you\nA guiding principle throughout this book is,\nShiny app projects that you’re sharing with others belong in an R package.\nI could extend this statement to ‘most R projects,’ but it’s especially true for shiny applications destined for deployment in a production environment.9\nThe first and obvious benefit to structuring your shiny app project as a package is that it simplifies file and folder management. If every shiny app project you develop is structured as a package, it removes the time you spend manually creating directories (or re-orienting yourself to each project’s structure).\nIf you’re using Posit Workbench, the package structure will give you access to a well-designed IDE for shiny applications. Posit Workbench has tools to help develop and debug functions, create and run unit tests, store internal and external data, manage dependencies, and write help files and long-form documentation."
  },
  {
    "objectID": "intro.html#packages-help-them",
    "href": "intro.html#packages-help-them",
    "title": "Introduction",
    "section": "Packages help them",
    "text": "Packages help them\n\n“a package [is] the fundamental unit of shareable, reusable, and reproducible R code.” - R Packages, 2ed\n\nIt’s safe to assume the code used to build shiny apps being deployed to a production environment will be seen (and hopefully used) by others. R packages make sharing your hard work with your colleagues easier because it removes their need to figure out where everything is, how it all fits together, and how it all (hopefully) works."
  },
  {
    "objectID": "intro.html#scalable",
    "href": "intro.html#scalable",
    "title": "Introduction",
    "section": "Scalable",
    "text": "Scalable\nGreat R packages define and solve common problems.\nSuppose you use R to perform analyses, design data visualizations, or build and run reports. If you currently use source() to load any utility functions to perform this work, I suggest putting those functions in a package. Doing this will help extend your mental model from the specific use cases (i.e., “X code performs task Y”) to a model for their more general uses (i.e., “X package performs tasks like Y”).\nThe beauty of an R package mental model is that you’ll inevitably notice the similarities across common problems. Creating packages that define and solve common problems in your workflow can sometimes be some of the most popular/valuable contributions (see datapasta and reprex)."
  },
  {
    "objectID": "intro.html#how-to-read-this-book",
    "href": "intro.html#how-to-read-this-book",
    "title": "Introduction",
    "section": "How to read this book",
    "text": "How to read this book\nThe chapters in this book (roughly) represent the steps of R package development, but from the lens of an existing shiny application.10 Each topic can (and should) be applied when creating new app-packages. Still, in my experience, many Shiny developers have existing applications they’d like to convert into an R package.\nCode examples\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s main branch\nThe code files for each chapter are stored in GitHub repositories. Major code changes are stored in Git branches. Whenever a new branch or repo is used, you’ll see the Git Branch icon with a link to the repo in the margin."
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "The DESCRIPTION file in monthApp contains fields not included in the arguments passed to usethis::use_description() (these were added separately), and a few arguments can be adapted or removed to save time.↩︎\nThe .Rproj file is the connection between the DESCRIPTION fields, the code in the R/ folder, and the IDE’s Build pane or “package development mode.” If you already have an .Rproj file in your shiny app project, you can activate these settings under Tools &gt; Project Options &gt; Build Tools.↩︎\nThe monthApp.Rproj file contains additional settings you can add with Tools &gt; Project Options &gt; Build Tools, then under Generate documentation with Roxygen, click Configure and select Install and Restart.↩︎\nThe NAMESPACE file is empty and the Imports field is missing from the DESCRIPTION (although the chapter discusses importing shiny).↩︎\nroxygen2 is mentioned, but it’s beyond the scope of Mastering Shiny, so for now just know roxygen2 syntax is placed in the code below R/ to create the help files and the NAMESPACE.↩︎\nmonthApp doesn’t have the testing infrastructure provided by testthat, but this can be quickly created using usethis::use_testthat() (and an entire chapter is dedicated to testing.↩︎\nMastering Shiny includes an example for converting an existing application with usethis::use_description(), but not creating a new app-package (i.e., with usethis::create_package()).↩︎\nMost of the pain points/barriers to adopting golem I’ve heard from developers are related to structuring their application as a package.↩︎\nDavid Neuzerling has a great post on the benefits of structuring your project as a package↩︎\nThe original code and data for the application in this book comes from the Building Web Applications with Shiny (BWAS) course.↩︎"
  },
  {
    "objectID": "shiny.html#shiny-programming",
    "href": "shiny.html#shiny-programming",
    "title": "Shiny apps",
    "section": "Shiny programming",
    "text": "Shiny programming\nReactivity is the underlying process that allows Shiny apps to update and respond to user interactions automatically. Developing Shiny apps involves harnessing the connection between inputs, reactivity, and outputs to control and predict the application’s behavior.\nShiny programming differs from regular R programming in several key aspects:\n\n\nAn Event-driven UI: Shiny apps require developers to design and develop a user interface (UI). User experience (UX) design is an entirely separate field, but as Shiny developers, we need to know enough to allow users to interact with and navigate our apps. The UI also captures each ‘event,’ meaning that the user’s actions (such as button clicks or input changes) trigger the application’s inputs, updates, or outputs.\n\nRegular R programming often involves executing predefined steps or functions without direct interaction or responses to user events.\n\n\n\nA Reactive Server: In Shiny, the application’s behavior is determined by the dependencies between reactive inputs (i.e., the inputIds), reactive values, and outputs (i.e., the outputIds), allowing for automatic updates and propagation of changes throughout the application.\n\nIn standard R programming, we typically define a series of sequential steps (i.e., functions) that operate on data to generate output to the console or a typesetting system for technical and scientific publications (model results, graphs, tables, etc.) without accounting for reactivity or downstream changes.\n\n\n\nLearning reactivity can be challenging when you start, but fortunately, there are excellent tutorials and articles to help you along the way!"
  },
  {
    "objectID": "shiny.html#new-shiny-app-projects",
    "href": "shiny.html#new-shiny-app-projects",
    "title": "Shiny apps",
    "section": "New shiny app projects",
    "text": "New shiny app projects\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s main branch\nIf you’re creating a new application using the New Project Wizard, you’ll see the following:\n\n\n\n(a) New shiny app\n\nFigure 1: New shiny app project\n\nSelect the location of your shiny app project, then pick a name and decide whether you want to use Git or renv (I’ll be using Git).\n\n\n\n(a) Shiny app info\n\nFigure 2: New shiny app project in a Git repository\n\nAfter clicking Create Project, a new session will open with your project files."
  },
  {
    "objectID": "shiny.html#shiny-app-project-contents",
    "href": "shiny.html#shiny-app-project-contents",
    "title": "Shiny apps",
    "section": "Shiny app project contents",
    "text": "Shiny app project contents\nNote that the only items in the new shiny app project are app.R and the projApp.Rproj file.\n\nprojApp/\n    ├── app.R\n    └── projApp.Rproj\n\n1 directory, 2 files\n\napp.R\napp.R initially contains a boilerplate application, which we can launch by clicking on the Run App button:\n\n\n\n\nClick on Run App\n\n\n\n\n(a) Old Faithful geyser app\n\nFigure 3: Boilerplate Old Faithful geyser app in new shiny projects\n\nThe boilerplate ‘Old Faith Geyser Data’ app is a perfect example of what Shiny can do with a single app.R file, but we’ll want to exchange this code for a slightly more advanced application (because most shiny apps grow beyond an app.R file)."
  },
  {
    "objectID": "shiny.html#movie-review-data-app",
    "href": "shiny.html#movie-review-data-app",
    "title": "Shiny apps",
    "section": "Movie review data app",
    "text": "Movie review data app\nMost shiny applications move beyond a single app.R file. Knowing how to store any utility functions, data, documentation, and metadata will set you up for success as you transition to storing your app in an R package.\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s 02_movies-app branch\nI’m going to work through an example of some intermediate/advanced shiny app features using the application from the Building Web Applications with Shiny course. This app is a great use case for the following reasons:\n\nIt has multiple input types that are collected in the UI\nThe graph output can be converted to a utility function\nThe app loads an external data file when it’s launched\nThe code is accessible (and comes from a trusted source)\n\nApp\nThe code below replaces the boilerplate ‘Old Faith Geyser Data’ app in app.R:\n\n\n\n\n\n\napp.R\n\n\n\n\n\n\nshow/hide movie review shiny appui &lt;- shiny::fluidPage(theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\"The data represent\", \n        nrow(movies), \n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n        shiny::p(shiny::em(\"The code for this shiny application comes from\", \n          shiny::a(\"Building Web Applications with shiny\", \n            href = \"https://rstudio-education.github.io/shiny-course/\"))\n          )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  new_plot_title &lt;- shiny::reactive({\n      tools::toTitleCase(input$plot_title)\n    }) |&gt; \n    shiny::bindEvent(input$update_plot_title, \n                     ignoreNULL = FALSE, \n                     ignoreInit = FALSE)\n    \n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n        df = movies,\n        x_var = input$x,\n        y_var = input$y,\n        col_var = input$z,\n        alpha_var = input$alpha,\n        size_var = input$size\n      ) + \n      ggplot2::labs(title = new_plot_title()) + \n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\n\nUtility function\nI’ve added the scatter_plot() utility function in a new utils.R file:\n\n\n\n\n\n\nutils.R\n\n\n\n\n\n\nshow/hide scatter_plot()scatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\nData\nThe movies.RData dataset contains reviews from IMDB and Rotten Tomatoes\n\n\n\n\n\n\nmovies.RData\n\n\n\n\n\nYou can download these data here\n\n\n\nUpdated movies app project contents\nThe projApp project now contains the following files:\n\nprojApp/\n  ├── app.R\n  ├── movies.RData\n  ├── projApp.Rproj\n  └── utils.R\n\n2 directories, 4 files\n\nTo run the movies app, we need to load the data and source the utils.R file by adding the code below to the top of the app.R file:\nAfter installing the packages below, add a comment (#) in front of these lines.\n\n\n\n\n\n\napp.R header\n\n\n\n\n\nI’ve placed the header below in the top of the app.R file:\n\n# install ------------------------------------\n# after installing, comment this out\npkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# data -----------------------------------------\nload(\"movies.RData\")\n\n# utils ----------------------------------------\nsource(\"utils.R\")\n\n\n\n\nClicking on Run App displays the movie review app:\n\n\n\n\n(a) movies app\n\nFigure 4: Movie review app"
  },
  {
    "objectID": "shiny.html#project-folders",
    "href": "shiny.html#project-folders",
    "title": "Shiny apps",
    "section": "Project folders",
    "text": "Project folders\nNow that we have a slightly more complex application in app.R, I’ll add a few project folders we can include in our project that have unique built-in behaviors. These folders will help organize your files and make additional resources available to your app.\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s 03_projApp branch\nR/\nIf your shiny app relies on utility or helper functions (outside the app.R file), you can place this code in an R/ folder. Any .R files in the R/ folder will be automatically sourced when the application is run.\n\n\n\n\n\n\nPlace utils.R in R/ folder\n\n\n\n\n\nI’ve moved the utils.R file into the R/ folder in projApp:\n\nprojApp/\n     └── R/\n         └── utils.R\n\n1 directory, 1 file\n\n\n\n\nThe function that makes this process (i.e., sourcing any .R files in an R/ folder) possible is loadSupport(). We’ll return to this function in a later chapter, because the R/ folder has a similar behavior (but different function) in R packages.1\nwww/\nWhen you run a shiny application, any static files (i.e., resources) under a www/ directory will automatically be made available within the application. This folder stores images, CSS or JavaScript files, and other static resources.\n\n\n\n\n\n\nCreate www/ folder and download image\n\n\n\n\n\nI’ve downloaded the shiny logo (shiny.png) and stored it in the www/ folder.\n\nprojApp/\n     └── www/\n           └── shiny.png\n\n1 directory, 1 file\n\nIn the section below, we’ll reference shiny.png directly in the UI.\n\n\n\nFollowing the conventional folder structure will also help set you up for success when/if you decide to convert it into an app-package."
  },
  {
    "objectID": "shiny.html#project-files",
    "href": "shiny.html#project-files",
    "title": "Shiny apps",
    "section": "Project files",
    "text": "Project files\nREADME.md\nIncluding a README.md file in your root folder is a good practice for any project. README.md should contain relevant documentation for running app.R.\n\n\n\n\n\n\nCreate README.md\n\n\n\n\n\nI’ve included the content below in the README.md file\n# movies app\n\nThe original code and data for this shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`projApp` branches](https://github.com/mjfrigaard/projApp/branches/all).\n\n\n\nDESCRIPTION\nDESCRIPTION files play an essential role in R packages, but they are also helpful in Shiny projects if I want to deploy the app in showcase mode.\n\n\n\n\n\n\nCreate DESCRIPTION\n\n\n\n\n\nI’ve included the content below in DESCRIPTION:\nType: shiny\nTitle: movies app\nAuthor: John Smith\nDisplayMode: Showcase\n&lt;empty final line&gt; &lt;- delete me but leave an empty final line!\n\n\n\n\n\n\nIt’s always a good idea to leave at least one &lt;empty final line&gt; in your DESCRIPTION file.\n\nAfter adding README.md and a DESCRIPTION file (listing DisplayMode: Showcase), the movies app will display the code and documentation when the app launches.2"
  },
  {
    "objectID": "shiny.html#project-code",
    "href": "shiny.html#project-code",
    "title": "Shiny apps",
    "section": "Project code",
    "text": "Project code\nThe following two items are considered best practices because they make your app more scalable by converting app.R into functions.\nModules\nShiny modules are a ‘pair of UI and server functions’ designed to compartmentalize input and output IDs into distinct namespaces,\n\n‘…a namespace is to an ID as a directory is to a file…’ - shiny::NS() help file.\n\nModule UI functions typically wrap the layout, input, and output functions in shiny::tagList(). Module server functions typically contain the ‘backend’ code in a shiny server function. Both the UI and server module functions are linked by an id argument, which is created using shiny::NS() (namespace) in the UI function and called in the server function with shiny::moduleServer().\nVariable inputs module\nmod_var_input_ui() creates a dedicated namespace for the inputIds with shiny::NS():\n\n\n\n\n\n\nmod_var_input_ui()\n\n\n\n\n\nCode placed in R/mod_var_input.R:\n\nshow/hide mod_var_input_ui()mod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n\n\nmod_var_input_server() returns these values in a reactive list with shiny::reactive():\n\n\n\n\n\n\nmod_var_input_server()\n\n\n\n\n\nCode placed in R/mod_var_input.R\n\nshow/hide mod_var_input_server()mod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n            \"y\" = input$y,\n            \"x\" = input$x,\n            \"z\" = input$z,\n            \"alpha\" = input$alpha,\n            \"size\" = input$size,\n            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n\n\n\n\n\nScatter-plot display module\nmod_scatter_display_ui() creates a dedicated namespace for the plot outputId (as \"scatterplot\"), along with some help text:\n\n\n\n\n\n\nmod_scatter_display_ui()\n\n\n\n\n\nCode placed in R/mod_scatter_display.R\n\nshow/hide mod_scatter_display_ui()mod_scatter_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\"The data for this application comes from the \",\n        shiny::tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))\n      ),\n    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n\n\nThe code to render the output$scatterplot is contained in the nested call to shiny::moduleServer() in mod_scatter_display_server():\nAfter loading the movies data, assembling the returned values from mod_var_input_server(), and creating the input() reactive, the scatter_plot() utility function creates the plot object and adds the plot_title():\n\n\n\n\n\n\nmod_scatter_display_server()\n\n\n\n\n\nCode placed in R/mod_scatter_display.R\n\nshow/hide mod_scatter_display_server()mod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # data --------------------------------------------------------------------\n    load(\"movies.RData\")\n\n    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        # data ----------------------------------------------------\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n\n\nBoth UI and server module functions are combined into a single .R file, and all modules are placed in the R/ folder so they are sourced when the application is run.\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n └── utils.R\n\nStandalone app function\nBoth module functions are combined in the ui and server arguments of shiny::shinyApp(). The id arguments (\"vars\" and \"plot\") connect the UI functions to their server counterparts, and the output from mod_var_input_server() is the var_inputs argument in mod_scatter_display_server().\nThe call to shiny::shinyApp() is wrapped in the movies_app() function and placed in app.R.\n\n\n\n\n\n\napp.R\n\n\n\n\n\nCode placed in in app.R\n\nshow/hide movies_app() in app.R# install ------------------------------------\n# after installing, comment this out\npkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nmovies_app()\n\n\n\n\n\nNow, I can run the app with movies_app().\n\n\n\n\n(a) Movie reviews app\n\nFigure 5: View a deployed version here.\n\n\nThe deployed files of projApp are below:\n\nprojApp/ # 03_projApp branch\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── projApp.Rproj\n├── rsconnect/\n│   └── shinyapps.io/\n│       └── user/\n│           └── projApp.dcf\n└── www/\n    └── shiny.png\n\n6 directories, 10 files\n\n\n\nThe rsconnect/ folder has been removed from the 03_projApp branch."
  },
  {
    "objectID": "shiny.html#additional-features",
    "href": "shiny.html#additional-features",
    "title": "Shiny apps",
    "section": "Additional features",
    "text": "Additional features\nBelow are two additional ‘optional’ features that can be included with your shiny application (I consider these ‘optional’ because they’re use depends on the specific needs and environment for each application).\nGlobal variables/functions with global.R\n\nPlacing a global.R file in your root folder (or in the R/ directory) causes this file to be sourced only once when the Shiny app launches, rather than each time a new user connects to the app. global.R is commonly used for initializing variables, loading libraries, loading large data sets and/or performing initial calculations.\n\n\n\n\n\n\nUsing global.R\n\n\n\n\n\nI could place the header from app.R in global.R to ensure these packages are loaded before the application launches:\n\nshow/hide contents of R/global.R# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n\nglobal.R can be placed in the R/ folder\n\nR/\n├── global.R\n├── mod_scatter_display.R\n├── mod_var_input.R\n└── utils.R\n\n1 directory, 4 files\n\nOr in the project root folder\n\n├── DESCRIPTION\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── global.R\n├── man\n├── movies.RData\n├── projApp.Rproj\n└── www\n    └── shiny.png\n\n4 directories, 10 files\n\nIn both locations, it will be sourced before launching the application.\n\n\n\nglobal.R can be used to maintain efficiency and consistency across application sessions.\nProject dependencies with renv\n\nIf you use renv, keep track of your dependencies by regularly running renv::status() and renv::snapshot().\n\n\n\n\n\n\nUsing renv\n\n\n\n\n\nStart by initiating renv with renv::init(), then run renv::status() to check which packages have been added to the lockfile:\n\nrenv::status()\n\n\nshow/hide example renv::status() outputThe following package(s) are in an inconsistent state:\n\n package      installed recorded used\n colorspace   y         n        y   \n fansi        y         n        y   \n farver       y         n        y   \n ggplot2      y         n        y   \n gtable       y         n        y   \n isoband      y         n        y   \n labeling     y         n        y   \n lattice      y         n        y   \n MASS         y         n        y   \n Matrix       y         n        y   \n mgcv         y         n        y   \n munsell      y         n        y   \n nlme         y         n        y   \n pillar       y         n        y   \n pkgconfig    y         n        y   \n RColorBrewer y         n        y   \n scales       y         n        y   \n shinythemes  y         n        y   \n tibble       y         n        y   \n utf8         y         n        y   \n vctrs        y         n        y   \n viridisLite  y         n        y   \n\n\nTake a ‘snapshot’ to capture the current package dependencies:\n\nrenv::snapshot()\n\n\nshow/hide example renv::snapshot() outputThe following package(s) will be updated in the lockfile:\n\n# CRAN --------------------------------------------------\n- lattice        [* -&gt; 0.21-8]\n- MASS           [* -&gt; 7.3-60]\n- Matrix         [* -&gt; 1.5-3]\n- mgcv           [* -&gt; 1.8-42]\n- nlme           [* -&gt; 3.1-162]\n- vctrs          [* -&gt; 0.6.3]\n\n# RSPM --------------------------------------------------\n- colorspace     [* -&gt; 2.1-0]\n- fansi          [* -&gt; 1.0.4]\n- farver         [* -&gt; 2.1.1]\n- ggplot2        [* -&gt; 3.4.2]\n- gtable         [* -&gt; 0.3.3]\n- isoband        [* -&gt; 0.2.7]\n- labeling       [* -&gt; 0.4.2]\n- munsell        [* -&gt; 0.5.0]\n- pillar         [* -&gt; 1.9.0]\n- pkgconfig      [* -&gt; 2.0.3]\n- RColorBrewer   [* -&gt; 1.1-3]\n- scales         [* -&gt; 1.2.1]\n- shinythemes    [* -&gt; 1.2.0]\n- tibble         [* -&gt; 3.2.1]\n- utf8           [* -&gt; 1.2.3]\n- viridisLite    [* -&gt; 0.4.2]\n\nDo you want to proceed? [Y/n]: y\n\n- Lockfile written to '~/path/to/projApp/renv.lock'."
  },
  {
    "objectID": "shiny.html#recap",
    "href": "shiny.html#recap",
    "title": "Shiny apps",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some differences between developing shiny apps and regular R programming, creating new shiny projects in Posit Workbench, and some practices to adopt that can make the transition to app-packages a little easier. The code used in this chapter is stored in the projApp repository.\n\n\n\n\n\n\nRecap\n\n\n\n\n\n\n\nPlacing utility or helper files in an R/ folder removes the need to call source() in app.R.\nImages, CSS, JavaScript, and other static resources can be stored in www/ and Shiny will serve these files when the application is run.\nREADME.md files can document the application’s description, purpose, requirements, etc.\nDESCRIPTION files provide metadata and include fields that affect application deployment (i.e., DisplayMode: Showcase)\nConverting the application code into functions (modules and standalone app functions) creates a ‘division of labor’ for each component, which makes it easier to think about and work on them independently.\nFinally, if you’re using renv, run renv::status() and renv::snapshot() to manage dependencies\n\n\n\n\n\nIn the next chapter, I’ll cover what makes a package a package, and some do’s and don’ts when converting a developed shiny application into an R package."
  },
  {
    "objectID": "shiny.html#footnotes",
    "href": "shiny.html#footnotes",
    "title": "Shiny apps",
    "section": "",
    "text": "Shiny introduced these features in version 1.3.2.9001, and you can read more about them in the section titled, ‘The R/ directory’ in App formats and launching apps↩︎\nRead more about showcase mode here↩︎"
  },
  {
    "objectID": "packages.html#projects-packages-and-app-packages",
    "href": "packages.html#projects-packages-and-app-packages",
    "title": "Packages",
    "section": "Projects, packages, and app-packages",
    "text": "Projects, packages, and app-packages\nBefore we start, we should establish some operational definitions of what is meant by the terms ‘project’, ‘package’, and ‘app-package’.\n\n\nI’ll use color to differentiate Shiny app projects, R packages, and Shiny app-packages\n\nShiny App Projects: I consider a Shiny app project to be any directory of files requiring R (the binary downloaded from CRAN with a version number and neat names like, ‘R 4.3.1 “Beagle Scouts” released on …’) to execute with an RStudio/Posit workbench project file (.Rproj) and an application (contained in an app.R file or ui.R/server.R files).\nR Package: I’ll use the term R package to describe a directory of functions, documentation, or data that can be installed and loaded into an R session. An R package includes the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench.\nShiny app-packages: A shiny app-package (which you have probably already guessed) is an R package containing a shiny application. shiny app-packages have all of the functionality of a standard R package but also contain the files and folders required to successfully develop, run, and deploy a shiny app.\n\nMotivation\nThere are multiple reasons for deciding to develop a shiny app-package: your shiny app project might need to be in an R package structure due to specific organizational practices around deploying applications, or maybe you’ve been convinced it will improve the shareability/reproducibility of your shiny app project.\nRegardless of the reason, you’ve likely found yourself in one of two circumstances:\n\nYou want to develop a new app, but want it structured as an R package.\nYou’ve already developed a shiny app project, but now you need to convert it to a shiny app-packages\n\nThe previous chapter covered a few practices to adopt during shiny development that improve the extensibility of your shiny app project to an shiny app-package.1\n\n\n\n\n\n\nR Packages & Posit Workbench\n\n\n\n\n\n\nPosit Workbench (formerly RStudio) is a popular integrated development environment (IDE) that streamlines many R package development tasks. I’ve purposely connected Posit Workbench to the definitions above for R package and Shiny app-packages–specifically, the package development tools provided in the Build pane and devtools.\nHowever, developing R packages in Posit Workbench (or using .Rproj files) is not required. There are alternative package development tools and processes outside of Posit Workbench, and many developers employ these setups.\nPackage development outside Posit Workbench would look almost identical to development in the IDE:\n\nCreate the package structure (R/ folder for .R scripts, man/ folder for documentation, data/ folder for datasets, etc.)\nAdd DESCRIPTION and NAMESPACE files, etc.\nEnsure the package can be installed and loaded into an R session.\n\nIt’s also possible to use many of the development workflow functions we’ll cover here outside of the IDE (roxygen2::roxygenize(), devtools::check(), devtools::install(), etc.).\n\n\n\n\n\nR packages vs. Shiny app projects\n\nBelow is are folder trees with some of the typical files and folders found in R packages (on the left) and the files that currently exist in projApp (on the right), our shiny app project.\n\n\n\n&lt;R package&gt;/\n    ├── DESCRIPTION\n    ├── &lt;R package&gt;.Rproj\n    ├── LICENSE \n    ├── LICENSE.md \n    ├── NAMESPACE \n    ├── NEWS.md\n    ├── README.Rmd\n    ├── README.md\n    ├── renv.lock\n    ├── R/\n    ├── man/\n    ├── tests/\n    ├── data/ \n    ├── data-raw/ \n    ├── vignettes/ \n    ├── inst/ \n    └── renv/\n  \n\n\nprojApp/\n├── DESCRIPTION\n├── projApp.Rproj\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n└── www/\n    └── shiny.png\n\n4 directories, 9 files\n\n\n\nR packages can be easily shared, reused, and reproduced because they all have a familiar structure, and each folder and file plays an essential role in extending R’s capabilities.2\nThis chapter will cover the minimum requirements for an R package, so you can handle both creating new shiny app-packages and converting existing shiny projects into shiny app-packages."
  },
  {
    "objectID": "packages.html#what-makes-an-r-package",
    "href": "packages.html#what-makes-an-r-package",
    "title": "Packages",
    "section": "What makes an R package?",
    "text": "What makes an R package?\nIf you’ve done some research on R packages, you’ve probably encountering one (or both) of the following statements,\n\n‘Every package must have a DESCRIPTION. In fact, it’s the defining feature of a package (RStudio and devtools consider any directory containing DESCRIPTION to be a package)’ - R Packages, 2ed (Chapter 9, DESCRIPTION)\n‘all a project needs to be a package is a directory of R/ files and a DESCRIPTION file.’ - Mastering Shiny (Chapter 20, Packages)\n\nThe information above should be confusing if you’ve been following along with the code in projApp.\nWe’ve created a shiny app project (projApp) with a DESCRIPTION file and an R/ directory, but it’s not a functioning R package.\nAs we noted above, a functioning R package can be installed and loaded into an R session and has access to the Build pane in the IDE.\nCan we load it with devtools?\nPackage development kicks off with the load_all() function from devtools, which is similar to calling library() (we’ll cover this function extensively in the devtools chapter). However, when we attempt to load the code in the R/ folder with load_all(), we see the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n(a) Load All Error\n\nFigure 1: devtools is looking for the Package field in our DESCRIPTION file\n\nWhere is the ‘Build’ pane?\nWhen opened, functioning R packages have access to the Build pane, which allows developers to quickly load, install, and test their packages.\nBut when projApp is opened, the Build pane is not displayed in the IDE:\n\n\n\n\n(a) projApp IDE\n\nFigure 2: Project IDE panes\n\n\nAs we’ve just learned, the presence of the DESCRIPTION file and an R/ folder are insufficient to turn a shiny app project into a functioning R package (or a shiny app-packages)."
  },
  {
    "objectID": "packages.html#what-really-makes-an-r-package",
    "href": "packages.html#what-really-makes-an-r-package",
    "title": "Packages",
    "section": "What really makes an R package?",
    "text": "What really makes an R package?\n\n“A project needs a DESCRIPTION file with specific fields, a directory of R/ files, and a properly configured .Rproj file to be a functioning R package.”\n\nLet’s see how each of these requirements work together to convert the contents of projApp from a shiny app project into a shiny app-package.\n\nDESCRIPTION fields\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s 04_description branch\nThe official R documentation3 lists the following required fields for the DESCRIPTION in R packages:\n\nThe ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and ‘Maintainer’ fields are mandatory.\n\nBelow is an example DESCRIPTION file for projApp with the mandatory fields:4\n\nPackage: projApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\n\n\n\n\n\n\n\nAuthor and Maintainer fields\n\n\n\n\n\nNote that the Author and Maintainer fields require additional information beyond first and last name (i.e., John Smith). These can be created with the utils::person() function:\n\n# Author\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  role = c(\"aut\", \"cre\"))\n## [1] \"John Smith [aut, cre]\"\n# Maintainer\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  email = \"John.Smith@email.io\")\n## [1] \"John Smith &lt;John.Smith@email.io&gt;\"\n\n\n\n\nAfter adding the mandatory fields to the DESCRIPTION file in projApp, load_all() runs without the previous error, but the IDE still doesn’t display the Build pane:\n\n\n\n\n(a) projApp IDE\n\nFigure 3: Where is the Build pane?\n\n\n\nProject Options…\n(i.e., the .Rproj file)\n.Rproj files are plain text files with various settings for the IDE. We were able to run devtools::load_all() above without the presence of the Build pane because the IDE displays the Build pane after reading the fields in the .Rproj file.\nThe quickest way to access the fields in the .Rproj file is under Tools &gt; Project Options….\nDefault options\nTools &gt; Project Options… provide access to the project-level options. For example, fields 2 - 4 are available under General, 5 - 8 affect the Code options, and the final two fields deal with Sweave.\n\n\n\n(a) projApp.Rproj fields\n\nFigure 4: Field settings from projApp.Rproj file\n\nThe default settings were created when we selected the shiny app project from the New Project Wizard in the last chapter.\nBuild tools\nI’ve placed the .Rproj file from pkgApp with the example .Rproj file from R Packages, (2ed) side-by-side so you can compare them below:5\n\n\n\n(a) .Rproj files\n\nFigure 5: Comparison of projApp.Rproj file and .Rproj file in R Packages, 2ed\n\nI’ve circled the fields in the .Rproj file that illustrate it’s configured to work with an R package. Note that in projApp, the Project build tools are initially set to (None) under Build Tools:6\n\n\n\n(a) projApp.Rproj build tools\n\nFigure 6: Build tool settings in projApp.Rproj file\n\nChanging the Project build tools option to Package will set the default Build Tools options:\n\n\n\n(a) Default package build tools\n\nFigure 7: Default build tool settings\n\nThe links between the Build Tools options and fields in projApp.Rproj are in the figure below:\n\n\n\n(a) projApp.Rproj build tool fields\n\nFigure 8: Default build tool settings in projApp.Rproj file\n\n\nBuildType: Package tells the IDE projApp is an R package and triggers the Build pane.\nPackageUseDevtools: Yes links the options in the Build pane to the devtools package.\nThe PackageInstallArgs are complicated, but I’ve included some information about them in the callout block below (and you can read more in the official R documentation)\n\nThe fourth option (PackageRoxygenize) is available under Generate documentation with Roxygen &gt; Use roxygen to generate:\n\nThese options affect the documentation in an R package. To match the example from R Packages, 2ed above, make sure Rd files, Collate field, and NAMESPACE file are selected and click OK.\n\n\n\n\n\n\n(a) PackageRoxygenize in .Rproj file\n\nFigure 9: roxygen2 build settings\n\nAfter clicking OK, the IDE will automatically reboot, and the additional fields will be added to the bottom of the projApp.Rproj:\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s 05_rproj branch\n\nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\n\n\n\n\n\n\n\nWhat is --no-multiarch --with-keep.source?\n\n\n\n\n\n\n\n--no-multiarch: refers to the option for the package installer to only compile the package for the architecture of the current R session. By default, R tries to compile packages for 32-bit and 64-bit architectures if running in a 64-bit R session on Windows. This flag can help avoid problems if a package can only be compiled on one architecture. Read more here.\n--with-keep.source: In R, when a function is created, its body can be stored in two ways: 1) as a parsed but unevaluated expression and 2) as a character string containing the function’s source code. By default, only the parsed expression is kept. If –with-keep.source is specified, R will also keep the source code as a character string, which can be helpful for debugging and tools that analyze or modify source code. Read more here.\n\n\n\n\n\nBuild pane\nWhen the new session starts, the new project-level options activate the Build pane in the IDE.\n\n\n\n\n(a) Build pane in IDE\n\nFigure 10: Build pane triggered from project-level settings\n\n\nWhen the IDE reboots, I can see the Build pane has been added, and I can check the R package functionality by loading the code with Build &gt; Load All\n\n\n\n(a) Load the code in the R/ folder\n\nFigure 11: Identical to running devtools::load_all()\n\nI should see the following in the Console:\nℹ Loading projApp\nThere you have it–projApp is a functional R package!"
  },
  {
    "objectID": "packages.html#functional-r-packages",
    "href": "packages.html#functional-r-packages",
    "title": "Packages",
    "section": "Functional R packages\n",
    "text": "Functional R packages\n\n\n\n\n\n(a) shiny app-package (with DESCRIPTION and Build pane)\n\nFigure 12: Fully functional shiny app-package\n\n\nIn a functional R package:\n\nThe DESCRIPTION file contains the seven mandatory fields (Package, Version, License, Description, Title, Author, and Maintainer), making running the necessary devtools functions possible.\nThe .Rproj file contains the three package configuration fields (BuildType: Package, PackageUseDevtools: Yes, and PackageInstallArgs: --no-multiarch --with-keep.source), which makes the Build pane accessible and functional.\n\nThe items above will create a functional R package, but these are the first steps (we haven’t developed anything yet!) on our way to a shiny app-package.\nThink of the two items above as a two-part process: the DESCRIPTION requires specific fields,7 and the IDE requires .Rproj fields to trigger the Build pane.8"
  },
  {
    "objectID": "packages.html#creating-shiny-app-packages-with-create_package",
    "href": "packages.html#creating-shiny-app-packages-with-create_package",
    "title": "Packages",
    "section": "Creating shiny app-packages with create_package()\n",
    "text": "Creating shiny app-packages with create_package()\n\nThe Posit documentation9 lists the following ways to create R packages,10\n\n\nCall usethis::create_package().\nIn RStudio, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\n\ncreate_package() is a great option if you’re looking for a way to quickly create or convert your shiny app project into a shiny app-package.11 In the following sections I’ll cover some suggestions for using create_package().\nNew shiny app-packages\n\nIf you haven’t written any code and want to create a new shiny app-package, create_package() is the quickest way to get started.\nFirst, install devtools:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\ndevtools automatically loads usethis\nLoading required package: usethis\nAssuming your current working directory is where you want your new shiny app-package, call usethis::create_package() with the path argument set to getwd()\n\nusethis::create_package(path = getwd())\n\nThis call launches a series of actions:\n\n\nFirst, the active project is set to whatever was given to the path argument.\n✔ Setting active project to 'path/to/newApp'\n\n\nThe R/ folder and DESCRIPTION/ file are created:\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\n\n\nThe NAMESPACE and .Rproj files are created:\n✔ Writing 'NAMESPACE'\n✔ Writing 'newApp.Rproj'\n\n\nThe .Rproj is added to the .Rbuildignore file, the .Rproj.user folder is added to the .gitignore and .Rbuildignore files.\n✔ Adding '^newApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n\n\nA new session is opened from the new .Rproj file:\n✔ Opening 'path/to/newApp/' in new RStudio session\n\n\nWhen the new session opens, newApp has the following contents:\n\nnewApp/\n  ├── .Rbuildignore\n  ├── .Rproj.user/\n  ├── .gitignore\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── projApp.Rproj\n\nYou’re now free to develop newApp. Store and document any .R files in the R/ folder, edit the DESCRIPTION file with details about the application, read through R Packages and Mastering Shiny, and add the shiny code to complete your shiny app-package.\nConverting existing shiny app projects\n\nIf you already have a shiny app project that needs to be converted into a shiny app-package (like the app files stored in the 03_projApp branch), you can also use create_package(path = getwd()) in your root folder, but I recommend using the following arguments:\n\nDESCRIPTION arguments\n\n\nfields: these are arguments passed to usethis::use_description(). If the fields argument is empty, a boilerplate DESCRIPTION file is created (similar to this one).\n\nThese boilerplate fields in the DESCRIPTION work, but I’ve found some of the fields are unnecessary (i.e., I’ve never needed Authors@R: or ORCID) and inevitably require revision, so I’d prefer to handle this during the creation process (and remove the risk of forgetting to change it later).\nAll fields should be passed in a list() as field = 'value' pairs.\n\n\nusethis::use_description(\n    list(Package = 'projApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"))\n\n\n\nA few fields require specially formatted values (see the utils::person() examples below).\n\nutils::person(\"John\", \"Smith\", \n              email = \"John.Smith@email.io\", \n              role = c(\"aut\", \"cre\"))\n\n[1] \"John Smith &lt;John.Smith@email.io&gt; [aut, cre]\"\n\n\n\n\n\n\nTwo additional arguments from use_description() are passed to create_package():\n\ncheck_name: verifies your shiny app-package name is valid for CRAN, so we can set this to FALSE (unless you’re planning on submitting to CRAN)\nroxygen2: is TRUE by default and adds the fields required to use roxygen2 (which I won’t cover here because we’ll cover documentation in-depth in a future chapter).\n\n\n\n\n\n\n\n\n\nWARNING: Don’t use usethis::create_package('.')!\n\n\n\n\n\n\nWhen converting your existing shiny app project into a shiny app-package with usethis::create_package(), don’t use '.' in the path argument:\nusethis::create_package('.')\nThis will return the following warning about creating nested projects, and ask if you want to proceed anyway:\nNew project 'projApp' is nested inside an existing project\n'./', which is rarely a good idea. If this is unexpected, \nthe here package has a function,\n`here::dr_here()` that reveals why './' is regarded as a\nproject.\n  \nDo you want to create anyway?\n\n1: Yes\n2: No way\n3: Not now\nWe can avoid this warning altogether by passing getwd() to the path argument, so I recommend cancelling the project creation:\nSelection: 2\nError: Cancelling project creation.\n\n\n\n\nIDE arguments\n\nrstudio: adds the necessary Build Tools fields in the .Rproj file (leave as TRUE)\nopen: can be set to FALSE because we don’t need RStudio/Posit Workbench to open in a new session\n\n\nusethis::create_package(\n  path = getwd(),\n  fields = list(Package = 'projApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"),\n  roxygen = TRUE,\n  check_name = FALSE, \n  rstudio = TRUE,\n  open = FALSE)\n\nAfter running usethis::create_package() with the arguments above, the IDE will present us with a few prompts to confirm:\nOverwrite pre-existing file 'DESCRIPTION'?\nOverwrite pre-existing file 'projApp.Rproj'?\nThe shiny app-package structure is below:\n\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── projApp.Rproj\n└── www\n    └── shiny.png\n\n3 directories, 10 files\n\nThe DESCRIPTION file (shown below) has a few additional fields (Encoding, Roxygen, and RoxygenNote) we didn’t include when we converted projApp above. We will cover these in the upcoming chapters.\n\nPackage: projApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith &lt;John.Smith@email.io&gt; [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s 06_create-package branch"
  },
  {
    "objectID": "packages.html#recap",
    "href": "packages.html#recap",
    "title": "Packages",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered the mandatory fields in the DESCRIPTION file and the R package configuration fields in .Rproj. We also covered creating and converting shiny app projects using the usethis::create_package() function.\n\n\n\n\n\n\nRecap: Packages!\n\n\n\n\n\n\n\n\nThe DESCRIPTION file ultimately controls whether you have a functional shiny app-package.\n\nThe mandatory fields are Package, Version, License, Description, Title, Author, and Maintainer.\n\n\nusethis::create_package() can be used to create a new R package and to convert an existing shiny project into a shiny app-package.\n\nThe IDE reads RStudio (.Rproj) files and determines R session settings at the project-level (i.e., working directory, workspace, history, code formatting, etc.)\n\nPackage development settings can be accessed via Project Options &gt; Build Tools.\n\n\n\n\n\n\n\nIn the next chapter, I’ll cover how you can quickly Load, Document, and Install your package!\nend packages.qmd"
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "Packages",
    "section": "",
    "text": "Shiny app project features are covered in the Project Folders section of the Shiny apps chapter.↩︎\nFortunately, shiny app-packages don’t require all the files and folders displayed in the folder tree to gain the functionality and benefits of an R package.↩︎\nThe mandatory fields are covered in Writing R Extensions, ‘The DESCRIPTION file’↩︎\nAlways leave empty final line in the DESCRIPTION file.↩︎\n.Rproj files are covered in the What makes an RStudio Project? section of R Packages (2 ed)↩︎\nThe initial Build Tools settings (i.e., (None)) should help explain the absence of any R package development fields in the projApp.Rproj when we compared it to the version in R Packages, 2ed (i.e., BuildType, PackageUseDevtools, PackageInstallArgs, and PackageRoxygenize).↩︎\nThe mandatory fields prevent the devtools error we encountered above.↩︎\nIf you’d like to learn more about the topics in this chapter, you should read Writing R Extensions (the official documentation for creating R packages) and R Packages, 2ed.↩︎\nThis information comes from the Writing R Packages documentation for Posit Workbench.↩︎\nWe now know it’s possible to create an R package with the DESCRIPTION file fields and configuring the Project Build Tools.↩︎\nusethis::create_package() is covered in the ‘Fundamental development workflows’ chapter of R Packages, 2ed↩︎"
  },
  {
    "objectID": "development.html#developing-packages-with-devtools",
    "href": "development.html#developing-packages-with-devtools",
    "title": "Development",
    "section": "Developing packages with devtools\n",
    "text": "Developing packages with devtools\n\n\n“One package to rule them all.” - Not the devtools development team\n\nIf you’re new to package development, having a little background on the devtools package is helpful. Earlier versions of devtools contained most of the functions used for package development. In version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\n\nThe usethis package contains the functions for creating package folders and files (.R files, tests, vignettes, etc.). usethis is also automatically loaded when you call library(devtools).\nLoading and building your app-package is handled by pkgload and pkgbuild\nFor app-packages destined for CRAN, the R CMD check is handled by rcmdcheck and revdepcheck\nInstalling packages from non-CRAN repositories (i.e., install_github()) is handled by remotes\n\nYou don’t have to install all of these packages (they will be loaded with devtools), but the information is essential because it affects the dependencies in your app-package:\n\n‘Package developers who wish to depend on devtools features should also pay attention to which package the functionality is coming from and depend on that rather than devtools. In most cases, packages should not depend on devtools directly.’ - devtools 2.0.0, tidyverse blog\n\nWe will cover this topic more in the dependencies chapter."
  },
  {
    "objectID": "development.html#projapp",
    "href": "development.html#projapp",
    "title": "Development",
    "section": "projApp",
    "text": "projApp\nLet’s assume we’re continuing with the app project we converted manually in the 04_description branch of projApp (the files and folders are below).\n\n\n\n\n\nGit Branch\n\nprojApp repo’s 04_description branch\n\n\nprojApp/ # 04_description branch\n  ├── DESCRIPTION\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── projApp.Rproj\n  └── www\n      └── shiny.png\n\n4 directories, 9 files\n\nWe’re backing up to the branch we created by manually editing the DESCRIPTION file to show the connection between the devtools functions and specific fields in the DESCRIPTION file.1\nDESCRIPTION\nThe version of projApp in this branch has a DESCRIPTION file with the seven mandatory fields:\n\n# in Terminal\n$ cat DESCRIPTION \nPackage: projApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\n\nprojApp.Rproj\nHowever, the .Rproj file is still configured to work with a shiny project:2\n\n# in Terminal\n$ cat projApp.Rproj \nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX"
  },
  {
    "objectID": "development.html#package-development-habits",
    "href": "development.html#package-development-habits",
    "title": "Development",
    "section": "Package development habits",
    "text": "Package development habits\nThe differences between developing an R package and a shiny app can be boiled down to a handful of habits. These habit call various devtools functions:\n\n\nI’ll use bold to indicate each devtools habit and accompanying function.\n\nLoad all the functions and data in your app-package with load_all()\nDocument the app-package functions and data with document()\nInstall the app-package with install()\n\nIn the sections below, I’ll cover each function and my opinion about how it should be used when your shiny app becomes an app-package.3\n\n\n\n\n\n\nKeyboard shortcuts\n\n\n\n\n\n\nI strongly recommend using the keyboard shortcuts for each devtools function. Shortcuts reduce typing and bundle all those keystrokes into a single action. They also create a kind of ‘muscle memory’ for each step.\n\n\n\n\nLoad\nInstall devtools\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\nusethis is automatically loaded/attached with devtools.\nLoading required package: usethis\nCtrl/Cmd + Shift + L\n\n‘load_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management’ - Benefits of load_all(), R Packages, 2ed\n\nload_all() is the most common devtools function we’ll use during development because we should load the package when anything changes in the R/ folder.\n\ndevtools::load_all()\n\nUsing load_all() is similar to calling library(projApp) because it loads the code in R/ along with any data files. load_all() is also designed for iteration (unlike using source()), and when it’s successful, the output is a single informative message:\nℹ Loading projApp\nDocument\nThe document() function from devtools serves two purposes:\n\nWriting the package NAMESPACE file\nCreates the help files in the man/ folder\n\ndevtools is smart enough to recognize the first time document() is called, so when I initially run it in the Console, it prompts me that the roxygen2 version needs to be set in the DESCRIPTION file:\n\ndevtools::document()\n\nℹ Updating projApp documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\ndevtools relies on roxygen2 for package documentation, so the RoxygenNote field is required in the DESCRIPTION. You may have noticed calling document() also calls load_all(), which scans the loaded package contents for special documentation syntax before writing the NAMESPACE file (we’ll cover the NAMESPACE in the chapter on Dependencies).\nℹ Loading projApp\nWriting NAMESPACE\nIf we open the NAMESPACE file, we see it’s empty (and that we shouldn’t edit this file by hand).\n\n\n\n(a) NAMESPACE\n\nFigure 1: Initial NAMESPACE file\n\nThe last few output lines warn us to include the Encoding field in the DESCRIPTION. devtools won’t automatically add Encoding (like it did with RoxygenNote above), so we’ll need to add it to the DESCRIPTION file manually:\nWarning message:\nroxygen2 requires Encoding: \"UTF-8\"\nℹ Current encoding is NA \nNote: The Encoding value shouldn’t include quotes like the warning message above (i.e., UTF-8). See the example below:\n\nPackage: projApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\n\nAfter adding the required fields to the DESCRIPTION file,4 we’ll document() the package again using the keyboard shortcut:\n\nCtrl/Cmd + Shift + D\n\nIn the Build pane, we see the following:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating projApp documentation\nℹ Loading projApp\nDocumentation completed\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\nInstall\n\nCtrl/Cmd + Shift + B\n\nThe final package development habit to adopt is regularly installing the package with devtools::install().\n\ndevtools::install()\n\ninstall() will prompt the following output in the Build pane:\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source projApp\n\n* installing to library ‘/path/to/local/install/projApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘projApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\nNo man pages found in package  ‘projApp’ \n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (projApp)\nThere are a few connections worth making in this initial install() output:\n\n\nThe first line in the output should look familiar–we saw both of these settings in the projApp.Rproj file from the previous chapter\nPackageInstallArgs: --no-multiarch --with-keep.source\n\nNo man pages found in package 'projApp' tells us none of the code in R/ has adequately been documented (which we’ll cover in the roxygen2 chapter)\ninstall() attempts to install the package from the *source* files and a ‘bundle’ or source tarball file (i.e., .tar.gz)\nhelp files are built, along with other documentation (like vignettes)\nDONE (projApp) means projApp was successfully installed!\n\nInstall a package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\n\n\nGit Branch\n\nThis section’s code is in the projApp repo’s 06_devtools branch\nCheck?\ndevtools::check() performs a series of checks to ensure a package meets the standards set by CRAN. You can consider check() as a ‘quality control’ function for documentation, NAMESPACE dependencies, unnecessary or non-standard folders and files, etc. R Packages recommends using check() often, but I agree with the advice in Mastering Shiny on using check() with app-packages,\n\n‘I don’t recommend that you [call devtools::check()] the first time, the second time, or even the third time you try out the package structure. Instead, I recommend that you get familiar with the basic structure and workflow before you take the next step to make a fully compliant package.’\n\nHowever, I’ve included an example of running check() on projApp in the callout box below to demonstrate how it works.\n\n\n\n\n\n\nRunning devtools::check()\n\n\n\n\n\n\ndevtools::check()\n\nThe output from check() can be rather lengthy (it’s pretty comprehensive!), and it provides feedback on each item in the form of a note (N), warning (W), or error (E).\n==&gt; devtools::check()\n\nDuration: 15.3s\n\nN  checking top-level files\n   Non-standard files/directories found at top level:\n     ‘app.R’ ‘movies.RData’\n\nW  checking dependencies in R code ...\n   '::' or ':::' imports not declared from:\n     ‘ggplot2’ ‘shiny’ ‘stringr’\n\nN  checking R code for possible problems (3.1s)\n   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n     variable ‘movies’\n   scatter_plot: no visible binding for global variable ‘.data’\n   Undefined global functions or variables:\n     .data movies\n\nW  checking for missing documentation entries ...\n   Undocumented code objects:\n     ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n     ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n   All user-level objects in a package should have documentation entries.\n   See chapter ‘Writing R documentation files’ in the ‘Writing R\n   Extensions’ manual.\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nA summary of each item is below:\n\nchecking top-level files: This note refers to the two non-standard (i.e., not typically found in an R package) files, app.R and movies.RData.\nchecking dependencies in R code: This warning tells I need to namespace functions from add-on packages (in this case, ggplot2, shiny, and stringr)\nchecking R code for possible problems: This item refers to the call to load the movies data in the module server function (mod_scatter_display_server).\nchecking for missing documentation entries: This is warning me that the module functions aren’t properly documented and refers me to the official R documentation.\n\nEach of these items is also printed under the ── R CMD check results heading:\nDuration: 15.3s\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' imports not declared from:\n    ‘ggplot2’ ‘shiny’ ‘stringr’\n\n❯ checking for missing documentation entries ... WARNING\n  Undocumented code objects:\n    ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n    ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n  All user-level objects in a package should have documentation entries.\n  See chapter ‘Writing R documentation files’ in the ‘Writing R\n  Extensions’ manual.\n\n❯ checking top-level files ... NOTE\n  Non-standard files/directories found at top level:\n    ‘app.R’ ‘movies.RData’\n\n❯ checking R code for possible problems ... NOTE\n  mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n    variable ‘movies’\n  scatter_plot: no visible binding for global variable ‘.data’\n  Undefined global functions or variables:\n    .data movies\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nIf you’re submitting your app-package to CRAN (or want to use check() for other reasons), follow the suggested workflow for check():\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check() or press Shift + Ctrl/Cmd + E\nFix the first problem.\nRepeat until there are no more problems.’\n\n\nI’ve found a good habit for when to check() to be:\nAfter adding a bug fix or feature, check a package and keep any notes, warnings, or errors from accumulating.\n\n\n\nRecap\nCreating an app-package involves adopting some new devtools habits, and the initial contents of projApp hopefully helped demonstrate the purpose of each function.\n\n\n\n\n\n\nRecap: Package development habits\n\n\n\n\n\n\nAfter installing and loading devtools:\n\n\nLoad the package whenever changes occur in the R/ folder.\n\n\nCtrl/Cmd + Shift + L load all the code in the package.\n\n\n\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\n\n\nCtrl/Cmd + Shift + D record the documentation and dependencies.\n\n\n\nInstall the package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\nCtrl/Cmd + Shift + B confirms the package can be installed.\n\n\n\nHabits require repetition to develop, and I hope the workflow above can be applied to your shiny app-packages, provided you’re using devtools and Posit workbench.\n\n\n\n\nThe following section will cover documenting functions with roxygen2"
  },
  {
    "objectID": "development.html#footnotes",
    "href": "development.html#footnotes",
    "title": "Development",
    "section": "",
    "text": "If you create or convert your shiny app project with usethis::create_package(), a few fields (i.e., Roxygen and RoxygenNote) are added automatically without explaining their role or purpose.↩︎\nIf you created your shiny app using the New Project Wizard, your .Rproj file has been configured to work with project, not a package.↩︎\nThe topics covered in this section shouldn’t be considered a replacement for the ‘Whole Game’ chapter in R packages (2 ed) or the ‘Workflow’ section of Mastering Shiny (and I highly recommend reading both).↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎"
  },
  {
    "objectID": "app_packages.html#introduction-review-chapters-1---3",
    "href": "app_packages.html#introduction-review-chapters-1---3",
    "title": "App-packages",
    "section": "Introduction (Review Chapters 1 - 3)",
    "text": "Introduction (Review Chapters 1 - 3)\nLet’s briefly review what we’ve covered in the last three chapters:\nShiny apps (Chapter 1)\nThe Shiny apps Chapter covered shiny projects and some ‘pre-package practices’ to adopt for your shiny app that can make the transition to working with app-packages easier.\n\n\n\n\n\n\nChapter 1: GitHub branches\n\n\n\n\n\n\nThe code for Chapter 1 (Shiny apps) is stored in the following branches:\n\nmain: Contains a new shiny app project created from the New Project Wizard (with Old Faithful Geyser Data)\n02_movies-app: The boilerplate app in app.R is replaced with the code for the movie review application, and the scatter_plot() utility function is added to utils.R and movies.RData is added to the project.\n\n03_projApp contains an ‘fully developed’ shiny app project with the following contents:\n\n\nDESCRIPTION file\n\n\nREADME.md file\n\n\nR/ folder\n\n\nModules: two module files are created in the R/ folder (mod_var_input.R and mod_scatter_display.R)\n\n\nStandalone app function: the code in app.R is converted to a standalone app function: movies_app()\n\n\nUtility function: Move utils.R into the R/ folder\n\n\n\nThe www/ folder contains the image file (shiny.png)\n\n\nDeployment: The rsconnect/ folder contains files for deploying to shinyapps.io\n\n\n\n\n\n\n\n\nPackages (Chapter 2)\nPackages illustrated what separates projects from R packages. This chapter also covered 1) how to create a new shiny app-package or 2) convert an existing shiny project into an app-package.\n\n\n\n\n\n\nChapter 2: GitHub branches\n\n\n\n\n\n\nThe code for Chapter 2 (Projects) is stored in the following branches:\n\n03_projApp is an ‘advanced’ package from the previous chapter\n04_description is a branch from 03_projApp and adds the seven mandatory DESCRIPTION fields.\n05_rproj is a branch from 04_description and manually converts the shiny app project to a shiny app-package using the .Rproj file.\n06_create-package is a branch from 03_projApp and creates a package using usethis::create_package()\n\n\n\n\n\nDevelopment (Chapter 3)\nDevelopment introduced the devtools package and its core functions (load_all(), document(), and install()).\n\n\n\n\n\n\nChapter 3: GitHub branches\n\n\n\n\n\n\nThe code for Chapter 3 (devtools) is stored in the following branch:\n\n\n06_devtools is a branch from the manually converted app-package in 05_rproj\n\n\n\n\n\n\nWe’re now at a point that we’ve converted a Shiny project (projApp) into a package. The package conversions live in the 06_devtools and 06_create-package branches:\n\n\nIn the 06_devtools branch, projApp was converted to a package by manually adding the required fields to the DESCRIPTION file, then running the key devtools development functions (load_all(), document(), and install())\n\nPackage: projApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\n\n\n\nIn the 06_create-package branch, we used the usethis::create_package() function to convert projApp into a package.\n\nPackage: projApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\n\n\nThe only difference between these two branches lies in the DESCRIPTION files–in the 06_create-package branch, the Roxygen: list(markdown = TRUE) field was added (which we will cover in the upcoming Documentation chapter)."
  },
  {
    "objectID": "app_packages.html#app-packages-chapters-4---9",
    "href": "app_packages.html#app-packages-chapters-4---9",
    "title": "App-packages",
    "section": "App-packages (Chapters 4 - 9)",
    "text": "App-packages (Chapters 4 - 9)\nThe following three sections will continue with app-package development, emphasizing developing a shiny application within a package structure. We’ll be using the code stored in the pkgApp repository.\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s main branch\n\n\n\n\n\n\nGitHub [pkgApp]:[main]\n\n\n\n\n\n\nThe code for the next section can be found in the main branch of the pkgApp repo.\nThe main branch of pkgApp is identical to the 06_create-package branch from the projApp repository from the previous section:\npkgApp/ # 06_create-package\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── pkgApp.Rproj\n  └── www\n      └── shiny.png\n  \n  4 directories, 10 files\nThe rsconnect/ folder has been removed because we’ll cover deploying pkgApp in future sections.\n\n\n\n\nA summary of each chapter in this section is provided below.\nDocumentation (Chapter 4)\n\n\nroxygen2 basics:\n\n\nRequired tags\n- @title, @description, @details, @param, @return, and @examples\n\nApp-package considerations for modules and standalone app functions:\n- @seealso, @family, and @section\n\nDependencies (Chapter 5)\n\nExporting functions from your package namespace\n\n\n@export/export()\n\n\n\nImporting functions from add-on packages into your package namespace\n\n\n@import/import(), @importFrom/importFrom()\n\n\n\nThe Imports field in the DESCRIPTION\n\nLaunch (Chapter 6)\n\nWhat goes in app.R?\n\n\nshinyApp() vs. runApp()\n\n\n\nData (Chapter 7)\n\nDocumenting data with\n\nroxygen2: @format, \\describe, \\item\n\nLocation of data files: data/ vs. data-raw/ vs. inst/extdata/\n\nExternal files (Chapter 8)\n\ninst/ & www/\nsystem.file()\naddResourcePath()\nTests (Chapter 9)\n\ntestthat\ntestServer()\nshinytest2"
  },
  {
    "objectID": "document.html#roxygen2-basics",
    "href": "document.html#roxygen2-basics",
    "title": "Documentation",
    "section": "\nroxygen2 basics",
    "text": "roxygen2 basics\n\n\n\n\n\nGit Branch\n\npkgApp repo’s main branch\n\nroxygen2 connects the package code (i.e., the .R files in the R/ folder) to its documentation files (i.e., the .Rd files in the man/ folder):\n\n\n\n(a) roxygen2\n\nFigure 2: roxygen2 creates man/ documentation\n\nThe two pieces of roxygen2 syntax to know are comment blocks and tags:\n\n\nComment blocks are any lines beginning with #'\n#' \n#' \n#' \n\n\nTags begin with @\n#' \n#' @tag\n#' \n\n\nWhen documenting functions, roxygen2 tags and comment blocks are placed directly above any functions stored in R/.\n#' \n#' @tag\n#' \nmy_fun &lt;- function() {\n  \n}\nIn the following sections, we’ll cover roxygen2 basics using examples for the scatter_plot() function found in R/utils.R.\nmarkdown = TRUE\nWhen we created our app-package with usethis::create_package(), support for markdown formatting in package help files is automatically included by adding Roxygen: list(markdown = TRUE) to the DESCRIPTION file:\n\nPackage: pkgApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nDisplayMode: Showcase\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\n\n\n\n\nAlways leave at least one empty final line in your DESCRIPTION file.\n\n\n@title & @description\n\nThe first two sections of roxygen2 documentation are the title and description. These sections don’t require tags–roxygen2 will detect each section as long as there is at least one #' line separating them (and their contents don’t extend past the length indicated in parentheses below):\n#' function title (one line)\n#'\n#' A short description... (one paragraph)\n#' \nThe @title and @description for the scatter_plot() function stored in R/utils.R might look like this:\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n\n\n\n\n\n\nFunction @description and @details\n\n\n\n\n\nIf the contents in the @description for a function requires more complicated formatting than a single paragraph (i.e., multiple paragraphs, lists, etc.), you can use the @details tag:\n#' Create scatter plot  \n#' \n#' @description\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' @details\n#' `scatter_plot()` is a custom `ggplot2` function written to handle string arguments from reactive inputs (i.e., `input$x` or `input$y`). \n\n\n\n\n@param & @return\n\nDocument function arguments and outputs with @param and @return:\n\n\n@param: should include the name and description of each function input (i.e., their type and what they do)\n#' @param name description of its action\n\nRead more here\n\n\n\n\n@return: these describe the type (or class) and structure of the function output\n#' @return type/structure of the output\n\nRead more here\n\n\n\n\nBelow are examples for @param and @return in the scatter_plot() function stored in R/utils.R:\n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\nTo view how the roxygen2 syntax will appear in the .Rd file, I’ll document pkgApp:\n\n\nTo reduce the amount of repetitive code, I’ll just be showing the keyboard shortcuts for each devtools function from this point forward\n\nCtrl/Cmd + Shift + D\n\nI can see the scatter_plot.Rd file is written to the man/ folder:\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nWriting scatter_plot.Rd\nDocumentation completed\nR documentation (.Rd) files have a formatting style similar to (La)TeX (but roxygen2 saves us from having to learn this syntax). When we open man/scatter_plot.Rd, we see it contains the following:\n\n\n\n\n(a) .Rd file\n\nFigure 3: R documentation file\n\n\nroxygen2 graciously generates the scatter_plot.Rd file (and warns us not to edit it by hand). Note the following items were added without needing tags:\n\n\\name: the name of the function (as it appears in the index)\n\\alias: used to group “topics” and provides a look-up in the package index\n\n\\arguments: function arguments (header)\n\n\n\\item: description of argument\n\n\n\nThe following two items are a result of the markdown syntax we used:\n\n\\href: used for hyperlinks\n\\code: code formatting\n\n\n\n\n\n(a) @tag links to .Rd file\n\nFigure 4: roxygen2 tag links to .Rd file\n\n\nTo view the help file, I can enter ?scatter_plot in the console:\n\n?scatter_plot\n\nAnd an informative message tells me that the development version scatter_plot.Rd is being rendered:\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n(a) .Rd file\n\nFigure 5: Help file\n\n\nPreviewing the development documentation is a great way to verify the content in each .Rd file meets expectations.\n@examples\n\n@examples are unique because they include executable code demonstrating a function’s work. In the Posit Workbench IDE, @examples are especially helpful because they come with a ‘single click’ hyperlink (see the Run examples from ggplot2::aes() below):\n\n\n\n\n\n\n(a) Run examples hyperlink\n\n\n\n\n\n\n\n(b) Executed @examples code\n\n\n\nFigure 6: Run examples in help files\n\n\n\nThe syntax to create an example for scatter_plot() is below:\n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n\n\n\n\n\n\nTab-completion for @tags\n\n\n\n\n\n\nIf you’re documenting your package functions in Posit Workbench, tab-completion is your friend! The help text displayed with each tag ensures you’re including the correct version (see @example vs. @examples below).\n\n\nTab completion for @example\n\n\n\nTab completion for @examples\n\nRead more here.\n\n\n\n\nTo preview the @examples in the help file, I’ll document() and open the development .Rd file:\n\nCtrl/Cmd + Shift + D\n\n\n?scatter_plot\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n(a) @examples in .Rd preview\n\nFigure 7: Preview of examples\n\n\nThe Run examples hyperlink won’t be active in the .Rd file preview, but reviewing the code in @examples allows me to correct any errors or typos early.\nThe scatter_plot() function has a documented Title, Description, Usage, Arguments, Value, and Examples. I consider these tags the minimum documentation to include for functions I’m making available to other users.\n\n\n\n\n\n\nInserting roxygen2 skeletons\n\n\n\n\n\nYou can insert an roxygen2 skeleton into your function using Code &gt; Insert Roxygen Skeleton\n\n\n\n\n\nFigure 8: Standard roxygen2 skeleton"
  },
  {
    "objectID": "document.html#documenting-app-functions",
    "href": "document.html#documenting-app-functions",
    "title": "Documentation",
    "section": "Documenting app functions",
    "text": "Documenting app functions\nYour app-package will likely contain at least two functions specific to shiny: modules and a standalone app function. roxygen2 has a few tags that can make the documentation for these functions more informative for readers.\nDocumenting modules\nBelow are a few things to consider when documenting module functions:\n\nModules typically have two functions in a single .R file: one for the UI and a counterpart in the server.\nEvery module function will include at least one @param for the shared id.\nReturned objects are critical in shiny’s reactive context, so I recommend extending the description to include whether or not the returned output is reactive.\nIf the returned output is an input (i.e. @param) for another function, link to that documentation functions with @seealso or @family.\n\nBelow are some examples from the pkgApp modules.\n@seealso\nWhen documenting modules, think of the audience as someone looking to understand the execution path through the application. In pkgApp(), the inputs are collected with the var_input module and then passed to the scatter_display module.\nI use @seealso to connect mod_var_input_ui() to its server function counterpart. The hyperlink to mod_var_input_server() from mod_var_input_ui() is created by placing the destination function in square brackets [fun()]:\n#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n#' @seealso [mod_var_input_server()]\n#' \n\nCtrl/Cmd + Shift + D\n\n@seealso creates a hyperlink readers can use to open the next module in the execution path.\n\n\n\n\n(a) @seealso link\n\nFigure 9: Link values from var_input to scatter_display\n\n\nIn mod_var_input_server(), a link can be made to mod_scatter_display_server() (the module function collecting the returned values) using the square brackets in the @return section (without @seealso):\n#' Variable input module (server)\n#'\n#' @param id server module id\n#' \n#' @seealso [mod_var_input_ui()]\n#'\n#' @return reactive inputs are returned in a `list()`: \n#'  * `\"y\" = input$y`\n#'  * `\"x\" = input$x`\n#'  * `\"z\" = input$z`\n#'  * `\"alpha\" = input$alpha`\n#'  * `\"size\" = input$size`\n#'  * `\"plot_title\" = input$plot_title`\n#'  \n#' These become in the `var_inputs()` argument in [mod_scatter_display_server()]\n#' \n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n(a) @seealso in mod_var_input_ui()\n\n\n\n \n\n\n\n\n(b) @seealso in mod_var_input_server()\n\n\n\nFigure 10: Link values from var_input to scatter_display\n\n\n\n@family\nModule functions can also be grouped into families using @family {\"description\"}. Below is an example of grouping the “scatter plot module functions” into a family:\n#' Scatter plot display module (UI)\n#'\n#' @param id UI module id\n#' \n#'\n#' @return module UI (HTML)\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n@section\nThe @section tag will create a level two header (##/&lt;h2&gt;&lt;/h2&gt;) section, which can help organize topics (like how to use an input or argument).\n@seealso can also be used to link back to the scatter_plot() utility function:\n#' Scatter plot display module (server)\n#' \n#'\n#' @param id server module id \n#' @param var_inputs returned reactive list from [mod_var_input_server()].\n#' \n#' @section Referring to `var_inputs`: \n#' Refer to the reactive returned values from `mod_var_input_server()` as:\n#'  * `var_inputs()$x`\n#'  * `var_inputs()$y`\n#'  * `var_inputs()$z`\n#'  * `var_inputs()$alpha`\n#'  * `var_inputs()$size`\n#'  * `var_inputs()$plot_title`\n#' \n#'\n#' @return rendered plot and title output from [scatter_plot()]\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n@family in mod_var_input_server()\n\n\n\n \n\n\n\n\n@seealso in mod_scatter_display_server()\n\n\n\n\n\nThe figure above shows how the @seealso links can create a path for the graph parameters through the var_input and scatter_display modules. It also demonstrates how @family groups the scatter_display UI and server functions.\nThe scatter_plot() utility function should also include a @seealso tag for the module function it’s used in.\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n@seealso in mod_scatter_display_server()\n\n\n\n \n\n\n\n\n@seealso in scatter_plot()\n\n\n\n\n\nThe goal when cross-referencing functions in your app-package is for anyone reading your documentation to follow the links and better understand any modules, their inputs, reactive values, and outputs.\nIn this case, linking to the scatter_plot() function gives readers an interactive example to preview the output.\nStandalone app functions\nSplitting the code in app.R into separate functions has multiple benefits:\n\nDeveloping and loading a function is easier if stored in the R/ folder.\nHaving a dedicated UI, server, and app function means we can develop them independently.\nA standalone app function makes storing multiple applications in the same app-package possible.\n\nI’ve split the UI and server from movies_app() into separate movies_ui() and movies_server() below.\nUI & Server functions\nThe movies_ui() doesn’t have any arguments–the only change is wrapping the shiny::fluidPage() in shiny::tagList():\n\nmovies_ui &lt;- function() {\n  shiny::tagList(\n    shiny::fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nmovies_server() is written to be passed to the server argument in shinyApp():\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\nusage\nI’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). I’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n#' Movies UI function\n#' \n#' UI function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \nThe documentation for movies_server() is very similar to the Ui function–each module server function is documented in it’s own @section.\nStill, I’ll include a @section for Communication that describes how values are passed between mod_var_input_server() and mod_scatter_display_server().\n#' Movies server function\n#' \n#' Server function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#' \n#' ```\n#' shinyApp(movies_ui, movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in [movies_ui()]   \n#'  * server is stored in `movies_server()`\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_server()] returns following reactive values:\n#'  * `x`\n#'  * `y`\n#'  * `z`\n#'  * `alpha`\n#'  * `size`\n#'  * `plot_title`\n#' \n#' @seealso [mod_var_input_ui()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_server()] displays the `ggplot2` graph with the [scatter_plot()] function.\n#' \n#' @seealso [mod_scatter_display_ui()]\n#' \n#' @section Communication: \n#' The output from [mod_var_input_server()] should be supplied to the \n#' `var_inputs` argument of [mod_scatter_display_server()].\n#\n#' @return `server` argument in `shiny::shinyApp()`\n#' \n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nmovies_ui()\n\n\n\n \n\n\n\n\nmovies_server()\n\n\n\n\n\nmovies_app()\nThe standalone app function (movies_app()) automatically calls shinyApp(), with the movies_ui and movies_server functions supplied to ui and server (without parentheses).\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nThe documentation for the standalone app function can be minimal–as long as it provides links to the UI and server.\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_app()\n\nFigure 11: Standalone app function documentation\n\nI’ll change the contents of app.R to the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nNow that we’ve documented everything in R/, we’ll run load(), document(), and install():\n\nCtrl/Cmd + Shift + L\n\ndevtools::load_all(\".\")\nℹ Loading pkgApp\n\nCtrl/Cmd + Shift + D\n\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nDocumentation completed\n\nCtrl/Cmd + Shift + B\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source pkgApp\n\n* installing to library ‘/path/to/local/install/pkgApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘pkgApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (pkgApp)\nIn the Console, we should see the following:\nRestarting R session...\n\n&gt; library(pkgApp)\nThe roxygen2 documentation for pkgApp is saved in the 02-roxygen branch. As we can see, calling devtools::document() generates the .Rd files in the man/ folder for each function in the R/ folder:\n\n\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n ├── movies_app.R\n ├── movies_server.R\n ├── movies_ui.R\n └── utils.R\n\n1 directory, 6 files\n\n\nman/\n  ├── mod_scatter_display_server.Rd\n  ├── mod_scatter_display_ui.Rd\n  ├── mod_var_input_server.Rd\n  ├── mod_var_input_ui.Rd\n  ├── movies_app.Rd\n  ├── movies_server.Rd\n  ├── movies_ui.Rd\n  └── scatter_plot.Rd\n\n1 directory, 8 files\n\n\n\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 02_roxygen2 branch"
  },
  {
    "objectID": "document.html#recap",
    "href": "document.html#recap",
    "title": "Documentation",
    "section": "Recap",
    "text": "Recap\nGood documentation aims to make it as easy as possible for others (and future you) to understand what your function does and how to use it.\nBelow is a recap of the topics covered in this chapter.\n\n\n\n\n\n\nroxygen2 recap\n\n\n\n\n\n\nThis chapter covered:\n\nFunction @title and @description: The @title should be a short one-line description of the function, followed by a more detailed paragraph @description. These tags should give users an idea of what the function does (you can also use @details)\nArguments (@param) and outputs (@return): List all function arguments with @param. Include the argument type (e.g., integer, character, etc.) and a brief description of what the argument does. Be sure to mention any default or optional arguments. Function outputs should be listed with @return and describe the type or class of the object, whether or not it’s reactive, and mention any related functions.\nExamples: @examples provide executable R code that captures how the function is used in your app-package. These are incredibly valuable for new users trying to understand how a function (and your app-package) works.\n\nApp-package specific considerations:\n\nConnect functions with@seealso and @family: Use @seealso to provide links to related functions (i.e., modules) so users can click through a ‘guided tour’ of your application’s code–group similar functions using @family {description}.\nGive more info with @sections: Use @section to give in-depth explanations and specific details about how a function works, including any information about the @usage or its @params.\n@usage: This field will be automatically generated by roxygen2, but in some circumstances, it makes sense to set it to NULL and describe a function’s use explicitly.\n\n\n\n\n\nIn the next section, we’ll use roxygen2 to manage our app-package dependencies."
  },
  {
    "objectID": "dependencies.html#pkgapp",
    "href": "dependencies.html#pkgapp",
    "title": "Dependencies",
    "section": "pkgApp",
    "text": "pkgApp\nWe will use the 02_roxygen2 branch of pkgApp from the end of the previous chapter. Below is a folder tree of its contents:\n\npkgApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   ├── movies_app.R\n  │   ├── movies_server.R\n  │   ├── movies_ui.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man/\n  │   ├── mod_scatter_display_server.Rd\n  │   ├── mod_scatter_display_ui.Rd\n  │   ├── mod_var_input_server.Rd\n  │   ├── mod_var_input_ui.Rd\n  │   ├── movies_app.Rd\n  │   ├── movies_server.Rd\n  │   ├── movies_ui.Rd\n  │   └── scatter_plot.Rd\n  ├── movies.RData\n  ├── pkgApp.Rproj\n  └── www/\n      └── shiny.png\n\n4 directories, 21 files\n\nWhen in doubt…\nLoad, document, and install\nWhile developing your app-package, you might lose track of which devtools function you ran last (I know I do). If this happens, I’ve found loading, documenting, and installing help re-orient me to the current state of the package.\nCtrl/Cmd + Shift + L / D / B\nℹ Loading pkgApp\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nDocumentation completed\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source pkgApp\n\n* installing to library ‘/path/to/local/install/pkgApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘pkgApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (pkgApp)\n\nRestarting R session...\n\n&gt; library(pkgApp)\nIt’s also satisfying to see all three functions execute without any errors!"
  },
  {
    "objectID": "dependencies.html#identifying-dependencies",
    "href": "dependencies.html#identifying-dependencies",
    "title": "Dependencies",
    "section": "Identifying dependencies",
    "text": "Identifying dependencies\nThe first step in managing dependencies is identifying which add-on packages pkgApp relies on. Our goal is to limit the dependencies to only those critical to the functioning of our app, because each additional dependency is a potential point of failure (should this package become unavailable or significantly change).\nI’ve made this process somewhat easier by explicitly namespacing all of the add-on package functions in pkgApp (i.e., with pkg::fun()). You’ll learn more about explicit namespacing in the following sections.\nRunning movies_app()\n\nIn the last chapter, we moved and documented the standalone app function (movies_app()) in the R/ folder. The app.R file now only contains the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nIdeally, we’ll want to replace these calls to libary(), but first we have to make sure the functions we’re using in these packages will be available in pkgApp.\nWhen we run the contents of app.R, we see the following:\n&gt; library(pkgApp)\n&gt; # pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n&gt; # install.packages(pkgs, quiet = TRUE)\n&gt; \n&gt; # packages ------------------------------------\n&gt; library(shiny)\n&gt; library(shinythemes)\n&gt; library(stringr)\n&gt; library(ggplot2)\n&gt; library(rlang)\n&gt; \n&gt; # movies_app ------------------------------------\n&gt; movies_app()\nError in movies_app() : could not find function \"movies_app\"\nWhy can’t R find the \"movies_app\" function in app.R?\nLet’s recap what we’ve done so far:\n\n\napp.R\n\n\napp.R loads the necessary packages and calls movies_app()\n\n\npkgApp/\n    └── app.R\n\n\n\n\n\nR/\n\n\nThe R/movies_app.R file contains the code and documentation for movies_app()\n\n\npkgApp/\n    └── R/\n        └── movies_app.R\n\n\n\n\n\nman/\n\n\nroxygen2 is generating the man/movies_app.Rd file\n\npkgApp/\n    └── man/\n          └── movies_app.Rd\n\n\n\nThe error tells me that despite having documentation for movies_app() in R/ and generating the corresponding .Rd file in man/, the movies_app() function isn’t being exported from pkgApp."
  },
  {
    "objectID": "dependencies.html#exports",
    "href": "dependencies.html#exports",
    "title": "Dependencies",
    "section": "Exports",
    "text": "Exports\nThe exact cause of the error above becomes more apparent when we try to explicitly namespace movies_app() from pkgApp:\n\npkgApp::movies_app()\n\nError: 'movies_app' is not an exported object from 'namespace:pkgApp'\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 03_pkg-exports branch\nTo make the movies_app() function available to users of our package, we need to export it. We export functions by including the @export tag in the roxygen2 comment block (above the function we want to export):\n\n\n@export: The function name (my_func) is not required.\n\n#' @export my_func \n#' my_func &lt;- function() {\n#' \n#' }\n\n\nRead more here\n\n\n\n\nExporting movies_app()\n\nLet’s start by exporting the movies_app() function from pkgApp by placing the @export tag above the function in R/movies_app.R:\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#' @export\n#' \nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nIn app.R, we’ll replace the calls to library() with a single call to library(pkgApp)\n\n# packages ------------------------------------\nlibrary(pkgApp)\n\n# movies_app ------------------------------------\nmovies_app()\n\nWe’ll load, document, and install the package to generate the NAMESPACE changes:\n\nCtrl/Cmd + Shift + L / D / B\n\nNow, when we run the code app.R, we see the following:\n\n\nmovies_app()\n\n\n\nWe’ve lost the shiny icon (www/shiny.png) in the UI, but we’ll address this in the inst/ & www/ chapter.\nmovies_app() launches our application!\n\n\nThe NAMESPACE file now contains a single export (movies_app), and when we enter pkgApp:: in the Console, we see the movies_app() function help file in the tab completion.\n\n\n\n\n\n\n(a) updated NAMESPACE\n\n\n\n\n\n(b) pkgApp namespace\n\n\n\nFigure 1: The movies_app() is now part of the pkgApp namespace\n\n\n\nWhat @export does\nWe’ll pause here to notice a few things about what @export does. After loading, documenting, and installing pkgApp, the NAMESPACE is updated with export(movies_app), and the Console automatically calls library(pkgApp).\nls() returns “the names of the objects in the specified environment, so we can use it to confirm the movies_app() function is the only export from pkgApp:\n\nls(name = \"package:pkgApp\")\n\n[1] \"movies_app\"\nThe search() list\nlibrary(pkgApp) attaches pkgApp to the search list. We can view all the attached packages in the string returned from search():\n\"package:pkgApp\" %in% search()\n[1] TRUE\nWhat about the functions from add-on packages movies_app() relies on, like ggplot2?\nLet’s check to see if ggplot2 is also attached to the search() list:\n\nc(\"package:ggplot2\") %in% search()\n\n[1] FALSE\nWhy does this matter? Because if these packages aren’t attached to the search() list, we can’t call their functions the way we would if we’d used library().\nFor example, if we try to use ggplot2 to build a plot (similar to the one we have in the app), we see the following:\n\nggplot(data = mtcars, \n  aes(x = disp, y = mpg)) + \n  geom_point()\n\nError in ggplot(data = mtcars, \n              aes(x = disp, y = mpg)) : \n  could not find function \"ggplot\"\nIf we want to use functions from the packages pkgApp relies on, we need to explicitly namespace these functions from their original package namespaces (i.e., pkg::fun()):\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\nWe can use ggplot2 if we explicitly namespace it’s functions\n\n\n\n\n\n\n\n\n\n\nAccessing add-on package functions\n\n\n\n\n\n\nWhen a user loads pkgApp with library(pkgApp), any add-on package functions used in exports are available to users if they use pkg::fun() (or if they load the package themselves with library()).\n\n\n\n\nAccess to add-on package functions has implications for the other functions in pkgApp–for example, the scatter_plot() function uses ggplot2 functions. But we’re not exporting scatter_plot(), so when we attempt to run the examples, we see the following error:\n\n\n\n\n\n\n(a) Examples in scatter_plot()\n\n\n\n\n\n(b) Error in scatter_plot() examples\n\n\n\nFigure 2: Examples in scatter_plot() function without exporting\n\n\n\nExamples for ‘pkgApp::scatter_plot’\nThe message at the top of the Help pane is informative because it tells us that despite scatter_plot() being functional when we run movies_app(), it’s not part of the package namespace (and thus, not accessible to users in the help file).\nExporting scatter_plot()\n\nShiny apps often contain utility functions in helper.R or utils.R files. Storing non-shiny code in these files isn’t a bad practice (in fact, it’s encouraged in Mastering Shiny). However, if we’re following the advice in R Packages, we should rename R/utils.R as we transition to an app-package,\n\n‘most of our packages have a utils.R file (Section 6.1) that contains small utility functions that are useful internally, but aren’t part of the core purpose of those packages. We don’t export such functions.’\n\n\n\n\n\n\n\nR/utils.R &gt;&gt; R/scatter_plot.R\n\n\n\n\n\n\nFrom now on, I’ve renamed R/utils.R to R/scatter_plot.R, so it aligns with the naming conventions in other R packages.\nFor a deep dive on R/utils.R files in R packages, I recommend reading Dissecting R Package “Utility Belts”\n\n\n\n\nLet’s add the @export tag to R/scatter_plot.R so it’s exported from pkgApp.\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n#' @export\n#' \n\nAfter loading, documenting, and installing pkgApp, the NAMESPACE is updated with the export() directive:\n\nCtrl/Cmd + Shift + L / D / B\n\nThe contents of the updated NAMESPACE file are below (and pkgApp:: in the Console now displays the scatter_plot() help file in the tab completion):\n\n\n\n\n\n\n(a) @export the scatter_plot function\n\n\n\n\n\n(b) pkgApp::scatter_plot()\n\n\n\nFigure 3: scatter_plot() is now part of the pkgApp namespace\n\n\n\nBelow, we confirm users can access the help file for scatter_plot() and run the examples:\n\n\n\n(a) scatter_plot() examples\n\nFigure 4: Running examples in ?scatter_plot\n\nloadedNamespaces()\nWe’ve already confirmed that ggplot2 isn’t attached with pkgApp (and hence, it is not included in the search() list)\n\nc(\"package:ggplot2\") %in% search()\n\n[1]  FALSE\nHowever, we can access the functions we used the pkg::fun() syntax with because those functions are included in the loaded namespaces (which we can view with loadedNamespaces())\n\nc(\"ggplot2\") %in% loadedNamespaces()\n\n[1] TRUE\nWhat to @export\n\n“When a user calls library(pkgApp), what functions do I want to be available?”\nWhen determining which functions to export, consider the question above. R Packages, 2ed also offers the following advice on what shouldn’t be exported:\n\n‘We believe that packages that have a wide audience should strive to do one thing and do it well. All functions in a package should be related to a single problem (or a set of closely related problems). Any functions not related to that purpose should not be exported.’ - What to export, R Packages, 2ed\n\nThere are multiple ways to interpret the advice above in the context of a shiny app-package:\n\nIf we take a narrow view of the word ‘problem’ to mean ‘create a way to visualize relationships in movie review data’, then maybe we’d consider it solved by only exporting the standalone app function.\nIf the ‘problem’ pkgApp solves is ‘creating a shiny movies app’, we might also want to export any functions that perform distinct tasks with potentially reusable functionality (i.e., generate specific UI components, perform data processing tasks, etc.).\nExtending the ‘problem’ statement to the broadest possible definition would assume users will want access to all the functions in pkgApp–this would allow them to customize, extend, or integrate the contents of pkgApp with other tools. You’ll rarely want to export everything from your app-package, but it can be helpful if your primary audience is other developers within your organization.\n\nMy advice on exports is to balance simplicity and utility when deciding on exported functions.\n\n\n\n\n\n\nLow-key @exports with @keywords internal\n\n\n\n\n\n\nIf you’d like function to be exported, but not listed in the package index, you can combine @export with @keywords internal. These should be used in combination,\n#' @export\n#' \n#' @keywords internal\nFor example, adding @export and @keywords internal to R/scatter_plot.R will make the function accessible to users:\n\n\n\n\nAnd include the help file:\n\n\n\n\nHowever, if a user were to click on the Index for pkgApp (at the bottom of the help file)\n\n\n\n\nscatter_plot is not listed:"
  },
  {
    "objectID": "dependencies.html#imports",
    "href": "dependencies.html#imports",
    "title": "Dependencies",
    "section": "Imports",
    "text": "Imports\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 04_pkg-imports branch\nHanding imports is slightly more involved than package exports because imported dependencies can live in DESCRIPTION and the NAMESPACE.\nThe DESCRIPTION file handles package-level dependencies, specifying which packages pkgApp uses. These packages are installed whenever a user installs pkgApp.\nOn the other hand, the NAMESPACE directives manage function-level access, importing functions from other packages to be used in pkgApp and–as we’ve seen above–exporting functions from pkgApp for others to use.\nWhen pkgApp is documented (i.e., Ctrl/Cmd + Shift + D), roxygen2 tags update the NAMESPACE with any imports or exports. However, the DESCRIPTION file must be edited independently:\n\n\n\nCtrl/Cmd + Shift + D updates the NAMESPACE, but it doesn’t change anything in the DESCRIPTION file.\n\n\n\n\n(a) roxygen2 does not connect the NAMESPACE to the DESCRIPTION\n\nFigure 5: roxygen2 & NAMESPACE = function-level access vs. DESCRIPTION = package-level dependencies\n\nThe differences between the dependencies listed in the NAMESPACE directives and the Imports field in the DESCRIPTION file can be a common point of confusion 1, which is understandable if you’ve consulted Writing R Extensions (specifically the sections on dependencies 2 and namespaces.3\nI’ve attempted to distill and consolidate the advice I’ve found when I’ve gone looking for (and had trouble finding) answers to the following questions:\n\nHow and where should I be importing add-on functions and packages?\nWhy and when should I import add-on packages/functions? and\nWhat happens when a package or function is imported?\n\nI’ve also emphasized the parts I’ve found worth committing to memory.\nHow and where?\nThere are three ways to import dependencies:\n\nUse a ‘fully qualified variable reference’ (i.e., the pkg::fun() syntax)4 for calls to add-on functions in the R/ folder\n\n\nList add-on packages in the Imports field of the DESCRIPTION file\nInclude an @import or @importFrom tag for add-on packages in the R/ folder roxygen25\n\n\n\n\n\n\n\nHow and where to use…\n\n\n\n\n\n\n\npkg::fun()\nImports (DESCRIPTION)\n@import/@importFrom (NAMESPACE)\n\n\n\nWriting R Extensions refers to the pkg::fun() syntax as a ‘fully-qualified reference’:\n\n“A fully-qualified reference to the function f in package foo is of the form foo::f.” - Specifying imports and exports\n\nUsing ‘pkg::fun()’ can seem tedious at first, but fortunately we have tools like tab-completion (if you’re using the Posit Workbench IDE) and packages like sinew (which we’ll cover in a later chapter)\n\n\nR Packages, 2ed recommends using the usethis::use_package() function to include add-on packages to the Imports field of the DESCRIRPTION file6\n\n“Remember usethis::use_package() is helpful for adding dependencies to DESCRIPTION” - Dependencies: In Practice\n\n\n\nR Packages, 2ed assumes you’ll be building your app-package with roxygen2 and devtools::document(), so the authors recommend using the usethis::use_import_from()7\n\n“A handy function for your interactive workflow is usethis::use_import_from()” - In code below R/\n\nUsing usethis::use_import_from() also adds a new R/[app-package]-package.R file, which can server as a ‘central repository’ for the imported functions and packages (see usethis::use_package_doc() also).\n\n\n\n\n\n\n\nHow and where in pkgApp\n\nWe’re already using pkg::fun() in the two exported functions from pkgApp (movies_app() and scatter_plot()):\n\n\npkg::fun() in movies_app():\n\n\nshow/hide explicit namespacing in movies_app()movies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\n\n\n\npkg::fun() in scatter_plot():\n\n\nshow/hide explicit namespacing in scatter_plot()scatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\nNow let’s cover when and why to list these packages and functions as imports.\nWhen and why?\nKnowing when and why to use each import method is just as important as knowing how and where to import add-on packages and functions.\nI’ve done my best to distill the available information into actionable decisions below:\n\n\n\n\n\n\nWhen and why to use…\n\n\n\n\n\n\n\npkg::fun()\nImports (DESCRIPTION)\n@import/@importFrom (NAMESPACE)\n\n\n\nIf your app-package only uses a handful of functions from an add-on package, using pkg::fun() is fine8\n\n“If a package only needs a few objects from another package it can use a fully qualified variable reference (foo::f) in the code instead of a formal import.” - Specifying imports and exports\n\nIf there is a potential name conflict, use the pkg::fun() syntax:\n\nUsing the foo::f form will be necessary when a package needs to use a function of the same name from more than one namespace.” - Specifying imports and exports\n\nOn the other hand, R Packages, 2ed recommends defaulting to pkg::fun() for calls to any add-on packages in the R/ folder because it makes these calls more explicit:\n\n“…the package::function() calling style is also our default recommendation for how to use your dependencies in the code below R/, because it eliminates all ambiguity.” - R packages, Namespace\n“Our recommended default is to call external functions using the package::function() syntax” - R Packages 2ed, In code below R/\n\n\n\nWriting R Extensions states that any add-on package functions using pkg::fun() should be listed in the DESCRIPTION (specifically, the Imports field).\n\n“The Imports field lists packages whose namespaces are imported from (as specified in the NAMESPACE file) but which do not need to be attached. Namespaces accessed by the :: and ::: operators must be listed here.” - Package Dependencies\n\nYou might be wondering, “What if I list a package in DESCRIPTION/Imports field, but don’t list it in the NAMESPACE?” R Packages, 2ed addresses this:\n\n“It is common for a package to be listed in Imports in DESCRIPTION, but not in NAMESPACE. The converse is not true. Every package mentioned in NAMESPACE must also be present in the Imports or Depends fields.” - Confusion about Imports\n\nOn when to use Imports vs. Depends:\n\nUnless there is a good reason otherwise, you should always list packages in Imports not Depends.” - Whether to Import or Depend\n\n\n\nWriting R Extensions states ‘variables exported from other packages’ need to be listed in the NAMESPACE (and recommends using @importFrom over @import in most cases):\n\n“Variables exported from other packages with namespaces need to be imported explicitly using the directives Imports and importFrom” Specifying imports and exports\n“Using importFrom selectively rather than Imports is good practice and recommended notably when importing from packages with more than a dozen exports and especially from those written by others (so what they export can change in future).” - Specifying imports and exports.\n\nUsing pkg::fun() is also referred to as less efficient than a ‘formal import’ in Writing R Extensions (a ‘formal import’ means the add-on package function uses a directive in the NAMESPACE):\n\n“[foo::f] is slightly less efficient than a formal import and also loses the advantage of recording all dependencies in the NAMESPACE file” - Specifying imports and exports.\n\nHowever, R Packages, 2ed recommends minimizing the use of both @import and @importFrom (the aaapkg represents a hypothetical package listed in the Imports field of the DESCRIPTION file in the example below)\n\n“Specifically, we recommend that you default to not importing anything from aaapkg into your namespace. This makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future. This also eliminates any concerns about name conflicts between aaapkg and your package.” Package is listed in Imports\n\nBut R Packages, 2ed also notes the following exceptions to this rule in Package is listed in Imports:\n\n“Sometimes you make such heavy use of so many functions from another package that you want to import its entire namespace.” 9\n“You can’t call an operator from another package via ::, so you must import it.” 10\n\nIf you happen to read the advice from the footnote, you’ll also find somewhat conflicting advice:\n\n“Always use a NAMESPACE to specify imports so that your package code isn’t harmed by other peoples’ use of Depends.” - Whether to Import or Depend: footnote reference\n\n\n\n\n\n\n\n\nWhen and why in pkgApp\n\nI’ve found the best guidance on when and why to use each method (pkg::fun(), Imports in the DESCRIPTION, or @import/@importFrom) comes from the roxygen2 documentation:\n\n“if you are using just a few functions from another package, we recommending adding the package to the Imports: field of the DESCRIPTION file and calling the functions explicitly using ::, e.g., pkg::fun()”\n“If the repetition of the package name becomes annoying you can @importFrom and drop the [pkg::fun()]” - Importing functions\n\nFollowing this advice (and the exceptions to the rule regarding ‘heavy use’11 and ‘operators’12 from add-on packages) we can:\n\n\nReplace the explicit namespacing from all calls to shiny functions (i.e., shiny::) with the @import tag in R/movies_app.R:\n\n\nshow/hide @import in movies_app()#' Movies app standalone function\n#'\n#' Wrapper function for `shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#' \n#' @import shiny\n#'\n#' @export\n#' \nmovies_app &lt;- function() {\n  shinyApp(ui = movies_ui, server = movies_server)\n}\n\n\n\n\nInclude @importFrom for the use of .data in R/scatter_plot.R:\n\n\nshow/hide @importFrom in scatter_plot()#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n#' @importFrom rlang .data\n#' \n#' @export\n#' \nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\nFinally, we need to list each add-on package to the Imports field in the DESCRIPTION using usethis::use_package() (below is the output for ggplot2):\nusethis::use_package(\"ggplot2\")\n✔ Setting active project to '/path/to/pkgApp'\n✔ Adding 'ggplot2' to Imports field in DESCRIPTION\n• Refer to functions with `ggplot2::fun()`\nAfter adding all add-on packages to the DESCRIPTION with usethis::use_package(), we’ll load, document, and install pkgApp:\n\nCtrl/Cmd + Shift + L / D / B\n\nAnd we should review the updated NAMESPACE and DESCRIPTION files:\n\n\n\n\n\n(a) Updated NAMESPACE with Imports and `importFrom\n\n\n\n\n\n(b) Updated DESCRIPTION with all Imports\n\n\n\nFigure 6: roxygen2 will update the NAMESPACE, but usethis::use_package() is needed to update the DESCRIPTION\n\n\nWhen we run movies_app(), we see the application launches and we can still run the scatter_plot() examples:\n\n\n\n\n\n(a) movies_app() works\n\n\n\n\n\n(b) Examples in ?scatter_plot\n\n\n\nFigure 7: Confirming we still have full functionality in pkgApp\n\n\nIn the next section, we’re going to cover what happens when these packages and functions were included as imports in pkgApp.\nWhat happens?\nWhat happens to imported packages and functions can get a bit technical, but I’ve done my best to include what I consider to be the necessary distinctions between using pkg::fun(), the @import/@importFrom tags, and the Imports field in the DESCRIPTION.\nI strongly encourage reading the namespaces section of Advanced R, 2ed for a deeper understanding of these topics.\n\n\n\n\n\n\nWhat happens when we use…\n\n\n\n\n\npkg::fun()\nImports (DESCRIPTION)\n@import/@importFrom (NAMESPACE)\n\n\n\n\n“Evaluating foo::f will cause package foo to be loaded, but not attached, if it was not loaded already” - Specifying imports and exports.\n\nThis means if users of our package want to use foo::f, they will have to use foo::f.\n\n\nR Packages, 2ed describes what happens to packages listed in Imports:\n\nConsider a dependency that is listed in DESCRIPTION in Imports:\nImports:\n    aaapkg\nThe code inside your package can assume that aaapkg is installed whenever pkg is installed.\n\nR Packages, 2ed also recommends using Imports (instead of Depends) and describes the the differences in their actions (i.e., loading vs. loaded & attaching)\n\n“The main difference is that a package you list in Imports will just be loaded when you use it, whereas a package you list in Depends will be attached when your package is attached. - Whether to Import or Depend\n\n\n\nImports are covered in Advanced R, 2ed:\n\n“Each namespace has an imports environment that can contain bindings to functions used by the package that are defined in another package. The imports environment is controlled by the package developer with the NAMESPACE file. Specifically, directives such as importFrom() and imports() populate this environment.” - Function lookup inside a package\n\n\n\n\n\n\n\nWhat happened in pkgApp\n\nFirst, let’s confirm we’re still only exporting movies_app() and scatter_plot() from pkgApp:\n\nls(name = \"package:pkgApp\")\n\n[1] \"movies_app\"   \"scatter_plot\"\nGreat. Now we’ve listed five packages in the Imports field of the DESCRIPTION file:\nImports: \n    ggplot2,\n    rlang,\n    shiny,\n    shinythemes,\n    stringr\nThe search() list\nAre these packages on the search list?\n\npkgs &lt;- c(\"package:ggplot2\", \"package:rlang\", \n          \"package:shiny\", \"package:shinythemes\", \n          \"package:stringr\")\npkgs %in% search()\n\n[1] FALSE FALSE FALSE FALSE FALSE\nThis demonstrates that none of these packages are attached with pkgApp. However, the rlang and shiny packages are included in the loadedNamespaces() (because we included them with @import/@importFrom).\n\npkgs &lt;- c(\"ggplot2\", \"rlang\", \"shiny\", \n          \"shinythemes\", \"stringr\")\npkgs %in% loadedNamespaces()\n\n[1] FALSE  TRUE  TRUE FALSE FALSE\nWe can still access the add-on package functions in pkgApp using the pkg::fun() syntax:\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\nggplot2 functions are still available if we explicitly namespace"
  },
  {
    "objectID": "dependencies.html#checking-dependencies",
    "href": "dependencies.html#checking-dependencies",
    "title": "Dependencies",
    "section": "Checking dependencies",
    "text": "Checking dependencies\nWith all the moving parts in dependency management, it can be easy to forget if you’ve documented everything correctly. So far we haven’t covered using devtools::check() as part of your app-package habits (which is fine), but this is one area it’s particularly helpful.\nFor example, if I had listed shiny as an import using the @import tag (resulting in the import(shiny) directive in the NAMESPACE), devtools::check() would produce the following error:\n── R CMD check results ────────────────────────── pkgApp 0.0.0.9000 ────\nDuration: 7.4s\n\n❯ checking package dependencies ... ERROR\n  Namespace dependency missing from DESCRIPTION Imports/Depends entries: ‘shiny’\n  \n  See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’\n  manual.\n\n1 error ✖ | 0 warnings ✔ | 0 notes ✔\nError: R CMD check found ERRORs\nExecution halted\n\nExited with status 1."
  },
  {
    "objectID": "dependencies.html#recap",
    "href": "dependencies.html#recap",
    "title": "Dependencies",
    "section": "Recap",
    "text": "Recap\nBelow are the main takeaways from managing the imports and exports from your app-package:\n\n\n\n\n\n\nDependencies recap\n\n\n\n\n\n\nThis chapter covered:\n\nExports: Aim for a balance between simplicity and utility when deciding which functions to export (i.e., what functions should be available to users who install your package). Export objects from using @export\n\nImports: Use pkg::fun() syntax when you use add-on package functions and include them in the Imports field of the DESCRIPTION file. App-packages use so many shiny functions it makes sense to include @import shiny to 1) ensure all of these functions are available, and 2) you won’t need to use pkg::fun().\n\nDESCRIPTION Imports This field lists the packages your app-package uses. All add-on packages used in the R/ folder must be listed in the Imports field. These functions can be called using the pkg::fun() syntax (or with @importFrom()). Functions from these packages will be available for your package, but not for the user unless they use the :: operator or load the package themselves with library().\nNAMESPACE imports: The @import/@importFrom tags make the functions from add-on packages available to your package. Favor using @importFrom over @import for add-on package functions (the only exception being shiny, which you’d want to use @import).\n\n\n\nThe Imports field in the DESCRIPTION handles package-level dependencies (and it is managed manually or with usethis::use_package()), while the NAMESPACE handles function-level access (with @export and @import/@importFrom).\n\n\n\n\nIn the next section, we’ll cover how the ensure the app.R file runs our application!"
  },
  {
    "objectID": "dependencies.html#footnotes",
    "href": "dependencies.html#footnotes",
    "title": "Dependencies",
    "section": "",
    "text": "See the section titled, ‘Confusion about Imports’ in R Packages, 2ed, “Listing a package in Imports in DESCRIPTION does not ‘import’ that package.”↩︎\nSee section 1.1.3 Package Dependencies in Writing R Extensions↩︎\nSee section 1.5, Package namespaces in Writing R Extensions↩︎\nWe’re already using this method in the functions for pkgApp↩︎\nThe @import and @importFrom tags will add the import() or importFrom() directives in the NAMESPACE, respectively.↩︎\nThe official R documentation assumes you’ll adding dependencies to the DESCRIPTION file manually↩︎\nThe official R documentation assumes you’ll be editing the NAMESPACE manually (i.e., with export(), import(), and importFrom() directives)↩︎\nThis is the case for ggplot2 in our exported scatter_plot() function from pkgApp↩︎\nApp-packages should include @import shiny because nearly all the functions (modules, standalone app functions, etc.) will require shiny.↩︎\nOur use of .data in scatter_plot() requires @importFrom because it’s not accessible with :: from rlang.↩︎\n“Sometimes you make such heavy use of so many functions from another package that you want to import its entire namespace.”, R Packages, 2ed, In code below R/”↩︎\n“You can’t call an operator from another package via ::, so you must import it”, R Packages, 2ed, In code below R/”↩︎"
  },
  {
    "objectID": "launch.html#app.r-main",
    "href": "launch.html#app.r-main",
    "title": "Launch",
    "section": "\napp.R (main)",
    "text": "app.R (main)\nWe’re going to revert back to the main branch of pkgApp to get a better understanding of the evolution of our app.R file. When we initially used app.R to run movies_app(), it contained the library() calls for the necessary packages, the code for movies_app(), and a call to the function:\n\n\n\n\n\nGit Branch\n\npkgApp repo’s main branch\n\n\nshow/hide initial version of movies_app()# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nmovies_app()\n\n\nmovies_app() is a wrapper function for shinyApp(), but it creates the ui and server arguments internally (with the modules). As we can see in the image below, the Run App icon is available in the Source pane:\n\n\n\n(a) app.R in main branch\n\nFigure 1: Run App icon in app.R of main branch\n\nClicking on Run App will call runApp() in the Console, but it also produces a warning:\n\n\n\nrunApp() in Console of main branch\n\nFigure 2: Clicking on Run App in app.R of main branch\n\nSo even though app.R contains a call to shinyApp(), movies_app() is actually run with runApp() (we’ll come back to this in a moment).\n\nloadSupport() warning\nThe warning in the Console tells us we should be mindful of ‘unexpected behavior(s)’ when sourcing the R/ subdirectory in an R package (or app-package in this case):\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\n  contain an R package. Sourcing files in R/ may cause unexpected behavior.\nIf you recall, we covered loadSupport() back in the shiny chapter.1 The warning above also tells us that despite pkgApp being structured as an app-package, the R/ folding is still being sourced like it’s a shiny project."
  },
  {
    "objectID": "launch.html#app.r-02_roxygen2",
    "href": "launch.html#app.r-02_roxygen2",
    "title": "Launch",
    "section": "\napp.R (02_roxygen2)",
    "text": "app.R (02_roxygen2)\nLet’s jump ahead to the 02_roxygen2 branch of pkgApp, which was the first version of movies_app() that we contained in the R/ folder (in R/movies_app.R).\n\n\n\n\n\nGit Branch\n\npkgApp repo’s 02_roxygen2 branch\n\nR/\n├── mod_scatter_display.R\n├── mod_var_input.R\n├── movies_app.R &lt;- movies_app()\n├── movies_server.R\n├── movies_ui.R\n└── utils.R\n\n1 directory, 6 files\nIn the 02_roxygen2 branch, the movies_app() function wasn’t exported yet, so we saw the error below when we run the contents of app.R:\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nError in movies_app() : could not find function \"movies_app\"\nHowever, if we run call runApp() in the Console, we see the following:\n\n\n\n(a) Calling runApp() in 02_roxygen2\n\nFigure 3: The application is launched (with the loadSupport() warning)\n\nFeature or bug?\nThe examples above demonstrate the differences between shinyApp() and runApp(), and the tensions between the R package structure and the shiny framework:\n\nThe reason we’re able to call runApp() in the Console and launch the application in movies_app() is because runApp() is designed to work with directories containing shiny apps.\nWe’re seeing the loadSupport() warning because one of the features of shiny projects is that all .R files in the R/ folder are source()ed when app launches.2\n\nAfter converting the contents of pkgApp into an app-package, the contents of R/ are loaded with devtools::load_all(). In the following section, we’ll compare shinyApp() and runApp() to determine which one to use in R/movies_app.R and the app.R file."
  },
  {
    "objectID": "launch.html#shinyapp-vs.-runapp",
    "href": "launch.html#shinyapp-vs.-runapp",
    "title": "Launch",
    "section": "\nshinyApp() vs. runApp()\n",
    "text": "shinyApp() vs. runApp()\n\nshinyApp() is typically used to create apps within an interactive R session (like the R console or in Posit Workbench). runApp() is designed to run standalone apps located in a separate directory containing ui.R and server.R (or app.R) files. 3\n\n\nshinyApp()\nDevelopers can use shinyApp() to quickly spin up simple applications by defining ui and server arguments (e.g. as shinyApp(ui, server)).\n\nshinyApp(\n  ui = fluidPage(\n    # UI elements\n  ),\n  server = function(input, output) {\n    # Server logic\n  }\n)\n\n\n\nrunApp()\nrunApp() is more suited to be used in app-packages because it can launch app organized inside a dedicated sub-directories (and the path can be provided to the appDir argument).\n\nrunApp(appDir = \"path/to/app/folder\")"
  },
  {
    "objectID": "launch.html#updated-movies_app",
    "href": "launch.html#updated-movies_app",
    "title": "Launch",
    "section": "Updated movies_app()\n",
    "text": "Updated movies_app()\n\nOne of the key features of shinyApp() is the creation of the shiny.appobj (a shiny app object):\n\napp &lt;- shinyApp(ui = movies_ui, \n                server = movies_server)\nstr(app)\n\nIf we look at the structure of the returned object from shinyApp(), we see the shiny.appobj includes the appDir (the first argument of runApp()).\nList of 5\n $ httpHandler     :function (req)  \n $ serverFuncSource:function ()  \n $ onStart         : NULL\n $ options         : list()\n $ appOptions      :List of 2\n  ..$ appDir       : chr \"/path/to/app/project/pkgApp\"\n  ..$ bookmarkStore: NULL\n - attr(*, \"class\")= chr \"shiny.appobj\"\nWe’ll rewrite movies_app() below using runApp().\nshiny.launch.browser\nWe want to have control over where the shiny application will be launched from (i.e., the Viewer pane, the IDE Window, or an external browser). We can access this with the shiny.launch.browser option:4\n\n  switch(EXPR = run, \n    view = options(shiny.launch.browser = .rs.invokeShinyPaneViewer),\n    browser = options(shiny.launch.browser = .rs.invokeShinyWindowExternal),\n    win = options(shiny.launch.browser = .rs.invokeShinyWindowViewer),\n    default = getOption(x = 'shiny.launch.browser')\n  )\n\ntest.mode\nAnother great feature of runApp() is the ability to control the application’s behavior with test.mode:\n\n‘Should the application be launched in test mode? This is only used for recording or running automated tests. Defaults to the shiny.testmode option, or FALSE if the option is not set.’\n\nThe test.mode argument lets us export values from our application when we’re running tests (which we’ll cover in-depth in the testing chapter).\nWe’ll make test an logical argument (defaulting to TRUE) in our updated movies_app() function.\n\nmovies_app &lt;- function(test = TRUE, run = \"default\") {\n  app &lt;- shinyApp(ui = movies_ui, \n                  server = movies_server)\n  switch(EXPR = run, \n    view = options(shiny.launch.browser = .rs.invokeShinyPaneViewer),\n    browser = options(shiny.launch.browser = .rs.invokeShinyWindowExternal),\n    win = options(shiny.launch.browser = .rs.invokeShinyWindowViewer),\n    default = getOption(x = 'shiny.launch.browser')\n  )\n   if (test)\n      runApp(appDir = app, test.mode = TRUE)\n   else\n      runApp(appDir = app, test.mode = FALSE)\n}\n\n\n\n\nRemember–we don’t need to explicitly namespace shinyApp() or runApp() (i.e., with pkg::fun()) because we’re using #' @import shiny in the R/movies_app.R file.\n\nThe updated roxygen2 documentation for movies_app() is below:\n#' Movies app standalone function\n#'\n#' Wrapper function for `runApp()`\n#' \n#' @param test logical, run in `test.mode`?\n#' @param run where to launch app: \n#'  * `view` = launch in viewer  \n#'  * `browse` = launch in external browser  \n#'  * `win` = launch in window\n#'  * `default` = `getOption(x = 'shiny.launch.browser')`\n#' \n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#' \n#' @import shiny\n#'\n#' @export\n#'"
  },
  {
    "objectID": "launch.html#updated-app.r",
    "href": "launch.html#updated-app.r",
    "title": "Launch",
    "section": "Updated app.R\n",
    "text": "Updated app.R\n\nNow that we’ve updated the movies_app() function, we should re-write the contents of app.R to account for the app-package structure.\nif (!interactive())\nThe first thing we should include is a check to see if there is a “human operator to interact with” with base::interactive():\n\nif (!interactive()) {\n  \n} else {\n   \n}\n\nYou have probably seen control flow like this in shiny help file examples (like flowLayout() below).\n\n\n\n(a) if (interactive()) in flowLayout() example\n\nFigure 4: Running examples interactively let’s us see the app demo beneath the code\n\nstderr()\nWhat if the session isn’t interactive (i.e., !interactive() == TRUE)?\nIn this case, we’ll divert all outputs (standard output stdout() and standard error (stderr())) to go to the same place (stderr()).\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n} else {\n   \n}\n\nThis is useful in a non-interactive settings if we want to re-direct the error output for the console text-mode connection.\ntryCatch()\ntryCatch() is used for ‘catching conditions’ during the execution of an expression (expr =):\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(pkgApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   \n}\n\nIn this case, if library(pkgApp) throws an error, the function specified after error = is executed (i.e., pkgload::load_all()).\nWritten this way, in a non-interactive R session, app.R will re-direct the error output and attempt to load and attach pkgApp, and if this fails, app.R will attempt to load all the files in the R/ folder.\npkgload::load_all()\nIf the session is interactive (i.e., !interactive() == FALSE), we want app.R to load all the code in the R/ folder with pkgload::load_all().5\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(pkgApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   pkgload::load_all()\n}\n\nRecall that pkgload::load_all() is function actually called when we run devtools::load_all() (or use Ctrl/Cmd + Shift + L), and this is analogous to running library(pkgApp)"
  },
  {
    "objectID": "launch.html#calling-movies_app",
    "href": "launch.html#calling-movies_app",
    "title": "Launch",
    "section": "Calling movies_app()\n",
    "text": "Calling movies_app()\n\nAfter loading, documenting, and installing pkgApp, we’ll run movies_app() in the Console to see if we’re still getting the loadSupport() warning:\n\n\n\n(a) Running movies_app() in Console\n\nFigure 5: The loadSupport() warning is gone"
  },
  {
    "objectID": "launch.html#running-app.r",
    "href": "launch.html#running-app.r",
    "title": "Launch",
    "section": "Running app.R\n",
    "text": "Running app.R\n\nIn app.R is a call to movies_app() (with test set to FALSE because we haven’t set up our testing suite yet).\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(pkgApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   pkgload::load_all()\n}\n\n# movies_app ------------------------------------\npkgApp::movies_app(test = FALSE)\n\nWhen we send the contents of app.R to the Console, the control flow safely loads pkgApp before running the app:\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 05_run-app branch\n\n\n\n(a) Sending app.R to Console\n\nFigure 6: pkgApp is loaded before running movies_app()\n\n\n\n\n\n\n\nR/_disable_autoload.R\n\n\n\n\n\n\nIn the documentation for loadSupport(), you’ll find an option to remove the R/ directory sourcing by placing a file named _disable_autoload.R in your R/ directory (this is also one of the behaviors of the golem framework, which we will cover in the following chapters).\nIt’s perfectly fine to adopt this behavior–this chapter demonstrates a way to remove the loadSupport() warning without having to add this file."
  },
  {
    "objectID": "launch.html#recap",
    "href": "launch.html#recap",
    "title": "Launch",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some options for what to include in the app.R file of your app-package. The differences between shinyApp() and runApp() are worth exploring further, especially if you plan on having more than one apps in a package (or multiple versions of the same application in the same app-package).\n\n\n\n\n\n\nRecap: shinyApp() vs. runApp()\n\n\n\n\n\n\nshinyApp():\n\nshinyApp() doesn’t care about file structure, so it’s useful for quick prototyping or if the app is in a single .R script. It’s also more portable because you can share your app with a single .R script.\nIt’s possible to bundle shinyApp() in a wrapper function to integrate within an R package (like we’ve done with movies_app()).\nshinyApp() can also be used to return a shiny app object, which can be useful if you want to explore the app structure programmatically (i.e., testing).\n\nrunApp()\n\nrunApp() is designed for running apps contained in a directory (i.e., runApp('path/to/app'). If the app is in separate ui.R and server.R files (or a single app.R file) runApp() will automatically look for these. However, a shiny app object can also be passed to the appDir argument to launch your app.\nIf you’ve separated your app into multiple files that includes additional assets like data or a www/ folder, runApp() is a better option.\n\n\n\n\n\nIn the following chapter, we’re going to cover how to ensure movies.Data becomes part of the pkgApp namespace."
  },
  {
    "objectID": "launch.html#footnotes",
    "href": "launch.html#footnotes",
    "title": "Launch",
    "section": "",
    "text": "loadSupport() is how the R/ and www/ folders are automatically sourced/served when we launched our app.↩︎\nWe covered the shiny::loadSupport() function in Chapter 1.↩︎\nIt’s worthwhile to read the documentation on shinyApp() and runApp().↩︎\nThe shiny.launch.browser options are covered in this blog post by Garrick Aden-Buie, and I’ve combined them into a run argument in movies_app()↩︎\npkgload is part of the conscious uncoupling of the devtools package we learned about back in Chapter 3.↩︎"
  },
  {
    "objectID": "data.html#app-package-data",
    "href": "data.html#app-package-data",
    "title": "Data",
    "section": "App-package data",
    "text": "App-package data\nThere are three folders used to store data in R packages: data/, data-raw/, and inst/extdata/. The folder you’ll use will depend on the format, accessibility, and intended purpose of the data file in your app-package.1"
  },
  {
    "objectID": "data.html#the-data-folder",
    "href": "data.html#the-data-folder",
    "title": "Data",
    "section": "The data/ folder",
    "text": "The data/ folder\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 06_data branch\nThe primary location for app-package data is the data/ folder. Data objects in the data/ folder are available in the package namespace when it’s installed and loaded, and can be accessed with the package::data syntax. See the example below:\n\nlibrary(dplyr)\nhead(dplyr::storms)\n## # A tibble: 6 × 13\n##   name   year month   day  hour   lat  long status\n##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; \n## 1 Amy    1975     6    27     0  27.5 -79   tropi…\n## 2 Amy    1975     6    27     6  28.5 -79   tropi…\n## 3 Amy    1975     6    27    12  29.5 -79   tropi…\n## 4 Amy    1975     6    27    18  30.5 -79   tropi…\n## 5 Amy    1975     6    28     0  31.5 -78.8 tropi…\n## 6 Amy    1975     6    28     6  32.4 -78.7 tropi…\n## # ℹ 5 more variables: category &lt;dbl&gt;, wind &lt;int&gt;,\n## #   pressure &lt;int&gt;,\n## #   tropicalstorm_force_diameter &lt;int&gt;,\n## #   hurricane_force_diameter &lt;int&gt;\n\nLazyData: true\nFiles in data/ should be in the .rda or .RData format. Data files become part of a package when they’re added to the data/ folder and LazyData: true is added to the DESCRIPTION file.\n\nLazyData: true: the data is only loaded into memory if it is explicitly accessed by the user or a function in the package. Until then, only the dataset names is loaded. This practice user-friendly and is the default for most R packages.\nLazyData: false (or omitted): accessing a data file from the package requires explicitly loading it using the data() function.\n\nBelow are the steps for adding movies to pkgApp:\n\nMove the movies.RData file into a newly created the data/ folder:\n\n\npkgApp/\n  │\n  └──data/\n      └── movies.RData\n\n\nInclude LazyData: true in the DESCRIPTION file (I’ve added it above Imports:):\n\n\nPackage: pkgApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nLazyData: true\nImports:\n  shiny,\n  ggplot2,\n  rlang,\n  stringr,\n  tools\n\n\nLoad, document, and install.\n\nCtrl/Cmd + Shift + L\nℹ Loading pkgApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nDocumentation completed\nCtrl/Cmd + Shift + B\nIn the Build pane, you’ll notice a few new ** data lines of output after adding data:\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\nWe can check to see if movies has been included in pkgApp using the package::data syntax:\n\n\n\n(a) roxygen2\n\nFigure 1: movies is now part of pkgApp\n\nusethis::use_data()\nIf you’d prefer to store data using the .rda format, the usethis package has the use_data() function that will automatically store an object in data/ in the .rda format.\nTo use usethis::use_data(), we can load the movies data into the global environment with load(\"movies.RData\"), then run usethis::use_data(movies):\n\nusethis::use_data(movies)\n\n✔ Setting active project to '/path/to/pkgApp'\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Saving 'movies' to 'data/movies.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nThe Depends: field is added to the DESCRIPTION file with an R version (this ensures the data files will be loaded)\nDepends: \n    R (&gt;= 2.10)\n(this function will also add LazyData: true to the DESCRIPTION)\n\n\n\n\n\n\nMastering Shiny data example\n\n\n\n\n\n::: {style=’font-size: If you happened to download, install and load the monthApp example from Mastering Shiny, you may have noticed the NAMESPACE was empty, but the data was exported from the package:\n\n\nmonthApp exports\n\nData files in data/ don’t require roxygen2 tags to be included in a package namespace. em; color: #696969;’}\nYour text\n\n\n\n::::\nDocumenting data/\n\nDocumenting data can be tedious, but it’s worth the effort if you’ll be sharing your application with collaborators. There are multiple ways to store the documentation for datasets. For example, we could create a data.R file in the R/ folder.\n\nfs::file_create(\"R/data.R\")\n\nIn data.R, we provide a @title, @description, and @details for the data (with or without the tags), followed by @format:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)   \n#'\n#' @format\n\n@format\nThe text following @format is a one-sentence description of the data (with it’s dimensions).\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#' \n#' @format A data frame with [] rows and [] variables:\n\n\\describe & \\item\nEach variable (column) in the data is documented with a combination of \\describe and \\item (pay close attention to the curly brackets):\n\n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n\nAfter closing the curly brackets in \\describe, place the name of the data in quotes (\"movies\") on the following line.\nBelow is the documentation for the first five columns in the movies dataset:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#' }\n#'\n\"movies\"\n\nIf we load and document pkgApp, we can see a preview of the help file:\nCtrl/Cmd + Shift + L\nℹ Loading pkgApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nWriting movies.Rd\nDocumentation completed\n\n?movies\n\n\n\n\n(a) The movies help file\n\nFigure 2: Documentation for the movies dataset\n\nI’ve provided documentation for the full movies dataset below.\n\nshow/hide full movies data documenation#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#'  \\item{studio}{name of studio, chr}\n#'  \\item{thtr_rel_date}{Theatre release date, POSIXct, min = 1970-05-19 21:00:00, max = 2014-12-24 21:00:00}\n#'  \\item{thtr_rel_year}{Theatre release year, num, min = 1970, max = 2014}\n#'  \\item{thtr_rel_month}{Theatre release month, num, min = 1, max =12}\n#'  \\item{thtr_rel_day}{Theatre release day, num, min = 1, max =31}\n#'  \\item{dvd_rel_date}{DVD release date, POSIXct, min = 1991-03-27 21:00:00, max = 2015-03-02 21:00:00}\n#'  \\item{dvd_rel_year}{DVD release year, num, min = 1991, max = 2015}\n#'  \\item{dvd_rel_month}{DVD release month, num, min = 1, max = 12}\n#'  \\item{dvd_rel_day}{DVD release day, num, min = 1, max = 31}\n#'  \\item{imdb_rating}{Internet movie database rating, avg = 6.49, sd = 1.08}\n#'  \\item{imdb_num_votes}{Internet movie database votes, avg = 57533, sd = 112124}\n#'  \\item{critics_rating}{Rotten tomatoes rating, fct (Certified Fresh, Fresh, Rotten)}\n#'  \\item{critics_score}{Rotten tomatoes score, avg = 57.7, sd = 28.4}\n#'  \\item{audience_rating}{Audience rating, fct (Spilled, Upright)}\n#'  \\item{audience_score}{Audience score, avg = 62.4, sd = 20.2}\n#'  \\item{best_pic_nom}{Best picture nomination, fct (no, yes)}\n#'  \\item{best_pic_win}{Best picture win, fct (no, yes)}\n#'  \\item{best_actor_win}{Best actor win, fct (no, yes)}\n#'  \\item{best_actress_win}{Best actress win, fct (no, yes)}\n#'  \\item{best_dir_win}{Best director win, fct (no, yes)}\n#'  \\item{top200_box}{Top 20 box-office, fct (no, yes)}\n#'  \\item{director}{Name of director, chr}\n#'  \\item{actor1}{Name of leading actor, chr}\n#'  \\item{actor2}{Name of supporting actor, chr}\n#'  \\item{actor3}{Name of #3 actor, chr}\n#'  \\item{actor4}{Name of #4 actor, chr}\n#'  \\item{actor5}{Name of #5 actor, chr}\n#'  \\item{imdb_url}{IMDB URL}\n#'  \\item{rt_url}{Rotten tomatoes URL}\n#' }\n#'\n\"movies\"\n\n\nRemove load()\n\nAfter documenting the movies data in data.R, we’ll remove the call to load() in the mod_scatter_display_server() function and replace it with a direct call to the dataset:\n\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n\n  inputs &lt;- reactive({\n    plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n  })\n  output$scatterplot &lt;- renderPlot({\n    plot &lt;- scatter_plot(\n      # data -------------------------\n      df = movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size\n    )\n    plot +\n      ggplot2::labs(\n        title = inputs()$plot_title,\n        x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n        y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n      ) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n})\n}\n\nAfter loading, documenting, and installing the package, we see the following application:\n\n\n\n\n(a) movies_app() with movies data file\n\nFigure 3: pkgApp::movies in movies_app()\n\n\nMore data/ examples\nTo illustrate other options for data documentation, we’ll use the dplyr package. dplyr stores its data in the data/ folder:\ndata/\n├── band_instruments.rda\n├── band_instruments2.rda\n├── band_members.rda\n├── starwars.rda\n└── storms.rda\nThe documentation for the datasets in dplyr are stored in R/ using a data- prefix:\nR/\n├── data-bands.R\n├── data-starwars.R\n└── data-storms.R\nThe three band_ datasets have documented in a single file, data-bands.R:\n\nshow/hide documentation for dplyr::band_ datasets# from the dplyr github repo: \n# https://github.com/tidyverse/dplyr/blob/main/R/data-bands.R\n# \n#' Band membership\n#'\n#' These data sets describe band members of the Beatles and Rolling Stones. They\n#' are toy data sets that can be displayed in their entirety on a slide (e.g. to\n#' demonstrate a join).\n#'\n#' `band_instruments` and `band_instruments2` contain the same data but use\n#' different column names for the first column of the data set.\n#' `band_instruments` uses `name`, which matches the name of the key column of\n#' `band_members`; `band_instruments2` uses `artist`, which does not.\n#'\n#' @format Each is a tibble with two variables and three observations\n#' @examples\n#' band_members\n#' band_instruments\n#' band_instruments2\n\"band_members\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments2\"\n\n\nIn the example above, note that two of the datasets (band_instruments and band_instruments2) have the @format set to NULL, and define the help search name with @rdname. The @examples tag can be used to view the dataset when users click ‘Run Examples’\nEither method works–what’s important is that each dataset in your package has documentation.\n\n\n\n\n\n\nDocumenting data in data/\n\n\n\n\n\nDocumenting data requires the following roxygen2 structure:\n#' \n#' @title single-sentence describing [data]\n#' \n#' @description\n#' Single-paragraph describing [data]\n#' \n#' @format [data] number of rows and columns:\n#' \\describe{\n#'  \\item{variable}{description}\n#'  \\item{variable}{description}\n#' }\n#'\n\"[data]\"\nReplace [data] with the name of your dataset."
  },
  {
    "objectID": "data.html#the-data-raw-folder",
    "href": "data.html#the-data-raw-folder",
    "title": "Data",
    "section": "The data-raw/ folder",
    "text": "The data-raw/ folder\nThe data-raw folder is not an official directory in the standard R package structure, but it’s a common location for any data processing or cleaning scripts, and the raw data file for datasets stored in data/.2\n\n\n\n\n\n\nScripts for creating movies data\n\n\n\n\n\n\nThe code used to produce the movies dataset in the data/ directory might* come from this GitHub repo. If so, the data-raw folder is where the data processing and preparation scritps would be stored (along with a copy of the data in .csv format) before saving a copy in the data/ folder.\n*I say ‘might’ because it’s not clear if the movies.RData is the output from these .R files (although many of the column names match).\n\n\n\n\nMore data-raw/ examples\nIf we look at the data in the dplyr package again, we can see the data-raw/ folder contains a combination of .R and .csv files:\ndata-raw/\n├── band_members.R\n├── starwars.R\n├── starwars.csv\n└── storms.R\n\n1 directory, 4 files\nIn this example, the starwars.R script downloads & prepares starwars, then saves a .csv copy of the data in data-raw."
  },
  {
    "objectID": "data.html#the-instextdata-folder",
    "href": "data.html#the-instextdata-folder",
    "title": "Data",
    "section": "The inst/extdata/ folder",
    "text": "The inst/extdata/ folder\nThe extdata folder (inside inst/) can be used for external datasets in other file formats (.csv, .tsv, .txt, .xlsx, etc).3 The data files in inst/extdata/ aren’t directly loadable using the package::data syntax or the data() function like with the data/ directory. These files can be imported using the file path accessor function, system.file().\nFor example, if we create the inst/extdata/ and save a copy of movies as a .fst file:\n\nlibrary(fs)\nlibrary(tibble)\nlibrary(fst)\n\n\nfst package v0.9.8\n\n\nfs::dir_create(\"inst/extdata/\")\nfst::write_fst(\n  x = movies, \n  path = \"inst/extdata/movies.fst\", \n  compress = 75)\n\n\nfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\n\nThen load, document, and install pkgApp:\nCtrl/Cmd + Shift + L / D / B\nWe can import movies.fst using system.file() to create a path to the file:\n\ntibble::as_tibble(\n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"pkgApp\")\n    )\n  )\n\n# A tibble: 651 × 34\n   title  title_type genre runtime mpaa_rating studio thtr_rel_date      \n   &lt;chr&gt;  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;  &lt;dttm&gt;             \n 1 Filly… Feature F… Drama      80 R           Indom… 2013-04-18 21:00:00\n 2 The D… Feature F… Drama     101 PG-13       Warne… 2001-03-13 21:00:00\n 3 Waiti… Feature F… Come…      84 R           Sony … 1996-08-20 21:00:00\n 4 The A… Feature F… Drama     139 PG          Colum… 1993-09-30 21:00:00\n 5 Malev… Feature F… Horr…      90 R           Ancho… 2004-09-09 21:00:00\n 6 Old P… Documenta… Docu…      78 Unrated     Shcal… 2009-01-14 21:00:00\n 7 Lady … Feature F… Drama     142 PG-13       Param… 1985-12-31 21:00:00\n 8 Mad D… Feature F… Drama      93 R           MGM/U… 1996-11-07 21:00:00\n 9 Beaut… Documenta… Docu…      88 Unrated     Indep… 2012-09-06 21:00:00\n10 The S… Feature F… Drama     119 Unrated     IFC F… 2012-03-01 21:00:00\n# ℹ 641 more rows\n# ℹ 27 more variables: thtr_rel_year &lt;dbl&gt;, thtr_rel_month &lt;dbl&gt;,\n#   thtr_rel_day &lt;dbl&gt;, dvd_rel_date &lt;dttm&gt;, dvd_rel_year &lt;dbl&gt;,\n#   dvd_rel_month &lt;dbl&gt;, dvd_rel_day &lt;dbl&gt;, imdb_rating &lt;dbl&gt;,\n#   imdb_num_votes &lt;int&gt;, critics_rating &lt;fct&gt;, critics_score &lt;dbl&gt;,\n#   audience_rating &lt;fct&gt;, audience_score &lt;dbl&gt;, best_pic_nom &lt;fct&gt;,\n#   best_pic_win &lt;fct&gt;, best_actor_win &lt;fct&gt;, best_actress_win &lt;fct&gt;, …\n# ℹ Use `print(n = ...)` to see more rows\nWe’ll cover inst/ and system.file() in more detail in the next chapter."
  },
  {
    "objectID": "data.html#recap",
    "href": "data.html#recap",
    "title": "Data",
    "section": "Recap",
    "text": "Recap\nIt’s common for shiny apps to require data, so knowing how to store and access these files in your app-package will make it easier to load and reproducible in other environments. Here are a few other things to consider when including data in your app-package:\n\n\n\n\n\n\nRecap: Package data files\n\n\n\n\n\n\n\ndata/: All data files stored in data/ will be ‘lazy loaded’ (see below) when the package is installed and loaded.\nLoading: include the LazyData: true field in the DESCRIPTION file so the data is only loaded when it’s used (and it increases package loading speed).\nSize: large data files can inflate the size of your app-package, making it harder for users to download and install. CRAN also has a size limit for packages (if you plan on submitting your app-package).\nFormat: data files in data/ must be either .rda or .RData format.\n\nDocumentation: document the data/ files in either a single R/data.R file or individual .R files. Documentation should include the following roxygen2 format:\n#' \n#' @title \n#' \n#' @description\n#' \n#' @format \n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n#'\n'data'\n\ninst/extdata/: Store external data in the inst/extdata/ directory and access it using system.file(). This can be helpful if your app-package needs access to data files that are not R objects. For faster loading, consider the fst or feather formats."
  },
  {
    "objectID": "data.html#footnotes",
    "href": "data.html#footnotes",
    "title": "Data",
    "section": "",
    "text": "Read more about the data folder in the ‘Data in packages’ section of Writing R Extenstions and the ‘Data’ chapter of R Packages, 2ed.↩︎\nRead more about the data-raw folder in R Packages, 2ed↩︎\nRead more about the inst/extdata/ folder in R Packages, 2ed↩︎"
  },
  {
    "objectID": "external.html#this-is-your-app-package",
    "href": "external.html#this-is-your-app-package",
    "title": "External files",
    "section": "This is your app-package",
    "text": "This is your app-package\nThe current files and folders of pkgApp are displayed below:\n\n\n\n\n\nGit Branch\n\npkgApp repo’s 06_data branch\n\n\n\n\n(a) The ‘source’ files for pkgApp\n\nFigure 1: Source files for the pkgApp app-package\n\nIf we’re using the Posit Workbench IDE, the Files pane is how we typically interact with the our app-package. For example, when we run movies_app(), we see the following:\n\n\n\n\n(a) movies_app() without logo\n\nFigure 2: www not accessible in pkgApp\n\n\nThe shiny.png logo in www/ is not being loaded into the UI when the application is launched. Before we dive into how to add the contents of www/ into pkgApp, we’ll take a step back and investigate what happens when a package is installed."
  },
  {
    "objectID": "external.html#this-is-your-app-package-installed",
    "href": "external.html#this-is-your-app-package-installed",
    "title": "External files",
    "section": "This is your app-package … installed\n",
    "text": "This is your app-package … installed\n\nWe’ve been running load_all(), document(), and install() on pkgApp, but we haven’t looked at the contents of the installed package. Reviewing the installed package will help us understand what the system.file() function is doing, and how we can use the inst/ folder to include external resources to our app-package.\nWhen we run devtools::install(), the output tells us where the package is being installed:\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source pkgApp\n\n* installing to library ‘/path/to/install/Library/R/x86_64/4.2/library’\nIf we add the pkgApp/ directory to the end of the path above, we can view the contents of the installed package (I’m using the tree command in the Terminal, but the fs::dir_tree() function will also print a folder tree):1\n\n/path/to/install/Library/R/x86_64/4.2/library/pkgApp/\n  ├── DESCRIPTION\n  ├── INDEX\n  ├── Meta/\n  │   ├── Rd.rds\n  │   ├── data.rds\n  │   ├── features.rds\n  │   ├── hsearch.rds\n  │   ├── links.rds\n  │   ├── nsInfo.rds\n  │   └── package.rds\n  ├── NAMESPACE\n  ├── R/\n  │   ├── pkgApp\n  │   ├── pkgApp.rdb\n  │   └── pkgApp.rdx\n  ├── data/\n  │   ├── Rdata.rdb\n  │   ├── Rdata.rds\n  │   └── Rdata.rdx\n  ├── extdata/\n  │   └── movies.fst\n  ├── help/\n  │   ├── AnIndex\n  │   ├── aliases.rds\n  │   ├── paths.rds\n  │   ├── pkgApp.rdb\n  │   └── pkgApp.rdx\n  └── html/\n      ├── 00Index.html\n      └── R.css\n\n7 directories, 24 files\n\nThe installed version of pkgApp has many of the same files as the ‘source’ version we’ve been working on (i.e., the NAMESPACE and DESCRIPTION). It also might surprise you to see that many of the source package files aren’t included in the installed version (.R, .Rd files. etc.).\nHopefully viewing this folder structure helps demystify what happens when a package is installed.2 Below is the official documentation on what happens to the inst/ folder (and it’s subfolders) when a package is installed:3\n\n“The contents of the inst/ subdirectory will be copied recursively to the installation directory. Subdirectories of inst/ should not interfere with those used by R (currently, R/, data/, demo/, exec/, libs/, man/, help/, html/ and Meta/, and earlier versions used latex/, R-ex/).” - Writing R extensions, Package subdirectories\n\n\n\n\n\n\n\nUses of inst/ in other packages\n\n\n\n\n\n\nYou can explore the structure of other installed packages to see how they work ‘under the hood’ to gain insight into how they use the inst/ folder.\n\n\nFor example, the inst/extdata/ folder in the readr package holds a variety of datasets:\n/path/to/install/Library/R/x86_64/4.2/library/readr/\n\nextdata/\n  ├── challenge.csv\n  ├── chickens.csv\n  ├── epa78.txt\n  ├── example.log\n  ├── fwf-sample.txt\n  ├── massey-rating.txt\n  ├── mini-gapminder-africa.csv\n  ├── mini-gapminder-americas.csv\n  ├── mini-gapminder-asia.csv\n  ├── mini-gapminder-europe.csv\n  ├── mini-gapminder-oceania.csv\n  ├── mtcars.csv\n  ├── mtcars.csv.bz2\n  ├── mtcars.csv.zip\n  └── whitespace-sample.txt\n\n1 directory, 15 files\n\n\nThese files are used in readr::readr_example()):\n#' Get path to readr example\n#'\n#' readr comes bundled with a number of sample files in its `inst/extdata`\n#' directory. This function make them easy to access\n#'\n#' @param file Name of file. If `NULL`, the example files will be listed.\n#' @export\n#' @examples\n#' readr_example()\n#' readr_example('challenge.csv')\nreadr_example &lt;- function(file = NULL) {\n  if (is.null(file)) {\n    dir(system.file('extdata', package = 'readr'))\n  } else {\n    system.file('extdata', file, package = 'readr', mustWork = TRUE)\n  }\n}\n\n\nem; color: #696969;’}\nYour text\n\n\n\n\nUsing system.file()\n\nsystem.file() gives us access to the package files on installation (i.e., the files we see at the path above). In the previous chapter, we used system.file() to access the movies.fst file in inst/extdata/:\n\ndplyr::glimpse(  \n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"pkgApp\")\n    )\n  )\n\n\nshow/hide glimpse() of movies.fstfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\nRows: 651\nColumns: 34\n$ title            &lt;chr&gt; \"Filly Brown\", \"The Dish\", \"Waiting for…\n$ title_type       &lt;fct&gt; Feature Film, Feature Film, Feature Fil…\n$ genre            &lt;fct&gt; Drama, Drama, Comedy, Drama, Horror, Do…\n$ runtime          &lt;dbl&gt; 80, 101, 84, 139, 90, 78, 142, 93, 88, …\n$ mpaa_rating      &lt;fct&gt; R, PG-13, R, PG, R, Unrated, PG-13, R, …\n$ studio           &lt;fct&gt; Indomina Media Inc., Warner Bros. Pictu…\n$ thtr_rel_date    &lt;dttm&gt; 2013-04-18 21:00:00, 2001-03-13 21:00:…\n$ thtr_rel_year    &lt;dbl&gt; 2013, 2001, 1996, 1993, 2004, 2009, 198…\n$ thtr_rel_month   &lt;dbl&gt; 4, 3, 8, 10, 9, 1, 1, 11, 9, 3, 6, 12, …\n$ thtr_rel_day     &lt;dbl&gt; 19, 14, 21, 1, 10, 15, 1, 8, 7, 2, 19, …\n$ dvd_rel_date     &lt;dttm&gt; 2013-07-29 21:00:00, 2001-08-27 21:00:…\n$ dvd_rel_year     &lt;dbl&gt; 2013, 2001, 2001, 2001, 2005, 2010, 200…\n$ dvd_rel_month    &lt;dbl&gt; 7, 8, 8, 11, 4, 4, 2, 3, 1, 8, 5, 9, 7,…\n$ dvd_rel_day      &lt;dbl&gt; 30, 28, 21, 6, 19, 20, 18, 2, 21, 14, 1…\n$ imdb_rating      &lt;dbl&gt; 5.5, 7.3, 7.6, 7.2, 5.1, 7.8, 7.2, 5.5,…\n$ imdb_num_votes   &lt;int&gt; 899, 12285, 22381, 35096, 2386, 333, 50…\n$ critics_rating   &lt;fct&gt; Rotten, Certified Fresh, Certified Fres…\n$ critics_score    &lt;dbl&gt; 45, 96, 91, 80, 33, 91, 57, 17, 90, 83,…\n$ audience_rating  &lt;fct&gt; Upright, Upright, Upright, Upright, Spi…\n$ audience_score   &lt;dbl&gt; 73, 81, 91, 76, 27, 86, 76, 47, 89, 66,…\n$ best_pic_nom     &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ best_pic_win     &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ best_actor_win   &lt;fct&gt; no, no, no, yes, no, no, no, yes, no, n…\n$ best_actress_win &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ best_dir_win     &lt;fct&gt; no, no, no, yes, no, no, no, no, no, no…\n$ top200_box       &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ director         &lt;chr&gt; \"Michael D. Olmos\", \"Rob Sitch\", \"Chris…\n$ actor1           &lt;chr&gt; \"Gina Rodriguez\", \"Sam Neill\", \"Christo…\n$ actor2           &lt;chr&gt; \"Jenni Rivera\", \"Kevin Harrington\", \"Ca…\n$ actor3           &lt;chr&gt; \"Lou Diamond Phillips\", \"Patrick Warbur…\n$ actor4           &lt;chr&gt; \"Emilio Rivera\", \"Tom Long\", \"Eugene Le…\n$ actor5           &lt;chr&gt; \"Joseph Julian Soria\", \"Genevieve Mooy\"…\n$ imdb_url         &lt;chr&gt; \"http://www.imdb.com/title/tt1869425/\",…\n$ rt_url           &lt;chr&gt; \"//www.rottentomatoes.com/m/filly_brown…\n\n\nTo include the contents of www/ in our app-package, we need to use isnt/ folder, system.file(), and the shiny::addResourcePath() function."
  },
  {
    "objectID": "external.html#addresourcepath",
    "href": "external.html#addresourcepath",
    "title": "External files",
    "section": "addResourcePath()",
    "text": "addResourcePath()\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 07_inst-www branch\nThe addResourcePath() function will add a “directory of static resources to Shiny’s web server.” In pkgApp, want to add the www directory that includes the shiny.png file (currently in our root (\".\") folder).4\nIf we want to continue keeping external resources in the www/ folder, we can move www/ and it’s contents into inst/:\n\ninst/\n  ├── extdata/\n  │   └── movies.fst\n  └── www/\n      └── shiny.png\n\n3 directories, 2 files\n\nIn R/movies_ui.R function, we’ll include the addResourcePath() at the top of the tagList() and reference the image in img() using only the subfolder in the path:\n\nmovies_ui &lt;- function() {\n  addResourcePath('www', system.file('www', package = 'pkgApp'))\n  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nAfter loading, documenting, and installing, the application now includes the image file.\nCtrl/Cmd + Shift + L / D / B\n\nlibrary(pkgApp)\nmovies_app()\n\n\n\n\n\n(a) movies_app() with logo\n\nFigure 3: inst/www accessible with addResourcePath()"
  },
  {
    "objectID": "external.html#other-uses-for-inst",
    "href": "external.html#other-uses-for-inst",
    "title": "External files",
    "section": "Other uses for inst/\n",
    "text": "Other uses for inst/\n\nThe inst/ folder can also be used to store files we’re using in alternate versions of our application. This can include alternate images, CSS styling, JS scripts, data files, or even entirely different apps!\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 07_dev-bslib branch\nAlternate external files\nWe can store inst/ alternative external files and configure our UI function to test different layouts. In the example below, I’ve included an optional UI layout from the bslib package.\nThe bslib argument in the movies_ui() includes an alternate image file (stored in inst/www/bootstrap.png):\n\nshow/hide movies_ui()movies_ui &lt;- function(bslib = FALSE) {\n  addResourcePath(\"www\", system.file(\"www\", package = \"pkgApp\"))\n  if (isFALSE(bslib)) {\n    tagList(\n      # I've omitted fluidPage() layout code here\n    )\n  } else {\n    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n            shiny::div(\n              shiny::img(\n                src = \"www/bootstrap.png\",\n                height = 40,\n                width = 50,\n                style = \"margin:10px 10px\"\n              )\n            ),\n            mod_scatter_display_ui(\"plot\")\n          )\n        )\n      )\n    )\n  }\n}\n\n\nThis alternate version of movies_app() uses the same modules and utility functions as the previous versions, but when bslib = TRUE, the app displays the alternate UI layout:\n\npkgApp::movies_app(test = FALSE, bslib = TRUE)\n\n\n\n\n\n(a) movies_app() with logo\n\nFigure 4: inst/www/bootstrap.png image from movies_ui()\n\n\nDevelopment versions\nIt’s not uncommon to be working on multiple ‘development’ versions of an application in the same package. In these situations, we might want to store an entire applications in the inst/ folder (like inst/dev/ below) and launch it with runApp().\n\ninst/dev/\n  ├── app.R\n  ├── ggp2movies.fst\n  └── imdb.png\n\n1 directory, 3 files\n\nThis ‘development’ application uses a tidy version of the ggplot2movies::movies data\n\nWe can create this in the data-raw/ggp2movies.R file.5\n\n\nIn inst/dev/, we can place the application’s code in an app.R file.\n\nIn app.R, we can create a new mod_variables_ui() development module with the correct variable names\n\n\nshow/hide mod_variables_ui()mod_variables_ui &lt;- function(id) {\n  addResourcePath(prefix = \"dev\", \n    directoryPath = system.file(\"dev\", package = \"pkgApp\"))\n    ns &lt;- NS(id)\n    tagList(\n      selectInput(\n        inputId = ns(\"y\"),\n        label = \"Y-axis:\",\n        choices = c(\n          \"Year\" = \"year\",\n          \"Length\" = \"length\",\n          \"Budget\" = \"budget\",\n          \"Rating\" = \"avg_rating\",\n          \"Votes\" = \"votes\"\n        ),\n        selected = \"budget\"\n      ),\n      selectInput(\n        inputId = ns(\"x\"),\n        label = \"X-axis:\",\n        choices = c(\n          \"Year\" = \"year\",\n          \"Length\" = \"length\",\n          \"Budget\" = \"budget\",\n          \"Rating\" = \"avg_rating\",\n          \"Votes\" = \"votes\"\n        ),\n        selected = \"avg_rating\"\n      ),\n      selectInput(\n        inputId = ns(\"z\"),\n        label = \"Color by:\",\n        choices = c(\n          \"MPAA\" = \"mpaa\",\n          \"Genres\" = \"genres\"\n        ),\n        selected = \"mpaa\"\n      ),\n      sliderInput(\n        inputId = ns(\"alpha\"),\n        label = \"Alpha:\",\n        min = 0, max = 1, step = 0.1,\n        value = 0.4\n      ),\n      sliderInput(\n        inputId = ns(\"size\"),\n        label = \"Size:\",\n        min = 0, max = 5, step = 0.5,\n        value = 2.5\n      ),\n      textInput(\n        inputId = ns(\"plot_title\"),\n        label = \"Plot title\",\n        placeholder = \"Enter plot title\"\n      )\n    )\n}\n\n\nHowever, by including a call to library(pkgApp) at the top of app.R, I can pair the mod_variables_ui() function with the mod_var_input_server() function.6\nWe’ll also include the alternate image (bootstrap.png) and data file (created with data-raw/ggp2movies.R). Finally, we’ll launch the development version of the app with a different standalone app function, stored in R/ggplot2movies_app.R.\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 07_dev-ggp2movies branch\nTo run this development app, I’ll create the ggplot2movies_app() function below:\n\n#' Development `ggplot2movies` app standalone function\n#'\n#' Wrapper function for `runApp()`\n#' \n#' @param test logical, run in `test.mode`?\n#' @param run where to launch app: \n#'  * `view` = launch in viewer  \n#'  * `browse` = launch in external browser  \n#'  * `win` = launch in window\n#'  * `default` = `getOption(x = 'shiny.launch.browser')`\n#' \n#' @return shiny app\n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#' \n#'\n#' @export\n#' \nggplot2movies_app &lt;- function(test = TRUE, run = \"default\") {\n  switch(EXPR = run, \n    view = options(shiny.launch.browser = .rs.invokeShinyPaneViewer),\n    browser = options(shiny.launch.browser = .rs.invokeShinyWindowExternal),\n    win = options(shiny.launch.browser = .rs.invokeShinyWindowViewer),\n    default = getOption(x = 'shiny.launch.browser')\n  )\n  if (test) {\n    runApp(appDir = system.file(\"dev\", package = \"pkgApp\"), \n           test.mode = TRUE)\n  } else {\n    runApp(appDir = system.file(\"dev\", package = \"pkgApp\"), \n           test.mode = FALSE)\n  }\n}\n\nggplot2movies_app() looks a lot like movies_app(), but the appDir argument is the location of the development application, which we provide with system.file().\nCtrl/Cmd + Shift + L / D / B\nAfter loading, documenting, and installing pkgApp, we can run the development version using ggplot2movies_app():\n\n\n\n\n(a) ggplot2movies_app()\n\nFigure 5: inst/dev/ app with dev_movies_ui()\n\n\nYou may have noticed that I’ve used a different color and theme for the two development examples above. I’ve found this can be a quick and easy way to differentiate ‘development’ and ‘production’ versions of an application."
  },
  {
    "objectID": "external.html#recap",
    "href": "external.html#recap",
    "title": "External files",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: inst & www folders\n\n\n\n\n\n\n\ninst/: the inst/ folder is installed with your app-package and will be accessible to users, so it’s a great location for files you want to contained in your app, but don’t fit into the standard R package structure.\nsystem.file(): constructs a path to files or folders within installed packages and is especially useful when working with external datasets (i.e., inst/extdata/) or other external resources included with your app-package (i.e., inst/www/).\nwww: used for external static resources in shiny apps. shiny will automatically serve files under the www/ directory, but in app-packages we need to explicitly set this location with shiny::addResourcePath()\n\naddResourcePath(): create a prefix (path) for a directoryPath of static files to accessible in shiny’s web server:\n# file location\ninst/\n  └── www/\n        └── shiny.png\n# add path\naddResourcePath('www', system.file('www', package='pkgApp'))\n# use path\nshiny::img(src = 'www/shiny.png')\n\n\n\n\n\n\nend inst.qmd"
  },
  {
    "objectID": "external.html#footnotes",
    "href": "external.html#footnotes",
    "title": "External files",
    "section": "",
    "text": "Using fs::path_packcage(package = \"pkgApp\") will also return the path to your installed package.↩︎\nThe key takeaway here is that the inst/ subfolders and files are available unchanged in the installed version (with the inst/ folder omitted.).↩︎\nRead more about sub-directories to avoid in inst/ in R Packages, 2ed.↩︎\nYou can read more about adding external resources in the documentation for addResourcePath().↩︎\nWe covered the data-raw/ folder in the Data chapter, and you can read more about it here in R packages, 2ed↩︎\nThis requires exporting mod_var_input_server() with @export in the R/ folder.↩︎"
  },
  {
    "objectID": "tests.html#user-specifications-requirements",
    "href": "tests.html#user-specifications-requirements",
    "title": "Tests",
    "section": "User specifications & requirements",
    "text": "User specifications & requirements\nWhen developing tests, everyone is faced with the same two questions:\n\nWhat do I test?\n\nHow do I test it?\n\nThe shiny app in pkgApp we’ve been developing doesn’t have a software requirements specification (SRS), which is the document that typically captures the application’s intended purpose or the problem it’s designed to solve. In regular app development, the SRS contains the user specifications, feature requirements and functional requirements, which are are the guidelines that direct the development process, albeit from slightly different perspectives.\nUnderstanding their relationship is important for knowing the application we’re developing meets the technical standards and satisfies the user needs.\nUser Requirements\nUser Requirements are what the end-user (i.e., a film analyst) wants to achieve with the dashboard.5\n\n\n\n\n\n\nScatter plot user requirements\n\n\n\n\n\n\nUR1: The user wants to view an interactive scatter plot on a dashboard that consolidates movie reviews from multiple sources to quickly compare and analyze trends and outliers in movie ratings.\n\n\n\n\nFeature Requirements\nEach Feature Requirement is a high-level description of the feature’s capabilities (i.e, the scatter plot), phrased at satisfying the end-user’s needs outlined in the User Requirements.6\n\n\n\n\n\n\nScatter plot feature requirements\n\n\n\n\n\n\nFE1: The Shiny app should offer an interactive scatter plot feature that allows users to visualize and compare movie reviews from at least two data sources (IMDb, Rotten Tomatoes). The scatter plot should offer options for selecting variables of interest (i.e., audience scores, website ratings, runtime, etc.) to zoom into specific data points for detailed analysis.\n\n\n\n\nFunctional Requirements\nThe Functional Requirements are written for the developer and provide technical details on how the feature (i.e., the scatter plot) should behave and what it needs to do.7\n\n\n\n\n\n\nScatter plot functional requirements\n\n\n\n\n\n\n\nFR1: The system shall display movie reviews from IMDb and Rotten Tomatoes collected from their respective APIs.\nFR2: The scatter plot shall be displayed on the dashboard and updated with new user inputs.\nFR3: Each data point on the scatter plot shall represent a movie and be color-coded based on MPAA ratings, genre, title type, critics rating, and audience rating.\nFR4: The scatter plot shall have axes labeled with rating scales and must include a legend to differentiate between data sources.\nFR5: Users can zoom into specific areas of the scatter plot for a more detailed view.\n\n\n\n\n\nTraceability matrix\nIn our app-package, we want to ensure that corresponding functionalities and tests address all user requirements and that every functionality is justified in terms of user needs and has been tested. A traceability matrix is typically used to link the user specifications (and corresponding feature requirements) to the functional requirements they give rise to and the tests used to verify that the application has been developed correctly.\nFortunately, the R package structure gives us the tools we need to capture this documentation in the form of vignettes. We’ll write the specifications for pkgApp in the specs vignette by using usethis::use_vignette():\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 08_tests-specs branch\n\nusethis::use_vignette(\"specs\")\n\nAdding our first vignette to the vignettes/ folder does the following:\n\n\nAdds the knitr and rmarkdown packages to the Suggests field in DESCRIPTION8\nSuggests: \n    knitr,\n    rmarkdown\n\n\nAdds knitr to the VignetteBuilder field9\nVignetteBuilder: knitr\n\nAdds inst/doc to .gitignore and *.html, *.R to vignettes/.gitignore10\n\nWhen building the traceability matrix, start with the user specifications. The general language used in these descriptions can typically provide a basis for deriving the more technical (but still high-level) feature requirements, which form a basis for us to derive multiple functional requirements.\n\n\n\n\n\n\n\nUser Specification\n      Feature Requirement\n      Functional Requirements\n    \n\nUR1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, options to explore variables of interest)\nFR1: data source\n\n\n\n\n\nIn this way, a single user specification usually gives rise to multiple functional requirements.\n\n\n\n\n\n\n\nUser Specification\n      Feature Requirement\n      Functional Requirements\n    \n\n\nUR1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, options to explore variables of interest)\nFR1: data source\n\n\n-\n-\nFR2: user-input updating\n\n\n-\n-\nFR3: color-coded data points\n\n\n-\n-\nFR4: plot axis and legend\n\n\n-\n-\nFR5: plot zoom capability\n\n\n\n\n\n\nNow that we have the technical details for our application requirement, we can identify what needs to be tested:\n\n\n\n\n\n\n\nUser Specification\n      Feature Requirement\n      Functional Requirements\n      Test\n    \n\n\nUR1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, options to explore variables of interest)\nFR1: data source\nT1: \n\n\n-\n-\nFR2: user-input updating\nT2: \n\n\n-\n-\nFR3: color-coded data points\nT3: \n\n\n-\n-\nFR4: plot axis and legend\nT4: \n\n\n-\n-\nFR5: plot zoom capability\nT5: \n\n\n\n\n\n\nAfter we’ve written our tests, we can include their results in the matrix to ensure:\n\nEach user specification has an accompanying feature requirement.\nThe feature requirements have been broken down into precise, measurable, and testable pieces of code.\nTests have been written for each functional requirement (and indicate whether they are passing or not).\n\n\n\n\n\n\n\n\nUser Specification\n      Feature Requirement\n      Functional Requirements\n      Test\n      Status\n    \n\n\nUR1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, options to explore variables of interest)\nFR1: data source\nT1: \nT1 Status: \n\n\n-\n-\nFR2: user-input updating\nT2: \nT2 Status: \n\n\n-\n-\nFR3: color-coded data points\nT3: \nT3 Status: \n\n\n-\n-\nFR4: plot axis and legend\nT4: \nT4 Status: \n\n\n-\n-\nFR5: plot zoom capability\nT5: \nT5 Status: \n\n\n\n\n\n\nVignettes are a great place to store this information (although it probably shouldn’t be the only place to store it), because it’s self-contained and travels with the package whenever the code is updated."
  },
  {
    "objectID": "tests.html#the-test-suite",
    "href": "tests.html#the-test-suite",
    "title": "Tests",
    "section": "The test suite",
    "text": "The test suite\nMultiple strategies exist for testing code. For example, if you’ve adopted test-driven development (TDD)11, you’ll develop tests before writing utility functions, modules, or your standalone app function. However, if you’re a mere mortal like the rest of us, you’ll typically develop your tests and functions in tandem.\nRegardless of the testing strategy, we’ll set up the testing infrastructure in our app-package with the testthat package:\nuse_testthat()\nIn packages using devtools, the unit testing infrastructure is built with usethis::use_testthat():\n\nusethis::use_testthat()\n\n\n\nSet active project to current working directory:\n✔ Setting active project to '/path/to/pkgApp'\n\n\nIn the DESCRIPTION file, add the Suggests field and include testthat (&gt;= 3.0.0) and the testthat edition (Config/testthat/edition: 3)\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\n\n\nA new tests/ folder is created, with a testthat/ subfolder:\n✔ Creating 'tests/testthat/'\n\n\nThe testthat.R file is created (sometimes referred to as the test ‘runner’ because it runs all your tests).\n✔ Writing 'tests/testthat.R'\n\n\nFinally, we’re given some advice on the next step for creating our first test:\n• Call `use_test()` to initialize a basic test file and open it for editing.\nOur new tests/ folder structure is below:\n\ntests/\n  ├── testthat\n  └── testthat.R\n\n2 directories, 1 file"
  },
  {
    "objectID": "tests.html#unit-tests",
    "href": "tests.html#unit-tests",
    "title": "Tests",
    "section": "Unit tests",
    "text": "Unit tests\n\n\n\n\n\nGit Branch\n\nThis section’s code is in the pkgApp repo’s 08_testthat-tests branch\nIf I’m writing write a unit test for the scatter_plot() function in R/scatter_plot.R, I’ll create test file with usethis::use_test(\"scatter_plot\").\nNew tests with use_test()\n\n\nusethis::use_test(\"scatter_plot\")\n\nUnit test files\nThe IDE will automatically open the new test file:\n✔ Writing 'tests/testthat/test-scatter_plot.R'\n• Modify 'tests/testthat/test-scatter_plot.R'\nTests\nThe new test file contains a boilerplate test (I’ve included the argument names):\n\ntest_that(desc = \"multiplication works\", code = {\n  expect_equal(2 * 2, 4)\n})\n\nEach testthat test has a test context (supplied to the desc argument) followed by the test code (supplied in curly brackets). When a test is run, you’ll see feedback on whether it passes or fails:\n\ntest_that(desc = \"multiplication works\", code = {\n  expect_equal(2 * 2, 4)\n})\n## Test passed 😀\n\nExpectations\nMost expectation have two parts: an observed object, and an expected object. The observed object is an artifact of some code you’ve written, and it’s being compared against a known result (i.e., what is expected)\n\nexpect_equal(\n  object = 2 * 2,\n  expected = 4)\n\nComparisons\nComparison is the backbone of testing, and I’ve found knowing what package is performing the underlying comparison often saves me from surprising tests results.\nFor example, testthat::expect_equal() compares the observed and expected objects with the waldo package, with some help from diffobj.\n\nlibrary(waldo)\nlibrary(diffobj)\nlibrary(tibble)\n\nwaldo\nIf you’d like a preview of a comparison before writing a formal test, you can pass the your observed and expected objects to waldo::compare() to see what the result will be, but be mindful of the difference in argument names:\nFor example, suppose we have two objects: old and new\n\nold\n## # A tibble: 3 × 3\n##   chr     num fct  \n##   &lt;chr&gt; &lt;dbl&gt; &lt;ord&gt;\n## 1 B         1 L    \n## 2 C         2 M    \n## 3 D         3 H\n\n\nnew\n## # A tibble: 3 × 3\n##   CHR     num fct  \n##   &lt;chr&gt; &lt;int&gt; &lt;fct&gt;\n## 1 B         1 low  \n## 2 C         2 med  \n## 3 D         3 high\n\nThe outputs below show us both ‘No differences’ and the types of differences detected with waldo::compare():\n\n\n\ncompare(\n  x = old, \n  y = old)\n## ✔ No differences\n\n\ncompare(\n  x = old, \n  y = new)\n## `class(old)`: \"tbl_df\" \"tbl\" \"data.frame\"\n## `class(new)`:                \"data.frame\"\n## \n## `names(old)`: \"chr\" \"num\" \"fct\"\n## `names(new)`: \"CHR\" \"num\" \"fct\"\n## \n## `old$chr` is a character vector ('B', 'C', 'D')\n## `new$chr` is absent\n## \n## `old$num` is a double vector (1, 2, 3)\n## `new$num` is an integer vector (1, 2, 3)\n## \n## `class(old$fct)`: \"ordered\" \"factor\"\n## `class(new$fct)`:           \"factor\"\n## \n## `levels(old$fct)`: \"L\"   \"M\"   \"H\"   \n## `levels(new$fct)`: \"low\" \"med\" \"high\"\n## \n## `old$CHR` is absent\n## `new$CHR` is a character vector ('B', 'C', 'D')\n\n\n\ncompare() displays the differences in classes, names, and any individual value differences.\ndiffobj\nIf you’re using Posit Workbench, the diffobj package has a colorful display for making comparisons in the IDE.\nThe differences can be displayed vertically with diffobj::diffObj():\n\n\n\ndiffObj(\n  old, \n  new)\n\n\n\n\nFigure 1: Viewer ouput from diffobj::diffObj()\n\n\n\n\nIf you want to view the structure (str()) differences, you can use diffobj::diffStr():\n\n\n\ndiffStr(\n  old, \n  new)\n\n\n\n\nFigure 2: Viewer ouput from diffobj::diffStr()\n\n\n\n\nAfter seeing the old vs new comparisons with waldo and diffobj, you should notice the similarities in the results of a testthat test on the same objects:\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\n── Failure (test-old-vs-new.R:18:3): old vs. new ──────────\n`old` (`actual`) not equal to `new` (`expected`).\n\n`class(actual)`:   \"tbl_df\" \"tbl\" \"data.frame\"\n`class(expected)`:                \"data.frame\"\n\n`names(actual)`:   \"chr\" \"num\" \"fct\"\n`names(expected)`: \"CHR\" \"num\" \"fct\"\n\n`actual$chr` is a character vector ('B', 'C', 'D')\n`expected$chr` is absent\n\n`class(actual$fct)`:   \"ordered\" \"factor\"\n`class(expected$fct)`:           \"factor\"\n\n`levels(actual$fct)`:   \"L\"   \"M\"   \"H\"   \n`levels(expected$fct)`: \"low\" \"med\" \"high\"\n\n`actual$CHR` is absent\n`expected$CHR` is a character vector ('B', 'C', 'D')\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\nTest supporting files\nSometimes testing functions in isolation is not enough and it’s useful to include either helper functions or data. This is especially true when the code we’re testing goes beyond the function’s borders, such as connecting to a database or API. The term for these supporting files are test fixtures,12 and below we’ll cover including them in the tests/ folder.\nTest data\nTest data can be helpful for experimenting with various table and graphing package outputs, file formats, and application performance. Test data files can be stored in tests/testthat/fixtures/, and I’ve provided an example below of of the tidy ggplot2movies data we used in a previous branch.\nThe code used to create the test data (make-ggp2-movies.R) is stored in the same location as the output it creates (i.e., ggp2_movies.rds):\n\nshow/hide make-ggp2-movies.R# code to prepare `ggp2movies` test data\n# pkgs &lt;- c('ggplot2movies', 'tidyr', 'dplyr', 'stringr', 'purrr')\n# install.packages(pkgs, quiet = TRUE)\n\n# load packages --------------------\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(purrr)\n\nggp2movies &lt;- ggplot2movies::movies |&gt;\n  dplyr::mutate(id = 1:n()) |&gt;\n  tidyr::pivot_longer(\n    cols = Action:Short,\n    names_to = \"Genre\",\n    values_to = \"GenreMember\"\n  ) |&gt;\n  dplyr::group_by(\n    dplyr::across(-c(Genre, GenreMember))) |&gt;\n  tidyr::nest() |&gt;\n  dplyr::mutate(\n    Genres = purrr::map(data, ~ if (all(.x$GenreMember == 0)) {\n      character(0)\n    } else {\n      .x$Genre[.x$GenreMember == 1]\n    })\n  ) |&gt;\n  dplyr::ungroup() |&gt;\n  dplyr::select(title, Genres, length, year, \n                budget, rating, votes, mpaa) |&gt;\n  dplyr:::mutate(\n    genres = purrr::map_chr(\n      .x = Genres,\n      .f = stringr::str_c, collapse = \", \"\n    )\n  ) |&gt;\n  dplyr::select(title, genres, length, year, \n                budget, avg_rating = rating, \n                votes, mpaa) |&gt;\n  dplyr::mutate(\n    mpaa = dplyr::na_if(x = mpaa, y = \"\"),\n    mpaa = factor(mpaa,\n      levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n      labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\")\n    ),\n    genres = dplyr::na_if(x = genres, \"\"),\n    genres = factor(genres)\n  ) |&gt; \n  tidyr::drop_na()\n# save to tests/testthat/fixtures/\nsaveRDS(object = ggp2movies, file = \"tests/testthat/fixtures/ggp2_movies.rds\")\n\n\n\ntests/\n  └── testthat/\n      └── fixtures/\n            ├── ggp2_movies.rds\n            └── make-ggp2-movies.R\n       \n3 directories, 2 files\n\nTest helpers\nTest helpers are typically functions that make testing a little easier. I’ve included a small example function that includes nicely formatted messages for testing, test_cmt().\n\nshow/hide test_cmt() helper# test comment helper\ntest_cmt &lt;- function(start = NULL, end = NULL, msg) {\n  if (is.null(start) & is.null(end)) {\n    cat(\"\\n\", \n      stringr::str_glue(\"[{Sys.time()}| {msg}]\"), \n      \"\\n\")\n  } else if (!is.null(start) & is.null(end)) {\n    cat(\"\\n\", \n      stringr::str_glue(\"[ START | {Sys.time()} | {start} = {msg}]\"),\n      \"\\n\")\n  } else if (is.null(start) & !is.null(end)) {\n    cat(\"\\n\", \n      stringr::str_glue(\"[ END   | {Sys.time()} | {end} = {msg}]\"), \n      \"\\n\")\n  } else {\n    cat(\"\\n\", \n      stringr::str_glue(\"[ START | {Sys.time()} | {start} = {msg}]\"),\n      \"\\n\")\n    cat(\"\\n\", \n      stringr::str_glue(\"[ END   | {Sys.time()} | {end} = {msg}]\"),\n      \"\\n\")\n  }\n}\n\n\ntest_cmt() can be used to log when your test beings and ends, and includes a message for the context.13\n\ntest_that(desc = \"multiplication works\", code = {\n  test_cmt(start = \"multiplication\", msg = \"2 * 2 = 4\")\n  expect_equal(2 * 2, 4)\n  test_cmt(end = \"multiplication\", msg = \"2 * 2 = 4\")\n})\n## \n##  [ START | 2023-09-18 08:30:53 | multiplication = 2 * 2 = 4] \n## \n##  [ END   | 2023-09-18 08:30:53 | multiplication = 2 * 2 = 4] \n## Test passed 😸\n\nFunctions like test_cmt() can be stored in tests/testthat/helper.R, which is automatically loaded with devtools::load_all():\ntests/\n  └── testthat/\n      ├── fixtures/\n      │   ├── make-ggp2-movies.R\n      │   └── ggp2_movies.rds\n      ├── helper.R\n      └── ... all test files...\nSnapshots\nIf the expected output we’re interesting in testing is cumbersome to describe programmatically, we can consider using a snapshot tests. Examples of this include UI elements (which are mostly HTML created by Shiny’s UI layout and input/output functions) and data visualizations.14\nWriting tests for graph outputs can be difficult because we’re evaluating the “correctness” of the graph is somewhat subjective and requires human judgment.\nIf we try to compare the output from a custom plotting function like scatter_plot() against a graph built with analogous ggplot2 code, we can see why this test will fail by passing both objects to diffobj::diffObj():\n\nggp_graph &lt;- ggplot2::ggplot(mtcars, \n              ggplot2::aes(x = mpg, y = disp)) + \n              ggplot2::geom_point(\n                ggplot2::aes(color = cyl), \n                             alpha = 0.5, \n                             size = 3)\n  \napp_graph &lt;- scatter_plot(mtcars, \n                  x_var = \"mpg\", \n                  y_var = \"disp\", \n                  col_var = \"cyl\", \n                  alpha_var = 0.5, \n                  size_var = 3)\n\ndiffobj::diffObj(ggp_graph, app_graph)\n\n\n\n\n\n(a) diffobj::diffObj() on graph outputs\n\nFigure 3: Graph objects are difficult to use as test objects\n\n\nThe output shows us differences in the mapping and plot environment (plot_env), which we can assume will be different in the application, so using testthat::expect_equal() will fail.\nIn cases like this, a snapshot test might be warranted. The vdiffr package allows us to perform a ‘visual unit test’ by saving by capturing the expected output as a snapshot that we can compare with future versions.\nvdiffr\nThe expect_doppelganger() function from vdiffr is designed specifically to work with ‘graphical plots’.\n\nvdiffr::expect_doppelganger(\n      title = \"name of graph\", \n      fig = # ...code to create graph...\n  )\n\nexpect_doppelganger() can be dropped in test_that() like any other expectation. Below is an example comparing the graph outputs from ggplot2 and the custom scatter_plot() utility function in pkgApp.\nNotice I’ve loaded the ggp2_movies.rds data15 and included the test_cmt() helper with start and end messages (before and after the test code).\n\ntest_that(desc = \"scatter_plot() works\", code = {\n  test_cmt(\n    start =  \"scatter_plot()\", \n    msg = \"ggplot2movies::movies snapshot\")\n  ggp2_movies &lt;- readRDS(test_path(\"fixtures\", \"ggp2_movies.rds\"))\n    vdiffr::expect_doppelganger(\n      title = \"scatter_plot() graph\", \n      fig = scatter_plot(ggp2_movies, \n                    x_var = \"budget\", \n                    y_var = \"avg_rating\", \n                    col_var = \"mpaa\", \n                    alpha_var = 0.4, \n                    size_var = 2.5))\n    test_cmt(\n      end =  \"scatter_plot()\", \n      msg = \"ggplot2movies::movies snapshot\")\n})\n\nRunning test()s\nThe fourth devtools habit to adopt is regularly writing and running tests. If you’re using Posit Workbench and have devtools installed, you can test your app-package using the Build pane or the keyboard shortcut:\n\n\nCtrl/Cmd + Shift + T\n\n\n\n(a) Test you app-package\n\nFigure 4: devtools::test() (run all tests in your tests/ folder)\n\nWhen we initially run the test it passes, but with a warning that tells us the baseline snapshot was saved in tests/testthat/_snaps/:\n==&gt; Testing R file using 'testthat'\n\nℹ Loading pkgApp\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n [ START | 2023-09-13 11:58:04 | scatter_plot() = ggplot2movies::movies snapshot] \n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]\n [ END   | 2023-09-13 11:58:05 | scatter_plot() = ggplot2movies::movies snapshot] \n\n\n── Warning (test-scatter_plot.R:4:5): scatter_plot() works ─────────────────────\nAdding new file snapshot: 'tests/testthat/_snaps/scatter-plot-graph.svg'\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]\n\nTest complete\n\n\ntest_cmt() is handy because it let’s me track how long each test takes to run (unit test should be fast).\nAfter the inital test run, if we view the tests/ folder, we can see the new tests/testthat/_snaps is created:\n\ntests/\n  ├── testthat/\n  │   ├── _snaps/\n  │   │   └── scatter_plot/\n  │   │       └── scatter-plot-graph.svg\n  │   └── test-scatter_plot.R\n  └── testthat.R\n\nThe scatter-plot-graph.svg file is our baseline comparison object, which is then used in future tests.\nSnapshots are brittle\nThe term “brittle” in the context of testing refers to their susceptibility to changes (meaningful or not) that can produce false negatives (i.e., a test fails due to inconsequential changes in the graph) when comparing a new graph to the baseline image.\nIn a typical workflow, we’d write additional tests, then load, document, and build the package:\nCtrl/Cmd + Shift + L / D / B\nSubsequent tests in pkgApp will pass without a warning:\nCtrl/Cmd + Shift + T\n==&gt; devtools::test()\n\nℹ Testing pkgApp\n✔ | F W S  OK | Context\n⠏ |         0 | scatter_plot  \n [ START | 2023-09-13 11:58:53 | scatter_plot() = ggplot2movies::movies snapshot] \n⠋ |         1 | scatter_plot  \n [ END   | 2023-09-13 11:58:54 | scatter_plot() = ggplot2movies::movies snapshot] \n✔ |         1 | scatter_plot\n\n══ Results ═══════════════════\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n\n😸\nAnother option for using snapshots for testing is the expect_snapshot_file() function 16 but expect_doppelganger() is probably the better option for comparing graph outputs."
  },
  {
    "objectID": "tests.html#module-tests",
    "href": "tests.html#module-tests",
    "title": "Tests",
    "section": "Module tests",
    "text": "Module tests\nAlthough they’re typically stored in a single file, modules consist of UI and server functions, which would classify their tests as ‘integration’ or ‘interaction’ testing. Still, we can only pass the module server functions to testServer(), so these are still unit tests. Below are a few examples and tips for testing modules.\ntestServer()\ntestServer() is designed to test reactive interactions, which gives us the ability to write tests to verify the inputs, outputs, and returned values from module server functions.\nInitial values\nShiny inputs are initiated with a NULL value, so it’s tempting to want to test an inputId exists using expect_null(input$x). However, this test is not helpful because any value will pass this test.\nFor example, the test below looks like it tests an initial NULL value for input$x in mod_var_input_server():\n\nshiny::testServer(app = mod_var_input_server, expr = {\n  test_cmt(start = \"input$x\", msg = \"initial null\")\n  testthat::expect_null(input$x)\n  test_cmt(end = \"input$x\", msg = \"initial null\")\n})\n\nThis test passes:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n [ START | 2023-09-14 11:58:59 | input$x = initial null] \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n [ END   | 2023-09-14 11:58:59 | input$x = initial null]  \nUnfortunately, we can pass anything to expect_null() when testServer() is used this way:\n\nshiny::testServer(app = mod_var_input_server, expr = {\n  test_cmt(start = \"input$anything\", msg = \"initial null\")\n  testthat::expect_null(input$anything)\n  test_cmt(end = \"input$anything\", msg = \"initial null\")\n})\n\nThis test also passes:\n [ START | 2023-09-14 11:58:59 | input$anything = initial null] \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n [ END   | 2023-09-14 11:58:59 | input$anything = initial null] \nTo check the initial NULL value of an inputId, it’s better to build the shiny app object, then pass this to testServer().17\n\n# build app object with shinyApp()\napp &lt;- shinyApp(ui = movies_ui(bslib = FALSE), \n                  server = movies_server)\nshiny::testServer(app = app, expr = {\n  # check shiny app object \n  test_cmt(start = \"is.shiny.appobj\", msg = \"movies_app()\")\n  testthat::expect_true(is.shiny.appobj(app))\n  test_cmt(end = \"is.shiny.appobj\", msg = \"movies_app()\")\n  # check input for y axis is initially NULL\n  test_cmt(start = \"input$`vars-y`\", msg = \"initial NULL\")\n  testthat::expect_null(\n    object = input$`vars-y`)\n  test_cmt(end = \"input$`vars-y`\", msg = \"initial NULL\")\n})\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\n\n [ START | 2023-09-14 12:08:53 | is.shiny.appobj = movies_app()] \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\n [ END   | 2023-09-14 12:08:53 | is.shiny.appobj = movies_app()] \n\n [ START | 2023-09-14 12:08:53 | input$`vars-y` = initial NULL] \n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\n [ END   | 2023-09-14 12:08:53 | input$`vars-y` = initial NULL] \nNote the use of the input with the appended module IDs. This is an easy place to get tripped up with testServer(): in the app object, we have to access the inputs with input$`[module id]-[inputId]`\nReturned values\nTo confirm the returned list of graph inputs from mod_var_input_server(), we can build the list of inputs, then pass identical values to session$setInputs() and confirm the returned object with session$returned():\n\nshiny::testServer(app = mod_var_input_server, expr = {\n  test_vals &lt;- list(\n                  y = \"audience_score\",\n                  x = \"imdb_rating\",\n                  z = \"genre\",\n                  alpha = 0.5,\n                  size = 2,\n                  plot_title = \"example title\"\n                )\n  session$setInputs(\n                  y = \"audience_score\",\n                  x = \"imdb_rating\",\n                  z = \"genre\",\n                  alpha = 0.5,\n                  size = 2,\n                  plot_title = \"example title\"\n                )\n  test_cmt(start = \"returned(var_input)\", msg = \"var_input structure\")\n  testthat::expect_equal(\n    object = session$returned(),\n    expected = test_vals\n  )\n  test_cmt(end = \"returned(var_input)\", msg = \"var_input structure\")\n})\n\n==&gt; devtools::test()\n\nℹ Testing pkgApp\n✔ | F W S  OK | Context\n⠏ |         0 | mod_var_input_server                                                  Loading required package: shiny\n\n [ START | 2023-09-14 12:21:17 | returned(var_input) = var_input structure] \n [ END   | 2023-09-14 12:21:18 | returned(var_input) = var_input structure] \n✔ |         3 | mod_var_input_server\nThis confirms the structure of the returned object from mod_var_input_server().\nargs = list()\nNow that we’ve confirmed the returned values from mod_var_input_server() are in a list, we want to make sure it’s read correctly by the var_inputs argument in mod_scatter_display_server(). I’ve included the movies_server() function below refresh our memory of how this should work:18\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\nWhen we pass selected_vars to the var_inputs argument of mod_scatter_display_server(), we’re not passing the returned values (this is why we don’t need the parentheses). We’re calling on the method (or function) created by reactive().\nIf we pause execution with the debugger,19 we can see the difference between calling selected_vars and selected_vars():\n\n\n\nBrowse[1]&gt; selected_vars\nreactive({\n    list(\n      y = input$y, \n      x = input$x, \n      z = input$z, \n      alpha = input$alpha, \n      size = input$size, \n      plot_title = input$plot_title\n      )\n})\n\n\n \n\n\nBrowse[1]&gt; selected_vars()\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nThis distinction becomes important when we’re testing the communication between module server functions.\n\ntest_vals &lt;- list(x = \"audience_score\",\n                  y = \"imdb_rating\",\n                  z = \"mpaa_rating\",\n                  alpha = 0.5,\n                  size = 2,\n                  plot_title = \"Test title case\")\nshiny::testServer(\n  app = mod_scatter_display_server,\n  args = list(\n    var_inputs = shiny::reactive(test_vals)\n  ), expr = {\n    \n    test_cmt(start = \"mod_scatter_display_server\", msg = \"is.reactive(inputs())\")\n    \n    expect_true(object = is.reactive(inputs))\n    \n    test_cmt(end = \"mod_scatter_display_server\", msg = \"is.reactive(inputs())\")\n    \n  }\n)"
  },
  {
    "objectID": "tests.html#behavior-driven-development-bdd",
    "href": "tests.html#behavior-driven-development-bdd",
    "title": "Tests",
    "section": "Behavior-driven development (BDD)",
    "text": "Behavior-driven development (BDD)\n\n“[BDD] encourages teams to use conversation and concrete examples to formalize a shared understanding of how the application should behave.” - BDD, Wikipedia\n\ndescribe()\nThe testthat::describe() function follows a BDD format:\nit()\ntestthat::it()"
  },
  {
    "objectID": "tests.html#systemend-to-end-tests",
    "href": "tests.html#systemend-to-end-tests",
    "title": "Tests",
    "section": "System/end-to-end tests",
    "text": "System/end-to-end tests\n\nshinytest2"
  },
  {
    "objectID": "tests.html#test-coverage",
    "href": "tests.html#test-coverage",
    "title": "Tests",
    "section": "Test coverage",
    "text": "Test coverage\ncovr\ncovrpage"
  },
  {
    "objectID": "tests.html#continuous-integration-ci",
    "href": "tests.html#continuous-integration-ci",
    "title": "Tests",
    "section": "Continuous Integration (CI)",
    "text": "Continuous Integration (CI)\n\nend testing.qmd"
  },
  {
    "objectID": "tests.html#footnotes",
    "href": "tests.html#footnotes",
    "title": "Tests",
    "section": "",
    "text": "Unit tests are covered extensively in R Packages, 2ed and the testthat documentation↩︎\nshinytest2 has excellent documentation (and videos), and I highly recommend reading through those resources.↩︎\nMastering shiny has a Chapter on Testing, which covers unit tests and testServer(), and also includes some tips for using JavaScript with shinytest (not to be confused with shinytest2)↩︎\nThe testServer() documentation is sparse, so I’ll provide a few tips and tricks I’ve learned for testing module server functions.↩︎\nUser Requirements are sometimes referred to as “user stories,” “use cases,” or “general requirements”↩︎\n“Feature requirements” and “functional requirements” are sometimes used interchangeably, but they refer to different aspects of the software. Feature requirements are the high-level characteristics the system should have and often capture a collection of smaller functionalities (which are broken down into specific functional requirements).↩︎\nFunctional requirements describe what a software system should do and are precise, measurable, and testable.↩︎\nWe didn’t cover the Suggests field in the Dependencies chapter, but “lists packages that are not necessarily needed. This includes packages used only in examples, tests or vignettes … and packages loaded in the body of functions.” - Writing R Extensions, Pakcage Dependencies↩︎\nThe documentation on VignetteBuilder is an excellent example of how challenging if can be to manage dependencies, “Note that if, for example, a vignette has engine knitr::rmarkdown, then knitr provides the engine but both knitr and rmarkdown are needed for using it, so both these packages need to be in the VignetteBuilder field and at least suggested (as rmarkdown is only suggested by knitr, and hence not available automatically along with it).”↩︎\nWe learned about the inst/ folder in the External Files chapter, so this should help explain where knitted vignettes end up when a package is installed.↩︎\n“The tests should be written before the functionality that is to be tested. This has been claimed to have many benefits. It helps ensure that the application is written for testability, as the developers must consider how to test the application from the outset rather than adding it later.” - TDD, Wikipedia↩︎\nTest fixtures are described in-depth in R Packages, 2ed.↩︎\nIf you like verbose logging outputs, check out the logger package↩︎\nMastering Shiny covers creatng a snapshot file to test UI elements, but notes this is probably not the best approach.↩︎\nAccessing test files is made easier with testtthat::test_path()↩︎\nFollow the expect_snapshot_file() example from the testthat documentation↩︎\nThe shiny::is.shiny.appobj() will test if an object is a ‘shiny app object.’↩︎\nselected_vars are the reactive plot values returned from mod_var_input_server() we confirmed test-mod_var_input_server.R.↩︎\nWe’ll cover using browser() and the IDE’s debugger in a future chapter.↩︎"
  },
  {
    "objectID": "frameworks.html",
    "href": "frameworks.html",
    "title": "Frameworks",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\ngolem:\nleprechaun:\nrhino:\nend frameworks.qmd"
  },
  {
    "objectID": "golem.html",
    "href": "golem.html",
    "title": "golem",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\ngolem stuff\n\nCodeinstall.packages(\"golem\")\nlibrary(golem)\n\n\nend golem.qmd"
  },
  {
    "objectID": "leprechaun.html",
    "href": "leprechaun.html",
    "title": "leprechaun",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nleprechaun stuff\n\nCodeinstall.packages(\"leprechaun\")\nlibrary(leprechaun)\n\n\nend leprechaun.qmd"
  },
  {
    "objectID": "rhino.html",
    "href": "rhino.html",
    "title": "rhino",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nrhino stuff\n\nCodeinstall.packages(\"rhino\")\nlibrary(rhino)\n\n\nend rhino.qmd"
  },
  {
    "objectID": "special_topics.html",
    "href": "special_topics.html",
    "title": "Special topics",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nAll the other stuff…\nend special_topics.qmd"
  },
  {
    "objectID": "debugging.html",
    "href": "debugging.html",
    "title": "Debugging",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend debugging.qmd"
  },
  {
    "objectID": "css.html",
    "href": "css.html",
    "title": "CSS",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend css.qmd"
  },
  {
    "objectID": "js.html",
    "href": "js.html",
    "title": "JavaScript",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend js.qmd"
  },
  {
    "objectID": "code_tools.html#styler-lintr",
    "href": "code_tools.html#styler-lintr",
    "title": "Code tools",
    "section": "\nstyler & lintr\n",
    "text": "styler & lintr\n\nThe styler and lintr packages in R serve related but distinct purposes and have different focuses in their functionality. The primary difference between lintr and styler is that styler can automatically fix any stylistic issues it identifies in your code (rather than just reporting them).\nlintr: lintr is a static code analysis tool used to identify syntax errors, semantic issues, and violations of stylistic guidelines in your code. The package contains a list of ‘linters’ for various potential problems and can be customized according to your needs. lintr is designed to help improve your code’s quality and readability by generating reports in the ‘markers’ pane. Running lintr won’t automatically correct the identified issues (you’ll need to fix the linting issues it reports manually).\nstyler: On the other hand, the purpose of styler is to ensure consistency in the code formatting, which is crucial if you’re working in a team or contributing to open-source projects (like tidyverse packages). The styler package will change your code’s format according to specified style guidelines. These changes include indentation, spaces, and line breaks that adhere to your style guidelines.\nWhile there is some overlap (both packages can help enforce coding style guidelines), lintr is a more general tool for code quality, spotting potential issues and bugs. At the same time, styler focuses on code formatting and can automatically apply fixes. Many developers find combining both can help catch potential issues and ensure a consistent, readable coding style."
  },
  {
    "objectID": "code_tools.html#sinew",
    "href": "code_tools.html#sinew",
    "title": "Code tools",
    "section": "sinew",
    "text": "sinew\nThe sinew package also warrants mentioning because it can help ensure you’re namespacing functions from add-on packages.\nend code_tools.qmd"
  },
  {
    "objectID": "glossary.html#shiny-apps",
    "href": "glossary.html#shiny-apps",
    "title": "Glossary of terms",
    "section": "Shiny apps",
    "text": "Shiny apps\nUtility/helper functions\nExternal resources\nModule\nStandalone app function"
  },
  {
    "objectID": "glossary.html#packages",
    "href": "glossary.html#packages",
    "title": "Glossary of terms",
    "section": "Packages",
    "text": "Packages\nProject\nAny directory of R executable files with an RStudio/Posit workbench project file (.Rproj).\nPackage\nA directory of functions, documentation, and/or data can be installed and loaded into an R session. Packages include the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench.\nApp-package\nAn app-package is a package containing a shiny application. App-packages have all of the functionality of a standard R package, but also contain the files and folders required to successfully develop, run, and deploy a shiny application."
  },
  {
    "objectID": "glossary.html#devtools",
    "href": "glossary.html#devtools",
    "title": "Glossary of terms",
    "section": "devtools",
    "text": "devtools\nend glossary.qmd"
  },
  {
    "objectID": "github.html#projapp",
    "href": "github.html#projapp",
    "title": "GitHub",
    "section": "projApp",
    "text": "projApp\nThe projApp repo is a shiny application built outside of a package structure. It was initially created using the New Project Wizard (with a Git repo initialized).\nIf you’re new to GitHub, the steps below will walk you through setting up Git and GitHub from RStudio using the Git pane. The initial files in the project are below:\nprojApp/\n  ├── app.R\n  └── projApp.Rproj\n\n1 directory, 2 files\nAfter creating the project, head over to GitHub and create am empty repo. You’ll see the following options:\n\n\n\n\n(a) New repository on GitHub\n\nFigure 1: Empty GitHub repository options\n\n\nWe’re interested in the second option, “…push an existing repository from the command line”, but we’re going to use Posit Workbench’s Git pane.\nCommit\nCommit these initial changes to the repo using the Commit icon in the Git pane\n\n\n\n(a) Commit changes\n\n\n\n(b) First commit\n\nFigure 2: Click on Commit to open the Git window. Stage all the files, add a commit message, and click Commit\n\nAdd a commit message and click Commit. This is the equivalent of entering the following commands in the Terminal:\ngit commit -m 'first commit'\n\n\n\n\n\n\nCommit changes in your repository with a specific message\n\n\n\n\n\n\ngit commit -m 'first commit'\n\ngit commit: This command captures a snapshot of the changes in your project’s tracked files and directories. By committing, you’re saving the current state of those files in the Git repository.\n-m: This flag indicates that a commit message will be provided directly from the command line.\n'first commit': This is the commit message associated with this commit. Commit messages are useful for documenting the changes you’ve made, making it easier for others (and your future self) to understand the evolution and purpose of changes in the project.\n\nWhen you run git commit -m 'first commit', you are committing your staged changes (i.e., changes you’ve previously added to the staging area using git add) with the message ‘first commit’.\nThis message is then stored in the Git history, allowing anyone who looks at the commit logs to see a brief description of what was done in that particular commit.\n\n\n\n\nReview the output from the commit.\n\n\n\n(a) First commit output\n\nFigure 3: The .gitignore, app.R, and projApp.Rproj files have been committed to main\n\nThis shows the contents of projApp are part of the main branch. Now we need to make sure the local branch has a remote (on GitHub at https://github.com/&lt;username&gt;/projApp.git).\n\n\n\n\n\n\nRename the currently checked-out branch to main\n\n\n\n\n\n\nThe command git branch -M main is used to rename the currently checked-out branch to main.\nHere’s a breakdown of the command:\n\ngit branch: This command without any arguments would list all the local branches in the current repository. But, with certain options (like -M), you can perform other branch-related operations.\n-M: This option stands for ‘move/rename’ and forcibly renames the branch. If a branch named main already exists, it will be overwritten because of the forceful nature of the -M option. If you want to avoid accidentally overwriting an existing branch, you could use -m (lowercase) instead. The lowercase -m will rename only if the target name doesn’t already exist.\nmain: This is the new name for the currently checked-out branch.\n\nThe command became more common after the industry started transitioning from using master to main as the default branch name for new repositories. Running git branch -M main is a way to rename the master branch to main in existing repositories.\n\n\n\n\nAdding remotes\nClick the New Branch icon in the Git pane and create a new main branch. Then click on Add Remote… and name the remote origin.\n\n\n\n(a) Add branch and remote name\n\n\n\n(b) Add remote URL\n\nFigure 4: Create new main branch to track origin\n\nThe Remote URL is the link from the Quick Setup above. After clicking Add and Create, you’ll be asked to checkout or overwrite the existing main branch. In this case, we can select Overwrite (because we’re already on the main branch).\n\n\n\n\n\n\nAdd a new remote to your Git repository\n\n\n\n\n\n\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n\ngit remote: used to manage and set remotes (‘remote repositories’) for your project\nadd: specifies that you want to add a new remote.\norigin: a convention widely used in the Git community is to name the primary remote repository origin.\nhttps://github.com/&lt;username&gt;/&lt;repo&gt;.git: This is the URL to the Git repository (hosted on GitHub). Replace &lt;username&gt; with the GitHub username of the repository owner and &lt;repo&gt; with the name of the repository.\n\nSo, when you run this command, you’re telling Git: ‘I want to add a new remote called origin, and the URL for this remote is https://github.com/&lt;username&gt;/&lt;repo&gt;.git'.’\nAfter executing this command, you can then push to and pull from the repository using this remote by referring to its name (origin). For instance, git push origin master would push your local master branch to the master branch on the origin remote.\n\n\n\n\n\n\n\n(a) Overwrite main\n\n\n\n(b) branch main set up to track origin/main\n\nFigure 5: main will now track the remote (origin)\n\n\n\n\n\n\n\nPush a local branch (main) to a remote (origin), and set local branch to track remote branch\n\n\n\n\n\n\ngit push -u origin main\n\ngit push: used to push commits from your local repository to a remote repository.\norigin: name of the remote repository you want to push to. When you clone a repo or add a remote using git remote add, it’s common to name the main remote origin (though it could technically be any name).\nmain: name of the branch you’re pushing to the remote repository.\n-u or --set-upstream: When this option is used, it sets a tracking relationship between the local and upstream remote branches. This means that in the future, using git pull or git push doesn’t require specifying the remote or branch (Git will know you’re referring to the origin/main branch).\n\nIn essence, git push -u origin main is saying: ‘Push my ’main’ branch to the ‘origin’ remote, and also set my local ‘main’ branch to track the ‘main’ branch on ‘origin’.\nThe common workflow for setting up Git from the command line is below:\n# make changes \ngit add .\ngit commit 'first commit'\n# set remote on GitHub\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n# rename the current branch to main\ngit branch -M main\n# push and set upstream to origin (remote)\ngit push -u origin main"
  },
  {
    "objectID": "create.html#creating-app-packages-scenarios",
    "href": "create.html#creating-app-packages-scenarios",
    "title": "Appendix: Creating packages in Posit Workbench",
    "section": "Creating app-packages: scenarios",
    "text": "Creating app-packages: scenarios\nThe callout blocks below represent scenarios I’ve encountered requiring an app-package:\nScenario #1\n\n\n\n\n\n\nScenario #1: Create a new shiny app-package\n\n\n\n\n\n\nYou’re in the ‘brainstorming’ stages of app development, and no code (or very little code) has been written. Maybe you’ve investigated using a framework (like golem or rhino) but can’t decide if their features will fit your needs.\n\n\n\n\nIn this case, you’re in the perfect position to create a new package with usethis::create_package() or devtools::create(). If you’re using Posit Workbench, do File &gt; New Project &gt; New Directory &gt; R Package.\nScenario #2\n\n\n\n\n\n\nScenario #2: Convert a working app project into an app-package\n\n\n\n\n\n\nThe app is currently deployed and is being accessed by users, but the underlying code lives in the ‘root’ folder (i.e., an app.R or ui.R and server.R, global.R, helper.R, and/or other .R files, data, static resources, etc.). The application works, but you’d like to convert it to a package structure without breaking it.\n\n\n\n\nThis is a circumstance where I’d manually create the DESCRIPTION file (or use usethis::use_description()) and set the package-level build tools (Tools &gt; Project options &gt; Build Tools &gt; Project build tools). Then I’d begin organizing the shiny app files into a package structure (i.e., move .R files into the R/ folder, data files into the data/ folder, etc.)\nScenario #3\n\n\n\n\n\n\nScenario #3: Convert a legacy app project into a shiny app-package\n\n\n\n\n\n\nThe app was written some time ago, used superseded or deprecated functions (i.e., callModule()), and needs updating. Updating the apps might include adding data or static resources, writing utility functions and modules, etc.\nThe critical distinction is that this application is not working and requires updates.\n\n\n\n\nScenario #4\n\n\n\n\n\n\nScenario #4: Convert your ‘dev’ app project into an app-package\n\n\n\n\n\n\nYou’re currently developing an app project, and you read somewhere it should be an app-package; however, you can’t find clear instructions on how to accomplish this incrementally.\nAnd maybe you’re a minimalist (like me) who likes to have complete control over every aspect of the development process."
  }
]