[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "Welcome!\nShiny combines the power of R’s statistical capabilities with the interactivity of a web-based application.\nR packages are collections of pre-built, self-contained code, data, and documentation designed to perform operations or accomplish tasks beyond the capabilities of base R.\nShiny App-Packages covers how to create a Shiny application as an R package. If you’re comfortable building Shiny applications, but aren’t as familiar with writing R packages, this book was written for you."
  },
  {
    "objectID": "index.html#why-this-book",
    "href": "index.html#why-this-book",
    "title": "Shiny App-Packages",
    "section": "Why this book?",
    "text": "Why this book?\n\nDid you read Mastering Shiny and want to learn more about package development?\n\nMastering Shiny is an excellent introduction to the captivating world of Shiny and provides a foundation of best practices for building applications. R packages are covered in Mastering Shiny, and while this chapter is a great place to start, I think to fully understand and appreciate the benefits of developing a Shiny app as a package, I wanted an example with most (or some) of the development tools.\n\n\n\n\n\n\nWhat about the ‘Converting an existing app’ section in Mastering Shiny?\n\n\n\n\n\n\nThe ‘Converting an existing app’ section in Mastering Shiny provides an example of converting a Shiny app into an R Package. However, when I downloaded the source code (monthApp), many package development tools were missing (roxygen2 tags, NAMESPACE imports/exports, tests, vignettes, etc.).\n\n\n\n\n\nDid you read Engineering Production-Grade Shiny Apps and decide the golem framework wasn’t a good fit for your application?\n\ngolem is the ‘opinionated framework for building production-grade Shiny applications’ introduced in Engineering Production-Grade Shiny Apps (or EPGSA). golem offers a robust and standardized way to build, maintain, and deploy production-grade Shiny apps. Whether it’s due to golem’s learning curve, overhead, and dependencies or the legacy code, unconventional development, or deployment constraints of your existing application, it might not be the right fit for your situation.\n\n\n\n\n\n\nAren’t golem applications packages?\n\n\n\n\n\n\ngolem apps are built as packages. Still, EPGSA assumes the reader is ‘comfortable with building an R package.’ (if you’re familiar with package development, EPGSA is an excellent resource for Shiny apps)."
  },
  {
    "objectID": "index.html#connecting-the-dots",
    "href": "index.html#connecting-the-dots",
    "title": "Shiny App-Packages",
    "section": "Connecting the dots",
    "text": "Connecting the dots\nI wrote this book after multiple encounters with Shiny developers who had developed impressive, complex apps but struggled to share and deploy their code. Many of these developers had problems moving their applications into a production environment.\n\n\n\n\n\n\nWhat does it mean to put something into production?\n\n\n\n\n\n\n\n‘I think the easiest way to think about it for me is that we develop a model in one computational environment–think of this as maybe your laptop or maybe you work in a server environment–still, it’s in one place, and it turns out the software that you need to have installed there is about tuning, training, etc. Putting something into production is getting it out of that computational environment and successfully carrying it over to a new computational environment. For many people, this might be like a cloud computing environment. It might be some kind of server your organization has, and we need to take it, lift it, and then successfully have it working.’ - Julia Silge, What is ‘production’ anyway? MLOps for the curious (SatRdays London 2023)\n\nI’ve added emphasis and edited this for clarity.\n\n\n\n\n\n‘Production’ usually means passing the code from your personal development environment into your company’s cloud-based server environment, which typically involves bundling your app in a structure that can be shared, installed, tested, and launched.\nR packages are specifically designed for other users to install and load into their R environment. The package structure offers a standardized way of extending R’s capabilities by adding new functionality (like developing Shiny apps!).\nThis book is a resource intended to help ‘connect the dots’ between building scalable Shiny applications and writing R packages. Adopting R package development practices in the early stages of your Shiny app will improve the reusability, maintainability, and shareability of all your hard work."
  },
  {
    "objectID": "index.html#what-this-book-isnt",
    "href": "index.html#what-this-book-isnt",
    "title": "Shiny App-Packages",
    "section": "What this book isn’t",
    "text": "What this book isn’t\nThis book isn’t a replacement for R Packages, 2ed or Writing R Extensions. I highly suggest bookmarking both of those resources to come back and read when you’d like to learn more about package development.\nThis book also won’t recommend a particular Shiny framework or package, but I’ll cover a few popular choices and why you might consider adopting them."
  },
  {
    "objectID": "index.html#what-i-assume-about-you",
    "href": "index.html#what-i-assume-about-you",
    "title": "Shiny App-Packages",
    "section": "What I assume about you",
    "text": "What I assume about you\nIf you’re reading this, I assume you’re comfortable with R, Posit Workbench, Shiny, and the tidyverse. Maybe you haven’t built a ton of applications, but you understand reactivity, and you’re comfortable with the core Shiny concepts (i.e., the UI, server, *_Input(), *_Output(), and render_* functions, etc.)."
  },
  {
    "objectID": "index.html#other-resources",
    "href": "index.html#other-resources",
    "title": "Shiny App-Packages",
    "section": "Other resources",
    "text": "Other resources\nExcellent resources have been written for Shiny, and it’s also worthwhile to consult the documentation on the core package development tools:\n\n\ndevtools\n\n\nusethis\n\n\nroxygen2\n\npkgload"
  },
  {
    "objectID": "intro.html#packages-are-better-for-you",
    "href": "intro.html#packages-are-better-for-you",
    "title": "Introduction",
    "section": "Packages are better for you",
    "text": "Packages are better for you\nThe first and possibly obvious benefit to structuring your shiny app as a package is that it simplifies your file and folder management. If every shiny app project (and R project) is structured as a package, it removes the time spent re-orienting yourself to each project’s structure.\nIn Posit Workbench, a package structure will give access to a well-designed IDE for shiny applications. Posit Workbench comes with tools to help develop and debug functions, create and run unit tests, store internal and external data, manage dependencies, and write help files and long-form documentation."
  },
  {
    "objectID": "intro.html#packages-are-better-for-them",
    "href": "intro.html#packages-are-better-for-them",
    "title": "Introduction",
    "section": "Packages are better for them",
    "text": "Packages are better for them\n\n“a package [is] the fundamental unit of shareable, reusable, and reproducible R code.” - R Packages, 2ed\n\nIt’s safe to assume the code used to build shiny apps being deployed to a production environment will be seen (and hopefully used) by others. R packages make sharing your hard work with your colleagues easier because it removes their need to figure out where everything is, how it all fits together, and how it all (hopefully) works."
  },
  {
    "objectID": "intro.html#packages-are-scalable",
    "href": "intro.html#packages-are-scalable",
    "title": "Introduction",
    "section": "Packages are scalable",
    "text": "Packages are scalable\nGreat R packages define and solve common problems.\nIf you’re currently using R to perform analyses, run reports, design data visualizations, or build shiny apps, I’m suggesting extending your mental model from those specific use cases to a model for their more general uses (i.e., instead of ‘X code performs task Y’, think ‘X package performs tasks like Y’).\nThe beauty of an R package mental model is that you’ll inevitably notice the similarities across tasks with common problems as you develop multiple R packages. Creating packages that define and solve common problems in your workflow can sometimes be some of the most popular/valuable contributions (see datapasta and reprex)."
  },
  {
    "objectID": "intro.html#example-code",
    "href": "intro.html#example-code",
    "title": "Introduction",
    "section": "Example code",
    "text": "Example code\n\n\n\n\nNew Git Branch\n\nThe code for this section was pushed to the [main] branch of the [pkgApp] repo.\nThe code files for each chapter are stored in GitHub repositories. Major code changes are stored in Git branches. Whenever a new branch or repo is used, you’ll see an icon in the margin with a link to the branch."
  },
  {
    "objectID": "shiny.html#shiny-programming",
    "href": "shiny.html#shiny-programming",
    "title": "Shiny apps",
    "section": "Shiny programming",
    "text": "Shiny programming\nReactivity is the underlying process that allows Shiny apps to update and respond to user interactions automatically. Developing Shiny apps involves harnessing the connection between inputs, reactivity, and outputs to control and predict the application’s behavior.\nShiny programming differs from regular R programming in several key aspects:\n\n\nAn Event-driven UI: Shiny apps require developers to design and develop a user interface (UI). User experience (UX) design is an entirely separate field, but as Shiny developers, we need to know enough to allow users to interact with and navigate our apps. The UI also captures each ‘event,’ meaning that the user’s actions (such as button clicks or input changes) trigger the application’s inputs, updates, or outputs.\n\nRegular R programming often involves executing predefined steps or functions without direct interaction or responses to user events.\n\n\n\nA Reactive Server: In Shiny, the application’s behavior is determined by the dependencies between reactive inputs (i.e., the inputIds), reactive values, and outputs (i.e., the outputIds), allowing for automatic updates and propagation of changes throughout the application.\n\nIn standard R programming, we typically define a series of sequential steps (i.e., functions) that operate on data to generate output to the console or a typesetting system for technical and scientific publications (model results, graphs, tables, etc.) without accounting for reactivity or downstream changes.\n\n\n\nLearning reactivity can be challenging when you start, but fortunately, there are excellent tutorials and articles to help you along the way!"
  },
  {
    "objectID": "shiny.html#new-shiny-app-projects",
    "href": "shiny.html#new-shiny-app-projects",
    "title": "Shiny apps",
    "section": "New shiny app projects",
    "text": "New shiny app projects\nIf you’re creating a new application using the New Project Wizard, you’ll see the following:\n\n\n\n(a) New shiny app\n\nFigure 1: New shiny app project\n\nSelect the location of your shiny app project, then pick a name and decide whether you want to use Git or renv (I’ll be using Git).\n\n\n\n(a) Shiny app info\n\nFigure 2: New shiny app project in a Git repository\n\nAfter clicking Create Project, a new session will open with your project files."
  },
  {
    "objectID": "shiny.html#shiny-app-project-contents",
    "href": "shiny.html#shiny-app-project-contents",
    "title": "Shiny apps",
    "section": "Shiny app project contents",
    "text": "Shiny app project contents\nNote that the only items in the new shiny app project are app.R and the projApp.Rproj file.\nprojApp/\n    ├── app.R\n    └── projApp.Rproj\n\n1 directory, 2 files\napp.R\napp.R initially contains a boilerplate application, which we can launch by clicking on the Run App button:\n\n\n\n\nClick on Run App\n\n\n\n\n(a) Old Faithful geyser app\n\nFigure 3: Boilerplate Old Faithful geyser app in new shiny projects\n\nThe boilerplate ‘Old Faith Geyser Data’ app is a perfect example of what Shiny can do with a single app.R file, but we’ll want to exchange this code for a slightly more advanced application (because most shiny apps grow beyond an app.R file)."
  },
  {
    "objectID": "shiny.html#movie-review-app",
    "href": "shiny.html#movie-review-app",
    "title": "Shiny apps",
    "section": "Movie review app",
    "text": "Movie review app\n\n\n\n\n\n\nCopy me!\n\n\n\n\n\nIf you’re following along, these callout boxes contain code that should be copied and pasted into your shiny app project.\n\n\n\nThe application we’re going to place in app.R comes from the Building Web Applications with Shiny course. I’ve chosen to use this app for the following reasons:\n\nMultiple input types are collected in the UI\nAn output that can be created with a utility function\nThe app loads an external data file when it’s launched\n\nEach of these features provides an opportunity to explore some of the methods shiny apps have for running code and loading external files.\nApp\n\n\n\n\n\n\nPlace in app.R\n\n\n\n\n\nReplace the boilerplate ‘Old Faith Geyser Data’ app in app.R with the code below:\n\nshow/hide movie review shiny appui &lt;- shiny::fluidPage(theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\"The data represent\", \n        nrow(movies), \n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n        shiny::p(shiny::em(\"The code for this shiny application comes from\", \n          shiny::a(\"Building Web Applications with shiny\", \n            href = \"https://rstudio-education.github.io/shiny-course/\"))\n          )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  new_plot_title &lt;- shiny::reactive({\n      tools::toTitleCase(input$plot_title)\n    }) |&gt; \n    shiny::bindEvent(input$update_plot_title, \n                     ignoreNULL = FALSE, \n                     ignoreInit = FALSE)\n    \n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n        df = movies,\n        x_var = input$x,\n        y_var = input$y,\n        col_var = input$z,\n        alpha_var = input$alpha,\n        size_var = input$size\n      ) + \n      ggplot2::labs(title = new_plot_title()) + \n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\n\nUtility function\n\n\n\n\n\n\nPlace in utils.R\n\n\n\n\n\nPlace the scatter_plot() utility function in a new utils.R file:\n\nshow/hide scatter_plot()scatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\nData\n\n\n\n\n\n\nDownload movies.RData\n\n\n\n\n\nDownload the movies dataset here and upload movies.RData to the project.\n\n\n\nUpdated movies app project contents\nThe projApp project now contains the following files:\nprojApp/\n  ├── app.R\n  ├── movies.RData\n  ├── projApp.Rproj\n  └── utils.R\n\n2 directories, 4 files\nTo run the movies app, we need to load the data and source the utils.R file by adding the code below to the top of the app.R file:\nAfter the packages below are installed, add a comment (#) in front of these lines.\n\n\n\n\n\n\nPlace at the top of app.R\n\n\n\n\n\n\n# install ------------------------------------\n# after installing, comment this out\npkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# data -----------------------------------------\nload(\"movies.RData\")\n\n# utils ----------------------------------------\nsource(\"utils.R\")\n\n\n\n\nClicking on Run App displays the movie review app:\n\n\n\n\n(a) movies app\n\nFigure 4: Movie review app\n\n\n\n\n\n\nGit Branch\n\nThe code for this section was pushed to the [02_movies-app] branch of the [projApp] repo."
  },
  {
    "objectID": "shiny.html#project-folders",
    "href": "shiny.html#project-folders",
    "title": "Shiny apps",
    "section": "Project folders",
    "text": "Project folders\nNow that we have a slightly more complex application in app.R, I’ll few project folders we can add to our project that have unique built-in behaviors. These folders will help organize your files and make additional resources available to your app.\nFollowing the conventional folder structure will also help set you up for success when/if you decide to convert it into an app-package.\n\n\n\n\n\n\nCopy into projApp\n\n\n\n\n\nIf you’re following along, these callout boxes contain code or contents that have been included in projApp\n\n\n\nR/\nIf your shiny app relies on utility or helper functions (outside the app.R file), you can place this code in an R/ folder. Any .R files in the R/ folder will be automatically sourced when the application is run.\nI’ve moved the utils.R file into the R/ folder in projApp:\n\n\n\n\n\n\nPlace utils.R in R/ folder\n\n\n\n\n\nprojApp/\n     └── R/\n         └── utils.R\n\n1 directory, 1 file\n\n\n\nwww/\nWhen you run a shiny application, any static files (i.e., resources) under a www/ directory will automatically be made available within the application. Use this folder to store images, CSS or JavaScript files, and other static resources.\n\n\n\n\n\n\nCreate www/ folder and download image\n\n\n\n\n\nWe’ll download a logo (shiny.png) and store it in the www/ folder.\nprojApp/\n     └── www/\n           └── shiny.png\n\n1 directory, 1 file\nIn the section below, we’ll reference it directly in the UI."
  },
  {
    "objectID": "shiny.html#project-files",
    "href": "shiny.html#project-files",
    "title": "Shiny apps",
    "section": "Project files",
    "text": "Project files\nREADME.md\nIncluding a README.md file in your root folder is a good practice for any project. README.md should contain relevant documentation for running app.R.\n\n\n\n\n\n\nCreate README.md\n\n\n\n\n\nI’ve included the content below in the README.md file\n# movies app\n\nThe original code and data for this shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`projApp` branches](https://github.com/mjfrigaard/projApp/branches/all).\n\n\n\nDESCRIPTION\nDESCRIPTION files play an essential role in R packages, but they are also helpful in Shiny projects if I want to deploy the app in showcase mode.\n\n\n\n\n\n\nCreate DESCRIPTION\n\n\n\n\n\nI’ve included the content below in DESCRIPTION:\nType: shiny\nTitle: movies app\nAuthor: John Smith\nDisplayMode: Showcase\n&lt;empty final line&gt; &lt;- delete me but leave an empty final line!\n\n\n\n\n\n\nIt’s always a good idea to leave at least one &lt;empty final line&gt; in your DESCRIPTION file.\n\nAfter adding README.md and a DESCRIPTION file (listing DisplayMode: Showcase), the movies app will display the code and documentation when the app launches:\n\n\n\n\n(a) movies app (showcase)\n\nFigure 5: Read more about showcase mode here"
  },
  {
    "objectID": "shiny.html#project-code",
    "href": "shiny.html#project-code",
    "title": "Shiny apps",
    "section": "Project code",
    "text": "Project code\nThe following two items are considered best practices because they make your app more scalable by converting app.R into functions.\nModules\nShiny modules are a ‘pair of UI and server functions’ designed to compartmentalize input and output IDs into distinct namespaces,\n\n‘…a namespace is to an ID as a directory is to a file…’ - shiny::NS() help file.\n\nModule UI functions typically wrap the layout, input, and output functions in shiny::tagList(). Module server functions typically contain the ‘backend’ code in a shiny server function. Both the UI and server module functions are linked by an id argument, which is created using shiny::NS() (namespace) in the UI function, and called in the server function with shiny::moduleServer().\nVariable inputs (mod_var_input)\nmod_var_input_ui() creates a dedicated namespace for the inputIds with shiny::NS():\n\n\n\n\n\n\nPlace in R/mod_var_input.R\n\n\n\n\n\n\nshow/hide mod_var_input_ui()mod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n\n\nmod_var_input_server() returns these values in a reactive list with shiny::reactive():\n\n\n\n\n\n\nPlace in R/mod_var_input.R\n\n\n\n\n\n\nshow/hide mod_var_input_server()mod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n      list(\n        \"x\" = shiny::reactive({\n          input$x\n        }),\n        \"y\" = shiny::reactive({\n          input$y\n        }),\n        \"z\" = shiny::reactive({\n          input$z\n        }),\n        \"alpha\" = shiny::reactive({\n          input$alpha\n        }),\n        \"size\" = shiny::reactive({\n          input$size\n        }),\n        \"plot_title\" = shiny::reactive({\n          input$plot_title\n        })\n      )\n    )\n  })\n}\n\n\n\n\n\nScatter-plot display (mod_scatter_display)\nmod_scatter_display_ui() creates a dedicated namespace for the plot outputId (as \"scatterplot\"), along with some help text:\n\n\n\n\n\n\nPlace in R/mod_scatter_display.R\n\n\n\n\n\n\nshow/hide mod_scatter_display_ui()mod_scatter_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\"The data for this application comes from the \",\n        shiny::tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))\n      ),\n    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n\n\nThe code to render the output$scatterplot is contained in the nested call to shiny::moduleServer() in mod_scatter_display_server():\nAfter loading the movies data and collecting the returned values from mod_var_input_server(), and creating the input() reactive, the scatter_plot() utility function creates the plot object and adds the plot_title():\n\n\n\n\n\n\nPlace in R/mod_scatter_display.R\n\n\n\n\n\n\nshow/hide mod_scatter_display_server()mod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    \n    # data --------------------------------------------------------------------\n    load(\"movies.RData\")\n\n    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs$plot_title())\n      list(\n        x = var_inputs$x(),\n        y = var_inputs$y(),\n        z = var_inputs$z(),\n        alpha = var_inputs$alpha(),\n        size = var_inputs$size(),\n        plot_title = plot_title\n      )\n    })\n    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n\n\nBoth UI and server module functions are combined into a single module .R file, and all modules are placed in the R/ folder so they are sourced when the application is run.\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n └── utils.R\n\nStandalone app function\nBoth module functions are combined in the ui and server arguments of shiny::shinyApp(). The id arguments (\"vars\" and \"plot\") connect the UI functions to their server counterparts, and the output from mod_var_input_server() is the var_inputs argument in mod_scatter_display_server().\nThe call to shiny::shinyApp() is wrapped in the movies_app() function and placed in app.R.\n\n\n\n\n\n\nPlace in app.R\n\n\n\n\n\n\nshow/hide movies_app() in app.R# install ------------------------------------\n# after installing, comment this out\npkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nmovies_app()\n\n\n\n\n\nNow I can run the app with movies_app().\n\n\n\n\n(a) Movie reviews app\n\nFigure 6: View a deployed version here.\n\n\nThe files in the 03_projApp branch of the projApp repo are below:\n\nprojApp/ # 03_projApp branch\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── projApp.Rproj\n├── rsconnect/\n│   └── shinyapps.io/\n│       └── user/\n│           └── projApp.dcf\n└── www/\n    └── shiny.png\n\n6 directories, 10 files\n\n\n\n\n\nGit Branch\n\nThe code for this section was pushed to the [03_projApp] branch of the [projApp] repo."
  },
  {
    "objectID": "shiny.html#project-dependencies",
    "href": "shiny.html#project-dependencies",
    "title": "Shiny apps",
    "section": "Project dependencies",
    "text": "Project dependencies\nrenv\nIf you use renv, keep track of your dependencies by regularly running renv::status() and renv::snapshot().\n\n\n\n\n\n\nUsing renv\n\n\n\n\n\nStart by initiating renv with renv::init(), then run renv::status() to check which packages have been added to the lockfile:\n\nrenv::status()\n\n\nshow/hide example renv::status() outputThe following package(s) are in an inconsistent state:\n\n package      installed recorded used\n colorspace   y         n        y   \n fansi        y         n        y   \n farver       y         n        y   \n ggplot2      y         n        y   \n gtable       y         n        y   \n isoband      y         n        y   \n labeling     y         n        y   \n lattice      y         n        y   \n MASS         y         n        y   \n Matrix       y         n        y   \n mgcv         y         n        y   \n munsell      y         n        y   \n nlme         y         n        y   \n pillar       y         n        y   \n pkgconfig    y         n        y   \n RColorBrewer y         n        y   \n scales       y         n        y   \n shinythemes  y         n        y   \n tibble       y         n        y   \n utf8         y         n        y   \n vctrs        y         n        y   \n viridisLite  y         n        y   \n\n\nTake a ‘snapshot’ to capture the current package dependencies:\n\nrenv::snapshot()\n\n\nshow/hide example renv::snapshot() outputThe following package(s) will be updated in the lockfile:\n\n# CRAN --------------------------------------------------\n- lattice        [* -&gt; 0.21-8]\n- MASS           [* -&gt; 7.3-60]\n- Matrix         [* -&gt; 1.5-3]\n- mgcv           [* -&gt; 1.8-42]\n- nlme           [* -&gt; 3.1-162]\n- vctrs          [* -&gt; 0.6.3]\n\n# RSPM --------------------------------------------------\n- colorspace     [* -&gt; 2.1-0]\n- fansi          [* -&gt; 1.0.4]\n- farver         [* -&gt; 2.1.1]\n- ggplot2        [* -&gt; 3.4.2]\n- gtable         [* -&gt; 0.3.3]\n- isoband        [* -&gt; 0.2.7]\n- labeling       [* -&gt; 0.4.2]\n- munsell        [* -&gt; 0.5.0]\n- pillar         [* -&gt; 1.9.0]\n- pkgconfig      [* -&gt; 2.0.3]\n- RColorBrewer   [* -&gt; 1.1-3]\n- scales         [* -&gt; 1.2.1]\n- shinythemes    [* -&gt; 1.2.0]\n- tibble         [* -&gt; 3.2.1]\n- utf8           [* -&gt; 1.2.3]\n- viridisLite    [* -&gt; 0.4.2]\n\nDo you want to proceed? [Y/n]: y\n\n- Lockfile written to '~/path/to/projApp/renv.lock'."
  },
  {
    "objectID": "shiny.html#recap",
    "href": "shiny.html#recap",
    "title": "Shiny apps",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some differences between developing shiny apps and regular R programming, creating new shiny projects in Posit Workbench, and some practices to adopt that can make the transition to app-packages a little easier. The code used in this chapter is stored in the projApp repository.\n\n\n\n\n\n\nRecap\n\n\n\n\n\n\n\nPlacing utility or helper files in an R/ folder removes the need to call source() in app.R.\nImages, CSS, JavaScript, and other static resources can be stored in www/ and Shiny will serve these files when the application is run.\nREADME.md files can document the application’s description, purpose, requirements, etc.\nDESCRIPTION files provide metadata and include fields that affect application deployment (i.e., DisplayMode: Showcase)\nConverting the application code into functions (modules and standalone app functions) creates a ‘division of labor’ for each component, which makes it easier to think about and work on them independently.\nFinally, if you’re using renv, run renv::status() and renv::snapshot() to manage dependencies\n\n\n\n\n\nIn the next chapter, I’ll cover what makes a package a package, and some do’s and don’ts when converting a developed shiny application into an R package.\nend shiny.qmd"
  },
  {
    "objectID": "packages.html#projects-packages-and-app-packages",
    "href": "packages.html#projects-packages-and-app-packages",
    "title": "Packages",
    "section": "Projects, packages, and app-packages",
    "text": "Projects, packages, and app-packages\nBefore we start, we should establish some ‘operational definitions’ of what I mean by the terms ‘project’, ‘package’, and ‘app-package’.\n\n\nI’ll use color to differentiate shiny app projects, R packages, and app-package.\n\nProject: I consider a project to be any directory of files requiring R (the binary downloaded from CRAN with a version number and neat names like, ‘R 4.3.1 “Beagle Scouts” released on …’) to execute with an RStudio/Posit workbench project file (.Rproj).\nPackage: I’ll be using the term package to describe a directory of functions, documentation, or data that can be installed and loaded into an R session. A package includes the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench.\nApp-package: an app-package (which you have probably already guessed) is a package containing a shiny application. App-packages have all of the functionality of a standard R package, but also contain the files and folders required to successfully develop, run, and deploy a shiny app.\n\n\n\n\n\n\n\nR Packages & Posit Workbench\n\n\n\n\n\n\nPosit Workbench (formerly RStudio) is a popular integrated development environment (IDE) streamlining many R package development tasks. I’ve purposely connected Posit Workbench to the definitions above for package and app-package–specifically, the package development tools provided in the Build pane and devtools.\nHowever, developing R packages in Posit Workbench (or using .Rproj files) is not required. There are alternative package development tools and processes outside of Posit Workbench, and many developers employ these setups.\nPackage development outside Posit Workbench would look almost identical to development in the IDE:\n\nCreate the package structure (R/ folder for .R scripts, man/ folder for documentation, data/ folder for datasets, etc.)\nAdd DESCRIPTION and NAMESPACE files, etc.\nEnsure the package can be installed and loaded into an R session.\n\nIt’s also possible to use many of the development workflow functions we’ll cover here outside of the IDE (roxygen2::roxygenize(), devtools::check(), devtools::install(), etc.).\n\n\n\n\nThe previous chapter covered a few practices to adopt during shiny development that improves the extensibility of your app project to an app-package (these are summarized in the callout box below).\n\n\n\n\n\n\nShiny ‘pre-package’ practices\n\n\n\n\n\n\n\n\nFolders\n\nwww: can be used to store static resources (images, CSS files, JavaScript)\n\nR/: any .R files in the R/ folder will automatically be loaded with your app when it’s run.\n\nConverting the code in app.R into separate functions (i.e., modules and standalone app functions) also allows you to develop and debug the code independently.\n\n\n\n\n\nFiles\n\n\nDESCRIPTION files store metadata and include fields for application deployment (i.e., DisplayMode: Showcase)\n\n\nREADME.md files can document application descriptions, purposes, requirements, etc.\n\n\n\nDependencies\n\n\nrenv can be used to help manage app dependencies.\n\nRun renv::status() & renv::snapshot() to record dependencies in the lock file."
  },
  {
    "objectID": "packages.html#app-packages-motivation",
    "href": "packages.html#app-packages-motivation",
    "title": "Packages",
    "section": "\nApp-packages: Motivation",
    "text": "App-packages: Motivation\nThere are multiple reasons for deciding to develop an app-package: your app project might have to be in a package structure due to specific organizational needs or practices around deploying applications, or maybe you’ve been convinced it’s the best practice for improving the shareability/reproducibility of your app project.\nRegardless of the reason, you’ve likely found yourself in one of two circumstances:\n\nYou want to develop a new shiny app, but want it structured as an app-package.\nYou’ve already developed a shiny app project, but now you need to convert it to an app-package.\n\nR package vs. shiny project\n\nBelow is a folder tree with some of the typical files and folders found in R packages:\n\n&lt;R package&gt;/\n    ├── DESCRIPTION\n    ├── &lt;R package&gt;.Rproj\n    ├── LICENSE \n    ├── LICENSE.md \n    ├── NAMESPACE \n    ├── NEWS.md\n    ├── README.Rmd\n    ├── README.md\n    ├── renv.lock\n    ├── R/\n    ├── man/\n    ├── tests/\n    ├── data/ \n    ├── data-raw/ \n    ├── vignettes/ \n    ├── inst/ \n    └── renv/\n  \n\nR packages can be easily shared, reused, and reproduced because they all have a familiar structure, and each folder and file plays an essential role in extending R’s capabilities.\nAt first glance, the contents above can seem daunting when compared to the folders and files that currently exist in your app project (like projApp below):\n\nprojApp/\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── projApp.Rproj\n├── rsconnect/\n└── www/\n    └── shiny.png\n\n4 directories, 9 files\n\nFortunately, app-packages don’t require all the files and folders displayed above to gain the functionality and benefits of an R package.\nThis chapter will cover what’s required in all R packages, so you can handle both creating new app-package and converting existing shiny projects into app-package."
  },
  {
    "objectID": "packages.html#what-makes-an-r-package",
    "href": "packages.html#what-makes-an-r-package",
    "title": "Packages",
    "section": "What makes an R package?",
    "text": "What makes an R package?\nIf you’ve read R packages, 2ed or Mastering Shiny, you might recall encountering one (or both) of the following quotes,\n\n‘Every package must have a DESCRIPTION. In fact, it’s the defining feature of a package (RStudio and devtools consider any directory containing DESCRIPTION to be a package)’ - R Packages, 2ed (Chapter 9, DESCRIPTION)\n‘all a project needs to be a package is a directory of R/ files and a DESCRIPTION file.’ - Mastering Shiny (Chapter 20, Packages)\n\nIf you’ve been following the code in projApp, the quotes above should confuse you. The projApp shiny project has a DESCRIPTION file and an R/ directory, but projApp is not a functioning package.\nAs we defined above, a functioning package can be installed and loaded into an R session and has access to the Build pane in the IDE.\n\ndevtools functions\ndevtools simulates installing and loading with load_all() (we’ll cover this function extensively in the devtools chapter),\nBut when we attempt to load the code in the R/ folder with load_all(), we see the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n(a) Load All Error\n\nFigure 1: devtools is looking for the Package field in the DESCRIPTION file\n\nThe Build pane\nWhen opened, functioning packages have access to the Build pane, which allows us to iterate between loading, installing, and testing quickly. But when projApp is opened, the Build pane is not displayed in the IDE:\n\n\n\n\n(a) projApp IDE\n\nFigure 2: Project IDE panes\n\n\nAs we’ve just learned, the presence of the DESCRIPTION file and an R/ folder are insufficient to turn your app project into a package (or an app-package)."
  },
  {
    "objectID": "packages.html#what-really-makes-an-r-package",
    "href": "packages.html#what-really-makes-an-r-package",
    "title": "Packages",
    "section": "What really makes an R package?",
    "text": "What really makes an R package?\nFor our purposes, I’ll rewrite the minimum requirements for creating a ‘functional’ R package:\n\n“A project needs a DESCRIPTION file with specific fields, a directory of R/ files, and a properly configured .Rproj file to be a package.” - Me\n\nLet’s see how each of these requirements works together to convert the contents of projApp from a project into a package.\n\nDESCRIPTION fields\nThe official R documentation lists the following required fields for the DESCRIPTION in R packages:\n\nThe ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and ‘Maintainer’ fields are mandatory.\n\nBelow is an example DESCRIPTION file for projApp with the mandatory fields:\n\n\n\n\nNew Git Branch\n\nThe code for this section was pushed to the [04_description] branch of the [projApp] repo.\nPackage: projApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\n*leave empty final line*\n\n\n\n\n\n\nAuthor and Maintainer fields\n\n\n\n\n\nNote that the Author and Maintainer fields require additional information beyond first and last name (i.e., John Smith). These can be created with the utils::person() function:\n\nshow/hide person() output# Author\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  role = c(\"aut\", \"cre\"))\n## [1] \"John Smith [aut, cre]\"\n# Maintainer\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  email = \"John.Smith@email.io\")\n## [1] \"John Smith &lt;John.Smith@email.io&gt;\"\n\n\n\n\n\nAfter adding the mandatory fields to the DESCRIPTION file in projApp, load_all() runs without the previous error, but the IDE still doesn’t display the Build pane:\n\n\n\n\n(a) projApp IDE\n\nFigure 3: Where is the Build pane?\n\n\n\nProject options\ni.e., the .Rproj file\n.Rproj files are plain text files with various settings for the IDE. We ran devtools::load_all() above without the presence of the Build pane is because the IDE displays the Build pane after reading the fields in the projApp.Rproj file.\nThe quickest way to access the fields in the .Rproj file is under Tools &gt; Project options.\nDefault project options\nTools &gt; Project options provide access to the project-level options. For example, fields 2 - 4 are available under General, 5 - 8 affect the Code options, and the final two fields deal with Sweave.\n\n\n\n(a) projApp.Rproj fields\n\nFigure 4: Field settings from projApp.Rproj file\n\nThese are the default settings created when we selected the Shiny App project from the New Project Wizard in the last chapter.\nBuild tools\nIf you’ve read the What makes an RStudio Project? section of R Packages (2 ed), you’ll notice a few differences between each .Rproj file (I’ve placed the files side-by-side so you can compare them below):\n\n\n\n(a) .Rproj files\n\nFigure 5: Comparison of projApp.Rproj file and .Rproj file in R Packages, 2ed\n\nI’ve circled the fields in the R Packages, 2ed .Rproj file that illustrate it’s configured to work with a package. Note that in projApp, the Project build tools are initially set to (None) under Build Tools:\n\n\n\n(a) projApp.Rproj build tools\n\nFigure 6: Build tool settings in projApp.Rproj file\n\nThis setting should help explain the absence of any package development fields in the projApp.Rproj when we compared it to the version in R Packages, 2ed (i.e., BuildType, PackageUseDevtools, PackageInstallArgs, and PackageRoxygenize).\nChanging the Project build tools option to Package will set the default Build Tools options:\n\n\n\n(a) Default package build tools\n\nFigure 7: Default build tool settings\n\nThe links between the Build Tools options and fields in projApp.Rproj are in the figure below:\n\n\n\n(a) projApp.Rproj build tool fields\n\nFigure 8: Default build tool settings in projApp.Rproj file\n\n\nBuildType: Package tells the IDE projApp is a package and triggers the Build pane.\nPackageUseDevtools: Yes links the options in the Build pane to the devtools package.\nThe PackageInstallArgs are complicated, but I’ve included some information about them in the callout block below (and you can read more in the official R documentation)\n\nThe fourth option (PackageRoxygenize) is available under Generate documentation with Roxygen &gt; Use roxygen to generate\n\nThese options affect the documentation in your package. To match the example from R Packages, 2ed above, make sure Rd files, Collate field, and NAMESPACE file are selected and click OK.\n\n\n\n\n\n\n(a) PackageRoxygenize in .Rproj file\n\nFigure 9: roxygen2 build settings\n\nAfter clicking OK, the IDE will automatically reboot, and the additional fields will be added to the bottom of the projApp.Rproj:\n\n\n\n\nNew Git Branch\n\nThe code for this section was pushed to the [05_rproj] branch of the [projApp] repo.\n\nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\n\n\n\n\n\n\n\nWhat is --no-multiarch --with-keep.source?\n\n\n\n\n\n\n\n--no-multiarch: refers to the option for the package installer to only compile the package for the architecture of the current R session. By default, R tries to compile packages for 32-bit and 64-bit architectures if running in a 64-bit R session on Windows. This flag can help avoid problems if a package can only be compiled on one architecture. Read more here.\n--with-keep.source: In R, when a function is created, its body can be stored in two ways: 1) as a parsed but unevaluated expression and 2) as a character string containing the function’s source code. By default, only the parsed expression is kept. If –with-keep.source is specified, R will also keep the original source code as a character string, which can be helpful for debugging and for tools that analyze or modify source code. Read more here.\n\n\n\n\n\nBuild pane\nWhen the new session starts, the new project-level options activate the Build pane in the IDE.\n\n\n\n\n(a) Build pane in IDE\n\nFigure 10: Build pane triggered from project-level settings\n\n\nWhen the IDE reboots, I can see the Build pane has been added, and I can check the package functionality by loading the code with Build &gt; Load All\n\n\n\n(a) Load the code in the R/ folder\n\nFigure 11: Identical to running devtools::load_all()\n\nI should see the following in the Console:\nℹ Loading projApp\nThere you have it–projApp is a functional package!"
  },
  {
    "objectID": "packages.html#functional-r-packages",
    "href": "packages.html#functional-r-packages",
    "title": "Packages",
    "section": "Functional R packages\n",
    "text": "Functional R packages\n\n\n\n\n\n(a) Shiny app-package (with DESCRIPTION and Build pane)\n\nFigure 12: Fully functional shiny app-package\n\n\nA functional R package:\n\nThe DESCRIPTION file contains the seven mandatory fields (Package, Version, License, Description, Title, Author, and Maintainer), which make it possible to run the necessary devtools functions.\nThe .Rproj file contains the three package configuration fields (BuildType: Package, PackageUseDevtools: Yes, and PackageInstallArgs: --no-multiarch --with-keep.source), which makes the Build pane accessible and functional.\n\nThe items above will create a functional R package, but these are the first steps (we haven’t developed anything yet!) on our way to an app-package.\nThink of the two items above as a two-part process: the official R documentation requires the DESCRIPTION fields (and hence, devtools), and the IDE requires .Rproj fields to trigger the Build pane.\nFor more information on the topics in this chapter, you should read Writing R Extensions (the official documentation for creating R packages) and R Packages, 2ed."
  },
  {
    "objectID": "packages.html#creating-packages-with-create_package",
    "href": "packages.html#creating-packages-with-create_package",
    "title": "Packages",
    "section": "Creating packages with create_package()\n",
    "text": "Creating packages with create_package()\n\nThe Posit documentation lists the following ways to create R packages,\n\n\nCall usethis::create_package().\nIn RStudio, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\n\nWhile this information isn’t incorrect, we just demonstrated it’s possible to create a package without the usethis::create_package() function. Still, if you’re looking for a way to quickly create or convert your app project into an app-package, using create_package() is a great option.\nThis function is covered in the ‘Fundamental development workflows’ chapter of R Packages, 2ed. I’ve provided some suggestions below for using create_package().\nNew app-packages\nIf you want to create a new shiny app-package, but haven’t written any code, you can create it with the create_package() function from the usethis package.\nFirst, install devtools:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\ndevtools automatically loads usethis\nLoading required package: usethis\nAssuming your current working directory is where you want your new app-package, call usethis::create_package() with the path argument set to getwd()\n\nusethis::create_package(path = getwd())\n\nThis call launches a series of actions:\n\n\nFirst, the active project is set to whatever was given to the path argument.\n✔ Setting active project to 'path/to/newApp'\n\n\nThe R/ folder and DESCRIPTION/ file are created:\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\n\n\nThe NAMESPACE and .Rproj files are created:\n✔ Writing 'NAMESPACE'\n✔ Writing 'newApp.Rproj'\n\n\nThe .Rproj is added to the .Rbuildignore file, the .Rproj.user folder is added to the .gitignore and .Rbuildignore files.\n✔ Adding '^newApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n\n\nA new session is opened from the new .Rproj file:\n✔ Opening 'path/to/newApp/' in new RStudio session\n\n\nWhen the new session opens, newApp has the following contents:\nnewApp/\n  ├── .Rbuildignore\n  ├── .Rproj.user/\n  ├── .gitignore\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── projApp.Rproj\nYou’re now free to develop newApp. Store and document any .R files in the R/ folder, edit the DESCRIPTION file with details about the application, read through R Packages and Mastering Shiny, and add the shiny code to complete your app-package\nConverting existing app\nIf you already have a shiny app project that needs to be converted into an app-package (like the app files stored in the 03_projApp branch), you can also use create_package(path = getwd()) in your root folder, but I recommend using the following arguments:\n\nDESCRIPTION arguments\n\n\nfields: these are arguments passed to usethis::use_description(). If the fields argument is empty, a boilerplate DESCRIPTION file is created (similar to this one).\n\nThese boilerplate fields in the DESCRIPTION work, but I’ve found some of the fields are unnecessary (i.e., I’ve never needed Authors@R: or ORCID) and inevitably require revision, so I’d prefer to handle this during the creation process (and remove the risk of forgetting to change it later).\nAll fields should be passed in a list() as field = 'value' pairs.\n\n\nusethis::use_description(\n    list(Package = 'projApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"))\n\n\n\nA few fields require specially formatted values (see the utils::person() examples below).\n\nutils::person(\"John\", \"Smith\", \n              email = \"John.Smith@email.io\", \n              role = c(\"aut\", \"cre\"))\n\n[1] \"John Smith &lt;John.Smith@email.io&gt; [aut, cre]\"\n\n\n\n\n\n\nTwo additional arguments from use_description() are passed to create_package():\n\ncheck_name: verifies your app-package name is valid for CRAN, so we can set this to FALSE (unless you’re planning on submitting to CRAN)\nroxygen2: is TRUE by default and adds the fields required to use roxygen2 (which I won’t cover here because we’ll cover documentation in-depth in a future chapter).\n\n\n\n\n\n\n\n\n\nWARNING: Don’t use usethis::create_package('.')!\n\n\n\n\n\n\nWhen converting your existing shiny app project into am app-package with usethis::create_package(), don’t use '.' in the path argument:\nusethis::create_package('.')\nThis will return the following warning about creating nested projects, and ask if you want to proceed anyway:\nNew project 'projApp' is nested inside an existing project\n'./', which is rarely a good idea. If this is unexpected, \nthe here package has a function,\n`here::dr_here()` that reveals why './' is regarded as a\nproject.\n  \nDo you want to create anyway?\n\n1: Yes\n2: No way\n3: Not now\nWe can avoid this warning altogether by passing the getwd() to the path argument, so I recommend cancelling the project creation:\nSelection: 2\nError: Cancelling project creation.\n\n\n\n\nIDE arguments\n\nrstudio: adds the necessary Build Tools fields in the .Rproj file (leave as TRUE)\nopen: can be set to FALSE because we don’t need RStudio/Posit Workbench to open in a new session\n\n\nusethis::create_package(\n  path = getwd(),\n  fields = list(Package = 'projApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"),\n  roxygen = TRUE,\n  check_name = FALSE, \n  rstudio = TRUE,\n  open = FALSE)\n\nAfter running usethis::create_package() with the arguments above, the IDE will present us with a few prompts to confirm:\nOverwrite pre-existing file 'DESCRIPTION'?\nOverwrite pre-existing file 'projApp.Rproj'?\nThe app-package structure is below:\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── projApp.Rproj\n└── www\n    └── shiny.png\n\n3 directories, 10 files\nThe DESCRIPTION file (shown below) has a few additional fields (Encoding, Roxygen, and RoxygenNote) we didn’t include when we converted projApp above. We will cover these in the upcoming chapters.\nPackage: projApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith &lt;John.Smith@email.io&gt; [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\n\n\n\nNew Git Branch\n\nThe code for this section was pushed to the [06_create-package] branch of the [projApp] repo."
  },
  {
    "objectID": "packages.html#recap",
    "href": "packages.html#recap",
    "title": "Packages",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered the mandatory fields in the DESCRIPTION file and the package configuration fields in .Rproj. We also covered creating and converting projects using the usethis::create_package() function.\n\n\n\n\n\n\nRecap: Packages!\n\n\n\n\n\n\n\n\nThe DESCRIPTION file ultimately controls whether you have a functional shiny package.\n\nThe mandatory fields are Package, Version, License, Description, Title, Author, and Maintainer.\n\n\nusethis::create_package() can be used to create a new package and to convert an existing shiny project into a shiny app-package.\n\nThe IDE reads RStudio (.Rproj) files and determines R session settings at the project-level (i.e., working directory, workspace, history, code formatting, etc.)\n\n\nPackage development settings can be accessed via Project Options &gt; Build Tools.\n\n\n\n\n\n\n\nIn the next chapter, I’ll cover how you can Install, Document, Test, and Check your package with a single click!\nend packages.qmd"
  },
  {
    "objectID": "devtools.html#developing-with-devtools",
    "href": "devtools.html#developing-with-devtools",
    "title": "devtools",
    "section": "Developing with devtools\n",
    "text": "Developing with devtools\n\n\n“One package to rule them all.” - not the devtools development team\n\nIf you’re new to package development, it’s helpful to have a little background on the devtools package:\nIn version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\n\nThe usethis package contains most of the functions for creating package folders and files (.R files, tests, vignettes, etc.). usethis is also automatically loaded when you call library(devtools).\nLoading and building your app-package is handled by pkgload and pkgbuild\nFor app-packages destined for CRAN, the R CMD check is handled by rcmdcheck and revdepcheck\nInstalling packages from non-CRAN repositories (i.e., install_github()) is handled by remotes\n\nYou don’t have to install any of these packages (they are loaded with devtools), but this information is important because it affects the dependencies in your app-package:\n\n‘Package developers who wish to depend on devtools features should also pay attention to which package the functionality is coming from and depend on that rather than devtools. In most cases packages should not depend on devtools directly.’ - devtools 2.0.0, tidyverse blog\n\nWe will cover this topic more in the dependencies chapter.\n\n\n\n\n\n\nImportant!\n\n\n\n\n\n\nIt would be best if you considered this section to be a brief overview and not a replacement for the ‘Whole Game’ chapter in R packages (2 ed) (which I highly recommend reading)"
  },
  {
    "objectID": "devtools.html#projapp",
    "href": "devtools.html#projapp",
    "title": "devtools",
    "section": "projApp",
    "text": "projApp\nLet’s assume we’re continuing with the app project we converted manually in the 04_description branch of projApp (the files and folders are below).\n\nprojApp/ # 04_description branch\n  ├── DESCRIPTION\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── projApp.Rproj\n  └── www\n      └── shiny.png\n\n4 directories, 9 files\n\nDESCRIPTION\nThe version of projApp in this branch has a DESCRIPTION file with the seven mandatory fields:\n\n# in Terminal\n$ cat DESCRIPTION \nPackage: projApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\n\nprojApp.Rproj\nHowever, the .Rproj file is still configured to work with a shiny project:\n\n# in Terminal\n$ cat projApp.Rproj \nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\n\n\n\n\n\n\nWhy this branch?\n\n\n\n\n\n\nWe’re backing up to the 04_description branch to show the connection between the devtools functions and specific fields in the DESCRIPTION file.\nIf you’re package was created or converted with usethis::create_package(), these fields are automatically added without any explanation of their role or purpose."
  },
  {
    "objectID": "devtools.html#package-development-habits",
    "href": "devtools.html#package-development-habits",
    "title": "devtools",
    "section": "Package development habits\n",
    "text": "Package development habits\n\n\n\n\n\n\n\nImportant!\n\n\n\n\n\n\nThis section shouldn’t be considered a replacement for the ‘Whole Game’ chapter in R packages (2 ed) (which I highly recommend reading)\n\n\n\n\nThe differences between developing an R package and a shiny app can be boiled down to a handful of habits. These habit call various devtools functions:\n\nLoad all the functions and data in your app-package with load_all()\nDocument the app-package functions and data with document()\nInstall the app-package with install()\n\nIn the sections below, I’ll cover each function and my opinion about how it should be used when your shiny app becomes an app-package.\n\n\n\n\n\n\nKeyboard shortcuts\n\n\n\n\n\n\nI strongly recommend using the keyboard shortcuts for each devtools function. Shortcuts reduce typing and bundle all those keystrokes into a single action. They also create a kind of ‘muscle memory’ for performing each step.\n\n\n\n\nLoad\nInstall devtools\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\nusethis is automatically loaded/attached with devtools.\nLoading required package: usethis\nCtrl/Cmd + Shift + L\n\n‘load_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management’ - Benefits of load_all(), R Packages, 2ed\n\nload_all() is the most common devtools function we’ll use during development because we should load the package when anything changes in the R/ folder.\n\ndevtools::load_all()\n\nUsing load_all() is similar to calling library(projApp) because it loads the code in R/ along with any data files. load_all() is also designed for iteration (unlike using source()), and when it’s successful, the output is a single informative message:\nℹ Loading projApp\nDocument\n\n\n\nThe document() function from devtools serves two purposes:\n\nWriting the package NAMESPACE file\nCreates the help files in the man/ folder\n\ndevtools is smart enough to recognize the first time document() is called, and it prompts me that the roxygen2 version needs to be set in the DESCRIPTION file:\n\ndevtools::document()\n\nℹ Updating projApp documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\ndevtools relies on roxygen2 for package documentation, so the RoxygenNote field is required in the DESCRIPTION. You may have noticed calling document() also calls load_all(), which scans the loaded package contents for special documentation syntax before writing the NAMESPACE file (we’ll cover the NAMESPACE in the chapter on Dependencies).\nℹ Loading projApp\nWriting NAMESPACE\nIf we open the NAMESPACE file, we see it’s empty (and that we shouldn’t edit this file by hand).\n\n\n\n(a) NAMESPACE\n\nFigure 1: Initial NAMESPACE file\n\nThe last few lines of output warn us to include the Encoding field in the DESCRIPTION. devtools won’t automatically add Encoding (like it did with RoxygenNote above), so we’ll need to manually add it to the DESCRIPTION file:\nWarning message:\nroxygen2 requires Encoding: \"UTF-8\"\nℹ Current encoding is NA \nNote: The Encoding value shouldn’t include quotes like the warning message above (i.e., UTF-8). See the example below:\nPackage: projApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\n&lt;empty final line&gt;\nAfter adding the required fields to the DESCRIPTION file, we’ll document() the package again using the keyboard shortcut:\n\nCtrl/Cmd + Shift + D\n\nIn the Build pane, we see the following:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating projApp documentation\nℹ Loading projApp\nDocumentation completed\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\nInstall\nCtrl/Cmd + Shift + B\nThe final package development habit to adopt is regularly installing the package with devtools::install().\n\ndevtools::install()\n\ninstall() will prompt the following output in the Build pane:\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source projApp\n\n* installing to library ‘/path/to/local/install/projApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘projApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\nNo man pages found in package  ‘projApp’ \n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (projApp)\nThere are a few connections worth making in this initial install() output:\n\n\nThe first line in the output should look familiar–we saw both of these settings in the projApp.Rproj file from the previous chapter\nPackageInstallArgs: --no-multiarch --with-keep.source\n\nNo man pages found in package 'projApp' tells us none of the code in R/ has adequately been documented (which we’ll cover in the roxygen2 chapter)\ninstall() attempts to install the package from the *source* files and a ‘bundle’ or source tarball file (i.e., .tar.gz)\nhelp files are built, along with other documentation (like vignettes)\nDONE (projApp) means projApp was successfully installed!\n\nInstall a package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\n\n\nNew Git Branch\n\nThe code for this section was pushed to the [06_devtools] branch of the [projApp] repo.\nCheck?\ndevtools::check() performs a series of checks to ensure a package meets the standards set by CRAN. You can consider check() to be a ‘quality control’ function for things like documentation, NAMESPACE dependencies, unnecessary or non-standard folders and files, etc. R Packages recommends using check() often, but I agree with the advice in Mastering Shiny on using check() with app-packages,\n\n‘I don’t recommend that you [call devtools::check()] the first time, the second time, or even the third time you try out the package structure. Instead, I recommend that you get familiar with the basic structure and workflow before you take the next step to make a fully compliant package.’\n\nHowever, I’ve included an example of running check() on projApp in the callout box below to demonstrate how it works.\n\n\n\n\n\n\nRunning devtools::check()\n\n\n\n\n\n\ndevtools::check()\n\nThe output from check() can be rather lengthy (it’s pretty comprehensive!), and it provides feedback on each item in the form of a note (N), warning (W), or error (E).\n\n==&gt; devtools::check()\n\nDuration: 15.3s\n\nN  checking top-level files\n   Non-standard files/directories found at top level:\n     ‘app.R’ ‘movies.RData’\n\nW  checking dependencies in R code ...\n   '::' or ':::' imports not declared from:\n     ‘ggplot2’ ‘shiny’ ‘stringr’\n\nN  checking R code for possible problems (3.1s)\n   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n     variable ‘movies’\n   scatter_plot: no visible binding for global variable ‘.data’\n   Undefined global functions or variables:\n     .data movies\n\nW  checking for missing documentation entries ...\n   Undocumented code objects:\n     ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n     ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n   All user-level objects in a package should have documentation entries.\n   See chapter ‘Writing R documentation files’ in the ‘Writing R\n   Extensions’ manual.\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\n\nA summary of each item is below:\n\nchecking top-level files: This note is referring to the two non-standard (i.e, not typically found in an R package) files, app.R and movies.RData\nchecking dependencies in R code ..: This warning tells I need to namespace functions from add-on packages (in this case, ggplot2, shiny, and stringr)\nchecking R code for possible problems: The final item is a note referring to the call to load the movies data in the scatter plot display module server function (mod_scatter_display_server).\nchecking for missing documentation entries: This is warning me that the module functions aren’t properly documented and refers me to the official R documentation.\n\nEach of these items are also printed under the ── R CMD check results heading:\n\nshow/hide check() resultsDuration: 15.3s\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' imports not declared from:\n    ‘ggplot2’ ‘shiny’ ‘stringr’\n\n❯ checking for missing documentation entries ... WARNING\n  Undocumented code objects:\n    ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n    ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n  All user-level objects in a package should have documentation entries.\n  See chapter ‘Writing R documentation files’ in the ‘Writing R\n  Extensions’ manual.\n\n❯ checking top-level files ... NOTE\n  Non-standard files/directories found at top level:\n    ‘app.R’ ‘movies.RData’\n\n❯ checking R code for possible problems ... NOTE\n  mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n    variable ‘movies’\n  scatter_plot: no visible binding for global variable ‘.data’\n  Undefined global functions or variables:\n    .data movies\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\n\n\nIf you’re submitting your app-package to CRAN (or want to use check() for other reasons), follow the suggested workflow for check():\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check() or press Shift + Ctrl/Cmd + E\nFix the first problem.\nRepeat until there are no more problems.’\n\n\nI’ve found a good habit for when to check() to be:\nCheck a package after adding a bug fix or feature keeps any notes, warnings, or errors from accumulating.\n\n\n\nRecap\nCreating an app-package involves adopting some new devtools habits, and the initial contents of projApp hopefully helped demonstrate the purpose of each function.\n\n\n\n\n\n\nRecap: Package development habits\n\n\n\n\n\n\nAfter installing and loading devtools:\n\n\nLoad the package whenever changes occur in the R/ folder\n\n\nCtrl/Cmd + Shift + L load all the code in the package\n\n\n\nDocument the package whenever changes are made to any roxygen2 syntax (or settings)\n\n\nCtrl/Cmd + Shift + D record the documentation and dependencies\n\n\n\nInstall the package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing\n\n\nCtrl/Cmd + Shift + B confirm the package can be installed\n\n\n\nHabits require repetition to develop, and I hope the workflow above can be applied to your shiny app-packages, provided you’re using devtools and Posit workbench.\n\n\n\n\nThe next section will cover documenting functions with roxygen2"
  },
  {
    "objectID": "app_packages.html#chapters-1---3-review",
    "href": "app_packages.html#chapters-1---3-review",
    "title": "App-packages",
    "section": "Chapters 1 - 3 Review",
    "text": "Chapters 1 - 3 Review\nShiny apps covered shiny projects and some ‘pre-package practices’ to adopt for your shiny app that can make the transition to working with app-packages easier.\n\n\n\n\n\n\nChapter 1: GitHub branches\n\n\n\n\n\n\nThe code for chapter 1 (Shiny apps) is stored in the following branches:\n\nmain contains a new shiny app project created from the New Project Wizard (with Old Faithful Geyser Data)\n02_movies-app the boilerplate app in app.R is replaced with the code for the movie review application, the scatter_plot() utility function is added to utils.R, and movies.RData is added to the project.\n\n03_projApp contains an ‘advanced’ shiny app project with the following contents:\n\n\nDESCRIPTION file\n\n\nREADME.md file\n\n\nR/ folder\n\n\nModules: two module files are created in the R/ folder (mod_var_input.R and mod_scatter_display.R)\n\n\nStandalone app function: the code in app.R is converted to a standalone app function: movies_app()\n\n\nUtility function: move utils.R into R/ folder\n\n\n\n\nwww/ folder with image file (shiny.png)\n\n\nDeployment: the rsconnect/ folder contains files for deploying to shinyapps.io\n\n\n\n\n\n\n\n\nPackages illustrated what separates projects from R packages. This chapter also covered 1) how to create a new shiny app-package or 2) convert an existing shiny project into an app-package.\n\n\n\n\n\n\nChapter 2: GitHub branches\n\n\n\n\n\n\nThe code for chapter 2 (Projects) is stored in the following branches:\n\n03_projApp is ‘advanced’ package from the previous chapter\n04_description is a branch from 03_projApp and adds the seven mandatory DESCRIPTION fields.\n05_rproj is a branch from 04_description and manually converts the shiny app project to a shiny app-package using the .Rproj file.\n06_create-package is a branch from 03_projApp and creates a package using usethis::create_package()\n\n\n\n\n\ndevtools introduced the devtools package and it’s core functions (load_all(), document(), and install()).\n\n\n\n\n\n\nChapter 3: GitHub branches\n\n\n\n\n\n\nThe code for chapter 3 (devtools) is stored in the following branch:\n\n\n06_devtools is a branch from the manually converted app-package in 05_rproj"
  },
  {
    "objectID": "app_packages.html#app-packages",
    "href": "app_packages.html#app-packages",
    "title": "App-packages",
    "section": "App-packages",
    "text": "App-packages\nThe next three sections will continue with app-package development, but with an emphasis on the particulars that come with developing a shiny application in a package structure. We’ll be using the code stored in the pkgApp repository.\n\n\n\n\nNew Git Branch\n\nThe code for the next section is in the [main] branch of the [pkgApp] repo.\n\n\n\n\n\n\nGitHub [pkgApp]:[main]\n\n\n\n\n\n\nThe code for the next section can be found in the main branch of the pkgApp repo.\nThe main branch of pkgApp is identical to the 06_create-package branch from the projApp repository from the previous section:\npkgApp [06_create-package]\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── pkgApp.Rproj\n  └── www\n      └── shiny.png\n  \n  4 directories, 10 files\nThe rsconnect/ folder has been removed because we’ll cover deploying pkgApp in future sections.\n\n\n\n\nA summary of each chapter in this section is provided below.\nroxygen2\n\n\nroxygen2 basics:\n\nRequired tags: @title, @description, @details, @param, @return, and @examples\n\nApp-package considerations for modules and standalone app functions: @seealso, @family, and @section\n\n\n\nDependencies\n\nExporting functions from your package namespace\n\n\n@export/export()\n\n\n\nImporting functions from add-on packages into your package namespace\n\n\n@import/import(), @importFrom/importFrom()\n\n\n\nThe Imports: field in the DESCRIPTION\n\nData files\n\nDocumenting data with roxygen2: @format, \\describe, \\item\nLocation of data files: data/ vs. data-raw/ vs. inst/extdata/\n\ninst/ & www/\n\n\nsystem.file()\naddResourcePath()\nTests\n\ntestthat\ntestServer()\nshinytest2\nRunning the app\n\nWhat goes in app.R?"
  },
  {
    "objectID": "roxygen2.html#roxygen2-basics",
    "href": "roxygen2.html#roxygen2-basics",
    "title": "roxygen2",
    "section": "\nroxygen2 basics",
    "text": "roxygen2 basics\nroxygen2 connects the package code (i.e., the.R files in the R/ folder) to it’s documentation files (i.e., the.Rd files in the man/ folder):\n\n\n\n(a) roxygen2\n\nFigure 2: roxygen2 creates man/ documentation\n\nThe two pieces of roxygen2 syntax to know are comment blocks and tags:\n\n\nComment blocks are any lines beginning with #'\n\n#' \n#' \n#' \n\n\n\nTags begin with @\n\n#' \n#' @tag\n#' \n\n\n\nWhen documenting functions, roxygen2 tags and comment blocks are placed directly above any functions stored in R/.\n\n#' \n#' @tag\n#' \nmy_fun &lt;- function() {\n  \n}\n\nIn the next sections, we’ll cover roxygen2 basics using examples for the scatter_plot() function found in R/utils.R.\nmarkdown = TRUE\nroxygen2 provides support for markdown formatting in package help files by adding the Roxygen: field in the DESCRIPTION file and setting it to list(markdown = TRUE):\nPackage: pkgApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nDisplayMode: Showcase\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\n\n@title & @description\n\nThe first two sections of roxygen2 documentation are the title and description. These sections don’t require tags–roxygen2 will detect each section as long as there is at least one #' line separating them (and they’re contents don’t extend past the length indicated in parentheses below):\n\n#' function title (one line)\n#'\n#' A short description... (one paragraph)\n#' \n\nThe @title and @description for the scatter_plot() function stored in R/utils.R might look like this:\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n\n\n\n\n\n\n\nFunction @description and @details\n\n\n\n\n\nIf the contents in the @description for a function requires more complicated formatting than a single paragraph (i.e., multiple paragraphs, lists, etc.), you can use the @details tag:\n\n#' Create scatter plot  \n#' \n#' @description\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' @details\n#' `scatter_plot()` is a custom `ggplot2` function written to handle string arguments from reactive inputs (i.e., `input$x` or `input$y`). \n\n\n\n\n\n@param & @return\n\nDocument function arguments and outputs with @param and @return:\n\n\n@param: should include the name and description of each function inputs (i.e., their type and what they do)\n\n#' @param name description of its action\n\n\nRead more here\n\n\n\n\n@return: these describe the type (or class) and structure of the function output\n\n#' @return type/structure of the output\n\n\nRead more here\n\n\n\n\nBelow are examples for @param and @return in the scatter_plot() function stored in R/utils.R:\n\n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n\nTo view how the roxygen2 syntax will appear in the .Rd file, I’ll document pkgApp:\n\n\nTo reduce the amount of repetitive code, I’ll just be showing the keyboard shortcuts for each devtools function from this point forward\n\nCtrl/Cmd + Shift + D\n\nI can see the scatter_plot.Rd file is written to the man/ folder:\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nWriting scatter_plot.Rd\nDocumentation completed\nR documentation (.Rd) files have a formatting style similar to (La)TeX (but roxygen2 saves us from having to learn this syntax). If we open man/scatter_plot.Rd, we see it contains the following:\n\n\n\n\n(a) .Rd file\n\nFigure 3: R documentation file\n\n\nroxygen2 graciously generates the scatter_plot.Rd file (and it also warns us not to edit this file by hand). Note the following items were added without needing tags:\n\n\\name: the name of the function (as it appears in the index)\n\\alias: used to group “topics” and provide look-up in the package index\n\n\\arguments: function arguments (header)\n\n\n\\item: description of argument\n\n\n\nThe following two items are a result of the markdown syntax we used:\n\n\\href: used for hyperlinks\n\\code: code formatting\n\n\n\n\n\n(a) @tag links to .Rd file\n\nFigure 4: roxygen2 tag links to .Rd file\n\n\nTo view the help file, I can enter ?scatter_plot in the console:\n\n?scatter_plot\n\nAnd an informative message tells me that the development version scatter_plot.Rd is being rendered:\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n(a) .Rd file\n\nFigure 5: Help file\n\n\nPreviewing the development documentation is a great way to verify the content in each .Rd file meets expectations.\n@examples\n\n@examples are unique because they include executable code that demonstrates how a function works. In the Posit Workbench IDE @examples are especially helpful because they come with ‘single click’ hyperlink (see the Run examples from ggplot2::aes() is below):\n\n\n\n\n\n\n(a) Run examples hyperlink\n\n\n\n\n\n\n\n(b) Executed @examples code\n\n\n\nFigure 6: Run examples in help files\n\n\n\nThe syntax to create an example for scatter_plot() is below:\n\n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n\n\n\n\n\n\n\nTab-completion for @tags\n\n\n\n\n\n\nIf you’re documenting your package functions in Posit Workbench, tab-completion is your friend! The help text displayed with each tag can help you make sure you’re including the right tag (see @example vs. @examples below).\n\n\nTab completion for @example\n\n\n\nTab completion for @examples\n\nRead more here.\n\n\n\n\nTo preview the @examples in the help file, I’ll document() and open the development .Rd file:\n\nCtrl/Cmd + Shift + D\n\n\n?scatter_plot\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n(a) @examples in .Rd preview\n\nFigure 7: Preview of examples\n\n\nThe Run examples hyperlink won’t be active in the .Rd file preview, but reviewing the code in @examples gives me an opportunity to correct any errors or typos early.\nThe scatter_plot() function has a documented Title, Description, Usage, Arguments, Value, and Examples. I consider this to be the minimum documentation to include for functions I’m making available to other users.\n\n\n\n\n\n\nInserting roxygen2 skeletons\n\n\n\n\n\nYou can insert an roxygen2 skeleton into your function using Code &gt; Insert Roxygen Skeleton\n\n\n\n\n\nFigure 8: Standard roxygen2 skeleton"
  },
  {
    "objectID": "roxygen2.html#app-package-functions",
    "href": "roxygen2.html#app-package-functions",
    "title": "roxygen2",
    "section": "App-package functions",
    "text": "App-package functions\nYour app-package will likely contain at least two functions that are specific to shiny: modules and a standalone app function. roxygen2 has a few tags that can make the documentation for these functions more informative for readers.\nModules\nA few things to consider when documenting module functions in app-packages:\n\nModules have two functions: one for the UI, and a counterpart in the server\nEvery module function will include at least one @param for the shared id\nReturned objects are particularly important in shiny’s reactive context, so I recommend extending the description to include whether or not the returned output is reactive\nIf the returned output is an input (i.e. @param) for another function, link to that documentation functions with @seealso or @family\n\nBelow are some examples from the pkgApp modules.\n@seealso\nWhen documenting modules, think of the audience as someone who is looking to understand the execution path through the application. In pkgApp(), the inputs are collected with the var_input module, then passed to the scatter_display module.\n\nshow/hide mod_var_input_ui() roxygen2#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n\n\nUse @seealso to connect mod_var_input_ui() to it’s server function counterpart. The hyperlink to mod_var_input_server() from mod_var_input_ui() is created by placing the destination function in square brackets [fun()]:\n\nshow/hide mod_var_input_ui() roxygen2#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n#' @seealso [mod_var_input_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\nseealso creates a hyperlink readers can use to open the next module in the execution path.\n\n\n\n\n(a) @seealso in mod_var_input_ui()\n\nFigure 9: Link mod_var_input_ui() to mod_var_input_server()\n\n\nIn mod_var_input_server(), a link can be made to mod_scatter_display_server() (the module function collecting the returned values) using the square brackets in the @return section (without @seealso):\n\nshow/hide mod_var_input_server() roxygen2#' Variable input module (server)\n#'\n#' @param id server module id\n#' \n#' @seealso [mod_var_input_ui()]\n#'\n#' @return reactive inputs are returned in a `list()`: \n#'  * `x()`\n#'  * `y()`\n#'  * `z()`\n#'  * `alpha()`\n#'  * `size()`\n#'  * `plot_title()`\n#'  \n#' These become in the `var_inputs` argument in [mod_scatter_display_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @seealso link\n\nFigure 10: Link values from var_input to scatter_display\n\n\n@family\nModule functions can also be grouped into families using @family {\"description\"}. Below is an example of grouping the ‘scatter plot module functions’ into a family:\n\nshow/hide mod_scatter_display_ui() roxygen2#' Scatter plot display module (UI)\n#'\n#' @param id UI module id\n#' \n#'\n#' @return module UI (HTML)\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n@section\nThe @section tag will create a level two header (##/&lt;h2&gt;&lt;/h2&gt;) section, which can be helpful for organizing topics (like how to use an input or argument).\n@seealso can also be used to link back to the scatter_plot() utility function:\n\nshow/hide mod_scatter_display_server() roxygen2#' Scatter plot display module (server)\n#' \n#'\n#' @param id server module id \n#' @param var_inputs returned reactive list from [mod_var_input_server()].\n#' \n#' @section Referring to `var_inputs`: \n#' Refer to the reactive returned values from `mod_var_input_server()` as:\n#'  * `var_inputs$x()`\n#'  * `var_inputs$y()`\n#'  * `var_inputs$z()`\n#'  * `var_inputs$alpha()`\n#'  * `var_inputs$size()`\n#'  * `var_inputs$plot_title()`\n#' \n#'\n#' @return rendered plot and title output from [scatter_plot()]\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @family link\n\nFigure 11: Link from var_input module and group scatter_display module\n\n\nThe figure above shows how the @seealso links can be used to create a path for the graph parameters through the var_input and scatter_display modules. It also demonstrates how @family groups the scatter_display UI and server functions.\nThe scatter_plot() utility function should also include a @seealso tag for the module function it’s used in.\n\nshow/hide scatter_plot() roxygen2#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @seealso and @family connections\n\nFigure 12: Connecting inputs and outputs, grouping modules, and linking utility functions\n\n\nThe goal when cross-referencing functions in your app-package is for anyone reading your documentation to be able to follow the links and get a better understanding of any modules, they’re inputs, reactive values, and outputs.\nIn this case, linking back to the scatter_plot() utility functions also gives reader an interactive example to preview the output.\nStandalone app functions\nSplitting the code in app.R into separate functions has multiple benefits. First, it’s easier to develop and load a function if it’s stored in the R/ folder. Second, having a dedicated ui, server, and app function means we can develop them independently. Finally, having a standalone app function makes it possible to store multiple applications in the same app-package.\nI’ve split the UI and server from movies_app() into separate movies_ui() and movies_server() below.\nmovies_ui()\nThe movies_ui() doesn’t have any arguments–the only change is wrapping the shiny::fluidPage() in shiny::tagList():\n\nmovies_ui &lt;- function() {\n  shiny::tagList(\n    shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nI’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). I’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n\nshow/hide roxygen2 for movies_ui()#' Movies UI function\n#' \n#' UI function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_ui()\n\nFigure 13: UI function documentation\n\nmovies_server()\nmovies_server() is written to be passed to the server argument in shinyApp():\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\nThe documentation for movies_server() is very similar to movies_ui()–each module server function is documented in it’s own @section, but I’ll also include a @section for Communication that describes how values are passed between mod_var_input_server() and mod_scatter_display_server().\n\nshow/hide roxygen2 for movies_server()#' Movies server function\n#' \n#' Server function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#' \n#' ```\n#' shinyApp(movies_ui, movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in [movies_ui()]   \n#'  * server is stored in `movies_server()`\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_server()] returns following reactive values:\n#'  * `x()`\n#'  * `y()`\n#'  * `z()`\n#'  * `alpha()`\n#'  * `size()`\n#'  * `plot_title()`\n#' \n#' @seealso [mod_var_input_ui()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_server()] displays the `ggplot2` graph with the [scatter_plot()] function.\n#' \n#' @seealso [mod_scatter_display_ui()]\n#' \n#' @section Communication: \n#' The output from [mod_var_input_server()] should be supplied to the \n#' `var_inputs` argument of [mod_scatter_display_server()].\n#\n#' @return `server` argument in `shiny::shinyApp()`\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_server()\n\nFigure 14: Server function documentation\n\nmovies_app()\nThe standalone app function (movies_app()) automatically calls shinyApp(), with the movies_ui and movies_server functions supplied to ui and server (without parentheses).\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nThe documentation for the standalone app function can be minimal–as long as it provides links to the UI and server.\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_app()\n\nFigure 15: Standalone app function documentation\n\nI’ll change the contents of app.R to the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\n\n\n\n\nNew Git Branch\n\nThe code for the next section is in the [02_roxygen2] branch of the [pkgApp] repo."
  },
  {
    "objectID": "roxygen2.html#recap",
    "href": "roxygen2.html#recap",
    "title": "roxygen2",
    "section": "Recap",
    "text": "Recap\nThe goal of good documentation is to make it as easy as possible for others (and future you) to understand what your function does and how to use it. Below is a recap of the topics covered in this chapter.\n\n\n\n\n\n\nroxygen2 recap\n\n\n\n\n\n\nThis chapter covered:\n\nFunction @title and @description: The @title should be a short one-line description of the function, followed by a more detailed paragraph @description of the function. These tags should give users an idea of what the function does (you can also use @details)\nArguments (@param) and outputs (@return): List all function arguments with @param. Include the argument type (e.g., integer, character, etc.), and a brief description of what the argument does. Be sure to mention any default or optional arguments. Function outputs should be listed with @return and describe the type or class of the object, whether or not it’s reactive, and mention any related functions.\nExamples: @examples provide executable R code that captures how the function is used in your app-package. These are incredibly valuable for new users trying to understand how a function (and your app-package) works.\n\nApp-package specific considerations:\n\nConnect functions with@seealso and @family: Use @seealso to provide links to related functions (i.e., modules) so users can click through a ‘guided tour’ of your application’s code. Group similar functions using @family {description}.\nGive more info with @sections: Use @section to give in-depth explanations and more specific details about how a function works, including any information about the function @usage or it’s @params.\n@usage: This field will be automatically generated by roxygen2, but in some circumstances, it makes sense to set it to NULL and describe a function’s use explicitly.\n\n\n\n\n\nIn the next section, we’ll use roxygen2 to manage our app-package dependencies."
  },
  {
    "objectID": "dependencies.html#your-package-namespace",
    "href": "dependencies.html#your-package-namespace",
    "title": "Dependencies",
    "section": "Your package NAMESPACE\n",
    "text": "Your package NAMESPACE\n\nThe previous chapter illustrated how roxygen2 connects the code in the R/ folder to the documentation in the man/ folder, but roxygen2 tags are also used to document the dependencies in the NAMESPACE file:\n\n\n\n(a) roxygen2\n\nFigure 1: roxygen2 writes the NAMESPACE file\n\nThe NAMESPACE file serves two important purposes: 1) it lists which functions and objects from your app-package are exposed to other users, and 2) it controls which functions from external (i.e., add-on) packages your app-package imports.\nUp to this point, we’ve been using document() to generate .Rd files in man/. Now we’ll use document() to make sure the NAMESPACE is updated with the correct imports and exports."
  },
  {
    "objectID": "dependencies.html#pkgapp",
    "href": "dependencies.html#pkgapp",
    "title": "Dependencies",
    "section": "pkgApp",
    "text": "pkgApp\nCurrently pkgApp has documentation for the help files in R/. We can see this by looking in the man/ folder:\nman/\n├── mod_scatter_display_server.Rd\n├── mod_scatter_display_ui.Rd\n├── mod_var_input_server.Rd\n├── mod_var_input_ui.Rd\n├── movies_app.Rd\n├── movies_server.Rd\n├── movies_ui.Rd\n└── scatter_plot.Rd\n\n1 directory, 8 files\nWe can see the individual help files for each function in pkgApp with ?function.\nWhen in doubt\nload, document, install\nDuring development, you might lose track of which devtools function you ran last (I know I do). When this happens, I’ve found loading, documenting, and installing will re-oriented you to the current state of the app-package.\nCtrl/Cmd + Shift + L\nℹ Loading pkgApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nDocumentation completed\nCtrl/Cmd + Shift + B\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source pkgApp\n\n* installing to library ‘/path/to/local/install/pkgApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘pkgApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (pkgApp)\n\nRestarting R session...\n\n&gt; library(pkgApp)\nIt’s also satisfying to see all three functions execute without any errors!\nRunning movies_app()\n\nThe movies_app() has been moved into the R/ folder and documented, so app.R now only contains the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nBut when we attempt to run the standalone app function.\n\nmovies_app()\n\nError in movies_app() : could not find function \"movies_app\"\nWhat do you mean, “could not find function”?\nLet’s recap what we know:\n\nThe R/movies_app.R file contains the code and documentation for movies_app()\nThe man/movies_app.Rd file is being generated\napp.R loads the necessary packages before calling movies_app()\n\nmovies_app() files:\n├── R/\n│   └── movies_app.R\n├── man/\n│   └── movies_app.Rd\n└── app.R\nSo why can’t R find \"movies_app\" function in app.R?\nThe error is telling me that despite having documentation for movies_app() in R/ and generating the corresponding .Rd file in man/, the movies_app() function isn’t being exported from pkgApp.\nThis becomes more apparent when we try to explicitly namespace movies_app() from pkgApp:\n\npkgApp::movies_app()\n\nError: 'movies_app' is not an exported object from 'namespace:pkgApp'"
  },
  {
    "objectID": "dependencies.html#roxygen2-exports",
    "href": "dependencies.html#roxygen2-exports",
    "title": "Dependencies",
    "section": "\nroxygen2 exports",
    "text": "roxygen2 exports\nIn order to make a function in R/ accessible to the users of your package, this function needs to exported. This process is handled with the @export tag from roxygen2 (and devtools::document()).\nWhat do I @export?\nWhen determining which functions to export from your app-package, ask yourself the question,\n“When someone else calls library(pkgApp), what functions are available?”\nR Packages has great advice on what functions should not be exported:\n\n‘We believe that packages that have a wide audience should strive to do one thing and do it well. All functions in a package should be related to a single problem (or a set of closely related problems). Any functions not related to that purpose should not be exported.’ - What to export, R Packages, 2ed\n\nThere are multiple ways to interpret the advice above in the context of a shiny app-package:\n\nIf we assume the ‘problem’ we’re solving with pkgApp is ‘create a shiny movies app’, then it might make sense to only export the standalone app function.\nIf the ‘problem’ pkgApp solves is ‘visualize relationships in movie review data’, then we’d want to export the scatter_plot() utility function.\nIf we extend the ‘problem’ statement to the broadest possible definition assume users will want access to any functions that give them the ability to customize, extend, or integrate the contents of pkgApp with other tools, then the module functions become prime candidates for exporting.\n\nMy advice on exporting functions from your a app-package:\nAim for a balance between simplicity and utility when deciding on exported functions\n@export\nExport a function by including the @export tag in the roxygen2 comment block above the function you want to export:\n\n\n@export: The function name is not required. Read more here\n\n#' @export name (*optional)\n\n\n\nExporting from utils.R\n\nShiny apps often contain helper functions (i.e., non-shiny code) in helper.R or utils.R files. This isn’t a bad practice (in fact, it’s encouraged in Mastering Shiny). However, as we transition to an app-package, scatter_plot() no longer belongs in R/utils.R if we’re using the advice in R Packages,\n\n‘most of our packages have a utils.R file (Section 6.1) that contains small utility functions that are useful internally, but aren’t part of the core purpose of those packages. We don’t export such functions.’\n\nGoing forward, I’ve renamed R/utils.R to R/scatter_plot.R so it aligns with the naming conventions in other R packages.\n\n\n\n\n\n\nMore info on R/utils.R\n\n\n\n\n\n\nFor a deep dive on R/utils.R files in R packages, I recommend reading Dissecting R Package “Utility Belts”\n\n\n\n\nI’ll add the @export tag to R/scatter_plot.R\n\n\nI’ve included the name of the function for clarity (but it’s not required)\n\n#' @export scatter_plot\n\n\n\n\n\n\n\n\n\nLow-key @exports with @keywords internal\n\n\n\n\n\n\nIf you’d like function to be exported, but not listed in the package index, you can combine @export with @keywords internal. These should be used in combination,\n#' @export\n#' \n#' @keywords internal\nFor example, adding @export and @keywords internal to R/scatter_plot.R will make the function accessible to users:\n\n\n\n\nAnd include the help file:\n\n\n\n\nHowever, if a user were to click on the Index for pkgApp (at the bottom of the help file)\n\n\n\n\nscatter_plot is not listed:"
  },
  {
    "objectID": "dependencies.html#roxygen2-imports",
    "href": "dependencies.html#roxygen2-imports",
    "title": "Dependencies",
    "section": "\nroxygen2 imports",
    "text": "roxygen2 imports\nNow that we’ve covered which functions we want accessible to users of pkgApp, we need to address the functions pkgApp imports. If we continue using scatter_plot() as an example, we see it contains functions from two add-on packages (ggplot2 and rlang):\n\nshow/hide scatter_plot()scatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\nTwo components help to ensure both ggplot2 and rlang functions become part of pkgApp:\n\nCall add-on package functions using the package::function() syntax, and\nInclude them in the NAMESPACE by using either @importFrom or @import\n\nExplicit namespacing let’s users know which functions are from your package and which functions are from external packages.\n\n\n\n\n\n\nWhy use the package::function() syntax?\n\n\n\n\n\n\nThink of add-on packages and their functions as families you can invite to a party. @import will invite the entire family, and @importFrom will only invite specific family members (this is helpful if it’s a huge family and you don’t have unlimited food and drinks).\nWhen you’re at the party, it’s clearer to refer to the guests by their first and last name, i.e., ‘This is my friend, Beth Johnson, she’s an amazing breakdancer!’ which avoids confusing them with another guest (maybe ‘Beth Smith,’ who has two left feet).\nThis metaphor should help explain why we use the package::function() syntax when referring to functions from add-on packages: our package can quickly become a massive party with many guests, and we don’t want anyone confused about who’s capable of performing what.\n\n\n\n\nImporting external functions and packages ensures they’re loaded when users install and load your package.\n\n@importFrom or @import\n\nI’ve included both tags below, but you should use @importFrom far more than @import (with the exception being @import shiny). Read more here:\n\n\n@importFrom: import a function from an add-on package into your package NAMESPACE.\n\n#' @importFrom package function\n\n\n\n@import: import all functions from an add-on package into your NAMESPACE.\n\n#' @import package\n\n\n\nBelow is an example of @importFrom in R/scatter_plot.R:\n\n#' \n#' @importFrom ggplot2 ggplot aes geom_point\n#' @importFrom rlang .data\n#' \n\nTo record these changes in the NAMESPACE, I’ll load() and document():\n\nCtrl/Cmd + Shift + L\n\nℹ Loading pkgApp\n\nCtrl/Cmd + Shift + D\n\nNote that the contents of man/utils.Rd have now been written to man/scatter_plot.Rd:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nWriting NAMESPACE\nWriting scatter_plot.Rd\nWriting NAMESPACE\nDocumentation completed\nYou may have noticed the document() resulted in the NAMESPACE being written twice (one for imports, one for exports).\n\nCtrl/Cmd + Shift + B\n\nAfter installing pkgApp, I can use pkgApp:: in the Console and see the scatter_plot() function help file in the tab completion:\n\n\n\n(a) pkgApp::scatter_plot()\n\nFigure 2: Tab completion for scatter_plot()\n\nExporting scatter_plot() also means users can run the examples in the scatter_plot() help file,\n\n\n\n(a) scatter_plot() examples\n\nFigure 3: Running examples in ?scatter_plot"
  },
  {
    "objectID": "dependencies.html#namespace-directives",
    "href": "dependencies.html#namespace-directives",
    "title": "Dependencies",
    "section": "\nNAMESPACE directives",
    "text": "NAMESPACE directives\nAfter adding the @export and @importFrom tags in the R/scatter_plot.R file and documenting the package, roxygen2 writes the exports and imports in the NAMESPACE file.\nThe NAMESPACE file contains directives, which are derived from roxygen2 tags:\n\nThe @export scatter_plot tag results in the export(scatter_plot) directive\nThe @importFrom package function tag creates the importFrom(package, function) directives\n\n\n\n\n(a) updated NAMESPACE file\n\nFigure 4: Updated NAMESPACE directives\n\nThe NAMESPACE file ensures that the package environment is isolated and controls which functions from add-on packages can be used by your package. It also helps avoid naming conflicts between different packages."
  },
  {
    "objectID": "dependencies.html#description-imports",
    "href": "dependencies.html#description-imports",
    "title": "Dependencies",
    "section": "\nDESCRIPTION Imports:\n",
    "text": "DESCRIPTION Imports:\n\nSo far we haven’t run devtools::check() on pkgApp, which is fine in this stage of development. However, check() is helpful here in identifying a common point of confusion when managing dependencies, so I’ve included a specific ERROR you’d find from running check() on pkgApp:\n── R CMD check results ────────────────── pkgApp 0.0.0.9000 ────\nDuration: 7.7s\n\n❯ checking package dependencies ... ERROR\n  Namespace dependencies missing from DESCRIPTION Imports/Depends entries:\n    'ggplot2', 'rlang'\n  \n  See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’\n  manual.\nThis particular error brings us (intentionally) to an important point about dependency management in R packages:\n\nThe NAMESPACE file manages function-level access, importing functions from other packages to be used in your package, and exporting functions from your package for others to use\nThe DESCRIPTION file handles package-level dependencies, specifying which packages that your package uses\n\n\n\n\n(a) roxygen2, NAMESPACE, & DESCRIPTION\n\nFigure 5: roxygen2 does not connect the imports to the DESCRIPTION\n\nThe differences between the NAMESPACE and DESCRIPTION can be a common point of confusion when managing dependencies, so try to remember that whenever you update the NAMESPACE directives with @import or @importFrom, it’s important to sync this with the Imports: field in the DESCRIPTION file:\nPackage: pkgApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nDisplayMode: Showcase\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nImports:\n  ggplot2,\n  rlang\nYou can also add packages to the DESCRIPTION file with usethis::use_package()."
  },
  {
    "objectID": "dependencies.html#namespace-in-pkgapp",
    "href": "dependencies.html#namespace-in-pkgapp",
    "title": "Dependencies",
    "section": "\nNAMESPACE in pkgApp\n",
    "text": "NAMESPACE in pkgApp\n\nI’ve added @export to each function in pkgApp and used explicit namespacing (::) with @importFrom to import the functions from the add-on packages.\n\n\nR/movies_app.R\n\n\nmovies_app() is the standalone app function, so we’ll export this function and @import shiny here\n\n\nshow/hide R/movies_app.R roxygen2#'\n#' @export\n#' \n#' @import shiny\n#'\n\n\n\n\nR/movies_ui.R & R/movies_server.R\n\n\nmovies_ui() and movies_server() both use only shiny functions, so they don’t need an @import or @importFrom tags (but both are exported):\n\n\nshow/hide R/movies_ui.R & R/movies_server.R roxygen2#'\n#' @export\n#' \n\n\n\n\nR/mod_var_input.R\n\n\nmod_var_input_ui() and mod_var_input_server() only use shiny functions, so no need for @import or @importFrom tags (however, we’ll export both module functions).\n\n\nshow/hide R/mod_var_input.R roxygen2#'\n#' @export\n#' \n\n\n\n\nR/mod_scatter_display.R\n\n\nmod_scatter_display_ui() also only contains shiny functions (no @import or @importFrom) so this function only gets an @export tag\n\n\nshow/hide R/mod_scatter_display.R roxygen2#' \n#' @export\n#' \n\n\n\n\nmod_scatter_display_server() uses functions from tools, ggplot2 and stringr (all are imported with @importFrom tags). This function is also exported:\n\n\nshow/hide R/mod_scatter_display.R roxygen2#' \n#' @export\n#' \n#' @importFrom tools toTitleCase\n#' @importFrom stringr str_replace_all\n#' @importFrom ggplot2 labs theme_minimal theme\n#' \n\n\n\n\nThe updated DESCRIPTION file is below:\nPackage: pkgApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nDisplayMode: Showcase\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nImports:\n  shiny,\n  ggplot2,\n  rlang,\n  stringr,\n  tools\n&lt;remember to keep an empty final line&gt;\nCtrl/Cmd + Shift + L / D / B\nAfter pkgApp installs, I’ll check the namespace by using pkgApp:: in the Console:\n\n\n\n(a) pkgApp:: namespace\n\nFigure 6: Exported functions from pkgApp"
  },
  {
    "objectID": "dependencies.html#app.r",
    "href": "dependencies.html#app.r",
    "title": "Dependencies",
    "section": "app.R",
    "text": "app.R\nAs a final step, we want to remove any calls to library() in pkgApp (these packages are now handled in the NAMESPACE and DESCRIPTION files).\napp.R should now contain a single call to library(pkgApp) and then the movies_app() function:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# load pacakge ----------------------------------\nlibrary(pkgApp)\n\n# movies_app ------------------------------------\nmovies_app()\n\nrunApp()\nAfter loading, documenting, and installing pkgApp, the Run App icon is no longer available in the app.R file.\n\n\n\n(a) Run App in app.R\n\nFigure 7: The Run App icon has been removed from app.R\n\nIf we call shiny::runApp() in the Console, we see the icon image (www/shiny.png) in our application UI.\n\n\n\n(a) Run App in pkgApp\n\nFigure 8: IDE from clicking Run App in pkgApp\n\nWarning in loadSupport\nrunApp() also produces the following warning:\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to \n  contain an R package. Sourcing files in R/ may cause unexpected behavior.\nshinyApp()\nHowever, if we run movies_app() in app.R–which calls shinyApp()–the image is missing from the UI:\n\n\n\n(a) movies_app() in pkgApp\n\nFigure 9: IDE from running movies_app() in pkgApp\n\nThe differences we’re seeing are due to the subtle but important differences between runApp() and shinyApp() (which we will cover in the next chapter!).\n\n\n\n\nNew Git Branch\n\nThe code for this section is in the [03_dependencies] branch of the [pkgApp] repo."
  },
  {
    "objectID": "dependencies.html#recap",
    "href": "dependencies.html#recap",
    "title": "Dependencies",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nDependencies recap\n\n\n\n\n\n\nThis chapter covered:\n\n\nNAMESPACE: lists the exported functions and the functions your package imports from add-on packages.\n\nNAMESPACE exports: Aim for a balance between simplicity and utility when deciding which functions to export ((i.e., what functions should be available to users who install your package)\nNAMESPACE imports: The @import/@importFrom tags make the functions from add-on packages available to your package. Use @importFrom for most add-on package functions (the only exception being shiny, which you’d want to use @import)\n\n\nDESCRIPTION Imports:: use this field to list the packages that your app-package uses. Functions from these packages will be available for your package, but not for the user unless they use the :: operator or load the package themselves with library().\n\nThe Imports: field in the DESCRIPTION handles package-level dependencies (and it is managed manually or with usethis::use_package()), while the NAMESPACE handles function-level access (with @export and @import and @importFrom).\n\n\n\n\nIn the next section, we’ll cover how the ensure the movies.RData becomes part of pkgApp"
  },
  {
    "objectID": "data.html#app-package-data",
    "href": "data.html#app-package-data",
    "title": "Data files",
    "section": "App-package data",
    "text": "App-package data\nThere are three folders used to store data in R packages: data/, data-raw/, and inst/extdata/. The folder you’ll use will depend on the format, accessibility, and intended purpose of the data file in your app-package."
  },
  {
    "objectID": "data.html#the-data-folder",
    "href": "data.html#the-data-folder",
    "title": "Data files",
    "section": "The data/ folder",
    "text": "The data/ folder\nYou can read more about the data folder in the ‘Data in packages’ section of Writing R Extenstions and the ‘Data’ chapter of R Packages, 2ed.\nThe primary location for app-package data is the data/ folder. Data objects in the data/ folder are available in the package namespace when it’s installed and loaded, and can be accessed with the package::data syntax. See the example below:\n\nlibrary(dplyr)\nstr(dplyr::storms)\n\ntibble [19,066 × 13] (S3: tbl_df/tbl/data.frame)\n $ name                        : chr [1:19066] \"Amy\" \"Amy\" \"Amy\" \"Amy\" ...\n $ year                        : num [1:19066] 1975 1975 1975 1975 1975 ...\n $ month                       : num [1:19066] 6 6 6 6 6 6 6 6 6 6 ...\n $ day                         : int [1:19066] 27 27 27 27 28 28 28 28 29 29 ...\n $ hour                        : num [1:19066] 0 6 12 18 0 6 12 18 0 6 ...\n $ lat                         : num [1:19066] 27.5 28.5 29.5 30.5 31.5 32.4 33.3 34 34.4 34 ...\n $ long                        : num [1:19066] -79 -79 -79 -79 -78.8 -78.7 -78 -77 -75.8 -74.8 ...\n $ status                      : Factor w/ 9 levels \"disturbance\",..: 7 7 7 7 7 7 7 7 8 8 ...\n $ category                    : num [1:19066] NA NA NA NA NA NA NA NA NA NA ...\n $ wind                        : int [1:19066] 25 25 25 25 25 25 25 30 35 40 ...\n $ pressure                    : int [1:19066] 1013 1013 1013 1013 1012 1012 1011 1006 1004 1002 ...\n $ tropicalstorm_force_diameter: int [1:19066] NA NA NA NA NA NA NA NA NA NA ...\n $ hurricane_force_diameter    : int [1:19066] NA NA NA NA NA NA NA NA NA NA ...\n\n\nLazyData: true\nFiles in data/ should be in the .rda or .RData format. Data files become part of a package when they’re added to the data/ folder and LazyData: true is added to the DESCRIPTION file.\n\nLazyData: true: the data is only loaded into memory if it is explicitly accessed by the user or a function in the package. Until then, only the dataset names is loaded. This practice user-friendly and is the default for most R packages.\nLazyData: false (or omitted): accessing a data file from the package requires explicitly loading it using the data() function.\n\nBelow are the steps for adding movies to pkgApp:\n\n\nMove the movies.RData file into a newly created the data/ folder:\npkgApp/\n  │\n  └──data/\n      └── movies.RData\n\n\nInclude LazyData: true in the DESCRIPTION file (I’ve added it above Imports:):\nPackage: pkgApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nLazyData: true\nImports:\n  shiny,\n  ggplot2,\n  rlang,\n  stringr,\n  tools\n\nLoad, document, and install.\n\nCtrl/Cmd + Shift + L\nℹ Loading pkgApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nDocumentation completed\nCtrl/Cmd + Shift + B\nIn the Build pane, you’ll notice a few new ** data lines of output after adding data:\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\nWe can check to see if movies has been included in pkgApp using the package::data syntax:\n\n\n\n(a) roxygen2\n\nFigure 1: movies is now part of pkgApp\n\nusethis::use_data()\nIf you’d prefer to store data using the .rda format, the usethis package has the use_data() function that will automatically store an object in data/ in the .rda format.\nTo use usethis::use_data(), we can load the movies data into the global environment with load(\"movies.RData\"), then run usethis::use_data(movies):\n\nusethis::use_data(movies)\n\n✔ Setting active project to '/path/to/pkgApp'\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Saving 'movies' to 'data/movies.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nThe Depends: field is added to the DESCRIPTION file with an R version (this ensures the data files will be loaded)\nDepends: \n    R (&gt;= 2.10)\n(this function will also add LazyData: true to the DESCRIPTION)\n\n\n\n\n\n\nMastering Shiny data example\n\n\n\n\n\n\nIf you happened to download, install and load the monthApp example from Mastering Shiny, you may have noticed the NAMESPACE was empty, but the data was exported from the package:\n\n\nmonthApp exports\n\nData files in data/ don’t require roxygen2 tags to be included in a package namespace.\n\n\n\n\nDocumenting data/\n\nDocumenting data can be tedious, but it’s worth the effort if you’ll be sharing your application with collaborators. There are multiple ways to store the documentation for datasets. For example, we could create a data.R file in the R/ folder.\n\nfs::file_create(\"R/data.R\")\n\nIn data.R, we provide a @title, @description, and @details for the data (with or without the tags), followed by @format:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)   \n#'\n#' @format\n\n@format\nThe text following @format is a one-sentence description of the data (with it’s dimensions).\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#' \n#' @format A data frame with [] rows and [] variables:\n\n\\describe & \\item\nEach variable (column) in the data is documented with a combination of \\describe and \\item (pay close attention to the curly brackets):\n\n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n\nAfter closing the curly brackets in \\describe, place the name of the data in quotes (\"movies\") on the following line.\nBelow is the documentation for the first five columns in the movies dataset:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#' }\n#'\n\"movies\"\n\nIf we load and document pkgApp, we can see a preview of the help file:\nCtrl/Cmd + Shift + L\nℹ Loading pkgApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nWriting movies.Rd\nDocumentation completed\n\n?movies\n\n\n\n\n(a) The movies help file\n\nFigure 2: Documentation for the movies dataset\n\nI’ve provided documentation for the full movies dataset below.\n\nshow/hide full movies data documenation#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#'  \\item{studio}{name of studio, chr}\n#'  \\item{thtr_rel_date}{Theatre release date, POSIXct, min = 1970-05-19 21:00:00, max = 2014-12-24 21:00:00}\n#'  \\item{thtr_rel_year}{Theatre release year, num, min = 1970, max = 2014}\n#'  \\item{thtr_rel_month}{Theatre release month, num, min = 1, max =12}\n#'  \\item{thtr_rel_day}{Theatre release day, num, min = 1, max =31}\n#'  \\item{dvd_rel_date}{DVD release date, POSIXct, min = 1991-03-27 21:00:00, max = 2015-03-02 21:00:00}\n#'  \\item{dvd_rel_year}{DVD release year, num, min = 1991, max = 2015}\n#'  \\item{dvd_rel_month}{DVD release month, num, min = 1, max = 12}\n#'  \\item{dvd_rel_day}{DVD release day, num, min = 1, max = 31}\n#'  \\item{imdb_rating}{Internet movie database rating, avg = 6.49, sd = 1.08}\n#'  \\item{imdb_num_votes}{Internet movie database votes, avg = 57533, sd = 112124}\n#'  \\item{critics_rating}{Rotten tomatoes rating, fct (Certified Fresh, Fresh, Rotten)}\n#'  \\item{critics_score}{Rotten tomatoes score, avg = 57.7, sd = 28.4}\n#'  \\item{audience_rating}{Audience rating, fct (Spilled, Upright)}\n#'  \\item{audience_score}{Audience score, avg = 62.4, sd = 20.2}\n#'  \\item{best_pic_nom}{Best picture nomination, fct (no, yes)}\n#'  \\item{best_pic_win}{Best picture win, fct (no, yes)}\n#'  \\item{best_actor_win}{Best actor win, fct (no, yes)}\n#'  \\item{best_actress_win}{Best actress win, fct (no, yes)}\n#'  \\item{best_dir_win}{Best director win, fct (no, yes)}\n#'  \\item{top200_box}{Top 20 box-office, fct (no, yes)}\n#'  \\item{director}{Name of director, chr}\n#'  \\item{actor1}{Name of leading actor, chr}\n#'  \\item{actor2}{Name of supporting actor, chr}\n#'  \\item{actor3}{Name of #3 actor, chr}\n#'  \\item{actor4}{Name of #4 actor, chr}\n#'  \\item{actor5}{Name of #5 actor, chr}\n#'  \\item{imdb_url}{IMDB URL}\n#'  \\item{rt_url}{Rotten tomatoes URL}\n#' }\n#'\n\"movies\"\n\n\nRemove load()\n\nAfter documenting the movies data in data.R, we’ll remove the call to load() in the mod_scatter_display_server() function and replace it with a direct call to the dataset:\n\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n\n    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs$plot_title())\n      list(\n        x = var_inputs$x(),\n        y = var_inputs$y(),\n        z = var_inputs$z(),\n        alpha = var_inputs$alpha(),\n        size = var_inputs$size(),\n        plot_title = plot_title\n      )\n    })\n    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        # data -----------------------------------------------------\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n          y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\nAfter loading, documenting, and installing the package, we see the following application:\n\n\n\n\n(a) movies_app() with movies data file\n\nFigure 3: pkgApp::movies in movies_app()\n\n\n\ndplyr example\nTo illustrate other options for data documentation, we’ll use the dplyr package. dplyr stores its data in the data/ folder:\ndata/\n├── band_instruments.rda\n├── band_instruments2.rda\n├── band_members.rda\n├── starwars.rda\n└── storms.rda\nThe documentation for the datasets in dplyr are stored in R/ using a data- prefix:\nR/\n├── data-bands.R\n├── data-starwars.R\n└── data-storms.R\nThe three band_ datasets have documented in a single file, data-bands.R:\n\nshow/hide documentation for dplyr::band_ datasets# from the dplyr github repo: \n# https://github.com/tidyverse/dplyr/blob/main/R/data-bands.R\n# \n#' Band membership\n#'\n#' These data sets describe band members of the Beatles and Rolling Stones. They\n#' are toy data sets that can be displayed in their entirety on a slide (e.g. to\n#' demonstrate a join).\n#'\n#' `band_instruments` and `band_instruments2` contain the same data but use\n#' different column names for the first column of the data set.\n#' `band_instruments` uses `name`, which matches the name of the key column of\n#' `band_members`; `band_instruments2` uses `artist`, which does not.\n#'\n#' @format Each is a tibble with two variables and three observations\n#' @examples\n#' band_members\n#' band_instruments\n#' band_instruments2\n\"band_members\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments2\"\n\n\nIn the example above, note that two of the datasets (band_instruments and band_instruments2) have the @format set to NULL, and define the help search name with @rdname. The @examples tag can be used to view the dataset when users click ‘Run Examples’\nEither method will–what’s important is that each dataset in your package has documentation.\n\n\n\n\n\n\nDocumenting data in data/\n\n\n\n\n\nDocumenting data requires the following roxygen2 structure:\n#' \n#' @title single-sentence describing [data]\n#' \n#' @description\n#' Single-paragraph describing [data]\n#' \n#' @format [data] number of rows and columns:\n#' \\describe{\n#'  \\item{variable}{description}\n#'  \\item{variable}{description}\n#' }\n#'\n\"[data]\"\nReplace [data] with the name of your dataset.\n\n\n\nThe data-raw/ folder\nThe data-raw folder is not an official directory in the standard R package structure, but it’s a common location for any data processing or cleaning scripts, and the raw data file for datasets stored in data/.\n\n\n\n\n\n\nScripts for creating movies data\n\n\n\n\n\n\nThe code used to produce the movies dataset in the data/ directory might* come from this GitHub repo. If so, the data-raw folder is where the data processing and preparation scritps would be stored (along with a copy of the data in .csv format) before saving a copy in the data/ folder.\n*I say ‘might’ because it’s not clear if the movies.RData is the output from these .R files (although many of the column names match).\n\n\n\n\n\ndplyr example\nIf we look at the data in the dplyr package again, we can see the data-raw/ folder contains a combination of .R and .csv files:\ndata-raw/\n├── band_members.R\n├── starwars.R\n├── starwars.csv\n└── storms.R\n\n1 directory, 4 files\nIn this example, the starwars.R script downloads & prepares starwars, then saves a .csv copy of the data in data-raw.\nRead more about the data-raw folder in R Packages, 2ed"
  },
  {
    "objectID": "data.html#the-instextdata-folder",
    "href": "data.html#the-instextdata-folder",
    "title": "Data files",
    "section": "The inst/extdata/ folder",
    "text": "The inst/extdata/ folder\nThe extdata folder (inside inst/) can be used for external datasets in other file formats (.csv, .tsv, .txt, .xlsx, etc).\nThe data files in inst/extdata/ aren’t directly loadable using the package::data syntax or the data() function like with the data/ directory. These files can be imported using the file path accessor function, system.file().\nFor example, if we create the inst/extdata/ and save a copy of movies as a .fst file:\n\nlibrary(fs)\nlibrary(tibble)\nlibrary(fst)\n\n\nfst package v0.9.8\n\n\nfs::dir_create(\"inst/extdata/\")\nfst::write_fst(\n  x = movies, \n  path = \"inst/extdata/movies.fst\", \n  compress = 75)\n\n\nfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\n\nThen load, document, and install pkgApp:\nCtrl/Cmd + Shift + L / D / B\nWe can import movies.fst using system.file() to create a path to the file:\n\ntibble::as_tibble(\n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"pkgApp\")\n    )\n  )\n\n# A tibble: 651 × 34\n   title  title_type genre runtime mpaa_rating studio thtr_rel_date      \n   &lt;chr&gt;  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;  &lt;dttm&gt;             \n 1 Filly… Feature F… Drama      80 R           Indom… 2013-04-18 21:00:00\n 2 The D… Feature F… Drama     101 PG-13       Warne… 2001-03-13 21:00:00\n 3 Waiti… Feature F… Come…      84 R           Sony … 1996-08-20 21:00:00\n 4 The A… Feature F… Drama     139 PG          Colum… 1993-09-30 21:00:00\n 5 Malev… Feature F… Horr…      90 R           Ancho… 2004-09-09 21:00:00\n 6 Old P… Documenta… Docu…      78 Unrated     Shcal… 2009-01-14 21:00:00\n 7 Lady … Feature F… Drama     142 PG-13       Param… 1985-12-31 21:00:00\n 8 Mad D… Feature F… Drama      93 R           MGM/U… 1996-11-07 21:00:00\n 9 Beaut… Documenta… Docu…      88 Unrated     Indep… 2012-09-06 21:00:00\n10 The S… Feature F… Drama     119 Unrated     IFC F… 2012-03-01 21:00:00\n# ℹ 641 more rows\n# ℹ 27 more variables: thtr_rel_year &lt;dbl&gt;, thtr_rel_month &lt;dbl&gt;,\n#   thtr_rel_day &lt;dbl&gt;, dvd_rel_date &lt;dttm&gt;, dvd_rel_year &lt;dbl&gt;,\n#   dvd_rel_month &lt;dbl&gt;, dvd_rel_day &lt;dbl&gt;, imdb_rating &lt;dbl&gt;,\n#   imdb_num_votes &lt;int&gt;, critics_rating &lt;fct&gt;, critics_score &lt;dbl&gt;,\n#   audience_rating &lt;fct&gt;, audience_score &lt;dbl&gt;, best_pic_nom &lt;fct&gt;,\n#   best_pic_win &lt;fct&gt;, best_actor_win &lt;fct&gt;, best_actress_win &lt;fct&gt;, …\n# ℹ Use `print(n = ...)` to see more rows\nWe’ll cover inst/ and system.file() in more detail in the next chapter.\n\n\n\n\nNew Git Branch\n\nThe code for this section is in the [04_data] branch of the [pkgApp] repo."
  },
  {
    "objectID": "data.html#recap",
    "href": "data.html#recap",
    "title": "Data files",
    "section": "Recap",
    "text": "Recap\nIt’s common for shiny apps to require data, so knowing how to store and access these files in your app-package will make it easier to load and reproducible in other environments. Here are a few other things to consider when including data in your app-package:\n\n\n\n\n\n\nRecap: Package data files\n\n\n\n\n\n\n\ndata/: All data files stored in data/ will be ‘lazy loaded’ (see below) when the package is installed and loaded.\nLoading: include the LazyData: true field in the DESCRIPTION file so the data is only loaded when it’s used (and it increases package loading speed).\nSize: large data files can inflate the size of your app-package, making it harder for users to download and install. CRAN also has a size limit for packages (if you plan on submitting your app-package).\nFormat: data files in data/ must be either .rda or .RData format.\n\nDocumentation: document the data/ files in either a single R/data.R file or individual .R files. Documentation should include the following roxygen2 format:\n#' \n#' @title \n#' \n#' @description\n#' \n#' @format \n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n#'\n'data'\n\ninst/extdata/: Store external data in the inst/extdata/ directory and access it using system.file(). This can be helpful if your app-package needs access to data files that are not R objects. For faster loading, consider the fst or feather formats."
  },
  {
    "objectID": "inst_www.html#pkgapp",
    "href": "inst_www.html#pkgapp",
    "title": "\ninst/ & www/\n",
    "section": "pkgApp",
    "text": "pkgApp\nThe current structure of pkgApp is below:\npkgApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   ├── data.R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   ├── movies_app.R\n  │   ├── movies_server.R\n  │   ├── movies_ui.R\n  │   └── scatter_plot.R\n  ├── README.md\n  ├── app.R\n  ├── data/\n  │   └── movies.RData\n  ├── inst/\n  │   └── extdata\n  │       └── movies.fst\n  ├── man/\n  │   ├── mod_scatter_display_server.Rd\n  │   ├── mod_scatter_display_ui.Rd\n  │   ├── mod_var_input_server.Rd\n  │   ├── mod_var_input_ui.Rd\n  │   ├── movies.Rd\n  │   ├── movies_app.Rd\n  │   ├── movies_server.Rd\n  │   ├── movies_ui.Rd\n  │   └── scatter_plot.Rd\n  ├── pkgApp.Rproj\n  └── www/\n      └── shiny.png\n\n7 directories, 24 files\nWhen we run movies_app(), we see the following:\n\n\n\n\n(a) movies_app() without logo\n\nFigure 1: www not accessible in pkgApp\n\n\nThe shiny.png logo in www/ is not being loaded into the UI when the application is launched. Before we dive into adding the contents of www/ into our app-package, we’ll take a step back and investigate what happens when pkgApp is installed."
  },
  {
    "objectID": "inst_www.html#whats-in-the-installed-package",
    "href": "inst_www.html#whats-in-the-installed-package",
    "title": "\ninst/ & www/\n",
    "section": "What’s in the ‘installed’ package?",
    "text": "What’s in the ‘installed’ package?\nWe’ve been running load_all(), document(), and install() on pkgApp, but we haven’t looked at the contents of the installed package. Reviewing the installed package will help us understand what the system.file() function is doing, and how we can use the inst/ folder to include external resources to our app-package.\nWhen we run devtools::install(), the output tells us where the package is being installed:\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source pkgApp\n\n* installing to library ‘/path/to/install/Library/R/x86_64/4.2/library’\nIf we add the pkgApp/ directory to the end of the path above, we can view the contents of the installed package (I’m using the tree command in the Terminal, but the fs::dir_tree() function will also print a folder tree):\n/path/to/install/Library/R/x86_64/4.2/library/pkgApp/\n├── DESCRIPTION\n├── INDEX\n├── Meta/\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R/\n│   ├── pkgApp\n│   ├── pkgApp.rdb\n│   └── pkgApp.rdx\n├── data/\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── extdata/\n│   └── movies.fst\n├── help/\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── paths.rds\n│   ├── pkgApp.rdb\n│   └── pkgApp.rdx\n└── html/\n    ├── 00Index.html\n    └── R.css\n\n7 directories, 24 files\nThe installed version of pkgApp has many of the same files as the ‘source’ version we’ve been writing (i.e., the NAMESPACE and DESCRIPTION). It also might surprise you to see that many of the source package files aren’t included in the installed version (.R, .Rd files. etc.). The key takeaway here is that the inst/ subfolders and files are available in the installed version unchanged (with the inst/ folder omitted.).\nHopefully viewing this folder structure helps demystify what happens when a package is installed. Below is the official documentation on what happens to the inst/ folder (and it’s subfolders) when a package is installed:\n\n“The contents of the inst/ subdirectory will be copied recursively to the installation directory. Subdirectories of inst/ should not interfere with those used by R (currently, R/, data/, demo/, exec/, libs/, man/, help/, html/ and Meta/, and earlier versions used latex/, R-ex/).” - Writing R extensions, Package subdirectories\n\n\n\n\n\n\n\nOther installed package structures\n\n\n\n\n\n\nYou can explore the structure of other installed packages to see how they work ‘under the hood’ to gain insight into how they use the inst/ folder.\n\n\nFor example, the inst/extdata/ folder in the readr package holds a variety of datasets:\n/path/to/install/Library/R/x86_64/4.2/library/readr/\n\nextdata/\n  ├── challenge.csv\n  ├── chickens.csv\n  ├── epa78.txt\n  ├── example.log\n  ├── fwf-sample.txt\n  ├── massey-rating.txt\n  ├── mini-gapminder-africa.csv\n  ├── mini-gapminder-americas.csv\n  ├── mini-gapminder-asia.csv\n  ├── mini-gapminder-europe.csv\n  ├── mini-gapminder-oceania.csv\n  ├── mtcars.csv\n  ├── mtcars.csv.bz2\n  ├── mtcars.csv.zip\n  └── whitespace-sample.txt\n\n1 directory, 15 files\n\n\nThese files are used in readr::readr_example() (in R/example.R):\n#' Get path to readr example\n#'\n#' readr comes bundled with a number of sample files in its `inst/extdata`\n#' directory. This function make them easy to access\n#'\n#' @param file Name of file. If `NULL`, the example files will be listed.\n#' @export\n#' @examples\n#' readr_example()\n#' readr_example('challenge.csv')\nreadr_example &lt;- function(file = NULL) {\n  if (is.null(file)) {\n    dir(system.file('extdata', package = 'readr'))\n  } else {\n    system.file('extdata', file, package = 'readr', mustWork = TRUE)\n  }\n}\n\n\n\n\n\n\nHow system.file() works\nsystem.file() gives us access to the package files on installation (i.e., the files we see at the path above). In the previous chapter, we used system.file() to access the movies.fst file in inst/extdata/:\n\ndplyr::glimpse(  \n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"pkgApp\")\n    )\n  )\n\n\nshow/hide glimpse() of movies.fstfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\nRows: 651\nColumns: 34\n$ title            &lt;chr&gt; \"Filly Brown\", \"The Dish\", \"Waiting for…\n$ title_type       &lt;fct&gt; Feature Film, Feature Film, Feature Fil…\n$ genre            &lt;fct&gt; Drama, Drama, Comedy, Drama, Horror, Do…\n$ runtime          &lt;dbl&gt; 80, 101, 84, 139, 90, 78, 142, 93, 88, …\n$ mpaa_rating      &lt;fct&gt; R, PG-13, R, PG, R, Unrated, PG-13, R, …\n$ studio           &lt;fct&gt; Indomina Media Inc., Warner Bros. Pictu…\n$ thtr_rel_date    &lt;dttm&gt; 2013-04-18 21:00:00, 2001-03-13 21:00:…\n$ thtr_rel_year    &lt;dbl&gt; 2013, 2001, 1996, 1993, 2004, 2009, 198…\n$ thtr_rel_month   &lt;dbl&gt; 4, 3, 8, 10, 9, 1, 1, 11, 9, 3, 6, 12, …\n$ thtr_rel_day     &lt;dbl&gt; 19, 14, 21, 1, 10, 15, 1, 8, 7, 2, 19, …\n$ dvd_rel_date     &lt;dttm&gt; 2013-07-29 21:00:00, 2001-08-27 21:00:…\n$ dvd_rel_year     &lt;dbl&gt; 2013, 2001, 2001, 2001, 2005, 2010, 200…\n$ dvd_rel_month    &lt;dbl&gt; 7, 8, 8, 11, 4, 4, 2, 3, 1, 8, 5, 9, 7,…\n$ dvd_rel_day      &lt;dbl&gt; 30, 28, 21, 6, 19, 20, 18, 2, 21, 14, 1…\n$ imdb_rating      &lt;dbl&gt; 5.5, 7.3, 7.6, 7.2, 5.1, 7.8, 7.2, 5.5,…\n$ imdb_num_votes   &lt;int&gt; 899, 12285, 22381, 35096, 2386, 333, 50…\n$ critics_rating   &lt;fct&gt; Rotten, Certified Fresh, Certified Fres…\n$ critics_score    &lt;dbl&gt; 45, 96, 91, 80, 33, 91, 57, 17, 90, 83,…\n$ audience_rating  &lt;fct&gt; Upright, Upright, Upright, Upright, Spi…\n$ audience_score   &lt;dbl&gt; 73, 81, 91, 76, 27, 86, 76, 47, 89, 66,…\n$ best_pic_nom     &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ best_pic_win     &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ best_actor_win   &lt;fct&gt; no, no, no, yes, no, no, no, yes, no, n…\n$ best_actress_win &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ best_dir_win     &lt;fct&gt; no, no, no, yes, no, no, no, no, no, no…\n$ top200_box       &lt;fct&gt; no, no, no, no, no, no, no, no, no, no,…\n$ director         &lt;chr&gt; \"Michael D. Olmos\", \"Rob Sitch\", \"Chris…\n$ actor1           &lt;chr&gt; \"Gina Rodriguez\", \"Sam Neill\", \"Christo…\n$ actor2           &lt;chr&gt; \"Jenni Rivera\", \"Kevin Harrington\", \"Ca…\n$ actor3           &lt;chr&gt; \"Lou Diamond Phillips\", \"Patrick Warbur…\n$ actor4           &lt;chr&gt; \"Emilio Rivera\", \"Tom Long\", \"Eugene Le…\n$ actor5           &lt;chr&gt; \"Joseph Julian Soria\", \"Genevieve Mooy\"…\n$ imdb_url         &lt;chr&gt; \"http://www.imdb.com/title/tt1869425/\",…\n$ rt_url           &lt;chr&gt; \"//www.rottentomatoes.com/m/filly_brown…\n\n\nTo include the contents of www/ in our app-package, we need to use isnt/ folder, system.file(), and the shiny::addResourcePath() function."
  },
  {
    "objectID": "inst_www.html#addresourcepath",
    "href": "inst_www.html#addresourcepath",
    "title": "\ninst/ & www/\n",
    "section": "addResourcePath()",
    "text": "addResourcePath()\nshiny’s addResourcePath() function will add a “directory of static resources to Shiny’s web server.” In pkgApp, want to add the www directory that includes the shiny.png file (currently in our root (\".\") folder).\nIf we want to continue using the www/ folder name, we can simply move www and it’s contents into inst/:\ninst/\n├── extdata\n│   └── movies.fst\n└── www/\n    └── shiny.png\n\n3 directories, 2 files\nIn R/movies_ui.R function, we’ll include the addResourcePath() at the top of the tagList() and reference the image in img() using only the subfolder in the path:\n\nmovies_ui &lt;- function() {\n  shiny::addResourcePath('www', system.file('www', package = 'pkgApp'))\n  shiny::tagList(\n    shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nAfter loading, documenting, and installing, the application now includes the image file.\nCtrl/Cmd + Shift + L / D / B\n\nlibrary(pkgApp)\nmovies_app()\n\n\n\n\n\n(a) movies_app() with logo\n\nFigure 2: inst/www accessible with addResourcePath()\n\n\nYou can read more about adding external resources in the documentation for addResourcePath(). We’ll also cover adding CSS and JavaScript files in later chapters.\n\n\n\n\nNew Git Branch\n\nThe code for this section is in the [05_inst] branch of the [pkgApp] repo."
  },
  {
    "objectID": "inst_www.html#recap",
    "href": "inst_www.html#recap",
    "title": "\ninst/ & www/\n",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: inst & www folders\n\n\n\n\n\n\n\ninst/: the inst/ folder is installed with your app-package and will be accessible to users, so it’s a great location for files you want to contained in your app, but don’t fit into the standard R package structure.\nsystem.file(): constructs a path to files or folders within installed packages. The system.file() function is especially useful when working with external datasets (i.e., inst/extdata/) or other external resources included with your app-package (i.e., inst/www/).\nwww: used for external static resources in shiny apps. shiny will automatically serve files under the www/ directory, but in app-packages we need to explicitly set this location with shiny::addResourcePath()\n\naddResourcePath(): create a prefix (path) for a directoryPath of static files to accessible in shiny’s web server:\n# file location\ninst/\n  └── www/\n        └── shiny.png\n# add path\naddResourcePath('www', system.file('www', package='pkgApp'))\n# use path\nshiny::img(src = 'www/shiny.png')\n\n\n\n\n\n\nend inst.qmd"
  },
  {
    "objectID": "tests.html#running-test",
    "href": "tests.html#running-test",
    "title": "Tests",
    "section": "Running test()\n",
    "text": "Running test()\n\nThe fourth devtools habit to adopt is regularly writing and running tests. If you’re using Posit Workbench and have devtools installed, you can test our package using the Build pane or the keyboard shortcut:\n\n\nCtrl/Cmd + Shift + T\n\n\n\n(a) Test you app-package\n\nFigure 1: devtools::test() (run all tests in your tests/ folder)\n\nWhen we initally run devtools::test() in pkgApp, we see the following:\n==&gt; devtools::test()\n\nℹ No testing infrastructure found.\n• Setup testing with `usethis::use_testthat()`.\nThis shouldn’t be surprising, because we haven’t written any tests for pkgApp yet!. The error is informative, though, because it tells us pkgApp doesn’t have the testing infrastructure set up. In R packages using\nIn the next section we’ll cover setting up the test suite in your app-package.\n\n\n\n\n\n\nMastering Shiny monthApp tests\n\n\n\n\n\n\nIf you downloaded, loaded and installed monthApp example from Mastering Shiny, then clicked on Test in the Build pane, you also saw the following:\n\n\nTesting monthApp app-package"
  },
  {
    "objectID": "tests.html#your-app-package-test-suite",
    "href": "tests.html#your-app-package-test-suite",
    "title": "Tests",
    "section": "Your app-package test suite",
    "text": "Your app-package test suite\nIf you adopt test-driven development, you’ll develop tests before writing any utility functions, modules, or standalone app function. However, if you’re a mere mortal like the rest of us, you’ll typically develop your tests and functions in tandem.\nRegardless of the testing strategy, we’ll follow the advice in the output above and set up the testing infrastructure with the testthat package:\nuse_testthat()\nThe ‘infrastructure’ created by running usethis::use_testthat() is detailed below:\n\nusethis::use_testthat()\n\n\n\nSet active project to current working directory:\n✔ Setting active project to '/path/to/pkgApp'\n\n\nIn the DESCRIPTION file, add the Suggests field and include testthat (&gt;= 3.0.0) and the testthat edition (Config/testthat/edition: 3)\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\n\n\nA new tests/ folder is created, with a testthat/ subfolder:\n✔ Creating 'tests/testthat/'\n\n\nThe testthat.R file is created (sometimes referred to as the test ‘runner’ because it runs all your tests).\n✔ Writing 'tests/testthat.R'\n\n\nFinally, we’re given some advice on the next step for creating our first test:\n• Call `use_test()` to initialize a basic test file and open it for editing.\nOur new tests/ folder structure is below:\ntests/\n  ├── testthat\n  └── testthat.R\n\n2 directories, 1 file"
  },
  {
    "objectID": "tests.html#unit-tests",
    "href": "tests.html#unit-tests",
    "title": "Tests",
    "section": "Unit tests",
    "text": "Unit tests\nIf I’m writing write a unit test for the scatter_plot() function in R/scatter_plot.R, I’ll create test file with usethis::use_test(\"scatter_plot\").\nNew tests with use_test()\n\n\nusethis::use_test(\"scatter_plot\")\n\nThe IDE will automatically open the new test file:\n✔ Writing 'tests/testthat/test-scatter_plot.R'\n• Modify 'tests/testthat/test-scatter_plot.R'\nThe new file contains boilerplate test below (I’ve added the testthat namespace and arguments):\n\ntestthat::test_that(desc = \"multiplication works\", code = {\n  testthat::expect_equal(object = 2 * 2, expected = 4)\n})\n\nEach testthat test has a test context (supplied to the desc argument) followed by the test (created in curly brackets in the code argument).\nExpectations\nSnapshots\nvdiffr\nThe vdiffr package"
  },
  {
    "objectID": "tests.html#moduleintegration-tests",
    "href": "tests.html#moduleintegration-tests",
    "title": "Tests",
    "section": "Module/integration tests",
    "text": "Module/integration tests\nModule tests involve both UI and server functions, I consider these integration tests (i.e., we’re testing how a module’s functions ‘integrate’ with each other, or with other modules).\ntestServer()\ntestServer(args = list())"
  },
  {
    "objectID": "tests.html#end-to-end-tests",
    "href": "tests.html#end-to-end-tests",
    "title": "Tests",
    "section": "End-to-end tests",
    "text": "End-to-end tests\nshinytest2\n\n\n\n\nNew Git Branch\n\nThe code for this section is in the [06_tests] branch of the [pkgApp] repo.\nend testing.qmd"
  },
  {
    "objectID": "run.html#app-package-contents",
    "href": "run.html#app-package-contents",
    "title": "Running the app",
    "section": "App-package contents",
    "text": "App-package contents\nLet’s review the files and folders in shiny app-packages.\nDESCRIPTION\n\npkgApp/\n  └── DESCRIPTION\n\nNAMESPACE\n\npkgApp/\n  └── NAMESPACE\n\n\nR/ folder\n\npkgApp/\n  └── R/\n  \n\n\nman/ folder\n\npkgApp/\n  └── man/\n  \n\n\ndata/ folder\n\npkgApp/\n  └── data/\n  \n\n\nrunApp()\n\nloadSupport warning\n\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\ncontain an R package. Sourcing files in R/ may cause unexpected behavior."
  },
  {
    "objectID": "frameworks.html",
    "href": "frameworks.html",
    "title": "Frameworks",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\ngolem:\nleprechaun:\nrhino:\nend frameworks.qmd"
  },
  {
    "objectID": "golem.html",
    "href": "golem.html",
    "title": "goelm",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\ngoelm stuff\n\nCodeinstall.packages(\"goelm\")\nlibrary(goelm)\n\n\nend golem.qmd"
  },
  {
    "objectID": "leprechaun.html",
    "href": "leprechaun.html",
    "title": "leprechaun",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nleprechaun stuff\n\nCodeinstall.packages(\"leprechaun\")\nlibrary(leprechaun)\n\n\nend leprechaun.qmd"
  },
  {
    "objectID": "rhino.html",
    "href": "rhino.html",
    "title": "rhino",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nrhino stuff\n\nCodeinstall.packages(\"rhino\")\nlibrary(rhino)\n\n\nend rhino.qmd"
  },
  {
    "objectID": "special_topics.html",
    "href": "special_topics.html",
    "title": "Special topics",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nAll the other stuff…\nend special_topics.qmd"
  },
  {
    "objectID": "debugging.html",
    "href": "debugging.html",
    "title": "Debugging",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend debugging.qmd"
  },
  {
    "objectID": "css.html",
    "href": "css.html",
    "title": "CSS",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend css.qmd"
  },
  {
    "objectID": "js.html",
    "href": "js.html",
    "title": "JavaScript",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend js.qmd"
  },
  {
    "objectID": "code_tools.html#styler-lintr",
    "href": "code_tools.html#styler-lintr",
    "title": "Code tools",
    "section": "\nstyler & lintr\n",
    "text": "styler & lintr\n\nThe styler and lintr packages in R serve related but distinct purposes and have different focuses in their functionality. The primary difference between lintr and styler is that styler can automatically fix any stylistic issues it identifies in your code (rather than just reporting them).\nlintr: lintr is a static code analysis tool used to identify syntax errors, semantic issues, and violations of stylistic guidelines in your code. The package contains a list of ‘linters’ for various potential problems and can be customized according to your needs. lintr is designed to help improve your code’s quality and readability by generating reports in the ‘markers’ pane. Running lintr won’t automatically correct the identified issues (you’ll need to fix the linting issues it reports manually).\nstyler: On the other hand, the purpose of styler is to ensure consistency in the code formatting, which is crucial if you’re working in a team or contributing to open-source projects (like tidyverse packages). The styler package will change your code’s format according to specified style guidelines. These changes include indentation, spaces, and line breaks that adhere to your style guidelines.\nWhile there is some overlap (both packages can help enforce coding style guidelines), lintr is a more general tool for code quality, spotting potential issues and bugs. At the same time, styler focuses on code formatting and can automatically apply fixes. Many developers find combining both can help catch potential issues and ensure a consistent, readable coding style."
  },
  {
    "objectID": "code_tools.html#sinew",
    "href": "code_tools.html#sinew",
    "title": "Code tools",
    "section": "sinew",
    "text": "sinew\nThe sinew package also warrants mentioning because it can help ensure you’re namespacing functions from add-on packages.\nend code_tools.qmd"
  },
  {
    "objectID": "glossary.html#shiny-apps",
    "href": "glossary.html#shiny-apps",
    "title": "Glossary of terms",
    "section": "Shiny apps",
    "text": "Shiny apps\nUtility/helper functions\nExternal resources\nModule\nStandalone app function"
  },
  {
    "objectID": "glossary.html#packages",
    "href": "glossary.html#packages",
    "title": "Glossary of terms",
    "section": "Packages",
    "text": "Packages\nProject\nAny directory of R executable files with an RStudio/Posit workbench project file (.Rproj).\nPackage\nA directory of functions, documentation, and/or data can be installed and loaded into an R session. Packages include the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench.\nApp-package\nAn app-package is a package containing a shiny application. App-packages have all of the functionality of a standard R package, but also contain the files and folders required to successfully develop, run, and deploy a shiny application."
  },
  {
    "objectID": "glossary.html#devtools",
    "href": "glossary.html#devtools",
    "title": "Glossary of terms",
    "section": "devtools",
    "text": "devtools\nend glossary.qmd"
  },
  {
    "objectID": "github.html#projapp",
    "href": "github.html#projapp",
    "title": "GitHub",
    "section": "projApp",
    "text": "projApp\nThe projApp repo is a shiny application built outside of a package structure. It was initially created using the New Project Wizard (with a Git repo initialized).\nIf you’re new to GitHub, the steps below will walk you through setting up Git and GitHub from RStudio using the Git pane. The initial files in the project are below:\nprojApp/\n  ├── app.R\n  └── projApp.Rproj\n\n1 directory, 2 files\nAfter creating the project, head over to GitHub and create am empty repo. You’ll see the following options:\n\n\n\n\n(a) New repository on GitHub\n\nFigure 1: Empty GitHub repository options\n\n\nWe’re interested in the second option, “…push an existing repository from the command line”, but we’re going to use Posit Workbench’s Git pane.\nCommit\nCommit these initial changes to the repo using the Commit icon in the Git pane\n\n\n\n(a) Commit changes\n\n\n\n(b) First commit\n\nFigure 2: Click on Commit to open the Git window. Stage all the files, add a commit message, and click Commit\n\nAdd a commit message and click Commit. This is the equivalent of entering the following commands in the Terminal:\ngit commit -m 'first commit'\n\n\n\n\n\n\nCommit changes in your repository with a specific message\n\n\n\n\n\n\ngit commit -m 'first commit'\n\ngit commit: This command captures a snapshot of the changes in your project’s tracked files and directories. By committing, you’re saving the current state of those files in the Git repository.\n-m: This flag indicates that a commit message will be provided directly from the command line.\n'first commit': This is the commit message associated with this commit. Commit messages are useful for documenting the changes you’ve made, making it easier for others (and your future self) to understand the evolution and purpose of changes in the project.\n\nWhen you run git commit -m 'first commit', you are committing your staged changes (i.e., changes you’ve previously added to the staging area using git add) with the message ‘first commit’.\nThis message is then stored in the Git history, allowing anyone who looks at the commit logs to see a brief description of what was done in that particular commit.\n\n\n\n\nReview the output from the commit.\n\n\n\n(a) First commit output\n\nFigure 3: The .gitignore, app.R, and projApp.Rproj files have been committed to main\n\nThis shows the contents of projApp are part of the main branch. Now we need to make sure the local branch has a remote (on GitHub at https://github.com/&lt;username&gt;/projApp.git).\n\n\n\n\n\n\nRename the currently checked-out branch to main\n\n\n\n\n\n\nThe command git branch -M main is used to rename the currently checked-out branch to main.\nHere’s a breakdown of the command:\n\ngit branch: This command without any arguments would list all the local branches in the current repository. But, with certain options (like -M), you can perform other branch-related operations.\n-M: This option stands for ‘move/rename’ and forcibly renames the branch. If a branch named main already exists, it will be overwritten because of the forceful nature of the -M option. If you want to avoid accidentally overwriting an existing branch, you could use -m (lowercase) instead. The lowercase -m will rename only if the target name doesn’t already exist.\nmain: This is the new name for the currently checked-out branch.\n\nThe command became more common after the industry started transitioning from using master to main as the default branch name for new repositories. Running git branch -M main is a way to rename the master branch to main in existing repositories.\n\n\n\n\nAdding remotes\nClick the New Branch icon in the Git pane and create a new main branch. Then click on Add Remote… and name the remote origin.\n\n\n\n(a) Add branch and remote name\n\n\n\n(b) Add remote URL\n\nFigure 4: Create new main branch to track origin\n\nThe Remote URL is the link from the Quick Setup above. After clicking Add and Create, you’ll be asked to checkout or overwrite the existing main branch. In this case, we can select Overwrite (because we’re already on the main branch).\n\n\n\n\n\n\nAdd a new remote to your Git repository\n\n\n\n\n\n\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n\ngit remote: used to manage and set remotes (‘remote repositories’) for your project\nadd: specifies that you want to add a new remote.\norigin: a convention widely used in the Git community is to name the primary remote repository origin.\nhttps://github.com/&lt;username&gt;/&lt;repo&gt;.git: This is the URL to the Git repository (hosted on GitHub). Replace &lt;username&gt; with the GitHub username of the repository owner and &lt;repo&gt; with the name of the repository.\n\nSo, when you run this command, you’re telling Git: ‘I want to add a new remote called origin, and the URL for this remote is https://github.com/&lt;username&gt;/&lt;repo&gt;.git'.’\nAfter executing this command, you can then push to and pull from the repository using this remote by referring to its name (origin). For instance, git push origin master would push your local master branch to the master branch on the origin remote.\n\n\n\n\n\n\n\n(a) Overwrite main\n\n\n\n(b) branch main set up to track origin/main\n\nFigure 5: main will now track the remote (origin)\n\n\n\n\n\n\n\nPush a local branch (main) to a remote (origin), and set local branch to track remote branch\n\n\n\n\n\n\ngit push -u origin main\n\ngit push: used to push commits from your local repository to a remote repository.\norigin: name of the remote repository you want to push to. When you clone a repo or add a remote using git remote add, it’s common to name the main remote origin (though it could technically be any name).\nmain: name of the branch you’re pushing to the remote repository.\n-u or --set-upstream: When this option is used, it sets a tracking relationship between the local and upstream remote branches. This means that in the future, using git pull or git push doesn’t require specifying the remote or branch (Git will know you’re referring to the origin/main branch).\n\nIn essence, git push -u origin main is saying: ‘Push my ’main’ branch to the ‘origin’ remote, and also set my local ‘main’ branch to track the ‘main’ branch on ‘origin’.\nThe common workflow for setting up Git from the command line is below:\n# make changes \ngit add .\ngit commit 'first commit'\n# set remote on GitHub\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n# rename the current branch to main\ngit branch -M main\n# push and set upstream to origin (remote)\ngit push -u origin main"
  },
  {
    "objectID": "create.html#creating-app-packages-scenarios",
    "href": "create.html#creating-app-packages-scenarios",
    "title": "Appendix: Creating packages in Posit Workbench",
    "section": "Creating app-packages: scenarios",
    "text": "Creating app-packages: scenarios\nThe callout blocks below represent scenarios I’ve encountered requiring an app-package:\nScenario #1\n\n\n\n\n\n\nScenario #1: Create a new shiny app-package\n\n\n\n\n\n\nYou’re in the ‘brainstorming’ stages of app development, and no code (or very little code) has been written. Maybe you’ve investigated using a framework (like golem or rhino) but can’t decide if their features will fit your needs.\n\n\n\n\nIn this case, you’re in the perfect position to create a new package with usethis::create_package() or devtools::create(). If you’re using Posit Workbench, do File &gt; New Project &gt; New Directory &gt; R Package.\nScenario #2\n\n\n\n\n\n\nScenario #2: Convert a working app project into an app-package\n\n\n\n\n\n\nThe app is currently deployed and is being accessed by users, but the underlying code lives in the ‘root’ folder (i.e., an app.R or ui.R and server.R, global.R, helper.R, and/or other .R files, data, static resources, etc.). The application works, but you’d like to convert it to a package structure without breaking it.\n\n\n\n\nThis is a circumstance where I’d manually create the DESCRIPTION file (or use usethis::use_description()) and set the package-level build tools (Tools &gt; Project options &gt; Build Tools &gt; Project build tools). Then I’d begin organizing the shiny app files into a package structure (i.e., move .R files into the R/ folder, data files into the data/ folder, etc.)\nScenario #3\n\n\n\n\n\n\nScenario #3: Convert a legacy app project into a shiny app-package\n\n\n\n\n\n\nThe app was written some time ago, used superseded or deprecated functions (i.e., callModule()), and needs updating. Updating the apps might include adding data or static resources, writing utility functions and modules, etc.\nThe critical distinction is that this application is not working and requires updates.\n\n\n\n\nScenario #4\n\n\n\n\n\n\nScenario #4: Convert your ‘dev’ app project into an app-package\n\n\n\n\n\n\nYou’re currently developing an app project, and you read somewhere it should be an app-package; however, you can’t find clear instructions on how to accomplish this incrementally.\nAnd maybe you’re a minimalist (like me) who likes to have complete control over every aspect of the development process."
  },
  {
    "objectID": "devtools.html#developing-packages-with-devtools",
    "href": "devtools.html#developing-packages-with-devtools",
    "title": "devtools",
    "section": "Developing packages with devtools\n",
    "text": "Developing packages with devtools\n\n\n“One package to rule them all.” - not the devtools development team\n\nIf you’re new to package development, it’s helpful to have a little background on the devtools package. Earlier versions of devtools contained most of the functions used for package development. In version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\n\nThe usethis package contains most of the functions for creating package folders and files (.R files, tests, vignettes, etc.). usethis is also automatically loaded when you call library(devtools).\nLoading and building your app-package is handled by pkgload and pkgbuild\nFor app-packages destined for CRAN, the R CMD check is handled by rcmdcheck and revdepcheck\nInstalling packages from non-CRAN repositories (i.e., install_github()) is handled by remotes\n\nYou don’t have to install all of these packages (they will be loaded with devtools), but the information is important because it affects the dependencies in your app-package:\n\n‘Package developers who wish to depend on devtools features should also pay attention to which package the functionality is coming from and depend on that rather than devtools. In most cases packages should not depend on devtools directly.’ - devtools 2.0.0, tidyverse blog\n\nWe will cover this topic more in the dependencies chapter."
  },
  {
    "objectID": "roxygen2.html#documenting-app-package-functions",
    "href": "roxygen2.html#documenting-app-package-functions",
    "title": "roxygen2",
    "section": "Documenting app-package functions",
    "text": "Documenting app-package functions\nYour app-package will likely contain at least two functions that are specific to shiny: modules and a standalone app function. roxygen2 has a few tags that can make the documentation for these functions more informative for readers.\nModules\nA few things to consider when documenting module functions in app-packages:\n\nModules have two functions: one for the UI, and a counterpart in the server\nEvery module function will include at least one @param for the shared id\nReturned objects are particularly important in shiny’s reactive context, so I recommend extending the description to include whether or not the returned output is reactive\nIf the returned output is an input (i.e. @param) for another function, link to that documentation functions with @seealso or @family\n\nBelow are some examples from the pkgApp modules.\n@seealso\nWhen documenting modules, think of the audience as someone who is looking to understand the execution path through the application. In pkgApp(), the inputs are collected with the var_input module, then passed to the scatter_display module.\n\nshow/hide mod_var_input_ui() roxygen2#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n\n\nUse @seealso to connect mod_var_input_ui() to it’s server function counterpart. The hyperlink to mod_var_input_server() from mod_var_input_ui() is created by placing the destination function in square brackets [fun()]:\n\nshow/hide mod_var_input_ui() roxygen2#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n#' @seealso [mod_var_input_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\nseealso creates a hyperlink readers can use to open the next module in the execution path.\n\n\n\n\n(a) @seealso in mod_var_input_ui()\n\nFigure 9: Link mod_var_input_ui() to mod_var_input_server()\n\n\nIn mod_var_input_server(), a link can be made to mod_scatter_display_server() (the module function collecting the returned values) using the square brackets in the @return section (without @seealso):\n\nshow/hide mod_var_input_server() roxygen2#' Variable input module (server)\n#'\n#' @param id server module id\n#' \n#' @seealso [mod_var_input_ui()]\n#'\n#' @return reactive inputs are returned in a `list()`: \n#'  * `x()`\n#'  * `y()`\n#'  * `z()`\n#'  * `alpha()`\n#'  * `size()`\n#'  * `plot_title()`\n#'  \n#' These become in the `var_inputs` argument in [mod_scatter_display_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @seealso link\n\nFigure 10: Link values from var_input to scatter_display\n\n\n@family\nModule functions can also be grouped into families using @family {\"description\"}. Below is an example of grouping the ‘scatter plot module functions’ into a family:\n\nshow/hide mod_scatter_display_ui() roxygen2#' Scatter plot display module (UI)\n#'\n#' @param id UI module id\n#' \n#'\n#' @return module UI (HTML)\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n@section\nThe @section tag will create a level two header (##/&lt;h2&gt;&lt;/h2&gt;) section, which can be helpful for organizing topics (like how to use an input or argument).\n@seealso can also be used to link back to the scatter_plot() utility function:\n\nshow/hide mod_scatter_display_server() roxygen2#' Scatter plot display module (server)\n#' \n#'\n#' @param id server module id \n#' @param var_inputs returned reactive list from [mod_var_input_server()].\n#' \n#' @section Referring to `var_inputs`: \n#' Refer to the reactive returned values from `mod_var_input_server()` as:\n#'  * `var_inputs$x()`\n#'  * `var_inputs$y()`\n#'  * `var_inputs$z()`\n#'  * `var_inputs$alpha()`\n#'  * `var_inputs$size()`\n#'  * `var_inputs$plot_title()`\n#' \n#'\n#' @return rendered plot and title output from [scatter_plot()]\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @family link\n\nFigure 11: Link from var_input module and group scatter_display module\n\n\nThe figure above shows how the @seealso links can be used to create a path for the graph parameters through the var_input and scatter_display modules. It also demonstrates how @family groups the scatter_display UI and server functions.\nThe scatter_plot() utility function should also include a @seealso tag for the module function it’s used in.\n\nshow/hide scatter_plot() roxygen2#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @seealso and @family connections\n\nFigure 12: Connecting inputs and outputs, grouping modules, and linking utility functions\n\n\nThe goal when cross-referencing functions in your app-package is for anyone reading your documentation to be able to follow the links and get a better understanding of any modules, they’re inputs, reactive values, and outputs.\nIn this case, linking back to the scatter_plot() utility functions also gives reader an interactive example to preview the output.\nStandalone app functions\nSplitting the code in app.R into separate functions has multiple benefits. First, it’s easier to develop and load a function if it’s stored in the R/ folder. Second, having a dedicated ui, server, and app function means we can develop them independently. Finally, having a standalone app function makes it possible to store multiple applications in the same app-package.\nI’ve split the UI and server from movies_app() into separate movies_ui() and movies_server() below.\nmovies_ui()\nThe movies_ui() doesn’t have any arguments–the only change is wrapping the shiny::fluidPage() in shiny::tagList():\n\nmovies_ui &lt;- function() {\n  shiny::tagList(\n    shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nI’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). I’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n\nshow/hide roxygen2 for movies_ui()#' Movies UI function\n#' \n#' UI function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_ui()\n\nFigure 13: UI function documentation\n\nmovies_server()\nmovies_server() is written to be passed to the server argument in shinyApp():\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\nThe documentation for movies_server() is very similar to movies_ui()–each module server function is documented in it’s own @section, but I’ll also include a @section for Communication that describes how values are passed between mod_var_input_server() and mod_scatter_display_server().\n\nshow/hide roxygen2 for movies_server()#' Movies server function\n#' \n#' Server function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#' \n#' ```\n#' shinyApp(movies_ui, movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in [movies_ui()]   \n#'  * server is stored in `movies_server()`\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_server()] returns following reactive values:\n#'  * `x()`\n#'  * `y()`\n#'  * `z()`\n#'  * `alpha()`\n#'  * `size()`\n#'  * `plot_title()`\n#' \n#' @seealso [mod_var_input_ui()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_server()] displays the `ggplot2` graph with the [scatter_plot()] function.\n#' \n#' @seealso [mod_scatter_display_ui()]\n#' \n#' @section Communication: \n#' The output from [mod_var_input_server()] should be supplied to the \n#' `var_inputs` argument of [mod_scatter_display_server()].\n#\n#' @return `server` argument in `shiny::shinyApp()`\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_server()\n\nFigure 14: Server function documentation\n\nmovies_app()\nThe standalone app function (movies_app()) automatically calls shinyApp(), with the movies_ui and movies_server functions supplied to ui and server (without parentheses).\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nThe documentation for the standalone app function can be minimal–as long as it provides links to the UI and server.\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_app()\n\nFigure 15: Standalone app function documentation\n\nI’ll change the contents of app.R to the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\n\n\n\n\nNew Git Branch\n\nThe code for the next section is in the [02_roxygen2] branch of the [pkgApp] repo."
  },
  {
    "objectID": "roxygen2.html#documenting-app-functions",
    "href": "roxygen2.html#documenting-app-functions",
    "title": "roxygen2",
    "section": "Documenting app functions",
    "text": "Documenting app functions\nYour app-package will likely contain at least two functions that are specific to shiny: modules and a standalone app function. roxygen2 has a few tags that can make the documentation for these functions more informative for readers.\nDocumenting modules\nBelow are a few things to consider when documenting module functions:\n\nModules typically have two functions in a single .R file: one for the UI, and a counterpart in the server\nEvery module function will include at least one @param for the shared id\nReturned objects are particularly important in shiny’s reactive context, so I recommend extending the description to include whether or not the returned output is reactive\nIf the returned output is an input (i.e. @param) for another function, link to that documentation functions with @seealso or @family\n\nBelow are some examples from the pkgApp modules.\n@seealso\nWhen documenting modules, think of the audience as someone who is looking to understand the execution path through the application. In pkgApp(), the inputs are collected with the var_input module, then passed to the scatter_display module.\n\nshow/hide mod_var_input_ui() roxygen2#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n\n\nUse @seealso to connect mod_var_input_ui() to it’s server function counterpart. The hyperlink to mod_var_input_server() from mod_var_input_ui() is created by placing the destination function in square brackets [fun()]:\n\nshow/hide mod_var_input_ui() roxygen2#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n#' @seealso [mod_var_input_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\nseealso creates a hyperlink readers can use to open the next module in the execution path.\n\n\n\n\n(a) @seealso in mod_var_input_ui()\n\nFigure 9: Link mod_var_input_ui() to mod_var_input_server()\n\n\nIn mod_var_input_server(), a link can be made to mod_scatter_display_server() (the module function collecting the returned values) using the square brackets in the @return section (without @seealso):\n\nshow/hide mod_var_input_server() roxygen2#' Variable input module (server)\n#'\n#' @param id server module id\n#' \n#' @seealso [mod_var_input_ui()]\n#'\n#' @return reactive inputs are returned in a `list()`: \n#'  * `x()`\n#'  * `y()`\n#'  * `z()`\n#'  * `alpha()`\n#'  * `size()`\n#'  * `plot_title()`\n#'  \n#' These become in the `var_inputs` argument in [mod_scatter_display_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @seealso link\n\nFigure 10: Link values from var_input to scatter_display\n\n\n@family\nModule functions can also be grouped into families using @family {\"description\"}. Below is an example of grouping the ‘scatter plot module functions’ into a family:\n\nshow/hide mod_scatter_display_ui() roxygen2#' Scatter plot display module (UI)\n#'\n#' @param id UI module id\n#' \n#'\n#' @return module UI (HTML)\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n@section\nThe @section tag will create a level two header (##/&lt;h2&gt;&lt;/h2&gt;) section, which can be helpful for organizing topics (like how to use an input or argument).\n@seealso can also be used to link back to the scatter_plot() utility function:\n\nshow/hide mod_scatter_display_server() roxygen2#' Scatter plot display module (server)\n#' \n#'\n#' @param id server module id \n#' @param var_inputs returned reactive list from [mod_var_input_server()].\n#' \n#' @section Referring to `var_inputs`: \n#' Refer to the reactive returned values from `mod_var_input_server()` as:\n#'  * `var_inputs$x()`\n#'  * `var_inputs$y()`\n#'  * `var_inputs$z()`\n#'  * `var_inputs$alpha()`\n#'  * `var_inputs$size()`\n#'  * `var_inputs$plot_title()`\n#' \n#'\n#' @return rendered plot and title output from [scatter_plot()]\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @family link\n\nFigure 11: Link from var_input module and group scatter_display module\n\n\nThe figure above shows how the @seealso links can be used to create a path for the graph parameters through the var_input and scatter_display modules. It also demonstrates how @family groups the scatter_display UI and server functions.\nThe scatter_plot() utility function should also include a @seealso tag for the module function it’s used in.\n\nshow/hide scatter_plot() roxygen2#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `pkgApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n(a) @seealso and @family connections\n\nFigure 12: Connecting inputs and outputs, grouping modules, and linking utility functions\n\n\nThe goal when cross-referencing functions in your app-package is for anyone reading your documentation to be able to follow the links and get a better understanding of any modules, they’re inputs, reactive values, and outputs.\nIn this case, linking back to the scatter_plot() utility functions also gives reader an interactive example to preview the output.\nStandalone app functions\nSplitting the code in app.R into separate functions has multiple benefits. First, it’s easier to develop and load a function if it’s stored in the R/ folder. Second, having a dedicated ui, server, and app function means we can develop them independently. Finally, having a standalone app function makes it possible to store multiple applications in the same app-package.\nI’ve split the UI and server from movies_app() into separate movies_ui() and movies_server() below.\nmovies_ui()\nThe movies_ui() doesn’t have any arguments–the only change is wrapping the shiny::fluidPage() in shiny::tagList():\n\nmovies_ui &lt;- function() {\n  shiny::tagList(\n    shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nI’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). I’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n\nshow/hide roxygen2 for movies_ui()#' Movies UI function\n#' \n#' UI function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_ui()\n\nFigure 13: UI function documentation\n\nmovies_server()\nmovies_server() is written to be passed to the server argument in shinyApp():\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\nThe documentation for movies_server() is very similar to movies_ui()–each module server function is documented in it’s own @section, but I’ll also include a @section for Communication that describes how values are passed between mod_var_input_server() and mod_scatter_display_server().\n\nshow/hide roxygen2 for movies_server()#' Movies server function\n#' \n#' Server function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#' \n#' ```\n#' shinyApp(movies_ui, movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in [movies_ui()]   \n#'  * server is stored in `movies_server()`\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_server()] returns following reactive values:\n#'  * `x()`\n#'  * `y()`\n#'  * `z()`\n#'  * `alpha()`\n#'  * `size()`\n#'  * `plot_title()`\n#' \n#' @seealso [mod_var_input_ui()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_server()] displays the `ggplot2` graph with the [scatter_plot()] function.\n#' \n#' @seealso [mod_scatter_display_ui()]\n#' \n#' @section Communication: \n#' The output from [mod_var_input_server()] should be supplied to the \n#' `var_inputs` argument of [mod_scatter_display_server()].\n#\n#' @return `server` argument in `shiny::shinyApp()`\n#' \n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_server()\n\nFigure 14: Server function documentation\n\nmovies_app()\nThe standalone app function (movies_app()) automatically calls shinyApp(), with the movies_ui and movies_server functions supplied to ui and server (without parentheses).\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nThe documentation for the standalone app function can be minimal–as long as it provides links to the UI and server.\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n(a) movies_app()\n\nFigure 15: Standalone app function documentation\n\nI’ll change the contents of app.R to the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\n\n\n\n\nNew Git Branch\n\nThe code for the next section is in the [02_roxygen2] branch of the [pkgApp] repo.\nNow that we’ve documented everything in R/, we’ll run load(), document(), and install():\n\nCtrl/Cmd + Shift + L\n\ndevtools::load_all(\".\")\nℹ Loading pkgApp\n\nCtrl/Cmd + Shift + D\n\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating pkgApp documentation\nℹ Loading pkgApp\nDocumentation completed\n\nCtrl/Cmd + Shift + B\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source pkgApp\n\n* installing to library ‘/path/to/local/install/pkgApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘pkgApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (pkgApp)\nIn the Console, we should see the following:\nRestarting R session...\n\n&gt; library(pkgApp)\nThe roxygen2 documentation for pkgApp is saved in the 02-roxygen branch. The new app-package contents are below:\n\npkgApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   ├── movies_app.R\n  │   ├── movies_server.R\n  │   ├── movies_ui.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man/\n  │   ├── mod_scatter_display_server.Rd\n  │   ├── mod_scatter_display_ui.Rd\n  │   ├── mod_var_input_server.Rd\n  │   ├── mod_var_input_ui.Rd\n  │   ├── movies_app.Rd\n  │   ├── movies_server.Rd\n  │   ├── movies_ui.Rd\n  │   └── scatter_plot.Rd\n  ├── movies.RData\n  ├── pkgApp.Rproj\n  └── www/\n      └── shiny.png\n\n4 directories, 22 files"
  },
  {
    "objectID": "dependencies.html#your-app-package-namespace",
    "href": "dependencies.html#your-app-package-namespace",
    "title": "Dependencies",
    "section": "Your app-package NAMESPACE\n",
    "text": "Your app-package NAMESPACE\n\nThe previous chapter illustrated how roxygen2 connects the code in the R/ folder to the documentation in the man/ folder, but roxygen2 tags are also used to document the dependencies in the NAMESPACE file:\n\n\n\n(a) roxygen2\n\nFigure 1: roxygen2 writes the NAMESPACE file\n\nThe NAMESPACE file serves two important purposes: 1) it lists which functions and objects from your app-package are exposed to other users, and 2) it controls which functions from external (i.e., add-on) packages your app-package imports.\nUp to this point, we’ve been using document() to generate .Rd files in man/. Now we’ll use document() to make sure the NAMESPACE is updated with the correct imports and exports."
  },
  {
    "objectID": "app.html#app-package-contents",
    "href": "app.html#app-package-contents",
    "title": "app.R",
    "section": "App-package contents",
    "text": "App-package contents\nLet’s review the files and folders in shiny app-packages.\nDESCRIPTION\n\npkgApp/\n  └── DESCRIPTION\n\nNAMESPACE\n\npkgApp/\n  └── NAMESPACE\n\n\nR/ folder\n\npkgApp/\n  └── R/\n  \n\n\nman/ folder\n\npkgApp/\n  └── man/\n  \n\n\ndata/ folder\n\npkgApp/\n  └── data/\n  \n\n\nrunApp()\n\nloadSupport warning\n\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\ncontain an R package. Sourcing files in R/ may cause unexpected behavior."
  },
  {
    "objectID": "app.html#pkgapp-contents",
    "href": "app.html#pkgapp-contents",
    "title": "app.R",
    "section": "\npkgApp contents",
    "text": "pkgApp contents\nLet’s review the files and folders in pkgApp.\n\nR/ folder\npkgApp/\n  R/\n  ├── mod_scatter_display.R\n  ├── mod_var_input.R\n  ├── movies_app.R\n  ├── movies_server.R\n  ├── movies_ui.R\n  └── scatter_plot.R\n  \n  1 directory, 6 files\n  \n\nman/ folder\npkgApp/\n  man/\n  ├── mod_scatter_display_server.Rd\n  ├── mod_scatter_display_ui.Rd\n  ├── mod_var_input_server.Rd\n  ├── mod_var_input_ui.Rd\n  ├── movies_app.Rd\n  ├── movies_server.Rd\n  ├── movies_ui.Rd\n  └── scatter_plot.Rd\n  \n  1 directory, 8 files\n\nwww/ folder\npkgApp/\n  www/\n    └── shiny.png\n\n1 directory, 1 file\nDESCRIPTION\nPackage: pkgApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith &lt;John.Smith@email.io&gt; [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\nImports:\n  shiny,\n  ggplot2,\n  rlang,\n  stringr,\n  tools\nNAMESPACE\n# Generated by roxygen2: do not edit by hand\n\nexport(mod_scatter_display_server)\nexport(mod_scatter_display_ui)\nexport(mod_var_input_server)\nexport(mod_var_input_ui)\nexport(movies_app)\nexport(movies_server)\nexport(movies_ui)\nexport(scatter_plot)\nimport(shiny)\nimportFrom(ggplot2,aes)\nimportFrom(ggplot2,geom_point)\nimportFrom(ggplot2,ggplot)\nimportFrom(ggplot2,labs)\nimportFrom(ggplot2,theme)\nimportFrom(ggplot2,theme_minimal)\nimportFrom(rlang,.data)\nimportFrom(stringr,str_replace_all)\nimportFrom(tools,toTitleCase)\nREADME.md\n# movies app\n\nThe original code and data for this shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`pkgApp` branches](https://github.com/mjfrigaard/pkgApp/branches/).\nmovies.RData\n\npkgApp.Rproj\nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\napp.R\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# load pacakge ----------------------------------\nlibrary(pkgApp)\n\n# movies_app ------------------------------------\nmovies_app()\n\nmovies_app()\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#' @export\n#' \n#' @import shiny\n#' \nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nloadSupport warning\n\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to\ncontain an R package. Sourcing files in R/ may cause unexpected behavior."
  },
  {
    "objectID": "app.html#runapp",
    "href": "app.html#runapp",
    "title": "app.R",
    "section": "runApp()",
    "text": "runApp()\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#' @export\n#' \n#' @import shiny\n#' \nmovies_app &lt;- function(runApp = TRUE) {\n  app &lt;- shiny::shinyApp(\n                  ui = movies_ui, \n                  server = movies_server)\n   if (runApp)\n      shiny::runApp(app, test.mode = TRUE)\n   else\n      app\n}"
  },
  {
    "objectID": "app.html#updated-app.r",
    "href": "app.html#updated-app.r",
    "title": "app.R",
    "section": "Updated app.R\n",
    "text": "Updated app.R\n\ninteractive()\n\n# load package ----------------------------------\nif (!interactive()) {\n  \n} else {\n   \n}\n\nstderr()\n\n# load package ----------------------------------\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch({\n      library(pkgApp)\n   }, error = function(e) {\n      \n   })\n} else {\n   \n}\n\npkgload::load_all()\n\n# load package ----------------------------------\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch({\n      library(pkgApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   pkgload::load_all()\n}\n\n\n# load package ----------------------------------\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch({\n      library(pkgApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   pkgload::load_all()\n}\n\n# movies_app ------------------------------------\npkgApp::movies_app(runApp = interactive())"
  },
  {
    "objectID": "app.html#recap",
    "href": "app.html#recap",
    "title": "app.R",
    "section": "Recap",
    "text": "Recap"
  }
]