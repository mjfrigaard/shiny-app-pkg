[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "Welcome"
  },
  {
    "objectID": "index.html#why-this-book",
    "href": "index.html#why-this-book",
    "title": "Shiny App-Packages",
    "section": "Why this book?",
    "text": "Why this book?\nIf you’re comfortable building Shiny applications but aren’t as familiar with writing R packages, this book is for you.\nI started putting this resource together after multiple encounters with Shiny developers who had created impressive, complex apps but struggled to convert them into R packages. This problem often resulted in delays when moving their applications into a production environment.\n\n\nDid you read Mastering Shiny and want to learn more about package development?\n\n\nMastering Shiny is an excellent introduction to the captivating world of Shiny and provides a foundation of best practices for building applications. R packages are introduced in Mastering Shiny, and this chapter is a great place to start. 1 However, to fully understand and appreciate the benefits of developing your Shiny app as an R package, I’ve found it’s helpful to have an example that includes the full suite of the package development tools (loading, documenting, testing, deploying, etc.). That’s what I’ve attempted to do with this book.\n\n\nDid you read R Packages, 2ed and find it difficult to apply package development practices to your shiny application?\n\n\nR Packages, 2ed primarily focuses on creating conventional R packages. This text is the premier reference for implementing the best practices when creating functions, writing documentation, managing package namespaces, and many other fundamental aspects of package development. However, R Packages, 2ed doesn’t cover the complexity of designing interactive user interfaces, server-side computations, or modules. Moreover, testing and debugging a Shiny application differs from the traditional methods used in R packages.2\n\n\nDid you read Engineering Production-Grade Shiny Apps and decide the golem framework wasn’t a good fit for your application?\n\n\ngolem is an ‘opinionated framework for building production-grade Shiny applications’ introduced in Engineering Production-Grade Shiny Apps (or EPGSA) that offers a robust and standardized way to build, maintain, and deploy production-grade Shiny apps. Whether due to the learning curve, overhead, dependencies, legacy code, or your particular deployment constraints, golem might not be the right fit for your situation.3"
  },
  {
    "objectID": "index.html#what-this-book-is",
    "href": "index.html#what-this-book-is",
    "title": "Shiny App-Packages",
    "section": "What this book is",
    "text": "What this book is\n\n\n\n\n\n\n\nThis book is a resource to help ‘connect the dots’ between building scalable Shiny applications and writing R packages. Adopting R package development practices in the early stages of your Shiny app will improve the reusability, maintainability, and shareability of all your hard work.\nFor continuity, I’ve used code and data from the excellent Building Web Applications with Shiny (BWAS) course. The learning modules in BWAS also serve as ‘prerequisites’ for many of the chapters covered here (if you haven’t completed that course, be sure you understand the topics it covers). You’ll find each section in this book also includes a dedicated GitHub repository and branch for you to follow along."
  },
  {
    "objectID": "index.html#what-this-book-isnt",
    "href": "index.html#what-this-book-isnt",
    "title": "Shiny App-Packages",
    "section": "What this book isn’t",
    "text": "What this book isn’t\nThis book isn’t a replacement for Mastering Shiny, R Packages, 2ed (or Writing R Extensions), or Engineering Production-Grade Shiny Apps. I highly suggest bookmarking those resources to return and read when you’d like to learn more about package development.\nI also won’t be recommending a particular Shiny framework or package, but I’ll cover a few popular choices, show you what they are doing ‘under the hood,’ and let you decide if you’d like to adopt some of their practices."
  },
  {
    "objectID": "index.html#what-i-assume-about-you",
    "href": "index.html#what-i-assume-about-you",
    "title": "Shiny App-Packages",
    "section": "What I assume about you",
    "text": "What I assume about you\nIf you’re reading this, I assume you’re comfortable with R, Posit Workbench, Shiny, and the tidyverse. Maybe you haven’t built a ton of applications, but you understand reactivity, and you’re comfortable with the core Shiny concepts (i.e., the UI, server, *_Input(), *_Output(), and render_* functions, etc.)."
  },
  {
    "objectID": "index.html#other-resources",
    "href": "index.html#other-resources",
    "title": "Shiny App-Packages",
    "section": "Other resources",
    "text": "Other resources\nExcellent resources have been written for Shiny, and it’s also worthwhile to consult the documentation on the core package development tools:\n\ndevtools\n\nusethis\n\nroxygen2"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "The ‘Converting an existing app’ chapter provides an example of converting a Shiny app into an R Package. However, many of the helpful package development tools aren’t available (i.e., roxygen2 tags, NAMESPACE imports/exports, tests, vignettes, etc.).↩︎\nTesting Shiny apps requires additional packages and tools to ensure an application’s reliability and performance.↩︎\ngolem apps are built as packages. Still, EPGSA assumes the reader is ‘comfortable with building an R package.’ (if you’re familiar with package development, EPGSA is an excellent resource).↩︎"
  },
  {
    "objectID": "intro.html#packages-help-you",
    "href": "intro.html#packages-help-you",
    "title": "Introduction",
    "section": "Packages help you",
    "text": "Packages help you\nThe first and obvious benefit to structuring your Shiny app as an R package is that it simplifies file and folder management. If every Shiny app project you develop is structured as an R package, it removes the time you spend manually creating directories (or re-orienting yourself to each project’s structure).\nIf you’re using Posit Workbench, the R package structure will give you access to a well-designed IDE for Shiny applications. Posit Workbench has tools to help develop and debug functions, create and run unit tests, store internal and external data, manage dependencies, and write help files and long-form documentation."
  },
  {
    "objectID": "intro.html#packages-help-them",
    "href": "intro.html#packages-help-them",
    "title": "Introduction",
    "section": "Packages help them",
    "text": "Packages help them\n\n“a package [is] the fundamental unit of shareable, reusable, and reproducible R code.” - R Packages, 2ed\n\nIt’s safe to assume the code used to build Shiny apps being deployed to a production environment will be seen (and hopefully used) by others. R packages make sharing your hard work with your colleagues easier because it removes their need to figure out where everything is, how it all fits together, and how it all (hopefully) works."
  },
  {
    "objectID": "intro.html#scalable",
    "href": "intro.html#scalable",
    "title": "Introduction",
    "section": "Scalable",
    "text": "Scalable\nSuppose you use R to perform analyses, design data visualizations, or build and run reports. If you currently use source() to load any utility functions to perform this work, I suggest putting those functions in a package. Doing this will help extend your mental model from the specific use cases (i.e., “X code performs task Y”) to a model for their more general uses (i.e., “X package performs tasks like Y”).\nGreat R packages define and solve common problems.\nThe beauty of an R package mental model is that you’ll inevitably notice the similarities across common problems. Creating packages that define and solve common problems in your workflow can sometimes be some of the most popular/valuable contributions (see datapasta and reprex)."
  },
  {
    "objectID": "intro.html#how-to-read-this-book",
    "href": "intro.html#how-to-read-this-book",
    "title": "Introduction",
    "section": "How to read this book",
    "text": "How to read this book\nThe chapters in this book (roughly) represent the steps of R package development, but from the lens of an existing shiny application.2 Each topic can be applied when creating new app-packages. Still, in my experience, many Shiny developers have existing applications they’d like to convert into an R package.\nThe first four chapters focus on a the development of Shiny app project and it’s gradual conversion into an app-package:\n\nChapter 1 is a ‘whole game’ for the development of a toy app-package. This chapter gives a high-level overview of the app-package development workflow.3\nIn Chapter 2 we’ll dive into shiny development, focusing on the files and folders found in most Shiny applications.\nR packages are introduced in Chapter 3, and it covers the differences between Shiny app projects, R packages, and Shiny app-packages.\nChapter 4 introduces devtools and the app-package development workflow.\n\nThe next section covers the primary elements of app-package development:\n\nChapter 5 covers documenting the application’s utility functions, modules, UI, server, and standalone app function using roxygen2.\nManging dependencies (both imports and exports) using the NAMESPACE file is introduced in Chapter 6.\nChapter 7 discusses the storage, format, and documentation of data files your app-package.\nThere are multiple ways to launch an application from an app-package. Chapter 8 covers options to include in the app.R file and your standalone app function.\nChapter 9 covers the many uses of the inst/ folder in R packages. This chapter also covers how to add external files and resources to your application.\n\nWhile developing your application, you’ll want to ensure it’s features are documented and tested. The next five chapters cover testing:\n\nBefore running any tests we need to set up the test suite in our app-package. Chapter 10 briefly covers setting up the testing infrastructure with testthat.\nKnowing what features to implement and what tests to develop reduces the chances of writing code that doesn’t address a user needs. Chapter 11 discusses how to identify user specifications, featurs, and functional requirements. It also briefly introduces behavior-driven development.\nChapter 12 covers how to include testing tools (fixtures and helpers) in your test suite to ensure isolated yet controllable test conditions.\nReactivity makes testing modules tricky. In Chapter 13, I’ll cover some strategies and approaches for verifying that your modules are communicating correctly with Shiny’s testServer() function.\nChapter 14 introduces performing system (or end-to-end) tests in you app-package with the shinytest2 package.\n\nIf you’re Googling ‘what is the best way to build a Shiny application?’ you’ll eventually encounter a Shiny framework. This section contains the development workflow and methods for three popular Shiny application frameworks (golem, leprechaun, and rhino).\n\nChapter 15 covers developing an application using the golem framework.\nFor developers looking for a ‘lightweight’ version of the golem package, Chapter 16 introduces the leprechaun package and development workflow\nThe Chapter 17 covers how to build a rhino application (which is not technically a package, but is still worth including based on it’s popularity and features).\n\nTransitioning from programming in R to building Shiny applications and writing R packages is complicated. It involves a shift in focus, skill set, and development practices. Reactivity and modules are a steep learning curve, especially if you’re also trying to understand how to develop an R package (with an application in it!).4 5\nThe chapters of this book are intended to help with the package development end of that learning curve.\n\nCode examples\n\n\n\n\n\n\n\nThis section’s code is in the main branch of moviesApp.\nThe code files for each chapter are stored in GitHub repositories. Major code changes are stored in branches. Whenever a new branch or repo is used, you’ll see the Git Branch icon with a link to the repo in the margin."
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "David Neuzerling has a great post on the benefits of structuring your project as a package↩︎\nThe original code and data for the application in this book comes from the Building Web Applications with Shiny (BWAS) course.↩︎\nR Packages, 2ed, has a similar chapter that covers developing standard R packages.↩︎\nEngineering Production-Grade Shiny Apps and the golem package assumes readers “are comfortable with building an R package.”↩︎\nMastering Shiny includes an example for converting an existing application with usethis::use_description(), but not creating a new app-package (i.e., with usethis::create_package()).↩︎"
  },
  {
    "objectID": "whole_game.html#toy-app-package-monthapppkg",
    "href": "whole_game.html#toy-app-package-monthapppkg",
    "title": "Whole app game",
    "section": "Toy app-package: monthAppPkg",
    "text": "Toy app-package: monthAppPkg\nThe monthAppPkg example we’re going to be developing has been adapted from Mastering Shiny.2"
  },
  {
    "objectID": "whole_game.html#use_description",
    "href": "whole_game.html#use_description",
    "title": "Whole app game",
    "section": "use_description()",
    "text": "use_description()\nEvery package needs a DESCRIPTION–calling devtools::load_all() without a DESCRIPTION will result in an error. The quickest way to create a description file is with usethis::use_description().3\n\nusethis::use_description(\n  list(Package = 'monthAppPkg',\n       Title = 'An example app-pkg',\n       Version = '0.0.0.9000',\n       Description = 'A shiny application built inside an R package.',\n       \"Authors@R\" = NULL,\n       Author = utils::person(                     \n          given = \"Jane\", \n          family = \"Doe\", \n          role = c(\"aut\", \"cre\")),\n        Maintainer = utils::person(\n          given = \"Jane\", \n          family = \"Doe\",\n          email = \"Jane.Doeh@email.io\"),\n        License = \"GPL-3\"))\n\nI’ve provided values to the fields list so this file isn’t generated with the boilerplate contents. The documentation for use_description() mentions putting this in your .Rprofile if you develop a lot of R packages (or app-packages!).4\nEvery R package needs the following seven fields:\n\nPackage: monthAppPkg\nTitle: An example app-pkg\nVersion: 0.0.0.9000\nAuthor: Jane Doe [aut, cre]\nMaintainer: Jane Doe &lt;Jane.Doeh@email.io&gt;\nDescription: A shiny application built inside an R package.\nLicense: GPL-3\n1\n\n\n1\n\nAlways leave an empty final line in the DESCRIPTION\n\n\n\n\nWe get the following fields for free (they will be required for function documentation and dependency management).\n\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3"
  },
  {
    "objectID": "whole_game.html#use_data",
    "href": "whole_game.html#use_data",
    "title": "Whole app game",
    "section": "use_data()",
    "text": "use_data()\nTo include the stones data in monthAppPkg, we create a script in data-raw/ with usethis::use_data_raw(\"stones\"), then move the birthstones.csv file into data-raw/, load it into the Global Environment and pass it to usethis::use_data():\n\nusethis::use_data_raw(\"stones\")\n\n✔ Setting active project to '/path/to/monthAppPkg'\n✔ Creating 'data-raw/'\n✔ Adding '^data-raw$' to '.Rbuildignore'\n✔ Writing 'data-raw/stones.R'\n• Modify 'data-raw/stones.R'\n• Finish the data preparation script in 'data-raw/stones.R'\n• Use `usethis::use_data()` to add prepared data to package\nMove birthstones.csv to data-raw/birthstones.csv:\n\nfs::file_move(path = \"birthstones.csv\", new_path = \"data-raw/birthstones.csv\")\n\nContents of data-raw/stones.R:\n\n## code to prepare `stones` dataset goes here\nlibrary(vroom)\nstones &lt;- vroom::vroom(\"data-raw/birthstones.csv\")\nusethis::use_data(stones, overwrite = TRUE)\n\nRows: 12 Columns: 2                                                                                                                                \n── Column specification ──────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): month, stone\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nusethis::use_data(stones)\n\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Setting LazyData to 'true' in 'DESCRIPTION'\n✔ Saving 'stones' to 'data/stones.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nData should be documented using roxygen2,5 which we’ll cover in the data chapter."
  },
  {
    "objectID": "whole_game.html#use_package",
    "href": "whole_game.html#use_package",
    "title": "Whole app game",
    "section": "use_package()",
    "text": "use_package()\nEvery Shiny app-package will need to import the shiny package as a dependency, which starts by listing it under the Imports field the DESCRIPTION file. We can do this using usethis::use_package().6\n\nusethis::use_package(\"shiny\")\n\n✔ Adding 'shiny' to Imports field in DESCRIPTION\n• Refer to functions with `shiny::fun()`\nWe’re advised to use explicit namespacing (i.e., pkg::fun()), but we can avoid this by importing Shiny’s functions into our package namespace.\nThe @import tag from roxygen2 can be used to import “the entire [shiny] namespace” into monthAppPkg.7"
  },
  {
    "objectID": "whole_game.html#load_all",
    "href": "whole_game.html#load_all",
    "title": "Whole app game",
    "section": "load_all()",
    "text": "load_all()\nShiny app development typically involves something like the following workflow:\n\nWrite UI code\n\nWrite server code\n\nClick Run App\n\nRinse, repeat\n\nWhen making the switch to app-package development, calling load_all() is somewhat analogous to clicking on the Run App icon–you’ll do it often (more than any other devtools or usethis function).\n\ndevtools::load_all()\n\nThe output we’re looking for from load_all() is straightforward:\nℹ Loading monthAppPkg\nload_all() is similar to calling library, but it’s specifically designed to be used during package development."
  },
  {
    "objectID": "whole_game.html#use_r",
    "href": "whole_game.html#use_r",
    "title": "Whole app game",
    "section": "use_r()",
    "text": "use_r()\nCreate new .R files under R/ using use_r():\n\nusethis::use_r(\"monthFeedback\")\n\n✔ Setting active project to '/projects/apps/monthAppPkg'\n• Modify 'R/monthFeedback.R'\nBoth UI and server module functions are stored in R/monthFeedback.R and R/birthstone.R. Tests should also be created for each function."
  },
  {
    "objectID": "whole_game.html#use_test",
    "href": "whole_game.html#use_test",
    "title": "Whole app game",
    "section": "use_test()",
    "text": "use_test()\nCreate new test- files under tests/testthat/ using using use_test():\n\nusethis::use_test(\"monthFeedbackServer\")\n\nThe first time you run use_test(), it will detect if your package has the testthat infrastructure (and create the necessary files if you don’t).8\nCalling use_test() adds the testthat package to the Suggests field in the DESCRIPTION and includes the edition (currently 3).\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\nThe tests/ folder will hold the necessary testing folder and files:\n\ntests/\n├── testthat/\n│   ├── test-birthstoneServer.R\n│   └── test-monthFeedbackServer.R\n└── testthat.R\n\n2 directories, 3 files\n\nTests are covered in Mastering Shiny,9 on the Shiny website,10 and in various testing packages (like shinytest11 and shinytest212)"
  },
  {
    "objectID": "whole_game.html#new-app.r-file-contents",
    "href": "whole_game.html#new-app.r-file-contents",
    "title": "Whole app game",
    "section": "New app.R file contents",
    "text": "New app.R file contents\nThe contents of app.R have been converted to a standalone app function (monthApp()), which is stored in the R/ folder.\nThe new contents of app.R includes a call to pkgload::load_all() and monthApp():\n\npkgload::load_all(\".\")\nmonthApp()\n\npkgload needs to be listed under Imports in the DESCRIPTION file (just like we did with shiny above).\n\nusethis::use_package(\"pkgload\")\n\n✔ Adding 'pkgload' to Imports field in DESCRIPTION\n• Refer to functions with `pkgload::fun()`\nBecause we’re only going to use load_all() from pkgload, we’ll use explicit namespacing (i.e., pkg::fun()).13\n\nuse_package_doc()\nThe use_package_doc() creates the R/[[name]-package].R file, which can be used as a single location for declaring dependencies in monthAppPkg:\n\nusethis::use_package_doc()\n\n✔ Setting active project to 'projects/apps/monthAppPkg'\n✔ Writing 'R/monthAppPkg-package.R'\n• Modify 'R/monthAppPkg-package.R'\nWe’ll use @importFrom to add only the load_all() function to the NAMESPACE.\n\n#' @keywords internal\n\"_PACKAGE\"\n\n## usethis namespace: start\n#' @importFrom pkgload load_all\n## usethis namespace: end\nNULL\n\n\n\nuse_build_ignore()\nR packages don’t typically have an app.R file in their root folder, so we’ll let devtools know this file should be ignored by creating a .Rbuildignore and include a pattern that excludes app.R whenever the package is built.\n\nusethis::use_build_ignore(\"app.R\")\n\n✔ Adding '^app\\\\.R$' to '.Rbuildignore'\nIt’s best to let use_build_ignore() handle excluding any files or folders from your package builds because it automatically writes the correct regular expression pattern."
  },
  {
    "objectID": "whole_game.html#license",
    "href": "whole_game.html#license",
    "title": "Whole app game",
    "section": "LICENSE",
    "text": "LICENSE\nIncluding a LICENSE file can be done with one of the usethis license functions. The license file should match the License field in the DESCRIPTION file (in this case, it’s MIT).\n\nusethis::use_mit_license()\n\nuse_mit_license() will automatically include the LICENSE.md file in the root folder (and includes the necessary pattern in the .Rbuildignore to exclude it from the package builds).\n✔ Adding 'MIT + file LICENSE' to License\n✔ Writing 'LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'"
  },
  {
    "objectID": "whole_game.html#document",
    "href": "whole_game.html#document",
    "title": "Whole app game",
    "section": "document()",
    "text": "document()\nAll of the files below R/ should include roxygen2 documentation. You can include an Roxygen skeleton in the IDE by clicking on Code &gt; Insert Roxygen Skeleton, or using the keyboard shortcut:\nOption/⌥ + Shift⇧ + Ctrl/Cmd + R\nAfter writing the documentation for the data, modules, and standalone app function, calling devtools::document()() generates the .Rd files and NAMESPACE\n\ndevtools::document()\n\nThe output from document() tells us what files have been created (and if there were any errors in them).14\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nWriting NAMESPACE\nWriting NAMESPACE\nWriting birthstoneUI.Rd\nWriting birthstoneServer.Rd\nWriting monthApp.Rd\nWriting monthFeedbackUI.Rd\nWriting monthFeedbackServer.Rd\n\nNAMESPACE\nThe NAMESPACE file contains the exported functions from monthAppPkg, and the two imports (shiny and pkgload::load_all()):\n# Generated by roxygen2: do not edit by hand\n\nexport(birthstoneServer)\nexport(birthstoneUI)\nexport(monthApp)\nexport(monthFeedbackServer)\nexport(monthFeedbackUI)\nimport(shiny)\nimportFrom(pkgload,load_all)"
  },
  {
    "objectID": "whole_game.html#project-options-.rproj",
    "href": "whole_game.html#project-options-.rproj",
    "title": "Whole app game",
    "section": "Project options (.Rproj)",
    "text": "Project options (.Rproj)\nIn order to enable the Build pane and keyboard shortcuts in the IDE, we need to update our .Rproj file. We can edit this file using file.edit():\n\nfile.edit(\"monthAppPkg.Rproj\")\n\nIf monthAppPkg was initially built as an RStudio project (i.e., not as a package), the following fields should be included at the bottom of monthAppPkg.Rproj:\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\nThese options are also available under Tools &gt; Project Options … &gt; Build Tools"
  },
  {
    "objectID": "whole_game.html#use_git",
    "href": "whole_game.html#use_git",
    "title": "Whole app game",
    "section": "use_git()",
    "text": "use_git()\nuse_git() is performed much earlier in R Packages, 2ed, but I’ve saved it for this step because using Git will prompt the IDE to re-initialize and display the Git pane (and it will also read our new settings in the .Rproj file).\n✔ Setting active project to '/projects/apps/monthAppPkg'\n✔ Initialising Git repo\n✔ Adding '.Rproj.user', '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\nThere are 12 uncommitted files:\n* '.gitignore'\n* '.Rbuildignore'\n* 'app.R'\n* 'data/'\n* 'DESCRIPTION'\n* 'LICENSE'\n* 'LICENSE.md'\n* 'man/'\n* 'monthAppPkg.Rproj'\n* 'NAMESPACE'\n* ...\nIs it ok to commit them?\n\n1: Absolutely not\n2: Not now\n3: Absolutely\nWe’ll agree to commit these files to Git:\nSelection: 3\n✔ Adding files\n✔ Making a commit with message 'Initial commit'\n• A restart of RStudio is required to activate the Git pane\nRestart now?\n\n1: Not now\n2: Negative\n3: Absolutely\nRestarting RStudio will activate the Git and Build panes:\n\n\n\nGit Pane\n\n\n\n\n\nBuild Pane\n\n\nThis will also activate the devtools keyboard shortcuts:\n\ndevtools keyboard shortcuts\n\n\n\nload_all()\nShift + Ctrl/Cmd + L\n\n\ndocument()\nShift + Ctrl/Cmd + D\n\n\n\n\ninstall()\nShift + Ctrl/Cmd + B\n\n\ntest()\nShift + Ctrl/Cmd + T"
  },
  {
    "objectID": "whole_game.html#install-1",
    "href": "whole_game.html#install-1",
    "title": "Whole app game",
    "section": "install()",
    "text": "install()\nNow we’re ready to install monthAppPkg with devtools::install(), which produces see the following output in the Build pane:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nDocumentation completed\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source monthAppPkg\n\n* installing to library ‘/path/to/Library/R/x86_64/4.2/library’\n* installing *source* package ‘monthAppPkg’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (monthAppPkg)\nBack in the Console, RStudio will restart and call library(monthAppPkg):\nRestarting R session...\n\n&gt; library(monthAppPkg)\nWe can now launch the app using monthApp()\n\nmonthApp()\n\n\n\n\nOur monthApp() application"
  },
  {
    "objectID": "whole_game.html#additional-files",
    "href": "whole_game.html#additional-files",
    "title": "Whole app game",
    "section": "Additional files",
    "text": "Additional files\nThe following sections cover additional files you should include in your ap-package (but are not required).\n\nuse_readme_rmd()\nThe README.md file is usually the initial point of contact for users and contributors looking for information about your app-package. use_readme_rmd() will create a README.Rmd (i.e., the file you’ll edit), which serves as the source document for your README.md.\n\nusethis::use_readme_rmd()\n\nThe README.Rmd pattern is automatically added to the .Rbuildignore, and includes a Git ‘pre-commit’ hook:\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n✔ Writing '.git/hooks/pre-commit'\nThis Git behavior is designed to prevent us from making changes to the README.Rmd and forgetting to re-render the README.md. If you find this behavior confusing or would like to disable it, run the following commands in the Terminal:\n\nrm .git/hooks/pre-commit\n\n\n\nuse_news_md()\nA NEWS.md is helpful for logging updates to your app-package and tracking release information.\n\nusethis::use_news_md()\n\nuse_news_md() will also prompt me to add and commit this file to the Git repository:\nThere is 1 uncommitted file:\n* 'NEWS.md'\nIs it ok to commit it?\n\n1: Negative\n2: Yeah\n3: Absolutely not\n\nSelection: 2\n✔ Adding files\n✔ Making a commit with message 'Add NEWS.md'\nThe contents of the NEWS.md are below:\n# monthAppPkg (development version)\n\n* Initial CRAN submission.\nThe 2nd bullet doesn’t apply to monthAppPkg, so I’ll remove it and re-commit/push the NEWS.md file.\n\n\nuse_vignette()\nVignettes can be used to store detailed tutorials, explanations of core concepts, use-cases, FAQs and troubleshooting, integration with other packages, etc.\n\nuse_vignette(\"monthAppPkg\")\n\nThe first time we call use_vignette() will prompt usethis to add the following fields in the DESCRIPTION:\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Adding 'knitr' to VignetteBuilder\nThe following files are also included in the .gitignore:\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'\n\n\n\n\n\n\n\n\n\nThis section’s code is in the main branch of monthAppPkg."
  },
  {
    "objectID": "whole_game.html#footnotes",
    "href": "whole_game.html#footnotes",
    "title": "Whole app game",
    "section": "",
    "text": "The example app comes from the Packages chapter of Mastering Shiny↩︎\nI’ve stored the code for this application in the monthAppPkg repository (to avoid confusing it with the actual application repo for this chapter).↩︎\nThe Whole Game chapter of R Packages, 2ed begins with the usethis::create_package() function, which calls usethis::use_description() internally.↩︎\nAt the time this was written, there are over 4,000 hits with the boilerplate value for Description (i.e., \"What the package does\"), which is a sign of how much usethis has been adopted (and how often people forget to come back and edit their DESCRIPTION file).↩︎\nView the documented stones dataset here on GitHub.↩︎\nWhenever you use a function from another package, start by running usethis::use_package() to ensure it’s in the DESCRIPTION file.↩︎\nI’ve included @import shiny above the definition of our standalone app function (R/movies_app.R), which means I don’t need to add shiny:: when using Shiny functions belowR/.↩︎\nYou can also set up the testthat infrastructure by calling usethis::use_testthat()↩︎\nThe Testing chapter in Mastering Shiny covers unit tests with testthat, shiny::testServer(), and the shinytest package.↩︎\nSee the ‘Server Function Testing’ article on the Shiny website for more information on testServer()↩︎\nCheck the shinytest package website and video tutorial for more information on testing your app.↩︎\nshinytest2 is an updated verison of shinytest with excellent documentation and videos.↩︎\nWe typically call devtools::load_all(), but using pkgload reduces the number of dependencies included with devtools. Read more about pkgload in the ‘Conscious uncoupling’ of devtools.↩︎\nThe files created by document() rely on the roxygen2 package (and should not be edited manually).↩︎"
  },
  {
    "objectID": "shiny.html#shiny-programming",
    "href": "shiny.html#shiny-programming",
    "title": "Shiny",
    "section": "Shiny programming",
    "text": "Shiny programming\nReactivity is the underlying process that allows Shiny apps to update and respond to user interactions automatically. Developing Shiny apps involves harnessing the connection between inputs, reactivity, and outputs to control and predict the application’s behavior.\nShiny programming differs from regular R programming in several key aspects:\n\nAn Event-driven UI: Shiny apps require developers to design and develop a user interface (UI). User experience (UX) design is an entirely separate field, but as Shiny developers, we need to know enough to allow users to interact with and navigate our apps. The UI also captures each ‘event,’ meaning that the user’s actions (such as button clicks or input changes) trigger the application’s inputs, updates, or outputs.\n\nRegular R programming often involves executing predefined steps or functions without direct interaction or responses to user events.\n\nA Reactive Server: In Shiny, the application’s behavior is determined by the dependencies between reactive inputs (i.e., the inputIds), reactive values, and outputs (i.e., the outputIds), allowing for automatic updates and propagation of changes throughout the application.\n\nIn standard R programming, we typically define a series of sequential steps (i.e., functions) that operate on data to generate output to the console or a typesetting system for technical and scientific publications (model results, graphs, tables, etc.) without accounting for reactivity or downstream changes.\n\n\nLearning reactivity can be challenging when you start, but fortunately, there are excellent tutorials and articles to help you along the way!"
  },
  {
    "objectID": "shiny.html#new-shiny-app-projects",
    "href": "shiny.html#new-shiny-app-projects",
    "title": "Shiny",
    "section": "New Shiny app projects",
    "text": "New Shiny app projects\n\n\n\n\n\n\n\nThis section’s code is in the main branch of moviesApp.\nIf you’re creating a new application using the New Project Wizard, you’ll see the following:\n\n\n\n\n\n(a) New Shiny app\n\n\nFigure 2.1: New Shiny app project\n\n\nSelect the location of your Shiny app project, then pick a name and decide whether you want to use Git or renv (I’ll be using Git).\n\n\n\n\n\n(a) Shiny app info\n\n\nFigure 2.2: New Shiny app project in a Git repository\n\n\nAfter clicking Create Project, a new session will open with your project files."
  },
  {
    "objectID": "shiny.html#shiny-app-project-contents",
    "href": "shiny.html#shiny-app-project-contents",
    "title": "Shiny",
    "section": "Shiny app project contents",
    "text": "Shiny app project contents\nNote that the only items in the new Shiny app project are app.R and the moviesApp.Rproj file.\n\nmoviesApp/\n    ├── app.R\n    └── moviesApp.Rproj\n\n1 directory, 2 files\n\n\napp.R\napp.R initially contains a boilerplate application, which we can launch by clicking on the Run App button:\n\n\n\n\n\nClick on Run App\n\n\n\n\n\n\n\n(a) Old Faithful geyser app\n\n\nFigure 2.3: Boilerplate Old Faithful geyser app in new Shiny projects\n\n\nThe boilerplate ‘Old Faith Geyser Data’ app is a perfect example of what Shiny can do with a single app.R file, but we’ll want to exchange this code for a slightly more advanced application (because most Shiny apps grow beyond an app.R file)."
  },
  {
    "objectID": "shiny.html#movie-review-data-app",
    "href": "shiny.html#movie-review-data-app",
    "title": "Shiny",
    "section": "Movie review data app",
    "text": "Movie review data app\nMost Shiny applications move beyond a single app.R file. Knowing how to store any utility functions, data, documentation, and metadata will set you up for success as you transition to storing your app in an R package.\n\n\n\n\n\n\n\nThis section’s code is in the 02_movies-app branch of moviesApp.\nI’m going to work through an example of some intermediate/advanced Shiny app features using the application from the Building Web Applications with Shiny course. This app is a great use case for the following reasons:\n\nIt has multiple input types that are collected in the UI\nThe graph output can be converted to a utility function\nThe app loads an external data file when it’s launched\nThe code is accessible (and comes from a trusted source)\n\n\nApp\nThe code below replaces the boilerplate ‘Old Faith Geyser Data’ app in app.R:\n\napp.R\n\n\nshow/hide movie review Shiny app\nui &lt;- shiny::fluidPage(\n  theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\n        \"The data represent\",\n        nrow(movies),\n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"\n      ),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n      shiny::p(shiny::em(\n        \"The code for this Shiny application comes from\",\n        shiny::a(\"Building Web Applications with shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"\n        )\n      ))\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- shiny::reactive({\n    tools::toTitleCase(input$plot_title)\n  }) |&gt;\n    shiny::bindEvent(input$update_plot_title,\n      ignoreNULL = FALSE,\n      ignoreInit = FALSE\n    )\n\n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n      df = movies,\n      x_var = input$x,\n      y_var = input$y,\n      col_var = input$z,\n      alpha_var = input$alpha,\n      size_var = input$size\n    ) +\n      ggplot2::labs(title = new_plot_title()) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\n\nUtility function\nI’ve added the scatter_plot() utility function in a new utils.R file:\n\nutils.R\n\n\nshow/hide scatter_plot()\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\nData\nThe movies.RData dataset contains reviews from IMDB and Rotten Tomatoes\n\nmovies.RData\nYou can download these data here\n\n\n\nUpdated movies app project contents\nThe moviesApp project now contains the following files:\n\nmoviesApp/\n  ├── app.R\n  ├── movies.RData\n  ├── moviesApp.Rproj\n  └── utils.R\n\n2 directories, 4 files\n\nTo run the movies app, we need to load the data and source the utils.R file by adding the code below to the top of the app.R file:\nAfter installing the packages below, add a comment (#) in front of these lines.\nI’ve placed the header below in the top of the app.R file:\n\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# data -----------------------------------------\nload(\"movies.RData\")\n\n# utils ----------------------------------------\nsource(\"utils.R\")\n\n\n1\n\nComment out these lines after installing pkgs\n\n\n\n\nClicking on Run App displays the movie review app:\n\n\n\n\n\n\n(a) movies app\n\n\nFigure 2.4: Movie review app"
  },
  {
    "objectID": "shiny.html#project-folders",
    "href": "shiny.html#project-folders",
    "title": "Shiny",
    "section": "Project folders",
    "text": "Project folders\nNow that we have a slightly more complex application in app.R, I’ll add a few project folders we can include in our project that have unique built-in behaviors. These folders will help organize your files and make additional resources available to your app.\n\n\n\n\n\n\n\nThis section’s code is in the 03_proj-app branch of moviesApp.\n\nR/\nIf your Shiny app relies on utility or helper functions (outside the app.R file), you can place this code in an R/ folder. Any .R files in the R/ folder will be automatically sourced when the application is run.\n\n\n\n\n\n\nPlace utils.R in R/ folder\n\n\n\n\n\nI’ve moved the utils.R file into the R/ folder in moviesApp:\n\nmoviesApp/\n     └── R/\n         └── utils.R\n\n1 directory, 1 file\n\n\n\n\nThe function that makes this process (i.e., sourcing any .R files in an R/ folder) possible is loadSupport(). We’ll return to this function in a later chapter, because the R/ folder has a similar behavior (but different function) in R packages.1\n\n\nwww/\nWhen you run a Shiny application, any static files (i.e., resources) under a www/ directory will automatically be made available within the application. This folder stores images, CSS or JavaScript files, and other static resources.\n\n\n\n\n\n\nCreate www/ folder and download image\n\n\n\n\n\nI’ve downloaded the Shiny logo (shiny.png) and stored it in the www/ folder.\n\nmoviesApp/\n     └── www/\n           └── shiny.png\n\n1 directory, 1 file\n\nIn the section below, we’ll reference shiny.png directly in the UI.\n\n\n\nFollowing the conventional folder structure will also help set you up for success when/if you decide to convert it into an app-package."
  },
  {
    "objectID": "shiny.html#project-files",
    "href": "shiny.html#project-files",
    "title": "Shiny",
    "section": "Project files",
    "text": "Project files\n\nREADME.md\nIncluding a README.md file in your root folder is a good practice for any project. README.md should contain relevant documentation for running app.R.\n\n\n\n\n\n\nCreate README.md\n\n\n\n\n\nI’ve included the content below in the README.md file\n# movies app\n\nThe original code and data for this Shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`moviesApp` branches](https://github.com/mjfrigaard/moviesApp/branches/all).\n\n\n\n\n\nDESCRIPTION\nDESCRIPTION files play an essential role in R packages, but they are also helpful in Shiny projects if I want to deploy the app in showcase mode.\n\n\n\n\n\n\nCreate DESCRIPTION\n\n\n\n\n\nI’ve included the content below in DESCRIPTION:\n\nType: shiny\nTitle: movies app\nAuthor: John Smith\nDisplayMode: Showcase                                                 \n                                                                      \n\n\n\n\n\n\n\nIt’s always a good idea to leave at least one &lt;empty final line&gt; in your DESCRIPTION file.\n\nAfter adding README.md and a DESCRIPTION file (listing DisplayMode: Showcase), the movies app will display the code and documentation when the app launches.2"
  },
  {
    "objectID": "shiny.html#project-code",
    "href": "shiny.html#project-code",
    "title": "Shiny",
    "section": "Project code",
    "text": "Project code\nThe following two items are considered best practices because they make your app more scalable by converting app.R into functions.\n\nModules\nShiny modules are a ‘pair of UI and server functions’ designed to compartmentalize input and output IDs into distinct namespaces,\n\n‘…a namespace is to an ID as a directory is to a file…’ - shiny::NS() help file.\n\nModule UI functions typically wrap the layout, input, and output functions in shiny::tagList(). Module server functions typically contain the ‘backend’ code in a Shiny server function. Both the UI and server module functions are linked by an id argument, which is created using shiny::NS() (namespace) in the UI function and called in the server function with shiny::moduleServer().\n\nVariable inputs module\nmod_var_input_ui() creates a dedicated namespace for the inputIds with shiny::NS():\n\nR/mod_var_input.R\n\n\nshow/hide mod_var_input_ui()\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n1      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n2      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n3      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n4      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n5      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n6      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\nmod_var_input_server() returns these values in a reactive list with shiny::reactive():\n\n\nshow/hide mod_var_input_server()\nmod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n1            \"y\" = input$y,\n2            \"x\" = input$x,\n3            \"z\" = input$z,\n4            \"alpha\" = input$alpha,\n5            \"size\" = input$size,\n6            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\n\n\n\nScatter-plot display module\nmod_scatter_display_ui() creates a dedicated namespace for the plot outputId (as \"scatterplot\"), along with some help text:\n\nR/mod_scatter_display.R\n\n\nshow/hide mod_scatter_display_ui()\nmod_scatter_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\"The data for this application comes from the \",\n        shiny::tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))\n      ),\n1    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n1\n\nNamespaced module id for plot in UI\n\n\n\n\nThe code to render the output$scatterplot is contained in the nested call to shiny::moduleServer() in mod_scatter_display_server():\nAfter 1) loading the movies data, 2) assembling the returned values from mod_var_input_server(), and creating the input() reactive, 3) the scatter_plot() utility function creates the plot object and adds the plot_title() and theme:\n\n\nshow/hide mod_scatter_display_server()\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    \n1    load(\"movies.RData\")\n\n2    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n3    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n4      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(\n                  tools::toTitleCase(\n                      inputs()$x),\n                  \"_\", \" \"),\n          y = stringr::str_replace_all(\n                  tools::toTitleCase(\n                    inputs()$y),\n                \"_\", \" \")\n        ) + \n5        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n1\n\nloading the movies data\n\n2\n\nassembling the returned values from mod_var_input_server(), and creating the input() reactive\n\n3\n\nscatter_plot() utility function creates the plot object\n\n4\n\nadds the plot_title()\n\n5\n\nadd theme to layers\n\n\n\n\nBoth UI and server module functions are combined into a single .R file, and all modules are placed in the R/ folder so they are sourced when the application is run.\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n └── utils.R\n\n\n\n\n\nStandalone app function\nBoth module functions are combined in the ui and server arguments of shiny::shinyApp(). The id arguments (\"vars\" and \"plot\") connect the UI functions to their server counterparts, and the output from mod_var_input_server() is the var_inputs argument in mod_scatter_display_server().\nThe call to shiny::shinyApp() is wrapped in the movies_app() function and placed in app.R.\n\napp.R\n\n\nshow/hide movies_app() in app.R\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\n2library(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nmovies_app &lt;- function() { \n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n3          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n4          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n5      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n6      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nmovies_app()\n\n\n\n1\n\nHeader (comment this out after the packages are installed)\n\n2\n\nLoad packages\n\n\n3\n\nVariable input UI module\n\n4\n\nGraph display UI module\n\n5\n\nVariable input server module\n\n6\n\nGraph display server module\n\n\n\n\nNow, I can run the app with movies_app().\n\n\n\n\n\n\n(a) Movie reviews app\n\n\nFigure 2.5: View a deployed version here.\n\n\n\nThe deployed files of moviesApp are below:\n\nmoviesApp/ # 03_proj-app branch\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── moviesApp.Rproj\n├── rsconnect/\n│   └── shinyapps.io/\n│       └── user/\n│           └── moviesApp.dcf\n└── www/\n    └── shiny.png\n\n6 directories, 10 files\n\n\n\nThe rsconnect/ folder has been removed from the 03_proj-app branch."
  },
  {
    "objectID": "shiny.html#additional-features",
    "href": "shiny.html#additional-features",
    "title": "Shiny",
    "section": "Additional features",
    "text": "Additional features\nBelow are two additional ‘optional’ features that can be included with your Shiny application (I consider these ‘optional’ because they’re use depends on the specific needs and environment for each application).\n\nGlobal variables/functions with global.R\nPlacing a global.R file in your root folder (or in the R/ directory) causes this file to be sourced only once when the Shiny app launches, rather than each time a new user connects to the app. global.R is commonly used for initializing variables, loading libraries, loading large data sets and/or performing initial calculations.\n\n\n\n\n\n\nUsing global.R\n\n\n\n\n\nI could place the header from app.R in global.R to ensure these packages are loaded before the application launches:\n\n\nshow/hide contents of R/global.R\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n\nglobal.R can be placed in the R/ folder\n\nR/\n├── global.R\n├── mod_scatter_display.R\n├── mod_var_input.R\n└── utils.R\n\n1 directory, 4 files\n\nOr in the project root folder\n\n├── DESCRIPTION\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── global.R\n├── man\n├── movies.RData\n├── moviesApp.Rproj\n└── www\n    └── shiny.png\n\n4 directories, 10 files\n\nIn both locations, it will be sourced before launching the application.\n\n\n\nglobal.R can be used to maintain efficiency and consistency across application sessions.\n\n\nProject dependencies with renv\nIf you use renv, keep track of your dependencies by regularly running renv::status() and renv::snapshot().\n\n\n\n\n\n\nUsing renv\n\n\n\n\n\nStart by initiating renv with renv::init(), then run renv::status() to check which packages have been added to the lockfile:\n\nrenv::status()\n\n\n\nshow/hide example renv::status() output\nThe following package(s) are in an inconsistent state:\n\n package      installed recorded used\n colorspace   y         n        y   \n fansi        y         n        y   \n farver       y         n        y   \n ggplot2      y         n        y   \n gtable       y         n        y   \n isoband      y         n        y   \n labeling     y         n        y   \n lattice      y         n        y   \n MASS         y         n        y   \n Matrix       y         n        y   \n mgcv         y         n        y   \n munsell      y         n        y   \n nlme         y         n        y   \n pillar       y         n        y   \n pkgconfig    y         n        y   \n RColorBrewer y         n        y   \n scales       y         n        y   \n shinythemes  y         n        y   \n tibble       y         n        y   \n utf8         y         n        y   \n vctrs        y         n        y   \n viridisLite  y         n        y   \n\n\nTake a ‘snapshot’ to capture the current package dependencies:\n\nrenv::snapshot()\n\n\n\nshow/hide example renv::snapshot() output\nThe following package(s) will be updated in the lockfile:\n\n# CRAN --------------------------------------------------\n- lattice        [* -&gt; 0.21-8]\n- MASS           [* -&gt; 7.3-60]\n- Matrix         [* -&gt; 1.5-3]\n- mgcv           [* -&gt; 1.8-42]\n- nlme           [* -&gt; 3.1-162]\n- vctrs          [* -&gt; 0.6.3]\n\n# RSPM --------------------------------------------------\n- colorspace     [* -&gt; 2.1-0]\n- fansi          [* -&gt; 1.0.4]\n- farver         [* -&gt; 2.1.1]\n- ggplot2        [* -&gt; 3.4.2]\n- gtable         [* -&gt; 0.3.3]\n- isoband        [* -&gt; 0.2.7]\n- labeling       [* -&gt; 0.4.2]\n- munsell        [* -&gt; 0.5.0]\n- pillar         [* -&gt; 1.9.0]\n- pkgconfig      [* -&gt; 2.0.3]\n- RColorBrewer   [* -&gt; 1.1-3]\n- scales         [* -&gt; 1.2.1]\n- shinythemes    [* -&gt; 1.2.0]\n- tibble         [* -&gt; 3.2.1]\n- utf8           [* -&gt; 1.2.3]\n- viridisLite    [* -&gt; 0.4.2]\n\nDo you want to proceed? [Y/n]: y\n\n- Lockfile written to '~/path/to/moviesApp/renv.lock'."
  },
  {
    "objectID": "shiny.html#recap",
    "href": "shiny.html#recap",
    "title": "Shiny",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some differences between developing Shiny apps and regular R programming, creating new Shiny projects in Posit Workbench, and some practices to adopt that can make the transition to app-packages a little easier. The code used in this chapter is stored in the moviesApp repository.\n\n\n\n\n\n\nRecap\n\n\n\n\n\n\n\nPlacing utility or helper files in an R/ folder removes the need to call source() in app.R.\nImages, CSS, JavaScript, and other static resources can be stored in www/ and Shiny will serve these files when the application is run.\nREADME.md files can document the application’s description, purpose, requirements, etc.\nDESCRIPTION files provide metadata and include fields that affect application deployment (i.e., DisplayMode: Showcase)\nConverting the application code into functions (modules and standalone app functions) creates a ‘division of labor’ for each component, which makes it easier to think about and work on them independently.\nFinally, if you’re using renv, run renv::status() and renv::snapshot() to manage dependencies\n\n\n\n\n\nIn the next chapter, I’ll cover what makes a package a package, and some do’s and don’ts when converting a developed Shiny application into an R package."
  },
  {
    "objectID": "shiny.html#footnotes",
    "href": "shiny.html#footnotes",
    "title": "Shiny",
    "section": "",
    "text": "Shiny introduced these features in version 1.3.2.9001, and you can read more about them in the section titled, ‘The R/ directory’ in App formats and launching apps↩︎\nRead more about showcase mode here↩︎"
  },
  {
    "objectID": "packages.html#projects-packages-and-app-packages",
    "href": "packages.html#projects-packages-and-app-packages",
    "title": "Packages",
    "section": "Projects, packages, and app-packages",
    "text": "Projects, packages, and app-packages\nBefore we start, we should establish some operational definitions of what is meant by the terms ‘project’, ‘package’, and ‘app-package’.\n\n\nI’ll use color to differentiate Shiny app projects, R packages, and Shiny app-packages\n\nShiny Projects: I consider a Shiny app project to be any directory of files requiring R (the binary downloaded from CRAN with a version number and neat names like, ‘R 4.3.1 “Beagle Scouts” released on …’) to execute with an RStudio/Posit workbench project file (.Rproj) and an application (contained in an app.R file or ui.R/server.R files).\nR Packages: I’ll use the term R package to describe a directory of functions, documentation, or data that can be installed and loaded into an R session. An R package includes the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench.\nShiny app-packages: A Shiny app-package (which you have probably already guessed) is an R package containing a Shiny application. Shiny app-packages have all of the functionality of a standard R Package but also contain the files and folders required to successfully develop, run, and deploy a Shiny app.\n\n\nMotivation\nThere are multiple reasons for deciding to develop a Shiny app-package: your Shiny app project might need to be in an R package structure due to specific organizational practices around deploying applications, or maybe you’ve been convinced it will improve the shareability/reproducibility of your Shiny project.\nRegardless of the reason, you’ve likely found yourself in one of two circumstances:\n\nYou want to develop a new app, but want it structured as an R package.\nYou’ve already developed a Shiny app project, but now you need to convert it to a Shiny app-packages\n\nThe previous chapter covered a few practices to adopt during Shiny development that improve the extensibility of your Shiny app project and make it easier to convert into a Shiny app-package.1\n\n\n\n\n\n\nR Packages & Posit Workbench\n\n\n\n\n\n\nPosit Workbench (formerly RStudio) is a popular integrated development environment (IDE) that streamlines many R package development tasks. I’ve purposely connected Posit Workbench to the definitions above for R package and Shiny app-packages–specifically, the package development tools provided in the Build pane and devtools.\nHowever, developing R packages in Posit Workbench (or using .Rproj files) is not required. There are alternative package development tools and processes outside of Posit Workbench, and many developers employ these setups.\nPackage development outside Posit Workbench would look almost identical to development in the IDE:\n\nCreate the package structure (R/ folder for .R scripts, man/ folder for documentation, data/ folder for datasets, etc.)\nAdd DESCRIPTION and NAMESPACE files, etc.\nEnsure the package can be installed and loaded into an R session.\n\nIt’s also possible to use many of the development workflow functions we’ll cover here outside of the IDE (roxygen2::roxygenize(), devtools::check(), devtools::install(), etc.).\n\n\n\n\n\n\nR packages vs. Shiny projects\nBelow are folder trees with some of the typical files and folders found in R packages (on the left) and the files that currently exist in moviesApp (on the right), our Shiny app project.\n\n\n\n&lt;R package&gt;/\n    ├── DESCRIPTION\n    ├── &lt;R package&gt;.Rproj\n    ├── LICENSE \n    ├── LICENSE.md \n    ├── NAMESPACE \n    ├── NEWS.md\n    ├── README.Rmd\n    ├── README.md\n    ├── renv.lock\n    ├── R/\n    ├── man/\n    ├── tests/\n    ├── data/ \n    ├── data-raw/ \n    ├── vignettes/ \n    ├── inst/ \n    └── renv/\n  \n\n\nmoviesApp/\n├── DESCRIPTION\n├── moviesApp.Rproj\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n└── www/\n    └── shiny.png\n\n4 directories, 9 files\n\n\n\nR packages can be easily shared, reused, and reproduced because they all have a familiar structure, and each folder and file plays an essential role in extending R’s capabilities.2\nThis chapter will cover the minimum requirements for an R package, so you can handle both creating new Shiny app-packages and converting existing Shiny projects into Shiny app-packages."
  },
  {
    "objectID": "packages.html#what-makes-an-r-package",
    "href": "packages.html#what-makes-an-r-package",
    "title": "Packages",
    "section": "What makes an R package?",
    "text": "What makes an R package?\nIf you’ve done some research on R packages, you’ve probably encountered one (or both) of the following statements,\n\n‘Every package must have a DESCRIPTION. In fact, it’s the defining feature of a package (RStudio and devtools consider any directory containing DESCRIPTION to be a package)’ - R Packages, 2ed (Chapter 9, DESCRIPTION)\n‘all a project needs to be a package is a directory of R/ files and a DESCRIPTION file.’ - Mastering Shiny (Chapter 20, Packages)\n\nThe information above should be confusing if you’ve been following along with the code in moviesApp.\nWe’ve created a Shiny app project (moviesApp) with a DESCRIPTION file and an R/ directory, but it’s not a functioning R package.\nAs we noted above, a functioning R package can be installed and loaded into an R session and has access to the Build pane in the IDE.\n\nCan we load it with devtools?\nPackage development kicks off with the load_all() function from devtools, which is similar to calling library() (we’ll cover this function extensively in the devtools chapter). However, when we attempt to load the code in the R/ folder with load_all(), we see the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n(a) Load All Error\n\n\nFigure 3.1: devtools is looking for the Package field in our DESCRIPTION file\n\n\n\n\nWhere is the ‘Build’ pane?\nWhen opened, functioning R packages have access to the Build pane, which allows developers to quickly load, install, and test their packages.\nBut when moviesApp is opened, the Build pane is not displayed in the IDE:\n\n\n\n\n\n\n(a) moviesApp IDE\n\n\nFigure 3.2: Project IDE panes\n\n\n\nAs we’ve just learned, the presence of the DESCRIPTION file and an R/ folder are insufficient to turn a Shiny app project into a functioning R package (or a Shiny app-package)."
  },
  {
    "objectID": "packages.html#what-really-makes-an-r-package",
    "href": "packages.html#what-really-makes-an-r-package",
    "title": "Packages",
    "section": "What really makes an R package?",
    "text": "What really makes an R package?\n\n“A project needs a DESCRIPTION file with specific fields, a directory of R/ files, and a properly configured .Rproj file to be a functioning R package.”\n\nLet’s see how each of these requirements work together to convert the contents of moviesApp from a Shiny project into a Shiny app-package.\n\nDESCRIPTION fields\n\n\n\n\n\n\n\nThis section’s code is in the 04_description branch of moviesApp.\nThe official R documentation3 lists the following required fields for the DESCRIPTION in R packages:\n\nThe ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and ‘Maintainer’ fields are mandatory.\n\nBelow is an example DESCRIPTION file for moviesApp with the mandatory fields:4\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\n\n\n\n\nAuthor and Maintainer fields\n\n\n\n\n\nNote that the Author and Maintainer fields require additional information beyond first and last name (i.e., John Smith). These can be created with the utils::person() function:\n\n# Author\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  role = c(\"aut\", \"cre\"))\n## [1] \"John Smith [aut, cre]\"\n# Maintainer\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  email = \"John.Smith@email.io\")\n## [1] \"John Smith &lt;John.Smith@email.io&gt;\"\n\n\n\n\nAfter adding the mandatory fields to the DESCRIPTION file, devtools::load_all() runs without the previous error, but the IDE still doesn’t display the Build pane:\n\n\n\n\n\n\n(a) moviesApp IDE\n\n\nFigure 3.3: Where is the Build pane?\n\n\n\n\n\nProject Options…\n(i.e., the .Rproj file)\n.Rproj files are plain text files with various settings for the IDE. We were able to run devtools::load_all() above without the presence of the Build pane because the IDE displays the Build pane after reading the fields in the .Rproj file.\nThe quickest way to access the fields in the .Rproj file is under Tools &gt; Project Options….\n\nDefault options\nTools &gt; Project Options… provide access to the project-level options. For example, fields 2 - 4 are available under General, 5 - 8 affect the Code options, and the final two fields deal with Sweave.\n\n\n\n\n\n(a) moviesApp.Rproj fields\n\n\nFigure 3.4: Field settings from moviesApp.Rproj file\n\n\nThe default settings were created when we selected the Shiny app project from the New Project Wizard in the last chapter.\n\n\nBuild tools\nI’ve placed the .Rproj file from moviesApp with the example .Rproj file from R Packages, (2ed) side-by-side so you can compare them below:5\n\n\n\n\n\n(a) .Rproj files\n\n\nFigure 3.5: Comparison of moviesApp.Rproj file and .Rproj file in R Packages, 2ed\n\n\nI’ve circled the fields in the .Rproj file that illustrate it’s configured to work with an R package. Note that in moviesApp, the Project build tools are initially set to (None) under Build Tools:\n\n\n\n\n\n(a) moviesApp.Rproj build tools\n\n\nFigure 3.6: Build tool settings in moviesApp.Rproj file\n\n\nChanging the Project build tools option to Package will set the default Build Tools options:6\n\n\n\n\n\n(a) Default package build tools\n\n\nFigure 3.7: Default build tool settings\n\n\nThe links between the Build Tools options and fields in moviesApp.Rproj are in the figure below:\n\n\n\n\n\n(a) moviesApp.Rproj build tool fields\n\n\nFigure 3.8: Default build tool settings in moviesApp.Rproj file\n\n\n\nBuildType: Package tells the IDE moviesApp is an R package and triggers the Build pane.\nPackageUseDevtools: Yes links the options in the Build pane to the devtools package.\nThe PackageInstallArgs are complicated, but I’ve included some information about them in the callout block below (and you can read more in the official R documentation)\nThe fourth option (PackageRoxygenize) is available under Generate documentation with Roxygen &gt; Use roxygen to generate:\n\nThese options affect the documentation in an R package. To match the example from R Packages, 2ed above, make sure Rd files, Collate field, and NAMESPACE file are selected and click OK.\n\n\n\n\n\n\n\n(a) PackageRoxygenize in .Rproj file\n\n\nFigure 3.9: roxygen2 build settings\n\n\nAfter clicking OK, the IDE will automatically reboot, and the additional fields will be added to the bottom of the moviesApp.Rproj:\n\n\n\n\n\n\n\nThis section’s code is in the 05_rproj branch of moviesApp.\n\nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\n                                            \n\n\n\n\n\n\n\nWhat is --no-multiarch --with-keep.source?\n\n\n\n\n\n\n\n--no-multiarch: refers to the option for the package installer to only compile the package for the architecture of the current R session. By default, R tries to compile packages for 32-bit and 64-bit architectures if running in a 64-bit R session on Windows. This flag can help avoid problems if a package can only be compiled on one architecture. Read more here.\n--with-keep.source: In R, when a function is created, its body can be stored in two ways: 1) as a parsed but unevaluated expression and 2) as a character string containing the function’s source code. By default, only the parsed expression is kept. If –with-keep.source is specified, R will also keep the source code as a character string, which can be helpful for debugging and tools that analyze or modify source code. Read more here.\n\n\n\n\n\n\n\nBuild pane\nWhen the new session starts, the new project-level options activate the Build pane in the IDE.\n\n\n\n\n\n\n(a) Build pane in IDE\n\n\nFigure 3.10: Build pane triggered from project-level settings\n\n\n\nWhen the IDE reboots, I can see the Build pane has been added, and I can check the R package functionality by loading the code with Build &gt; Load All\n\n\n\n\n\n(a) Load the code in the R/ folder\n\n\nFigure 3.11: Identical to running devtools::load_all()\n\n\nI should see the following in the Console:\nℹ Loading moviesApp\nThere you have it–moviesApp is a functional R package!"
  },
  {
    "objectID": "packages.html#functional-r-packages",
    "href": "packages.html#functional-r-packages",
    "title": "Packages",
    "section": "Functional R packages",
    "text": "Functional R packages\n\n\n\n\n\n\n(a) Shiny app-package (with DESCRIPTION and Build pane)\n\n\nFigure 3.12: Fully functional Shiny app-package\n\n\n\nIn a functional R package:\n\nThe DESCRIPTION file contains the seven mandatory fields (Package, Version, License, Description, Title, Author, and Maintainer), making running the necessary devtools functions possible.\nThe .Rproj file contains the three package configuration fields (BuildType: Package, PackageUseDevtools: Yes, and PackageInstallArgs: --no-multiarch --with-keep.source), which makes the Build pane accessible and functional.\n\nThink of the two items above as a two-part process: the DESCRIPTION requires specific fields,7 and the IDE requires .Rproj fields to trigger the Build pane."
  },
  {
    "objectID": "packages.html#creating-shiny-app-packages-with-create_package",
    "href": "packages.html#creating-shiny-app-packages-with-create_package",
    "title": "Packages",
    "section": "Creating Shiny app-packages with create_package()",
    "text": "Creating Shiny app-packages with create_package()\nThe Posit documentation lists the following way(s) to create R packages:8\n\n\nCall usethis::create_package().\nIn RStudio, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\n\ncreate_package() is a great option if you’re looking for a way to quickly create or convert your Shiny project into a Shiny app-package. In the following sections I’ll cover some suggestions for using create_package().9\n\nNew Shiny app-packages\nIf you haven’t written any code and want to create a new Shiny app-package, create_package() is the quickest way to get started.\nFirst, install devtools:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\ndevtools automatically loads usethis\nLoading required package: usethis\nAssuming your current working directory is where you want your new Shiny app-package, call usethis::create_package() with the path argument set to getwd()\n\nusethis::create_package(path = getwd())\n\nThis call launches a series of actions:\n\nFirst, the active project is set to whatever was given to the path argument.\n✔ Setting active project to 'path/to/newApp'\nThe R/ folder and DESCRIPTION/ file are created:\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\nThe NAMESPACE and .Rproj files are created:\n✔ Writing 'NAMESPACE'\n✔ Writing 'newApp.Rproj'\nThe .Rproj is added to the .Rbuildignore file, the .Rproj.user folder is added to the .gitignore and .Rbuildignore files.\n✔ Adding '^newApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\nA new session is opened from the new .Rproj file:\n✔ Opening 'path/to/newApp/' in new RStudio session\n\nWhen the new session opens, newApp has the following contents:\n\nnewApp/\n  ├── .Rbuildignore\n  ├── .Rproj.user/\n  ├── .gitignore\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── newApp.Rproj\n\nYou’re now free to develop newApp. Store and document any .R files in the R/ folder, edit the DESCRIPTION file with details about the application, read through R Packages and Mastering Shiny, and add the Shiny code to complete your Shiny app-package.\n\n\nConverting existing Shiny projects\nIf you already have a Shiny app project that needs to be converted into a Shiny app-package (like the app files stored in the 03_proj-app branch), you can also use create_package(path = getwd()) in your root folder, but I recommend using the following arguments:\n\nDESCRIPTION arguments\n\nfields: these are arguments passed to usethis::use_description(). If the fields argument is empty, a boilerplate DESCRIPTION file is created (similar to this one).\n\nThese boilerplate fields in the DESCRIPTION work, but I’ve found some of the fields are unnecessary (i.e., I’ve never needed Authors@R: or ORCID) and inevitably require revision, so I’d prefer to handle this during the creation process (and remove the risk of forgetting to change it later).\nAll fields should be passed in a list() as field = 'value' pairs.\n\n\nusethis::use_description(\n    list(Package = 'moviesApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review Shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"))\n\n\nA few fields require specially formatted values (see the utils::person() examples below).\n\nutils::person(\"John\", \"Smith\", \n              email = \"John.Smith@email.io\", \n              role = c(\"aut\", \"cre\"))\n\n[1] \"John Smith &lt;John.Smith@email.io&gt; [aut, cre]\"\n\n\n\nTwo additional arguments from use_description() are passed to create_package():\n\ncheck_name: verifies your Shiny app-package name is valid for CRAN, so we can set this to FALSE (unless you’re planning on submitting to CRAN)\nroxygen2: is TRUE by default and adds the fields required to use roxygen2 (which I won’t cover here because we’ll cover documentation in-depth in a future chapter).\n\n\n\n\n\n\n\n\nWARNING: Don’t use usethis::create_package('.')!\n\n\n\n\n\n\nWhen converting your existing Shiny app project into a Shiny app-package with usethis::create_package(), don’t use '.' in the path argument:\nusethis::create_package('.')\nThis will return the following warning about creating nested projects, and ask if you want to proceed anyway:\nNew project 'moviesApp' is nested inside an existing project\n'./', which is rarely a good idea. If this is unexpected, \nthe here package has a function,\n`here::dr_here()` that reveals why './' is regarded as a\nproject.\n  \nDo you want to create anyway?\n\n1: Yes\n2: No way\n3: Not now\nWe can avoid this warning altogether by passing getwd() to the path argument, so I recommend cancelling the project creation:\nSelection: 2\nError: Cancelling project creation.\n\n\n\n\n\n\nIDE arguments\n\nrstudio: adds the necessary Build Tools fields in the .Rproj file (leave as TRUE)\nopen: can be set to FALSE because we don’t need RStudio/Posit Workbench to open in a new session\n\n\nusethis::create_package(\n  path = getwd(),\n  fields = list(Package = 'moviesApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review Shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"),\n  roxygen = TRUE,\n  check_name = FALSE, \n  rstudio = TRUE,\n  open = FALSE)\n\nAfter running usethis::create_package() with the arguments above, the IDE will present us with a few prompts to confirm:\nOverwrite pre-existing file 'DESCRIPTION'?\nOverwrite pre-existing file 'moviesApp.Rproj'?\nThe Shiny app-package structure is below:\n\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── moviesApp.Rproj\n└── www\n    └── Shiny.png\n\n3 directories, 10 files\n\nThe DESCRIPTION file (shown below) has a few additional fields (Encoding, Roxygen, and RoxygenNote) we didn’t include when we converted moviesApp above, but we will cover these in the upcoming chapters.\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith &lt;John.Smith@email.io&gt; [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 06b_devtools branch of moviesApp."
  },
  {
    "objectID": "packages.html#recap",
    "href": "packages.html#recap",
    "title": "Packages",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered the mandatory fields in the DESCRIPTION file and the R package configuration fields in .Rproj. We also covered creating and converting Shiny app projects using the usethis::create_package() function.\n\n\n\n\n\n\nRecap: Packages!\n\n\n\n\n\n\n\nThe DESCRIPTION file ultimately controls whether you have a functional Shiny app-package.\n\nThe mandatory fields are Package, Version, License, Description, Title, Author, and Maintainer.\n\nusethis::create_package() can be used to create a new R package and to convert an existing Shiny project into a Shiny app-package.\nThe IDE reads RStudio (.Rproj) files and determines R session settings at the project-level (i.e., working directory, workspace, history, code formatting, etc.)\n\nPackage development settings can be accessed via Project Options &gt; Build Tools.\n\n\n\n\n\n\nIn the next chapter, I’ll cover how you can quickly Load, Document, and Install your package!\nend packages.qmd"
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "Packages",
    "section": "",
    "text": "Shiny app project features are covered in this section of the Shiny chapter.↩︎\nFortunately, Shiny app-packages don’t require all the files and folders displayed in the folder tree to gain the functionality and benefits of an R package.↩︎\nThe mandatory fields are covered in Writing R Extensions, ‘The DESCRIPTION file’↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎\n.Rproj files are covered in the What makes an RStudio Project? section of R Packages (2 ed)↩︎\nThe initial Build Tools settings (i.e., (None)) should help explain the absence of any R package development fields in the moviesApp.Rproj when we compared it to the version in R Packages, 2ed (i.e., BuildType, PackageUseDevtools, PackageInstallArgs, and PackageRoxygenize).↩︎\nThe mandatory fields prevent the devtools error we encountered above.↩︎\nThis information comes from the Writing R Packages documentation for Posit Workbench.↩︎\nusethis::create_package() is covered in the ‘Fundamental development workflows’ chapter of R Packages, 2ed↩︎"
  },
  {
    "objectID": "development.html#developing-packages-with-devtools",
    "href": "development.html#developing-packages-with-devtools",
    "title": "Development",
    "section": "Developing packages with devtools",
    "text": "Developing packages with devtools\n\n“One package to rule them all.” - Not the devtools development team\n\nIf you’re new to package development, having a little background on the devtools package is helpful. Earlier versions of devtools contained most of the functions used for package development. In version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\n\nThe usethis package contains the functions for creating package folders and files (.R files, tests, vignettes, etc.). usethis is also automatically loaded when you call library(devtools).\nLoading and building your app-package is handled by pkgload and pkgbuild\nFor app-packages destined for CRAN, the R CMD check is handled by rcmdcheck and revdepcheck\nInstalling packages from non-CRAN repositories (i.e., install_github()) is handled by remotes\n\nYou don’t have to install all of these packages (they will be loaded with devtools), but the information is essential because it affects the dependencies in your app-package:\n\n‘Package developers who wish to depend on devtools features should also pay attention to which package the functionality is coming from and depend on that rather than devtools. In most cases, packages should not depend on devtools directly.’ - devtools 2.0.0, tidyverse blog\n\nWe will cover this topic more in the dependencies chapter."
  },
  {
    "objectID": "development.html#moviesapp",
    "href": "development.html#moviesapp",
    "title": "Development",
    "section": "moviesApp",
    "text": "moviesApp\nLet’s assume we’re continuing with the app project we converted manually in the 04_description branch of moviesApp (the files and folders are below).\n\n\n\n\n\n\n\n\nGit branch: 04_description\n\n\nmoviesApp/ # 04_description branch\n  ├── DESCRIPTION\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── moviesApp.Rproj\n  └── www\n      └── shiny.png\n\n4 directories, 9 files\n\nWe’re backing up to the branch we created by manually editing the DESCRIPTION file to show the connection between the devtools functions and specific fields in the DESCRIPTION file.1\n\nDESCRIPTION\nThe version of moviesApp in this branch has a DESCRIPTION file with the seven mandatory fields:\n\n# in Terminal\n$ cat DESCRIPTION \nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data Shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\nmoviesApp.Rproj\nHowever, the .Rproj file is still configured to work with a Shiny project:2\n\n# in Terminal\n$ cat moviesApp.Rproj \nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX"
  },
  {
    "objectID": "development.html#package-development-habits",
    "href": "development.html#package-development-habits",
    "title": "Development",
    "section": "Package development habits",
    "text": "Package development habits\nThe differences between developing an R package and a Shiny app can be boiled down to a handful habits, each of which calls a devtools function:\n\n\nI’ll use bold to indicate each devtools habit and accompanying function.\n\nLoad all the functions and data in your app-package with load_all()\nDocument the app-package functions and data with document()\nInstall the app-package with install()\n\nIn the sections below, I’ll cover each function and my opinion about how it should be used when your Shiny app becomes an app-package.3\n\n\n\n\n\n\nKeyboard shortcuts\n\n\n\n\n\n\nI strongly recommend using the keyboard shortcuts for each devtools function. Shortcuts reduce typing and bundle all those keystrokes into a single action. They also create a kind of ‘muscle memory’ for each step.\n\n\n\n\n\nLoad\nInstall devtools\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\nusethis is automatically loaded/attached with devtools.\nLoading required package: usethis\n\n‘load_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management’ - Benefits of load_all(), R Packages, 2ed\n\nload_all() is the most common devtools function we’ll use during development because we should load the package when anything changes in the R/ folder.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\n\ndevtools::load_all()\n\nUsing load_all() is similar to calling library(moviesApp) because it loads the code in R/ along with any data files. load_all() is also designed for iteration (unlike using source()), and when it’s successful, the output is a single informative message:\nℹ Loading moviesApp\n\n\nDocument\nThe document() function from devtools serves two purposes:\n\nWriting the package NAMESPACE file\nCreates the help files in the man/ folder\n\ndevtools is smart enough to recognize the first time document() is called, so when I initially run it in the Console, it prompts me that the roxygen2 version needs to be set in the DESCRIPTION file:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\ndevtools::document()\n\nℹ Updating moviesApp documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\ndevtools relies on roxygen2 for package documentation, so the RoxygenNote field is required in the DESCRIPTION. You may have noticed calling document() also calls load_all(), which scans the loaded package contents for special documentation syntax before writing the NAMESPACE file (we’ll cover the NAMESPACE in the chapter on Dependencies).\nℹ Loading moviesApp\nWriting NAMESPACE\nIf we open the NAMESPACE file, we see it’s empty (and that we shouldn’t edit this file by hand).\n\n\n\n\n\n(a) NAMESPACE\n\n\nFigure 4.1: Initial NAMESPACE file\n\n\nThe last few output lines warn us to include the Encoding field in the DESCRIPTION. devtools won’t automatically add Encoding (like it did with RoxygenNote above), so we’ll need to add it to the DESCRIPTION file manually:\nWarning message:\nroxygen2 requires Encoding: \"UTF-8\"\nℹ Current encoding is NA \n\nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data Shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\n1Encoding: UTF-8\n2\n\n\n1\n\nThe Encoding value shouldn’t include quotes like the warning message above (i.e., UTF-8)\n\n\n2\n\nAlways leave an empty final line in the DESCRIPTION\n\n\n\n\nAfter adding the required fields to the DESCRIPTION file,4 we’ll document() the package again using the keyboard shortcut:\nIn the Build pane, we see the following:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nDocumentation completed\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\n\n\nInstall\nThe final package development habit to adopt is regularly installing the package with devtools::install().\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\ndevtools::install()\n\ninstall() will prompt the following output in the Build pane:\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source moviesApp\n\n* installing to library ‘/path/to/local/install/moviesApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘moviesApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\nNo man pages found in package  ‘moviesApp’ \n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (moviesApp)\nThere are a few connections worth making in this initial install() output:\n\nThe first line in the output should look familiar–we saw both of these settings in the moviesApp.Rproj file from the previous chapter\nPackageInstallArgs: --no-multiarch --with-keep.source\nNo man pages found in package 'moviesApp' tells us none of the code in R/ has adequately been documented (which we’ll cover in the roxygen2 chapter)\ninstall() attempts to install the package from the *source* files and a ‘bundle’ or source tarball file (i.e., .tar.gz)\nhelp files are built, along with other documentation (like vignettes)\nDONE (moviesApp) means moviesApp was successfully installed!\n\nInstall a package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\n\n\n\n\n\nThis section’s code is in the 06b_devtools branch of moviesApp.\n\n\nCheck?\ndevtools::check() performs a series of checks to ensure a package meets the standards set by CRAN. You can consider check() as a ‘quality control’ function for documentation, NAMESPACE dependencies, unnecessary or non-standard folders and files, etc. R Packages recommends using check() often, but I agree with the advice in Mastering Shiny on using check() with app-packages,\n\n‘I don’t recommend that you [call devtools::check()] the first time, the second time, or even the third time you try out the package structure. Instead, I recommend that you get familiar with the basic structure and workflow before you take the next step to make a fully compliant package.’\n\nHowever, I’ve included an example of running check() on moviesApp in the callout box below to demonstrate how it works.\n\n\n\n\n\n\nRunning devtools::check()\n\n\n\n\n\n\ndevtools::check()\n\nThe output from check() can be rather lengthy (it’s pretty comprehensive!), and it provides feedback on each item in the form of a note (N), warning (W), or error (E).\n==&gt; devtools::check()\n\nDuration: 15.3s\n\nN  checking top-level files\n   Non-standard files/directories found at top level:\n     ‘app.R’ ‘movies.RData’\n\nW  checking dependencies in R code ...\n   '::' or ':::' imports not declared from:\n     ‘ggplot2’ ‘shiny’ ‘stringr’\n\nN  checking R code for possible problems (3.1s)\n   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n     variable ‘movies’\n   scatter_plot: no visible binding for global variable ‘.data’\n   Undefined global functions or variables:\n     .data movies\n\nW  checking for missing documentation entries ...\n   Undocumented code objects:\n     ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n     ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n   All user-level objects in a package should have documentation entries.\n   See chapter ‘Writing R documentation files’ in the ‘Writing R\n   Extensions’ manual.\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nA summary of each item is below:\n\nchecking top-level files: This note refers to the two non-standard (i.e., not typically found in an R package) files, app.R and movies.RData.\nchecking dependencies in R code: This warning tells I need to namespace functions from add-on packages (in this case, ggplot2, shiny, and stringr)\nchecking R code for possible problems: This item refers to the call to load the movies data in the module server function (mod_scatter_display_server).\nchecking for missing documentation entries: This is warning me that the module functions aren’t properly documented and refers me to the official R documentation.\n\nEach of these items is also printed under the ── R CMD check results heading:\nDuration: 15.3s\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' imports not declared from:\n    ‘ggplot2’ ‘shiny’ ‘stringr’\n\n❯ checking for missing documentation entries ... WARNING\n  Undocumented code objects:\n    ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n    ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n  All user-level objects in a package should have documentation entries.\n  See chapter ‘Writing R documentation files’ in the ‘Writing R\n  Extensions’ manual.\n\n❯ checking top-level files ... NOTE\n  Non-standard files/directories found at top level:\n    ‘app.R’ ‘movies.RData’\n\n❯ checking R code for possible problems ... NOTE\n  mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n    variable ‘movies’\n  scatter_plot: no visible binding for global variable ‘.data’\n  Undefined global functions or variables:\n    .data movies\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nIf you’re submitting your app-package to CRAN (or want to use check() for other reasons), follow the suggested workflow for check():\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check() or press Shift + Ctrl/Cmd + E\nFix the first problem.\nRepeat until there are no more problems.’\n\n\nI’ve found a good habit for when to check() to be:\nAfter adding a bug fix or feature, check a package and keep any notes, warnings, or errors from accumulating.\n\n\n\n\n\nRecap\nCreating an app-package involves adopting some new devtools habits, and the initial contents of moviesApp hopefully helped demonstrate the purpose of each function.\n\n\n\n\n\n\nRecap: Package development habits\n\n\n\n\n\n\nAfter installing and loading devtools:\n\nLoad the package whenever changes occur in the R/ folder.\n\nCtrl/Cmd + Shift + L load all the code in the package.\n\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\n\nCtrl/Cmd + Shift + D record the documentation and dependencies.\n\nInstall the package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\nCtrl/Cmd + Shift + B confirms the package can be installed.\n\n\nHabits require repetition to develop, and I hope the workflow above can be applied to your Shiny app-packages, provided you’re using devtools and Posit workbench.\n\n\n\n\nThe following section will cover documenting functions with roxygen2"
  },
  {
    "objectID": "development.html#footnotes",
    "href": "development.html#footnotes",
    "title": "Development",
    "section": "",
    "text": "If you create or convert your Shiny app project with usethis::create_package(), a few fields (i.e., Roxygen and RoxygenNote) are added automatically without explaining their role or purpose.↩︎\nIf you created your Shiny app using the New Project Wizard, your .Rproj file has been configured to work with project, not a package.↩︎\nThe topics covered in this section shouldn’t be considered a replacement for the ‘Whole Game’ chapter in R packages (2 ed) or the ‘Workflow’ section of Mastering Shiny (and I highly recommend reading both).↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎"
  },
  {
    "objectID": "app_packages.html#review-chapters-1---4",
    "href": "app_packages.html#review-chapters-1---4",
    "title": "App-packages",
    "section": "Review Chapters 1 - 4",
    "text": "Review Chapters 1 - 4\nLet’s briefly review what we’ve covered in the last three chapters:\n\nWhole app game (Chapter 1)\nChapter 1 walks through the ‘whole game’ of the app-package development workflow. The application in this example comes from the Packages chapter of Mastering Shiny.\n\n\n\n\n\n\nChapter 1: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 1 (Whole app game) is stored in the following repository:\n\nmonthAppPkg\n\n\n\n\n\n\n\nShiny (Chapter 2)\nThe Shiny Chapter covered Shiny projects and some ‘pre-package practices’ to adopt for your Shiny app that can make the transition to working with app-packages easier.\n\n\n\n\n\n\nChapter 2: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 2 (Shiny) is stored in the following branches:\n\nmain: Contains a new Shiny app project created from the New Project Wizard (with Old Faithful Geyser Data)\n02_movies-app: The boilerplate app in app.R is replaced with the code for the movie review application, and the scatter_plot() utility function is added to utils.R and movies.RData is added to the project.\n03_proj-app contains an ‘fully developed’ Shiny app project with the following contents:\n\nDESCRIPTION file\n\nREADME.md file\n\nR/ folder\n\nModules: two module files are created in the R/ folder (mod_var_input.R and mod_scatter_display.R)\n\nStandalone app function: the code in app.R is converted to a standalone app function: movies_app()\nUtility function: Move utils.R into the R/ folder\n\n\nThe www/ folder contains the image file (shiny.png)\n\nDeployment: The rsconnect/ folder contains files for deploying to shinyapps.io\n\n\n\n\n\n\n\n\nPackages (Chapter 3)\nPackages illustrated what separates projects from R packages. This chapter also covered 1) how to create a new Shiny app-package or 2) convert an existing Shiny project into an app-package.\n\n\n\n\n\n\nChapter 3: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 3 (Packages) is stored in the following branches:\n\n03_proj-app is an ‘advanced’ package from the previous chapter\n04_description is a branch from 03_proj-app and adds the seven mandatory DESCRIPTION fields.\n05_rproj is a branch from 04_description and manually converts the Shiny app project to a Shiny app-package using the .Rproj file.\n06a_create-package is a branch from 05_rproj and creates a package using usethis::create_package()\n\n\n\n\n\n\n\nDevelopment (Chapter 4)\nChapter 4 introduced the devtools package and its core functions (load_all(), document(), and install()).\n\n\n\n\n\n\nChapter 4: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 4 (Development) is stored in the following branch:\n\n06b_devtools is a branch from the manually converted app-package in 05_rproj\n\n\n\n\n\nWe’re now at a point that we’ve converted a Shiny project (moviesApp) into a package. The package conversions live in the 06_devtools and 06_create-package branches:\n\nIn the 06_devtools branch, moviesApp was converted to a package by manually adding the required fields to the DESCRIPTION file, then running the key devtools development functions (load_all(), document(), and install())\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\n1\n\n\n1\n\nAlways leave an empty line in the DESCRIPTION\n\n\n\n\nIn the 06_create-package branch, we used the usethis::create_package() function to convert moviesApp into a package.\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\nThe only difference between these two branches lies in the DESCRIPTION files–in the 06_create-package branch, the Roxygen: list(markdown = TRUE) field was added (which we will cover in the upcoming Documentation chapter)."
  },
  {
    "objectID": "app_packages.html#app-packages",
    "href": "app_packages.html#app-packages",
    "title": "App-packages",
    "section": "App-packages",
    "text": "App-packages\nThe following six chapter will continue with app-package development, emphasizing developing a Shiny application within a package structure.\nIn the following chapters, we’ll be using code from the moviesApp repository:\n\n\n\n\n\n\nmoviesApp/tree/\n\n\n\n\n\n\nThe code for the next section can be found in the 06b_devtools branch of moviesApp repository.\nmoviesApp/ \n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── moviesApp.Rproj\n  └── www\n      └── shiny.png\n  \n  4 directories, 10 files\nThe rsconnect/ folder has been removed because we’ll cover deploying moviesApp in future sections.\n\n\n\n\nA preview of the topics covered in the following chapters is provided below.\n\nDocumentation (Chapter 5)\nChapter 5 covers documenting your app-package code in the R/ folder:\n\nroxygen2 basics:\n\nRequired tags:\n\n@title, @description, @details, @param, @return, and @examples\n\n\nApp-package tags for modules and standalone app functions:\n\n@seealso, @family, and @section\n\n\n\n\n\nDependencies (Chapter 6)\nChapter 6 dives into dependencies. We’ll cover how to export functions and objects from your app-packages for others to use, and how to handle functions from add-on (i.e., external) packages.\n\nExporting functions from your package namespace\n\n@export/export()\n\n\nImporting functions from add-on packages into your package namespace\n\n@import/import(), @importFrom/importFrom()\n\n\nThe Imports field in the DESCRIPTION\n\nusethis::use_package()\n\n\n\n\nData (Chapter 7)\nData covers how to include datasets in your app-package namespace, and the various kinds of data in R packages.\n\nDocumenting data with\n\nroxygen2: @format, \\describe, \\item\n\n\nLocation of data files: data/ vs. data-raw/ vs. inst/extdata/\n\n\n\nLaunch (Chapter 8)\nThe Launch chapter covers how to 1) run your application during development, how to run your app using a standalone app function, and 3) how to deploy your application to shinyapps.io.\n\nWhat goes in app.R?\n\nshinyApp() vs. shinyAppDir() vs. runApp()\n\nrsconnect::deployApp()\n\n\n\n\nExternal files (Chapter 9)\nThe Chapter 9 covers how to include external resources (i.e. the images, CSS, html, or other files that are typically included in the www/ folder and served when you run your Shiny app). This chapter also covers other uses for the isnt/ folder in app-packages.\n\nwww/ vs. inst/\nsystem.file()\naddResourcePath()"
  },
  {
    "objectID": "document.html#roxygen2-basics",
    "href": "document.html#roxygen2-basics",
    "title": "Documentation",
    "section": "roxygen2 basics",
    "text": "roxygen2 basics\n\n\n\n\n\n\n\n\nGit branch: 06b_devtools\n\nroxygen2 connects the package code (i.e., the .R files in the R/ folder) to its documentation files (i.e., the .Rd files in the man/ folder):\n\n\n\n\n\n(a) roxygen2\n\n\nFigure 5.1: roxygen2 creates man/ documentation\n\n\nThe two pieces of roxygen2 syntax to know are comment blocks and tags:\n\nComment blocks are any lines beginning with #'\n#' \n#' \n#' \nTags begin with @\n#' \n#' @tag\n#' \n\nWhen documenting functions, roxygen2 tags and comment blocks are placed directly above any functions stored in R/.\n#' \n#' @tag\n#' \nmy_fun &lt;- function() {\n  \n}\nIn the following sections, we’ll cover roxygen2 basics using examples for the scatter_plot() function found in R/utils.R.\n\n\n\n\n\n\nInserting roxygen2 skeletons\n\n\n\n\n\n\nYou can insert an roxygen2 skeleton into your function using Code &gt; Insert Roxygen Skeleton\n\n\n\nStandard roxygen2 skeleton\n\n\n\n\n\n\n\nmarkdown = TRUE\nWhen we created our app-package with usethis::create_package(), support for markdown formatting in package help files is automatically included by adding Roxygen: list(markdown = TRUE) to the DESCRIPTION file:\n\nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data Shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nDisplayMode: Showcase\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\n1\n\n\n1\n\nAlways leave at least one empty final line in your DESCRIPTION file.\n\n\n\n\n\n\n@title & @description\nThe first two sections of roxygen2 documentation are the title and description. These sections don’t require tags–roxygen2 will detect each section as long as there is at least one #' line separating them (and their contents don’t extend past the length indicated in parentheses below):\n#' function title (one line)\n#'\n#' A short description... (one paragraph)\n#' \nThe @title and @description for the scatter_plot() function stored in R/utils.R might look like this:\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n\n\n\n\n\n\nFunction @description and @details\n\n\n\n\n\nIf the contents in the @description for a function requires more complicated formatting than a single paragraph (i.e., multiple paragraphs, lists, etc.), you can use the @details tag:\n#' Create scatter plot  \n#' \n#' @description\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' @details\n#' `scatter_plot()` is a custom `ggplot2` function written to handle string arguments from reactive inputs (i.e., `input$x` or `input$y`). \n\n\n\n\n\n@param & @return\nDocument function arguments and outputs with @param and @return:\n\n@param: should include the name and description of each function input (i.e., their type and what they do)\n#' @param name description of its action\n\nRead more here\n\n@return: these describe the type (or class) and structure of the function output\n#' @return type/structure of the output\n\nRead more here\n\n\nBelow are examples for @param and @return in the scatter_plot() function stored in R/utils.R:\n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\nTo view how the roxygen2 syntax will appear in the .Rd file, I’ll document moviesApp:\n\n\nTo reduce the amount of repetitive code, I’ll just be showing the keyboard shortcuts for each devtools function from this point forward\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nI can see the scatter_plot.Rd file is written to the man/ folder:\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nWriting scatter_plot.Rd\nDocumentation completed\nShiny apps often contain utility functions in helper.R or utils.R files. Storing non-shiny code in these files isn’t a bad practice (in fact, it’s encouraged in Mastering Shiny). However, if we’re following the advice in R Packages,1 we should rename R/utils.R to R/scatter_plot.R so it matches man/scatter_plot.Rd as we transition to an app-package.2\n\n\n\n\n\n\nR/utils.R &gt;&gt; R/scatter_plot.R\n\n\n\n\n\n\nFrom now on, I’ve renamed R/utils.R to R/scatter_plot.R, so it aligns with the naming conventions in other R packages.\nFor a deep dive on R/utils.R files in R packages, I recommend reading Dissecting R Package “Utility Belts”\n\n\n\n\nR documentation (.Rd) files have a formatting style similar to (La)TeX (but roxygen2 saves us from having to learn this syntax). When we open man/scatter_plot.Rd, we see it contains the following:\n\n\n\n\n\n\n(a) .Rd file\n\n\nFigure 5.2: R documentation file\n\n\n\n\n\n\n\n\n\n.Rd file syntax\n\n\n\n\n\n\nroxygen2 graciously generates the scatter_plot.Rd file (and warns us not to edit it by hand).\n\n\n\nroxygen2 tag syntax in .Rd file\n\n\nNote the following items were added without needing tags:\n\n\\name: the name of the function (as it appears in the index)\n\\alias: used to group ‘topics’ and provides a look-up in the package index\n\\arguments: function arguments (header)\n\n\\item: description of argument\n\n\nThe following two items are a result of the markdown syntax we used:\n\n\\href: used for hyperlinks\n\\code: code formatting\n\n\n\n\n\nTo view the help file, I can enter ?scatter_plot in the console:\n\n?scatter_plot\n\nAnd an informative message tells me that the development version scatter_plot.Rd is being rendered:\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n\n(a) Help file\n\n\nFigure 5.3: Help file\n\n\n\nPreviewing the development documentation is a great way to verify the content in each .Rd file meets expectations.\n\n\n@examples\n@examples are unique because they include executable code demonstrating how a function works. In the Posit Workbench IDE, @examples are especially helpful because they come with a ‘single click’ hyperlink (the @examples from ggplot2::aes() are below):\n\n\n\n\n\n\n\n\n(a) Run examples hyperlink\n\n\n\n\n\n\n\n\n\n(b) Executed @examples code\n\n\n\n\nFigure 5.4: Run examples in help files\n\n\n\nThe syntax to create an example for scatter_plot() is below:\n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n\n\n\n\n\n\nTab-completion for @tags\n\n\n\n\n\n\nIf you’re documenting your package functions in Posit Workbench, tab-completion is your friend! The help text displayed with each tag ensures you’re including the correct version (see @example vs. @examples below).\n\n\n\nTab completion for @example\n\n\n\n\n\nTab completion for @examples\n\n\nRead more here.\n\n\n\n\nTo preview the @examples in the help file, I’ll document() and open the development .Rd file:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n?scatter_plot\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n\n\n(a) @examples in .Rd preview\n\n\nFigure 5.5: Preview of examples\n\n\n\nThe Run examples hyperlink won’t be active in the .Rd file preview, but reviewing the code in @examples allows me to correct any errors or typos early.\nThe scatter_plot() function has a documented Title, Description, Usage, Arguments, Value, and Examples. I consider these tags the minimum documentation to include for functions I’m making available to other users."
  },
  {
    "objectID": "document.html#documenting-app-functions",
    "href": "document.html#documenting-app-functions",
    "title": "Documentation",
    "section": "Documenting app functions",
    "text": "Documenting app functions\nYour app-package will likely contain at least two functions specific to shiny: modules and a standalone app function. roxygen2 has a few tags that can make the documentation for these functions more informative for readers.\n\nDocumenting modules\nBelow are a few things to consider when documenting module functions:\n\nModules typically have two functions in a single .R file: one for the UI and a counterpart in the server.\nEvery module function will include at least one @param for the shared id.\nReturned objects are critical in shiny’s reactive context, so I recommend extending the description to include whether or not the returned output is reactive.\nIf the returned output is an input (i.e. @param) for another function, link to that documentation functions with @seealso or @family.\n\nBelow are some examples from the moviesApp modules.\n\n\n@seealso\nWhen documenting modules, think of the audience as someone looking to understand the execution path through the application. In moviesApp(), the inputs are collected with the var_input module and then passed to the scatter_display module.\nI use @seealso to connect mod_var_input_ui() to its server function counterpart. The hyperlink to mod_var_input_server() from mod_var_input_ui() is created by placing the destination function in square brackets [fun()]:\n#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n#' @seealso [mod_var_input_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n@seealso creates a hyperlink readers can use to open the next module in the execution path.\n\n\n\n\n\n(a) @seealso link\n\n\nFigure 5.6: Link values from var_input to scatter_display\n\n\nIn mod_var_input_server(), a link can be made to mod_scatter_display_server() (the module function collecting the returned values) using the square brackets in the @return section (without @seealso):\n#' Variable input module (server)\n#'\n#' @param id server module id\n#' \n#' @seealso [mod_var_input_ui()]\n#'\n#' @return reactive inputs are returned in a `list()`: \n#'  * `\"y\" = input$y`\n#'  * `\"x\" = input$x`\n#'  * `\"z\" = input$z`\n#'  * `\"alpha\" = input$alpha`\n#'  * `\"size\" = input$size`\n#'  * `\"plot_title\" = input$plot_title`\n#'  \n#' These become in the `var_inputs()` argument in [mod_scatter_display_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) mod_var_input_ui()\n\n\n\n\n \n\n\n\n\n\n(b) mod_var_input_server()\n\n\n\n\nFigure 5.7: Link values from var_input to scatter_display\n\n\n\n\n\n@family\nModule functions can also be grouped into families using @family {\"description\"}. Below is an example of grouping the “scatter plot module functions” into a family:\n#' Scatter plot display module (UI)\n#'\n#' @param id UI module id\n#' \n#'\n#' @return module UI (HTML)\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n@section\nThe @section tag will create a level two header (##/&lt;h2&gt;&lt;/h2&gt;) section, which can help organize topics (like how to use an input or argument).\n@seealso can also be used to link back to the scatter_plot() utility function:\n#' Scatter plot display module (server)\n#' \n#'\n#' @param id server module id \n#' @param var_inputs returned reactive list from [mod_var_input_server()].\n#' \n#' @section Referring to `var_inputs`: \n#' Refer to the reactive returned values from `mod_var_input_server()` as:\n#'  * `var_inputs()$x`\n#'  * `var_inputs()$y`\n#'  * `var_inputs()$z`\n#'  * `var_inputs()$alpha`\n#'  * `var_inputs()$size`\n#'  * `var_inputs()$plot_title`\n#' \n#'\n#' @return rendered plot and title output from [scatter_plot()]\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@family in mod_scatter_display_ui()\n\n\n\n\n\n\n\n@seealso in mod_scatter_display_server()\n\n\n\n\n\n\nThe figure above shows how the @seealso links can create a path for the graph parameters through the var_input and scatter_display modules. It also demonstrates how @family groups the scatter_display UI and server functions.\nThe scatter_plot() utility function should also include a @seealso tag for the module function it’s used in.\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscatter_plot() in mod_scatter_display_server()\n\n\n\n\n\n\n\n@seealso in scatter_plot()\n\n\n\n\n\n\nThe goal when cross-referencing functions in your app-package is for anyone reading your documentation to follow the links and better understand any modules, their inputs, reactive values, and outputs.\nIn this case, linking to the scatter_plot() function gives readers an interactive example to preview the output.\n\n\nStandalone app functions\nSplitting the code in app.R into separate functions has multiple benefits:\n\nDeveloping and loading a function is easier if stored in the R/ folder.\nHaving a dedicated UI, server, and app function means we can develop them independently.\nA standalone app function makes storing multiple applications in the same app-package possible.\n\nI’ve split the UI and server from movies_app() into separate movies_ui() and movies_server() below.\n\nUI & Server functions\nThe movies_ui() doesn’t have any arguments–the only change is wrapping the shiny::fluidPage() in shiny::tagList():\n\nmovies_ui &lt;- function() {\n  shiny::tagList(\n    shiny::fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nmovies_server() is written to be passed to the server argument in shinyApp():\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\nusage\nI’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). I’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n#' Movies UI function\n#' \n#' UI function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_ui()\n\n\n\nThe documentation for movies_server() is very similar to the Ui function–each module server function is documented in it’s own @section.\nStill, I’ll include a @section for Communication that describes how values are passed between mod_var_input_server() and mod_scatter_display_server().\n#' Movies server function\n#' \n#' Server function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#' \n#' ```\n#' shinyApp(movies_ui, movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in [movies_ui()]   \n#'  * server is stored in `movies_server()`\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_server()] returns following reactive values:\n#'  * `x`\n#'  * `y`\n#'  * `z`\n#'  * `alpha`\n#'  * `size`\n#'  * `plot_title`\n#' \n#' @seealso [mod_var_input_ui()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_server()] displays the `ggplot2` graph with the [scatter_plot()] function.\n#' \n#' @seealso [mod_scatter_display_ui()]\n#' \n#' @section Communication: \n#' The output from [mod_var_input_server()] should be supplied to the \n#' `var_inputs` argument of [mod_scatter_display_server()].\n#\n#' @return `server` argument in `shiny::shinyApp()`\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_server()\n\n\n\n\n\n\nmovies_app()\nThe standalone app function (movies_app()) automatically calls shinyApp(), with the movies_ui and movies_server functions supplied to ui and server (without parentheses).\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nThe documentation for the standalone app function can be minimal–as long as it provides links to the UI and server.\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return Shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_app()\n\n\n\nI’ll change the contents of app.R to the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nNow that we’ve documented everything in R/, we’ll run load(), document(), and install():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\ndevtools::load_all(\".\")\nℹ Loading moviesApp\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nDocumentation completed\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source moviesApp\n\n* installing to library ‘/path/to/local/install/moviesApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘moviesApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (moviesApp)\nIn the Console, we should see the following:\nRestarting R session...\n\n&gt; library(moviesApp)\nThe roxygen2 documentation for moviesApp is saved in the 02-roxygen branch. As we can see, calling devtools::document() generates the .Rd files in the man/ folder for each function in the R/ folder:\n\n\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n ├── movies_app.R\n ├── movies_server.R\n ├── movies_ui.R\n └── utils.R\n\n1 directory, 6 files\n\n\nman/\n  ├── mod_scatter_display_server.Rd\n  ├── mod_scatter_display_ui.Rd\n  ├── mod_var_input_server.Rd\n  ├── mod_var_input_ui.Rd\n  ├── movies_app.Rd\n  ├── movies_server.Rd\n  ├── movies_ui.Rd\n  └── scatter_plot.Rd\n\n1 directory, 8 files\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 07_roxygen2 branch of moviesApp."
  },
  {
    "objectID": "document.html#recap",
    "href": "document.html#recap",
    "title": "Documentation",
    "section": "Recap",
    "text": "Recap\nGood documentation aims to make it as easy as possible for others (and future you) to understand what your function does and how to use it.\nBelow is a recap of the topics covered in this chapter.\n\n\n\n\n\n\nroxygen2 recap\n\n\n\n\n\n\nThis chapter covered:\n\nFunction @title and @description: The @title should be a short one-line description of the function, followed by a more detailed paragraph @description. These tags should give users an idea of what the function does (you can also use @details)\nArguments (@param) and outputs (@return): List all function arguments with @param. Include the argument type (e.g., integer, character, etc.) and a brief description of what the argument does. Be sure to mention any default or optional arguments. Function outputs should be listed with @return and describe the type or class of the object, whether or not it’s reactive, and mention any related functions.\nExamples: @examples provide executable R code that captures how the function is used in your app-package. These are incredibly valuable for new users trying to understand how a function (and your app-package) works.\n\nApp-package specific considerations:\n\nConnect functions with@seealso and @family: Use @seealso to provide links to related functions (i.e., modules) so users can click through a ‘guided tour’ of your application’s code–group similar functions using @family {description}.\nGive more info with @sections: Use @section to give in-depth explanations and specific details about how a function works, including any information about the @usage or its @params.\n@usage: This field will be automatically generated by roxygen2, but in some circumstances, it makes sense to set it to NULL and describe a function’s use explicitly.\n\n\n\n\n\nIn the next section, we’ll use roxygen2 to manage our app-package dependencies."
  },
  {
    "objectID": "document.html#footnotes",
    "href": "document.html#footnotes",
    "title": "Documentation",
    "section": "",
    "text": "‘most of our packages have a utils.R file (Section 6.1) that contains small utility functions that are useful internally, but aren’t part of the core purpose of those packages. We don’t export such functions.’↩︎\nHaving a 1:1 match on function and file names will also make writing and running tests easier.↩︎"
  },
  {
    "objectID": "dependencies.html#moviesapp",
    "href": "dependencies.html#moviesapp",
    "title": "Dependencies",
    "section": "moviesApp",
    "text": "moviesApp\nThis chapter will pick up where we left off with the 07_roxygen2 branch of moviesApp.\nBelow is a folder tree of its contents:\n\nmoviesApp/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   ├── movies_app.R\n  │   ├── movies_server.R\n  │   ├── movies_ui.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n1  ├── man/\n  │   ├── mod_scatter_display_server.Rd\n  │   ├── mod_scatter_display_ui.Rd\n  │   ├── mod_var_input_server.Rd\n  │   ├── mod_var_input_ui.Rd\n  │   ├── movies_app.Rd\n  │   ├── movies_server.Rd\n  │   ├── movies_ui.Rd\n  │   └── scatter_plot.Rd\n  ├── movies.RData\n  ├── moviesApp.Rproj\n  └── www/\n      └── shiny.png\n\n4 directories, 21 files\n\n\n1\n\nThe man folder now contains the help (.Rd) files for the functions in R/\n\n\n\n\n\nWhen in doubt…\nLoad, document, and install\nDuring development, you might lose track of the last devtools function you called (I know I do). If this happens, I’ve found loading, documenting, and installing help re-orient me to the current state of the package.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nDocumentation completed\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source moviesApp\n\n* installing to library ‘/path/to/local/install/moviesApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘moviesApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (moviesApp)\n\nRestarting R session...\n\n&gt; library(moviesApp)\nIt’s also satisfying to see all three functions execute without any errors!"
  },
  {
    "objectID": "dependencies.html#identifying-dependencies",
    "href": "dependencies.html#identifying-dependencies",
    "title": "Dependencies",
    "section": "Identifying dependencies",
    "text": "Identifying dependencies\nThe first step in managing dependencies is identifying which add-on packages moviesApp relies on.1 Our goal is to limit the dependencies to only those critical to the functioning of our app, because each additional dependency is a potential point of failure (should this package become unavailable or significantly change).\n\nRunning movies_app()\nIn the last chapter, we moved and documented the standalone app function (movies_app()) in the R/ folder. The app.R file now only contains the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nIdeally, we’ll want to replace these calls to libary(), but first we have to make sure the functions we’re using in these packages will be available in moviesApp.\nWhen we run the contents of app.R, we see the following:\n&gt; library(moviesApp)\n&gt; # pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n&gt; # install.packages(pkgs, quiet = TRUE)\n&gt; \n&gt; # packages ------------------------------------\n&gt; library(shiny)\n&gt; library(shinythemes)\n&gt; library(stringr)\n&gt; library(ggplot2)\n&gt; library(rlang)\n&gt; \n&gt; # movies_app ------------------------------------\n&gt; movies_app()\nError in movies_app() : could not find function \"movies_app\"\nWhy can’t R find the \"movies_app\" function in app.R?\nLet’s recap what we’ve done so far:\n\n\n\n\napp.R\n\napp.R loads the necessary packages and calls movies_app()\n\n\n\n\nmoviesApp/\n    └── app.R\n\n\n\n\n\n\nR/\n\nThe R/movies_app.R file contains the code and documentation for movies_app()\n\n\n\n\nmoviesApp/\n    └── R/\n        └── movies_app.R\n\n\n\n\n\n\nman/\n\nroxygen2 is generating the man/movies_app.Rd file\n\n\n\n\nmoviesApp/\n    └── man/\n          └── movies_app.Rd\n\n\n\nThe error above is telling us that despite having documentation for movies_app() in the R/ folder and generating the corresponding .Rd file in man/, movies_app() isn’t being exported from moviesApp."
  },
  {
    "objectID": "dependencies.html#exports",
    "href": "dependencies.html#exports",
    "title": "Dependencies",
    "section": "Exports",
    "text": "Exports\nThe exact cause of the error above becomes more apparent when we try to explicitly namespace movies_app() from moviesApp:\n\nmoviesApp::movies_app()\n\nError: 'movies_app' is not an exported object from 'namespace:moviesApp'\n\n\n\n\n\n\n\nThis section’s code is in the 08a_pkg-exports branch of moviesApp.\nTo make the movies_app() function available to users of our package, we need to export it. We export functions by including the @export tag in the roxygen2 comment block (above the function we want to export):\n\n@export: The function name (my_func) is not required.\n\n#' @export my_func \n#' my_func &lt;- function() {\n#' \n#' }\n\n\nRead more here\n\n\n\nExporting movies_app()\nLet’s start by exporting the movies_app() function from moviesApp by placing the @export tag above the function in R/movies_app.R:\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return Shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#' @export\n#' \nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nIn app.R, we’ll replace the calls to library() with a single call to library(moviesApp)\n\n# packages ------------------------------------\nlibrary(moviesApp)\n\n# movies_app ------------------------------------\nmovies_app()\n\nWe’ll load, document, and install the package to generate the NAMESPACE changes:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nNow, when we run the code app.R, we see the following:\n\n\n\nmovies_app()\n\n\n\n\nWe’ve lost the Shiny icon (www/shiny.png) in the UI, but we’ll address this in the inst/ & www/ chapter.\nmovies_app() launches our application!\n\n\nThe NAMESPACE file now contains a single export (movies_app), and when we enter moviesApp:: in the Console, we see the movies_app() function help file in the tab completion.\n\n\n\n\n\n\n\n\n(a) updated NAMESPACE\n\n\n\n\n\n\n\n(b) moviesApp namespace\n\n\n\n\nFigure 6.1: The movies_app() is now part of the moviesApp namespace\n\n\n\n\n\nWhat @export does\nWe’ll pause here to notice a few things about what @export does. After loading, documenting, and installing moviesApp, the NAMESPACE is updated with export(movies_app), and the Console automatically calls library(moviesApp).\nls() returns “the names of the objects in the specified environment, so we can use it to confirm the movies_app() function is the only export from moviesApp:\n\nls(name = \"package:moviesApp\")\n\n[1] \"movies_app\"\n\nThe search() list\nlibrary(moviesApp) attaches moviesApp to the search list. We can view all the attached packages in the string returned from search():\n\"package:moviesApp\" %in% search()\n[1] TRUE\nWhat about the functions from add-on packages movies_app() relies on, like ggplot2?\nLet’s check to see if ggplot2 is also attached to the search() list:\n\nc(\"package:ggplot2\") %in% search()\n\n[1] FALSE\nWhy does this matter? Because if these packages aren’t attached to the search() list, we can’t call their functions the way we would if we’d used library().\nFor example, if we try to use ggplot2 to build a plot (similar to the one we have in the app), we see the following:\n\nggplot(data = mtcars, \n  aes(x = disp, y = mpg)) + \n  geom_point()\n\nError in ggplot(data = mtcars, \n              aes(x = disp, y = mpg)) : \n  could not find function \"ggplot\"\nIf we want to use functions from the packages moviesApp relies on, we need to explicitly namespace these functions from their original package namespaces (i.e., pkg::fun()):\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nWe can use ggplot2 if we explicitly namespace it’s functions\n\n\n\n\n\n\n\n\n\n\n\nAccessing add-on package functions\n\n\n\n\n\n\nWhen a user loads moviesApp with library(moviesApp), any add-on package functions used in exports are available to users if they use pkg::fun() (or if they load the package themselves with library()).\n\n\n\n\nAccess to add-on package functions has implications for the other functions in moviesApp–for example, the scatter_plot() function uses ggplot2 functions. But we’re not exporting scatter_plot(), so when we attempt to run the examples, we see the following error:\n\n\n\n\n\n\n\n\n(a) Examples in scatter_plot()\n\n\n\n\n\n\n\n(b) Error in scatter_plot() examples\n\n\n\n\nFigure 6.2: Examples in scatter_plot() function without exporting\n\n\n\nExamples for ‘moviesApp::scatter_plot’\nThe message at the top of the Help pane is informative because it tells us that despite scatter_plot() being functional when we run movies_app(), it’s not part of the package namespace (and thus, not accessible to users in the help file).\n\n\nExporting scatter_plot()\nLet’s add the @export tag to R/scatter_plot.R so it’s exported from moviesApp.\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n#' @export\n#' \n\nAfter loading, documenting, and installing moviesApp, the NAMESPACE is updated with the export() directive:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nThe contents of the updated NAMESPACE file are below (and moviesApp:: in the Console now displays the scatter_plot() help file in the tab completion):\n\n\n\n\n\n\n\n\n(a) @export the scatter_plot function\n\n\n\n\n\n\n\n(b) moviesApp::scatter_plot()\n\n\n\n\nFigure 6.3: scatter_plot() is now part of the moviesApp namespace\n\n\n\nBelow, we confirm users can access the help file for scatter_plot() and run the examples:\n\n\n\n\n\n(a) scatter_plot() examples\n\n\nFigure 6.4: Running examples in ?scatter_plot\n\n\n\n\nloadedNamespaces()\nWe’ve already confirmed that ggplot2 isn’t attached with moviesApp (and hence, it is not included in the search() list)\n\nc(\"package:ggplot2\") %in% search()\n\n[1]  FALSE\nHowever, we can access the functions we used the pkg::fun() syntax with because those functions are included in the loaded namespaces (which we can view with loadedNamespaces())\n\nc(\"ggplot2\") %in% loadedNamespaces()\n\n[1] TRUE\n\n\n\nWhat to @export\n\n‘Always err on the side of caution, and simplicity. It’s easier to give people more functionality than it is to take away stuff they’re used to’ - What to export, R Packages, 2ed\n\nWhen determining which functions to export, consider the question: “When a user installs and loads moviesApp, what functions do I want to be available?”\nIn app-packages, I take the following general approach:\n\nStart by exporting only the standalone app function (movies_app())\nSelectively export modules and/or functions that perform distinct tasks with potentially reusable functionality (i.e., generate specific UI components, perform data processing tasks, etc.).\n\nYou’ll rarely want to export everything, but it might be helpful if the primary audience for your app-package is other developers within your organization. See the Low-key @exports with @keywords internal box below for exporting functions without including them in your package index.\n\n\n\n\n\n\nLow-key @exports with @keywords internal\n\n\n\n\n\n\nIf you’d like function to be exported, but not listed in the package index, you can combine @export with @keywords internal. These should be used in combination,\n#' @export\n#' \n#' @keywords internal\nFor example, adding @export and @keywords internal to R/scatter_plot.R will make the function accessible to users:\n\n\n\n\n\nAnd include the help file:\n\n\n\n\n\nHowever, if a user were to click on the Index for moviesApp (at the bottom of the help file)\n\n\n\n\n\nscatter_plot is not listed:"
  },
  {
    "objectID": "dependencies.html#imports",
    "href": "dependencies.html#imports",
    "title": "Dependencies",
    "section": "Imports",
    "text": "Imports\n\n\n\n\n\n\n\nThis section’s code is in the 08b_pkg-imports branch of moviesApp.\nManaging imports is slightly more involved than exports because imported dependencies can live in DESCRIPTION and the NAMESPACE:\n\nThe DESCRIPTION file handles package-level dependencies, specifying which add-on packages our app-package uses.\nThe NAMESPACE manages function-level access, importing functions from add-on packages to be used in our app-package, and–as we’ve seen above–exporting functions from our app-package for others to use.\n\n\nPackage-level depencencies\nThe DESCRIPTION file manages dependencies with three fields: Depends, Imports, and Suggests. 2\n\nDepends\nPackages listed under Depends are essential for our app-package to work. These packages will be attached before our package when library(moviesApp) is called.\n\n\nImports\nPackages listed under Imports are necessary for our app-package to work. These packages are loaded (but not attached) when our app-package is installed.\n\nMost add-on packages belong under the Imports field (i.e., functions from these packages are used in the code below R/).\n\n\n\nSuggests\nThe Suggests field should include any packages that enhance our app-package, but aren’t necessary for the basic functionality. This might include packages used in examples, vignettes, tests, etc.\n\n\n\nFunction-level access\nFunction-level access is managed using namespace-qualified (or explicit namespacing). The NAMESPACE includes add-on packages or functions with an @import and @importFrom tag.3\n\npkg::fun()\nRefer to add-on package functions using pkg::fun() syntax in the code below R/.\n\n\n@importFrom\n@importFrom should be used when 1) “You can’t call an operator from another package via ::” 2) “importing a function makes your code much more readable” (not easier to write)\n\n\n@import\n@import should be used if “you make such heavy use of so many functions from another package that you want to import its entire namespace”\n\n\n\nImports in moviesApp\nThe workflow I use to manage add-on dependencies comes from the advice in the roxygen2 documentation.4\n\nInclude the add-on package to the Imports field with usethis::use_package()\nRefer to add-on functions using explicit namespacing (i.e., pkg::fun()) in the code beneath R/\n\nWe have some special considerations for the imports in moviesApp:\n\nA substantial portion of the code in moviesApp comes from shiny, so we’ll remove the explicit namespacing and place the @import tag in R/movies_app.R5\n\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shinyApp()`\n#'\n#' @return Shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#' \n1#' @import shiny\n#'\n#' @export \n#' \n\n\n1\n\nImport entire shiny package namespace\n\n\n\n\n\n.data can’t be exported using ::, so we’ll include @importFrom for the use of .data in R/scatter_plot.R\n\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n1#' @importFrom rlang .data\n#' \n#' @export\n#' \n\n\n1\n\nImport a the .data operator from rlang\n\n\n\n\n\nAfter adding all add-on packages to the DESCRIPTION with usethis::use_package(), then deciding if/where to use @importFrom and @import, we’ll load, document, and install moviesApp:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nWhen we review the updated NAMESPACE and DESCRIPTION files, we should see the following:\n\n\n\n\n\n\n\n(a) Updated NAMESPACE with @import and @importFrom\n\n\n\n\n\n\n\n(b) Updated DESCRIPTION with all Imports\n\n\n\n\nFigure 6.5: roxygen2 will update the NAMESPACE, but usethis::use_package() is needed to update the DESCRIPTION\n\n\nWhen we run movies_app(), we see the application launches and we can still run the scatter_plot() examples:\n\n\n\n\n\n\n\n(a) movies_app() works\n\n\n\n\n\n\n\n(b) Examples in ?scatter_plot\n\n\n\n\nFigure 6.6: Confirming we still have full functionality in moviesApp\n\n\n\n\nWhat happened in moviesApp?\nThe figure below attempts to capture some of confusion between the dependencies listed in the NAMESPACE and the Imports field in the DESCRIPTION file.6\n\n\n\n\n\n(a) roxygen2 does not connect the NAMESPACE to the DESCRIPTION\n\n\nFigure 6.7: devtools::document() (or Ctrl/Cmd + Shift + D) updates the NAMESPACE with any @import, @importFrom or @export tags. However, no changes are made to the DESCRIPTION file.\n\n\nLet’s confirm we’re still only exporting movies_app() and scatter_plot() from moviesApp:\n\nls(name = \"package:moviesApp\")\n\n[1] \"movies_app\"   \"scatter_plot\"\nGreat. Now we’ve listed five packages in the Imports field of the DESCRIPTION file:\nImports: \n    ggplot2,\n    rlang,\n    shiny,\n    shinythemes,\n    stringr\n\nThe search() list\nAre these packages on the search list?\n\npkgs &lt;- c(\"package:ggplot2\", \"package:rlang\", \n          \"package:shiny\", \"package:shinythemes\", \n          \"package:stringr\")\npkgs %in% search()\n\n[1] FALSE FALSE FALSE FALSE FALSE\nThis demonstrates that none of these packages are attached with moviesApp. However, the rlang and shiny packages are included in the loadedNamespaces() (because we included them with @import/@importFrom).\n\npkgs &lt;- c(\"ggplot2\", \"rlang\", \"shiny\", \n          \"shinythemes\", \"stringr\")\npkgs %in% loadedNamespaces()\n\n[1] FALSE  TRUE  TRUE FALSE FALSE\nWe can still access the add-on package functions in moviesApp using the pkg::fun() syntax:\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nggplot2 functions are still available if we explicitly namespace"
  },
  {
    "objectID": "dependencies.html#more-info-on-imports",
    "href": "dependencies.html#more-info-on-imports",
    "title": "Dependencies",
    "section": "More info on imports",
    "text": "More info on imports\nI’ve provided a handful of useful tips on package imports below:\nHow can I include an add-on package to my DESCRIPTION file?\n\nusethis::use_package() automatically adds a package in the Imports section, and has options for specifying the minimum version\n\nWill users of my app-package have access to the packages listed in the Imports field of my DESCRIPTION file?\n\nlibrary(moviesApp) loads the namespace of imported packages, but they are not attached to the search() path7\n\nHow can I tell the difference between functions written by a package author and imported functions in the code below R/?\n\nUsing pkg::fun() makes calls to add-on packages explicit and easy to differentiate from the native functions developed in moviesApp8\n\nWhat does the NAMESPACE do when my package is installed by a user?\n\nManaging the NAMESPACE ensures your app-package works when it’s installed and loaded on another machine, because R will read your package namespace to find what it imports and exports9\n\nWhere should I place the @importFrom tag in the code below R/?\n\nPlace the @importFrom pkg fun tag directly above the code using the add-on function.10\n\nShould I be using @importFrom or @import from?\n\nPrefer using @importFrom over @import11 12\n\nWhere can I find more information about package namespaces and imports?\n\nImports are described briefly in R Packages, 2ed13 and covered in-depth in Advanced R, 2ed14 \n\n“Each namespace has an imports environment that can contain bindings to functions used by the package that are defined in another package.”\n\n“The imports environment is controlled by the package developer with the NAMESPACE file. Specifically, directives such as importFrom() and imports() populate this environment”\n\n\nIn order for app-package to work, users needs to have access to any add-on packages that are called in the code below R/. Knowing when, why, how and what happens to imports helps you decide how to fit these habits into your package development workflow."
  },
  {
    "objectID": "dependencies.html#checking-dependencies",
    "href": "dependencies.html#checking-dependencies",
    "title": "Dependencies",
    "section": "Checking dependencies",
    "text": "Checking dependencies\nWith all the moving parts in dependency management, it can be easy to forget if you’ve documented everything correctly. So far we haven’t covered using devtools::check() as part of your app-package habits (which is fine), but this is one area it’s particularly helpful.\nFor example, if I had listed shiny as an import using the @import tag (resulting in the import(shiny) directive in the NAMESPACE), devtools::check() would produce the following error:\n── R CMD check results ────────────────────────── moviesApp 0.0.0.9000 ────\nDuration: 7.4s\n\n❯ checking package dependencies ... ERROR\n  Namespace dependency missing from DESCRIPTION Imports/Depends entries: ‘shiny’\n  \n  See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’\n  manual.\n\n1 error ✖ | 0 warnings ✔ | 0 notes ✔\nError: R CMD check found ERRORs\nExecution halted\n\nExited with status 1."
  },
  {
    "objectID": "dependencies.html#recap",
    "href": "dependencies.html#recap",
    "title": "Dependencies",
    "section": "Recap",
    "text": "Recap\nBelow are the main takeaways from managing the imports and exports from your app-package:\n\n\n\n\n\n\nDependencies recap\n\n\n\n\n\n\nThis chapter covered:\n\nExports: Aim for a balance between simplicity and utility when deciding which functions to export (i.e., what functions should be available to users who install your package). Export objects from using @export\nImports: Use pkg::fun() syntax when you use add-on package functions and include them in the Imports field of the DESCRIPTION file. App-packages use so many shiny functions it makes sense to include @import shiny to 1) ensure all of these functions are available, and 2) you won’t need to use pkg::fun().\n\nDESCRIPTION Imports This field lists the packages your app-package uses. All add-on packages used in the R/ folder must be listed in the Imports field. These functions can be called using the pkg::fun() syntax (or with @importFrom()). Functions from these packages will be available for your package, but not for the user unless they use the :: operator or load the package themselves with library().\nNAMESPACE imports: The @import/@importFrom tags make the functions from add-on packages available to your package. Favor using @importFrom over @import for add-on package functions (the only exception being shiny, which you’d want to use @import).\n\n\nThe Imports field in the DESCRIPTION handles package-level dependencies (and it is managed manually or with usethis::use_package()), while the NAMESPACE handles function-level access (with @export and @import/@importFrom).\n\n\n\n\nIf you’d like to read more about package dependencies, I recommend Writing R Extensions (specifically the sections on dependencies 15 and namespaces 16).\nIn the next section, we’ll cover how the ensure the app.R file runs our application!"
  },
  {
    "objectID": "dependencies.html#footnotes",
    "href": "dependencies.html#footnotes",
    "title": "Dependencies",
    "section": "",
    "text": "I’ve made this process somewhat easier by explicitly namespacing all of the add-on package functions in moviesApp (i.e., with pkg::fun()).↩︎\nAdditional fields exists (i.e., Remotes), but these are special circumstances.↩︎\nRead more about this in the section titled, ‘In code below R/’ in R Packages, 2ed↩︎\n“if you are using just a few functions from another package, we recommending adding the package to the Imports: field of the DESCRIPTION file and calling the functions explicitly using ::, e.g., pkg::fun()”…“If the repetition of the package name becomes annoying you can @importFrom and drop the pkg::fun()”. Read more in the Importing functions section on the package website:↩︎\nUsing @import is not generally considered best practice, but it makes sense for app-packages: …for Shiny apps, I recommend using @import shiny to make all the functions in the Shiny package easily available. Mastering Shiny, R CMD check”↩︎\nSee the section titled, ‘Confusion about Imports’ in R Packages, 2ed, “Listing a package in Imports in DESCRIPTION does not ‘import’ that package.”↩︎\nUsers can access functions from add-on packages with the pkg::fun syntax↩︎\n“Our recommended default is to call external functions using the package::function() syntax” - R Packages, 2ed↩︎\nThe namespace controls the search strategy for variables used by functions in the package. If not found locally, R searches the package namespace first, then the imports, then the base namespace and then the normal search path (so the base namespace precedes the normal search rather than being at the end of it). - Writing R Extensions↩︎\nYou can also consolidate all @import and @importFrom tags into a single package doc file (i.e., R/[moviesApp]-package.R) by calling usethis::use_package_doc().↩︎\n“Using importFrom selectively rather than Imports is good practice and recommended notably when importing from packages with more than a dozen exports and especially from those written by others (so what they export can change in future).” - Specifying imports and exports.↩︎\n“Specifically, we recommend that you default to not importing anything from [add-on packages] into your namespace. This makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future. This also eliminates any concerns about name conflicts between [add-on packages] and your package.” - R Packages, 2ed↩︎\nSee the Function lookup inside a package Section of R Packages, 2ed↩︎\nSee the Package environments and the search path of Advanced R, 2ed↩︎\nSee section 1.1.3 Package Dependencies in Writing R Extensions↩︎\nSee section 1.5, Package namespaces in Writing R Extensions↩︎"
  },
  {
    "objectID": "data.html#app-package-data",
    "href": "data.html#app-package-data",
    "title": "Data",
    "section": "App-package data",
    "text": "App-package data\nData in R packages are typically stored in one of three folders: data/, data-raw/, and inst/extdata/. The folder you use will depend on the format, accessibility, and intended purpose of the data file.1"
  },
  {
    "objectID": "data.html#the-data-folder",
    "href": "data.html#the-data-folder",
    "title": "Data",
    "section": "The data/ folder",
    "text": "The data/ folder\nThe primary location for data is the data/ folder. Objects in data/ folder are available in your package namespace when it’s installed and loaded, and can be accessed with the :: syntax. See the example below of the storms data from dplyr:\n\nlibrary(dplyr)\nhead(dplyr::storms)\n## # A tibble: 6 × 13\n##   name   year month   day  hour   lat  long status\n##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; \n## 1 Amy    1975     6    27     0  27.5 -79   tropi…\n## 2 Amy    1975     6    27     6  28.5 -79   tropi…\n## 3 Amy    1975     6    27    12  29.5 -79   tropi…\n## 4 Amy    1975     6    27    18  30.5 -79   tropi…\n## 5 Amy    1975     6    28     0  31.5 -78.8 tropi…\n## 6 Amy    1975     6    28     6  32.4 -78.7 tropi…\n## # ℹ 5 more variables: category &lt;dbl&gt;, wind &lt;int&gt;,\n## #   pressure &lt;int&gt;,\n## #   tropicalstorm_force_diameter &lt;int&gt;,\n## #   hurricane_force_diameter &lt;int&gt;\n\n\nLazyData\nData files become part of a package when they’re added to the data/ folder and LazyData: true is added to the DESCRIPTION file.\n\nLazyData: true: the data is only loaded into memory if it is explicitly accessed by the user or a function in the package. Until then, only the dataset names is loaded. This practice user-friendly and is the default for most R packages.\nLazyData: false (or omitted): accessing a data file from the package requires explicitly loading it using the data() function.\n\nFiles in data/ should be in the .rda or .RData format. Below are the steps for adding movies to moviesApp:\n\nMove the movies.RData file into a newly created the data/ folder:\n\n\nmoviesApp/\n    └──data/\n        └── movies.RData\n\n\nInclude LazyData: true in the DESCRIPTION file (I’ve added it above Imports:):\n\n\nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nLazyData: true\nImports:\n  shiny,\n  ggplot2,\n  rlang,\n  stringr,\n  tools\n\n\nLoad, document, and install.\n\nCtrl/Cmd + Shift + L\nℹ Loading moviesApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nDocumentation completed\nCtrl/Cmd + Shift + B\nIn the Build pane, you’ll notice a few new ** data lines of output after adding data:\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\nWe can check to see if movies has been included in moviesApp using the package::data syntax:\n\n\n\n\n\n(a) roxygen2\n\n\nFigure 7.1: movies is now part of moviesApp\n\n\n\n\nusethis::use_data()\nIf you’d prefer to store data using the .rda format, the usethis package has the use_data() function that will automatically store an object in data/ in the .rda format.\nTo use usethis::use_data(), we can load the movies data into the global environment with load(\"movies.RData\"), then run usethis::use_data(movies):\n\nusethis::use_data(movies)\n\n✔ Setting active project to '/path/to/moviesApp'\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Saving 'movies' to 'data/movies.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nThe Depends: field is added to the DESCRIPTION file with an R version (this ensures the data files will be loaded)\nDepends: \n    R (&gt;= 2.10)\n(this function will also add LazyData: true to the DESCRIPTION)\n\n\nDocumenting data/\nDocumenting data can be tedious, but it’s worth the effort if you’ll be sharing your package with collaborators. There are multiple ways to store dataset documentation. A common approach is to create a data.R file in the R/ folder.2\n\nfs::file_create(\"R/data.R\")\n\nIn data.R, we provide a @title, @description, and @details for the data (with or without the tags), followed by @format:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)   \n#'\n#' @format\n\n\n@format\nThe text following @format is a one-sentence description of the data (with it’s dimensions).\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#' \n#' @format A data frame with [] rows and [] variables:\n\n\n\n\\describe & \\item\nEach variable (column) in the data is documented with a combination of \\describe and \\item (pay close attention to the curly brackets):\n\n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n\nAfter closing the curly brackets in \\describe, place the name of the data in quotes (\"movies\") on the following line.\nBelow is the documentation for the first five columns in the movies dataset:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#' }\n#'\n\"movies\"\n\nIf we load and document moviesApp, we can see a preview of the help file:\nCtrl/Cmd + Shift + L\nℹ Loading moviesApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nWriting movies.Rd\nDocumentation completed\n\n?movies\n\n\n\n\n\n\n(a) The movies help file\n\n\nFigure 7.2: Documentation for the movies dataset\n\n\nI’ve provided documentation for the full movies dataset below.\n\n\nshow/hide full movies data documenation\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#'  \\item{studio}{name of studio, chr}\n#'  \\item{thtr_rel_date}{Theatre release date, POSIXct, min = 1970-05-19 21:00:00, max = 2014-12-24 21:00:00}\n#'  \\item{thtr_rel_year}{Theatre release year, num, min = 1970, max = 2014}\n#'  \\item{thtr_rel_month}{Theatre release month, num, min = 1, max =12}\n#'  \\item{thtr_rel_day}{Theatre release day, num, min = 1, max =31}\n#'  \\item{dvd_rel_date}{DVD release date, POSIXct, min = 1991-03-27 21:00:00, max = 2015-03-02 21:00:00}\n#'  \\item{dvd_rel_year}{DVD release year, num, min = 1991, max = 2015}\n#'  \\item{dvd_rel_month}{DVD release month, num, min = 1, max = 12}\n#'  \\item{dvd_rel_day}{DVD release day, num, min = 1, max = 31}\n#'  \\item{imdb_rating}{Internet movie database rating, avg = 6.49, sd = 1.08}\n#'  \\item{imdb_num_votes}{Internet movie database votes, avg = 57533, sd = 112124}\n#'  \\item{critics_rating}{Rotten tomatoes rating, fct (Certified Fresh, Fresh, Rotten)}\n#'  \\item{critics_score}{Rotten tomatoes score, avg = 57.7, sd = 28.4}\n#'  \\item{audience_rating}{Audience rating, fct (Spilled, Upright)}\n#'  \\item{audience_score}{Audience score, avg = 62.4, sd = 20.2}\n#'  \\item{best_pic_nom}{Best picture nomination, fct (no, yes)}\n#'  \\item{best_pic_win}{Best picture win, fct (no, yes)}\n#'  \\item{best_actor_win}{Best actor win, fct (no, yes)}\n#'  \\item{best_actress_win}{Best actress win, fct (no, yes)}\n#'  \\item{best_dir_win}{Best director win, fct (no, yes)}\n#'  \\item{top200_box}{Top 20 box-office, fct (no, yes)}\n#'  \\item{director}{Name of director, chr}\n#'  \\item{actor1}{Name of leading actor, chr}\n#'  \\item{actor2}{Name of supporting actor, chr}\n#'  \\item{actor3}{Name of #3 actor, chr}\n#'  \\item{actor4}{Name of #4 actor, chr}\n#'  \\item{actor5}{Name of #5 actor, chr}\n#'  \\item{imdb_url}{IMDB URL}\n#'  \\item{rt_url}{Rotten tomatoes URL}\n#' }\n#'\n\"movies\"\n\n\n\n\n\nUsing movies\nAfter documenting the movies data in data.R, we’ll remove the call to load() in the mod_scatter_display_server() function and replace it with a direct call to the dataset:\n\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n\n  inputs &lt;- reactive({\n    plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n  })\n  output$scatterplot &lt;- renderPlot({\n    plot &lt;- scatter_plot(\n1      df = movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size\n    )\n    plot +\n      ggplot2::labs(\n        title = inputs()$plot_title,\n        x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n        y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n      ) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n})\n}\n\n\n1\n\nThe movies data from our package namespace\n\n\n\n\nAfter loading, documenting, and installing the package, we see the following application:\n\n\n\n\n\n\n(a) movies_app() with movies data file\n\n\nFigure 7.3: moviesApp::movies in movies_app()\n\n\n\n\nMore data/ examples\nTo illustrate other options for data documentation, we’ll use the dplyr package. dplyr stores its data in the data/ folder:\ndata/\n├── band_instruments.rda\n├── band_instruments2.rda\n├── band_members.rda\n├── starwars.rda\n└── storms.rda\nThe documentation for the datasets in dplyr are stored in R/ using a data- prefix:\nR/\n├── data-bands.R\n├── data-starwars.R\n└── data-storms.R\nThe three band_ datasets have documented in a single file, data-bands.R:\n\n\nshow/hide documentation for dplyr::band_ datasets\n# from the dplyr github repo: \n# https://github.com/tidyverse/dplyr/blob/main/R/data-bands.R\n# \n#' Band membership\n#'\n#' These data sets describe band members of the Beatles and Rolling Stones. They\n#' are toy data sets that can be displayed in their entirety on a slide (e.g. to\n#' demonstrate a join).\n#'\n#' `band_instruments` and `band_instruments2` contain the same data but use\n#' different column names for the first column of the data set.\n#' `band_instruments` uses `name`, which matches the name of the key column of\n#' `band_members`; `band_instruments2` uses `artist`, which does not.\n#'\n#' @format Each is a tibble with two variables and three observations\n#' @examples\n#' band_members\n#' band_instruments\n#' band_instruments2\n\"band_members\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments2\"\n\n\nIn the example above, note that two of the datasets (band_instruments and band_instruments2) have the @format set to NULL, and define the help search name with @rdname. The @examples tag can be used to view the dataset when users click ‘Run Examples’\nEither method works–what’s important is that each dataset in your package has documentation.\n\n\n\n\n\n\nDocumenting data in data/\n\n\n\n\n\nDocumenting data requires the following roxygen2 structure:\n#' \n#' @title single-sentence describing [data]\n#' \n#' @description\n#' Single-paragraph describing [data]\n#' \n#' @format [data] number of rows and columns:\n#' \\describe{\n#'  \\item{variable}{description}\n#'  \\item{variable}{description}\n#' }\n#'\n\"[data]\"\nReplace [data] with the name of your dataset."
  },
  {
    "objectID": "data.html#the-data-raw-folder",
    "href": "data.html#the-data-raw-folder",
    "title": "Data",
    "section": "The data-raw/ folder",
    "text": "The data-raw/ folder\nThe data-raw folder is not an official directory in the standard R package structure, but it’s a common location for any data processing or cleaning scripts, and the raw data file for datasets stored in data/.3\n\n\n\n\n\n\nScripts for creating movies data\n\n\n\n\n\n\nThe code used to produce the movies dataset in the data/ directory might* come from this GitHub repo. If so, the data-raw folder is where the data processing and preparation scritps would be stored (along with a copy of the data in .csv format) before saving a copy in the data/ folder.\n*I say ‘might’ because it’s not clear if the movies.RData is the output from these .R files (although many of the column names match).\n\n\n\n\n\nMore data-raw/ examples\nIf we look at the data in the dplyr package again, we can see the data-raw/ folder contains a combination of .R and .csv files:\ndata-raw/\n├── band_members.R\n├── starwars.R\n├── starwars.csv\n└── storms.R\n\n1 directory, 4 files\nIn this example, the starwars.R script downloads & prepares starwars, then saves a .csv copy of the data in data-raw."
  },
  {
    "objectID": "data.html#the-instextdata-folder",
    "href": "data.html#the-instextdata-folder",
    "title": "Data",
    "section": "The inst/extdata/ folder",
    "text": "The inst/extdata/ folder\nThe extdata folder (inside inst/) can be used for external datasets in other file formats (.csv, .tsv, .txt, .xlsx, etc).4 The data files in inst/extdata/ aren’t directly loadable using the package::data syntax or the data() function like with the data/ directory. These files can be imported using the file path accessor function, system.file().\nFor example, if we create the inst/extdata/ and save a copy of movies as a .fst file:\n\nlibrary(fs)\nlibrary(tibble)\nlibrary(fst)\n\n\nfst package v0.9.8\n\n\nfs::dir_create(\"inst/extdata/\")\nfst::write_fst(\n  x = movies, \n  path = \"inst/extdata/movies.fst\", \n  compress = 75)\n\n\nfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\n\nThen load, document, and install moviesApp:\nCtrl/Cmd + Shift + L / D / B\nWe can import movies.fst using system.file() to create a path to the file:\n\ntibble::as_tibble(\n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"moviesApp\")\n    )\n  )\n\n# A tibble: 651 × 34\n   title  title_type genre runtime mpaa_rating studio thtr_rel_date      \n   &lt;chr&gt;  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;  &lt;dttm&gt;             \n 1 Filly… Feature F… Drama      80 R           Indom… 2013-04-18 21:00:00\n 2 The D… Feature F… Drama     101 PG-13       Warne… 2001-03-13 21:00:00\n 3 Waiti… Feature F… Come…      84 R           Sony … 1996-08-20 21:00:00\n 4 The A… Feature F… Drama     139 PG          Colum… 1993-09-30 21:00:00\n 5 Malev… Feature F… Horr…      90 R           Ancho… 2004-09-09 21:00:00\n 6 Old P… Documenta… Docu…      78 Unrated     Shcal… 2009-01-14 21:00:00\n 7 Lady … Feature F… Drama     142 PG-13       Param… 1985-12-31 21:00:00\n 8 Mad D… Feature F… Drama      93 R           MGM/U… 1996-11-07 21:00:00\n 9 Beaut… Documenta… Docu…      88 Unrated     Indep… 2012-09-06 21:00:00\n10 The S… Feature F… Drama     119 Unrated     IFC F… 2012-03-01 21:00:00\n# ℹ 641 more rows\n# ℹ 27 more variables: thtr_rel_year &lt;dbl&gt;, thtr_rel_month &lt;dbl&gt;,\n#   thtr_rel_day &lt;dbl&gt;, dvd_rel_date &lt;dttm&gt;, dvd_rel_year &lt;dbl&gt;,\n#   dvd_rel_month &lt;dbl&gt;, dvd_rel_day &lt;dbl&gt;, imdb_rating &lt;dbl&gt;,\n#   imdb_num_votes &lt;int&gt;, critics_rating &lt;fct&gt;, critics_score &lt;dbl&gt;,\n#   audience_rating &lt;fct&gt;, audience_score &lt;dbl&gt;, best_pic_nom &lt;fct&gt;,\n#   best_pic_win &lt;fct&gt;, best_actor_win &lt;fct&gt;, best_actress_win &lt;fct&gt;, …\n# ℹ Use `print(n = ...)` to see more rows\nWe’ll cover inst/ and system.file() in more detail in the next chapter.\n\n\n\n\n\n\n\nThis section’s code is in the 09_data branch of moviesApp."
  },
  {
    "objectID": "data.html#recap",
    "href": "data.html#recap",
    "title": "Data",
    "section": "Recap",
    "text": "Recap\nIt’s common for shiny apps to require data, so knowing how to store and access these files in your app-package will make it easier to load and reproducible in other environments. Here are a few other things to consider when including data in your app-package:\n\n\n\n\n\n\nRecap: Package data files\n\n\n\n\n\n\n\ndata/: All data files stored in data/ will be ‘lazy loaded’ (see below) when the package is installed and loaded.\nLoading: include the LazyData: true field in the DESCRIPTION file so the data is only loaded when it’s used (and it increases package loading speed).\nSize: large data files can inflate the size of your app-package, making it harder for users to download and install. CRAN also has a size limit for packages (if you plan on submitting your app-package).\nFormat: data files in data/ must be either .rda or .RData format.\nDocumentation: document the data/ files in either a single R/data.R file or individual .R files. Documentation should include the following roxygen2 format:\n#' \n#' @title \n#' \n#' @description\n#' \n#' @format \n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n#'\n'data'\ninst/extdata/: Store external data in the inst/extdata/ directory and access it using system.file(). This can be helpful if your app-package needs access to data files that are not R objects. For faster loading, consider the fst or feather formats."
  },
  {
    "objectID": "data.html#footnotes",
    "href": "data.html#footnotes",
    "title": "Data",
    "section": "",
    "text": "Read more about the data folder in the ‘Data in packages’ section of Writing R Extenstions and the ‘Data’ chapter of R Packages, 2ed.↩︎\nThe ggplot2 package has a great example of documenting datasets in the R/data.R file↩︎\nRead more about the data-raw folder in R Packages, 2ed↩︎\nRead more about the inst/extdata/ folder in R Packages, 2ed↩︎"
  },
  {
    "objectID": "launch.html#app.r",
    "href": "launch.html#app.r",
    "title": "Launch",
    "section": "app.R",
    "text": "app.R\nIn the current branch of moviesApp, the app.R file loads our package and runs the standalone app function:\n\n\n\n\n\n\nTerminology\n\n\n\n\n\n\nI’ll be using the term ‘launch’ to differentiate successfully running an application locally (either in the IDE window, viewer pane, or browser) from clicking on the Run App icon or calling runApp() and deploying an application to shinyapps.io.\n\n\n\n\n\n\n\n\n\n\n\n\nGit branch: 08b_pkg-imports\n\n\n\nshow/hide app.R\n1# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n2# packages ------------------------------------\nlibrary(moviesApp)\n\n3# movies_app ------------------------------------\nmovies_app()\n\n\n\n1\n\nInstall packages (if needed)\n\n\n2\n\nLoad package\n\n\n3\n\nCall standalone app function\n\n\n\n\nmovies_app() is a wrapper function for shinyApp(), where it passes movies_ui() and movies_server() to the ui and server arguments.\n\nClicking ‘Run App’\nAs we can see in the image below, the Run App icon is available in the Source pane:\n\n\n\n\n\n(a) app.R in main branch\n\n\nFigure 8.1: Run App icon in app.R of main branch\n\n\nIf we load the code in R/ with load_all(), then click on Run App, we see this calls runApp() in the Console, but this also produces a warning:\n\n\n\n\n\n(a) Calling runApp() in main\n\n\nFigure 8.2: The application is launched (with the loadSupport() warning)"
  },
  {
    "objectID": "launch.html#app.r-07_roxygen2-branch",
    "href": "launch.html#app.r-07_roxygen2-branch",
    "title": "Launch",
    "section": "app.R (07_roxygen2 branch)",
    "text": "app.R (07_roxygen2 branch)\nLet’s jump back to the 07_roxygen2 branch of moviesApp. This is the first version of moviesApp with movies_app() in the R/ folder (i.e., in R/movies_app.R).\n\n\n\n\n\n\n\n\nGit branch: 07_roxygen2\n\n\nR/\n├── mod_scatter_display.R\n├── mod_var_input.R\n1├── movies_app.R\n├── movies_server.R\n├── movies_ui.R\n└── utils.R\n\n1 directory, 6 files\n\n\n1\n\nThe movies_app() standalone function\n\n\n\n\nBy moving the call to shinyApp() into the R/ folder, we no longer have the Run App icon in the app.R file:\n\n\n\n\n\n(a) app.R in 07_roxygen2 branch\n\n\nFigure 8.3: No Run App icon in app.R of 07_roxygen2 branch\n\n\nIn the 07_roxygen2 branch, the movies_app() function hasn’t been exported, so we should expect the following error when we run the contents of app.R:\nError in movies_app() : could not find function \"movies_app\"\nHowever, calling runApp() from the Console will launch the app.\n\nCalling runApp()\nThis behavior might be surprising to you–runApp() can launch the application in moviesApp, even without the standalone app function exported from the package namespace (but it still produces the loadSupport() warning).\n\n\n\n\n\n(a) runApp() with 07_roxygen2 branch\n\n\nFigure 8.4: Calling runApp() in the Console of 07_roxygen2 branch\n\n\n\n\nloadSupport()–feature or bug?\n\n\n\n\n\n\nWarning in loadSupport\n\n\n\n\n\n\n\nshiny::runApp()\n\n\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL):\n  Loading R/ subdirectory for Shiny application, but this directory \n  appears to contain an R package. \n  Sourcing files in R/ may cause unexpected behavior.\n\n\n\n\n\nThe warning in the Console is telling us loadSupport()1 has detected that moviesApp is a package, but it’s still sourcing the R/ subdirectory.\nThe examples above demonstrate the differences between calling shinyApp() and runApp(), and the tensions between having a standalone app function in an R package vs. having an app.R file in a Shiny project.\nIn the following sections, we’ll compare shinyApp(), shinyAppDir(), and runApp() to determine which one to use in R/movies_app.R and the app.R file."
  },
  {
    "objectID": "launch.html#launching-your-shiny-app",
    "href": "launch.html#launching-your-shiny-app",
    "title": "Launch",
    "section": "Launching your shiny app",
    "text": "Launching your shiny app\n\nshinyApp(), shinyAppDir(), or runApp()\nDuring development, the IDE provides the Run App icon for launching the application.\n\n\n\nThe Run App icon in the Source pane calls runApp())\n\n\nAs we’ve seen, Run App calls runApp(), even when we have a call to shinyApp() in the app.R file. This might make you wonder,\n“Why even include a call to shinyApp() if the app is being launched with runApp()?”\nLet’s review what happens when we call shinyApp(), shinyAppDir(), and runApp():\n\nshinyApp()\n\n\n\n\n\n\nshinyApp()\n\n\n\n\n\n\n\n\n\nshinyApp(): Creates and launches an app defined inline within the call itself (or with UI and server functions passed as arguments).\n\n\nshinyApp(\n  ui = fluidPage(\n    # UI elements\n  ),\n  server = function(input, output) {\n    # Server logic\n  }\n)\n\n\n\n\n\n\n\nOne of the key features of shinyApp() is the creation of the shiny.appobj (a shiny app object):\n\napp &lt;- shinyApp(ui = movies_ui, \n                server = movies_server)\nstr(app)\n\nIf we look at the structure of the returned object from shinyApp(), we see the shiny.appobj includes the appDir under appOptions:\n\nList of 5\n $ httpHandler     :function (req)  \n $ serverFuncSource:function ()  \n $ onStart         : NULL\n $ options         : list()\n $ appOptions      :List of 2\n1  ..$ appDir       : chr \"/path/to/moviesApp\"\n  ..$ bookmarkStore: NULL\n2 - attr(*, \"class\")= chr \"shiny.appobj\"\n\n\n1\n\nappDir is the first argument of runApp()\n\n\n2\n\nA shiny app object\n\n\n\n\nThis is why runApp() works with any .R file creating a shiny app object.\n\n\nshinyAppDir()\n\n\n\n\n\n\nshinyAppDir()\n\n\n\n\n\n\n\n\n\nshinyAppDir(): Launches an app from a directory (with an app.R or ui.R/server.R files).\n\n\nshinyAppDir(\n  appDir = \"path/to/app/\", \n  options = list())\n\n\n\n\n\n\n\nshinyAppDir() is similar to shinyApp(), but is designed to use a “path to directory that contains a Shiny app.”\nIn practice, we can use shinyAppDir() with a returned object from shinyApp():\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server\n      )\napp$appOptions$appDir\n\n\n[1] \"path/to/moviesApp\"\n\nThis path can be passed to the appDir argument (along with any shiny options).\n\nshinyAppDir(\n  appDir = app$appOptions$appDir,\n  options(test.mode = TRUE)\n)\n\n\n\nrunApp()\n\n\n\n\n\n\nrunApp()\n\n\n\n\n\n\n\n\n\nrunApp(): A generalized way to launch your app–it can run apps defined inline, or from a directory.\n\n\nrunApp(\n  appDir = \"path/to/app/\",\n  test.mode = TRUE/FALSE)\n\n\n\n\n\n\n\nThe reason we’re able to call runApp() in the Console to launch both applications above is because it’s versatile:\n\n\n\nrunApp()\nCan launch an app from a directory (i.e., from ui.R/server.R, or a app.R):\n\n\nIn moviesApp\n# In console\nrunApp()\n\n\n\n\nWorks with a path to an .R file that creates a shiny.appobj:2\n\n\nrunApp(appDir = \"path/to/moviesApp\")\n\n\n\n\nCan also use a shiny.appobj directly:\n\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server)\nrunApp(appDir = app)\n\n\n\nThis final method does not produce the loadSupport() warning because a Shiny object (shiny.appobj) has already been created, and runApp() is essentially calling print(app) in the Console.\n\nRecap\nshinyApp() is typically used to create apps within an interactive R session, while shinyAppDir() runs a Shiny app stored in a directory (containing an app.R file (or ui.R and server.R files). runApp() also launches apps in a directory, but it’s versatility makes it suitable for running apps in various formats, either defined inline or in separate directories.3"
  },
  {
    "objectID": "launch.html#app-launch-options",
    "href": "launch.html#app-launch-options",
    "title": "Launch",
    "section": "App launch options",
    "text": "App launch options\nBelow I’ll cover two options to consider when writing a standalone app function (and what you’ll include in app.R).\n\nif (interactive())\nThe first thing we should include is a check to see if there is a “human operator to interact with” with base::interactive():\n\nif (interactive()) {\n  \n} else {\n   \n}\n\nYou have probably seen control flow like this in shiny help file examples (like flowLayout() below):\n\n\n\n\n\n(a) if (interactive()) in flowLayout() example\n\n\nFigure 8.5: Running examples ‘interactively’ let’s us see the app demo beneath the code\n\n\nif (interactive()) allows us to distinguish between launching the app from a Posit Workbench session (i.e., during development) and deploying the application (i.e., publishing the application on Posit Connect).\n\n\noptions\nAn options argument can be passed to shinyApp() or shinyAppDir(). For example, one of the Shiny options we could include in our standalone app function is test.mode:\n\n‘Should the application be launched in test mode? This is only used for recording or running automated tests. Defaults to the shiny.testmode option, or FALSE if the option is not set.’\n\ntest.mode lets us export values from our application when we’re running tests (which we’ll cover in-depth in the Tests section).\nWe’ll make options an argument (defaulting to an empty list()) in our updated movies_app() function.\n\nmovies_app &lt;- function(options = list()) {\n    shinyApp(\n1      ui = movies_ui(),\n      server = movies_server,\n2      options = options\n      )\n}\n\n\n1\n\nBuild the shiny app object with movies_ui and movies_server\n\n\n2\n\nInclude options list\n\n\n\n\n\n\nshinyViewerType\nI’ve written display_type() helper function to control where the Shiny app is launched. The run argument in display_type() takes the following options:\n\n\"p\" = Viewer Pane\n\n\"w\" = IDE Window\n\n\"b\" = External browser\n\nThe option to access configuration is shiny.launch.browser:4\n\ndisplay_type &lt;- function(run = \"w\") {\n  if (run == \"p\") {\n    options(shiny.launch.browser = .rs.invokeShinyPaneViewer)\n  } else if (run == \"b\") {\n    options(shiny.launch.browser = .rs.invokeShinyWindowExternal) \n  } else if (run == \"w\") {\n    options(shiny.launch.browser = .rs.invokeShinyWindowViewer) \n  } else {\n    options(shiny.launch.browser = NULL)\n  }\n    shinyViewerType &lt;- getOption('shiny.launch.browser') |&gt; \n                        attributes() |&gt; \n                        unlist() |&gt; \n                        unname()\n    cli::cli_alert_info(\"shinyViewerType set to {shinyViewerType}\")\n}\n\n\nSet option\n\nGet option\n\nPrint option to console\n\nThe roxygen2 documentation for display_type() is below:\n\n\nshow/hide roxygen2 for R/display_type.R\n#' Shiny app display mode helper\n#'\n#' @param run where to launch app: \n#'  * `\"p\"` = launch in viewer pane \n#'  * `\"b\"` = launch in external browser  \n#'  * `\"w\"` = launch in window (default)\n#'\n#' @return notification of `shinyViewerType` option\n#' \n#' @export\n#'\n\n\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe cli package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('cli')."
  },
  {
    "objectID": "launch.html#updated-movies_app",
    "href": "launch.html#updated-movies_app",
    "title": "Launch",
    "section": "Updated movies_app()",
    "text": "Updated movies_app()\nIn movies_app(), I’ll add the interactive() check, display_type(), and test.mode option:\n\nmovies_app &lt;- function(options = list(), run = \"w\") {\n1  if (interactive()) {\n2    display_type(run = run)\n  }\n3    shinyApp(\n      ui = movies_ui(),\n      server = movies_server,\n      options = options\n    )\n}\n\n\n1\n\nCheck if interactive (Workbench) launch\n\n\n2\n\nSet shinyViewerType option with display_type()\n\n\n3\n\nLaunch app\n\n\n\n\nAfter loading, documenting, and installing the package, I can test my new standalone app function:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\n\n\n\n\n(a) updated movies_app() function\n\n\nFigure 8.6: The updated movies_app() function launches the application in the window (without the loadSupport() warning)\n\n\nNow we can see movies_app() is launching the application without the loadSupport() warning. We can also adjust the test and run arguments to see make sure these are implemented correctly:\n\n\n\n\n\n(a) test and run arguments in movies_app()\n\n\nFigure 8.7: Launching movies_app() in Viewer pane and test.mode"
  },
  {
    "objectID": "launch.html#updated-app.r",
    "href": "launch.html#updated-app.r",
    "title": "Launch",
    "section": "Updated app.R",
    "text": "Updated app.R\nYour app.R file should contain any options or settings that you’ll use during development. There are multiple ways to launch an application from app.R, and I encourage you to explore the options below to find a method that works for your workflow/environment.\n\nNon-interactive behaviors\n\n\nWhat if the session isn’t interactive (i.e., !interactive() == TRUE)?\nIn this case, we’ll divert all regular output to the standard error stream.\n\n\nstderr()\nThe sink() function “diverts R output to a connection”, so the code below sends the output that would normally print to the console to the where error messages are written.\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n} else {\n   \n}\n\nThis is useful in a non-interactive settings if we want to re-direct the error output for the console text-mode connection.\n\n\ntryCatch()\ntryCatch() is used for ‘catching conditions’ during the execution of an expression (expr =):\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(moviesApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   \n}\n\nIn this case, if library(moviesApp) throws an error, the function specified after error = is executed (i.e., pkgload::load_all()).5\nWritten this way, in a non-interactive R session, app.R will re-direct the error output and attempt to load and attach moviesApp, and if this fails, app.R will attempt to load all the files in the R/ folder.\n\n\n\npkgload\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe pkgload package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('pkgload').\n\n\n\n\nIf the session is interactive (i.e., !interactive() == FALSE), we want app.R to load all the code in the R/ folder with pkgload::load_all().6\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(moviesApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   pkgload::load_all()\n}\n\n\n\nwithr\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nThe withr package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('withr').\n\n\n\n\nThe withr package is designed to ‘run code with safely and temporarily modified global state’, and it comes in handy when launching shiny apps. For example, I want to turn off the loadSupport() behavior when launching the app from app.R.7\nI can use withr::with_options() to accomplish this using the following new and code arguments\n\nnew: a named list of the new options and their values\n\ncode: the ’Code to execute in the temporary environment\n\nI want to place the withr::with_options() at the top of app.R and pass contents of app.R into the code argument. Just to be sure no options for shiny.autoload.r previously exist, I’ll also set this option to NULL before executing the rest of the code.\n\n1withr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n2  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(moviesApp)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n3  } else {\n    pkgload::load_all()\n  }\n4    moviesApp::movies_app(\n      options = list(test.mode = TRUE), run = 'p')\n})\n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nDefine non-interactive behaviors\n\n\n3\n\nDefine interactive behaviors\n\n\n4\n\nLaunch app (with options)\n\n\n\n\nNow that we’ve updated the app.R account for the app-package structure, we should load, document, and install moviesApp and run it’s contents:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B"
  },
  {
    "objectID": "launch.html#running-app.r",
    "href": "launch.html#running-app.r",
    "title": "Launch",
    "section": "Running app.R",
    "text": "Running app.R\nWhen we send the contents of app.R to the Console, the loadSupport() options are applied before running the app:\n\n\n\n\n\n\n\nThis section’s code is in the 10_launch-app branch of moviesApp.\n\n\n\n\n\n(a) Sending app.R to Console\n\n\nFigure 8.8: The application is launched without the loadSupport() warning\n\n\n\n\n\n\n\n\nR/_disable_autoload.R\n\n\n\n\n\n\nIn the documentation for loadSupport(), you’ll find a second option for removing the R/ directory sourcing behavior: placing a _disable_autoload.R file in the R/ directory (this is also one of the behaviors of the golem framework, which we will cover in the following chapters).\nBoth methods work–this chapter demonstrates a way to remove the loadSupport() warning without having to add this file."
  },
  {
    "objectID": "launch.html#deploying-the-app",
    "href": "launch.html#deploying-the-app",
    "title": "Launch",
    "section": "Deploying the app",
    "text": "Deploying the app\nTo deploy the app, I can click on the Publish icon:\n\n\n\n\n\n(a) Click on the Publish icon\n\n\nFigure 8.9: Send app.R to Console and click Publish\n\n\nMake sure all the files in the package are selected, then click Publish\n\n\n\n\n\n(a) Publishing apps to shinyapps.io\n\n\nFigure 8.10: Publish the entire package to shinyapps.io\n\n\nThe Deploy pane will open and you’ll see a deployment log as your application is sent to the server:\n\n\nshow/hide deployment log\n── Preparing for deployment ────────────────────────────────────────────────────\nℹ Creating application on server...\n✔ Created application with id 10026672\nℹ Bundling 24 files: .Rbuildignore, app.R, DESCRIPTION, launch.R, movies.RData, NAMESPACE, README.md, www/shiny.png, man/display_type.Rd, man/mod_scatter_display_server.Rd, man/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, man/mod_var_input_ui.Rd, man/movies_app.Rd, man/movies_server.Rd, man/movies_ui.Rd, man/scatter_plot.Rd, R/display_mode.R, …, R/movies_ui.R, and R/scatter_plot.R\nℹ Capturing R dependencies with renv\n✔ Found 63 dependencies\n✔ Created 258,028b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 7740376\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1340526445\n  building: Parsing manifest\n  building: Building image: 9212796\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9212796\n  deploying: Starting instances\n  rollforward: Activating new instances\n  unstaging: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://yourusername.shinyapps.io/shinyap-run-app/&gt;\nDeployment completed: https://yourusername.shinyapps.io/shinyap-run-app/\n\n\nYou can view a deployed version of this application here."
  },
  {
    "objectID": "launch.html#recap-1",
    "href": "launch.html#recap-1",
    "title": "Launch",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some options for launching your app within your app-package. We went over what to include in the standalone app function and the app.R file, the differences between shinyApp(), shinyAppDir() and runApp(), but it’s worth exploring these topics further (especially if you plan on having more than one apps in your package).\n\n\n\n\n\n\nRecap: launching your app\n\n\n\n\n\n\nshinyApp():\n\nshinyApp() doesn’t care about file structure, so it’s useful for quick prototyping or if the app is in a single .R script. It’s also more portable because you can share your app with a single .R script.\n\nIt’s possible to bundle shinyApp() in a wrapper function to integrate within an R package (like we’ve done with movies_app()).\nshinyApp() returns a shiny app object, which can be useful if you want to explore the app structure programmatically (i.e., testing).\n\n\nshinyAppDir():\n\nshinyAppDir() launches an app from a directory, and is useful if an app is spread across multiple files and folders.\n\nrunApp()\n\nrunApp() a more generalized way to launch an app. It works with:\n\napps contained in a directory (i.e., runApp('path/to/app')\napps in separate ui.R and server.R files (or a single app.R file)\na shiny app object (passed to the appDir argument).\n\nClicking on Run App will run the application with runApp() if is detects a file (or files) that creates a shiny object.\n\n\n\n\n\nIn the following chapter, we’re going to cover how to ensure movies.Data becomes part of the moviesApp namespace."
  },
  {
    "objectID": "launch.html#footnotes",
    "href": "launch.html#footnotes",
    "title": "Launch",
    "section": "",
    "text": "If you recall, we covered the loadSupport() function in Chapter 1.↩︎\nShiny’s examples are run using runApp()↩︎\nIt’s worthwhile to read the documentation on shinyApp(), shinyAppDir(), and runApp().↩︎\nThe shiny.launch.browser options are covered in this blog post by Garrick Aden-Buie, and I’ve combined them into a run argument in movies_app()↩︎\npkgload is part of the conscious uncoupling of the devtools package we learned about back in Chapter 3.↩︎\npkgload::load_all() is the function that’s actually called when we run devtools::load_all() (or use Ctrl/Cmd + Shift + L), and this is somewhat analogous to running library(moviesApp)↩︎\nYou can read more about the shiny.autoload.r option and loadSupport() in this article↩︎"
  },
  {
    "objectID": "external.html#what-happened-to-our-icon-image",
    "href": "external.html#what-happened-to-our-icon-image",
    "title": "External files",
    "section": "What happened to our icon image?",
    "text": "What happened to our icon image?\n\n\n\n\n\n\n\n\nGit branch: 10_launch\n\nWhen we launch our app using the standalone app function, we see the following:\n\nmovies_app(run = 'p')\n\n\n\n\n\n\n\n(a) movies_app() without logo\n\n\nFigure 9.1: www/shiny.png is not accessible when we launch the app\n\n\n\nThe shiny.png logo in www/ is not being loaded into the UI when the application is launched. Serving the contents of www was previously being handled automatically by the Shiny framework, but now that moviesApp is an R package, we’ll need to explicitly tell the application where to find these resources.1"
  },
  {
    "objectID": "external.html#our-app-package-files",
    "href": "external.html#our-app-package-files",
    "title": "External files",
    "section": "Our app-package files",
    "text": "Our app-package files\nWhile developing, we are used to interacting with our app-package from the Files pane:\n\n\n\n\n\n(a) ‘Source’ files moviesApp in Files pane\n\n\nFigure 9.2: ?(caption)\n\n\nHowever, when we run install() (or use Ctrl/Cmd + Shift + B), the output in the Build pane gives us the location of our installed package:\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source moviesApp\n\n1* installing to library ‘/path/to/installed/package/moviesApp/’\n* installing *source* package ‘moviesApp’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** inst\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE \n\n\n1\n\nThis is the location of the installed version of moviesApp"
  },
  {
    "objectID": "external.html#our-app-package-installed",
    "href": "external.html#our-app-package-installed",
    "title": "External files",
    "section": "Our app-package … installed",
    "text": "Our app-package … installed\nIf we were to moviesApp to the path above, we’d see the files and folders in our installed package. Below are folder trees for our source package and our installed package:2\n\n\n\n\nsource/moviesApp/\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── data.R\n│   ├── display_type.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── movies_app.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   └── scatter_plot.R\n├── README.md\n├── app.R\n├── data\n│   ├── movies.RData\n│   └── movies.rda\n├── inst\n│   └── extdata\n│       └── movies.fst\n├── man\n│   ├── display_type.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── movies_app.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   └── scatter_plot.Rd\n├── moviesApp.Rproj\n└── www\n    └── shiny.png\n\n\n\n\ninstalled/moviesApp/\n├── DESCRIPTION\n├── INDEX\n├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R\n│   ├── moviesApp\n│   ├── moviesApp.rdb\n│   └── moviesApp.rdx\n├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── extdata\n│   └── movies.fst\n├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── moviesApp.rdb\n│   ├── moviesApp.rdx\n│   └── paths.rds\n└── html\n    ├── 00Index.html\n    └── R.css\n\n\n\n\nThe installed version of moviesApp has many of the same files as the ‘source’ version we’ve been working with (i.e., NAMESPACE and DESCRIPTION). It also might surprise you to see that many of the source files aren’t included in the installed version of moviesApp (.R, .Rd files. etc.).\nViewing the contents of your installed package should help demystify what happens when we run devtools::install() and give you a better idea of how system.file() works.3\n\n“The contents of the inst/ subdirectory will be copied recursively to the installation directory. Subdirectories of inst/ should not interfere with those used by R (currently, R/, data/, demo/, exec/, libs/, man/, help/, html/ and Meta/, and earlier versions used latex/, R-ex/).” - Writing R extensions, Package subdirectories"
  },
  {
    "objectID": "external.html#system.file",
    "href": "external.html#system.file",
    "title": "External files",
    "section": "system.file()",
    "text": "system.file()\nsystem.file() gives us access to the package files on installation (i.e., the files we saw in the folder tree above). In the data chapter, we used system.file() to access the movies.fst file in inst/extdata/:\n\nfst::read_fst(\n  path = system.file(\"extdata/\", \"movies.fst\", \n                     package = \"moviesApp\")\n  )\n\nAs we can see, the movies.fst has two locations: the ‘source’ package location, and the ‘installed’ location.\n\n\n\nSource package files\ninst/\n  └── extdata/\n        └── movies.fst\n\n\nInstalled package files\n└── extdata/\n      └── movies.fst\n\n\n\nsystem.file() is accessing movies.fst from the installed location.4\nTo include the contents of www/ in our app-package, we’ll need to move www/ into inst/, then access it’s contents with system.file() and addResourcePath()."
  },
  {
    "objectID": "external.html#addresourcepath",
    "href": "external.html#addresourcepath",
    "title": "External files",
    "section": "addResourcePath()",
    "text": "addResourcePath()\n\n\n\n\n\n\n\nThis section’s code is in the 11a_inst-www branch of moviesApp.\nThe addResourcePath() function will add a “directory of static resources to Shiny’s web server.” In moviesApp, want to add the www directory that includes the shiny.png file.5\n\n\n\nCurrent www location\n├── inst\n│   └── extdata\n│       └── movies.fst\n└── www\n    └── shiny.png\n\n\n \n\n\nNew www location\ninst/\n  ├── extdata/\n  │   └── movies.fst\n  └── www/\n      └── shiny.png\n\n\n\nIn R/movies_ui.R function, we’ll include the addResourcePath() at the top of the tagList() and reference the image in img() using only the subfolder in the path:\n\nmovies_ui &lt;- function() {\n  addResourcePath(\n1    prefix = 'www',\n2    directoryPath = system.file('www', package = 'moviesApp'))\n  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n3            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\n\n1\n\nPrefix (or folder name) of installed location\n\n\n2\n\nPath to installed package files\n\n\n3\n\nReference to installed package image file\n\n\n\n\nAfter loading, documenting, and installing, the application now includes the image file.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nlibrary(moviesApp)\nmovies_app(run = 'p')\n\n\n\n\n\n\n\n(a) movies_app() with logo\n\n\nFigure 9.3: inst/www accessible with addResourcePath()"
  },
  {
    "objectID": "external.html#app-versions-with-inst",
    "href": "external.html#app-versions-with-inst",
    "title": "External files",
    "section": "App versions with inst/",
    "text": "App versions with inst/\nThe inst/ folder can also be used to store files we’re using in alternate versions of our application. This can include alternate images, CSS styling, JS scripts, data files, or even entirely different apps!\n\nwww/ versions\nWe can store inst/ alternative external files and configure our UI function to test different layouts. In the example below, I’ve included an optional UI layout from the bslib package.\n\n\n\n\n\n\n\nThis section’s code is in the 11b_inst-bslib branch of moviesApp.\nThe bslib argument in the movies_ui() includes an alternate image file (stored in inst/www/bootstrap.png):\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nRemember to include the bslib and sass packages to your DESCRIPTION with usethis::use_package().\n\n\n\n\n\n\nshow/hide movies_ui()\nmovies_ui &lt;- function(bslib = FALSE) {\n1  addResourcePath(\n    prefix = 'www',\n    directoryPath = system.file('www', package = 'moviesApp'))\n  if (isFALSE(bslib)) {\n2  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ),\n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n3  } else {\n    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n                  tags$img(\n4                  src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\"\n                )\n              ),\n             bslib::card_body(\n              mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n\n1\n\nInclude inst/www resources\n\n\n2\n\nStandard fluidPage()\n\n\n3\n\nbslib layout\n\n\n4\n\nReference to alternate image (bootstrap.png)\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nThis alternate version of movies_app() uses the same modules and utility functions as the previous versions, but when bslib = TRUE, the app displays the alternate UI layout:\n\nmovies_app(run = 'p', bslib = TRUE)\n\n\n\n\n\n\n\n(a) movies_app() with logo\n\n\nFigure 9.4: inst/www/bootstrap.png image from movies_ui()\n\n\n\nThe example above was a simple, but using inst/ to hold alternate features (i.e., images or custom .html, .css, .sass, .js code) that can be easily displayed with an optional argument is a great tool for demonstrating features to users and stakeholders.\n\n\ndev/ versions\nIt’s not uncommon to be working on multiple ‘development’ versions of an application in the same package. In these situations, we might want to begin developing our application in the inst/dev folder:\n\ninst/dev/\n  ├── app.R\n  ├── tidy_movies.fst\n  └── imdb.png\n\n1 directory, 3 files\n\n\ndev/ data\nThe ‘development’ application in moviesApp uses a tidy version of the ggplot2movies::movies data, which we created in the data-raw/tidy_movies.R file.6\n\n\nshow/hide data-raw/tidy_movies.R\n## code to prepare `ggp2movies` dataset goes here\n# pkgs &lt;- c('ggplot2movies', 'tidyr', 'dplyr', 'stringr', 'fst')\n# install.packages(pkgs, quiet = TRUE)\n\n# load packages --------------------\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(fst)\n\n# tidy_movies\ntidy_movies &lt;- ggplot2movies::movies |&gt;\n  tidyr::pivot_longer(c(Action:Short),\n    names_to = \"genre_key\",\n    values_to = \"genre_value\"\n  ) |&gt;\n  dplyr::mutate(genre_value = as.logical(genre_value)) |&gt;\n  dplyr::select(\n    title, genre_key, genre_value, length,\n    year, budget, avg_rating = rating, votes, mpaa\n  ) |&gt;\n  dplyr::filter(genre_value == TRUE) |&gt;\n  dplyr::group_by(title) |&gt;\n  dplyr:::mutate(\n    genres = paste0(genre_key, collapse = \", \")\n  ) |&gt;\n  dplyr::select(\n    title, genres, length, year,\n    budget, avg_rating, votes, mpaa\n  ) |&gt;\n  dplyr::ungroup() |&gt;\n  dplyr::distinct(.keep_all = TRUE) |&gt;\n  dplyr::mutate(\n    genres = dplyr::na_if(x = genres, \"\"),\n    genre = dplyr::case_when(\n                stringr::str_detect(genres, \",\") ~ 'Multiple genres',\n                TRUE ~ genres),\n    genre = factor(genre),\n    mpaa = dplyr::na_if(x = mpaa, y = \"\"),\n    mpaa = factor(mpaa,\n      levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n      labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"))\n    ) |&gt; \n  dplyr::select(-genres)\n# save to inst/dev/\nfst::write_fst(x = tidy_movies, path = \"inst/dev/tidy_movies.fst\")\n\n\n\n\ndev/ code\nIn inst/dev/, we’ve placed the application modules in an app.R file. Any of the functions from moviesApp can be used in the dev/ modules with explicit namespacing (i.e., moviesApp::scatter_plot()).\n\nModules\ndev_mod_vars_ui() contains choices for the names in the tidy_movies data, but there’s no need to re-write the mod_var_input_server() function.\n\n\nshow/hide dev_mod_vars_ui()\ndev_mod_vars_ui &lt;- function(id) {\n      ns &lt;- NS(id)\n      tagList(\n        textInput(\n          inputId = ns(\"plot_title\"),\n          label = \"Plot title\",\n          placeholder = \"Enter plot title\"\n        ),\n        selectInput(\n          inputId = ns(\"y\"),\n          label = \"Y-axis:\",\n          choices = c(\n            \"Year\" = \"year\",\n            \"Length\" = \"length\",\n            \"Budget\" = \"budget\",\n            \"Rating\" = \"avg_rating\",\n            \"Votes\" = \"votes\"\n          ),\n          selected = \"budget\"\n        ),\n        selectInput(\n          inputId = ns(\"x\"),\n          label = \"X-axis:\",\n          choices = c(\n            \"Year\" = \"year\",\n            \"Length\" = \"length\",\n            \"Budget\" = \"budget\",\n            \"Rating\" = \"avg_rating\",\n            \"Votes\" = \"votes\"\n          ),\n          selected = \"year\"\n        ),\n        selectInput(\n          inputId = ns(\"z\"),\n          label = \"Color by:\",\n          choices = c(\n            \"MPAA\" = \"mpaa\",\n            \"Genre\" = \"genre\"\n          ),\n          selected = \"mpaa\"\n        ),\n        sliderInput(\n          inputId = ns(\"alpha\"),\n          label = \"Alpha:\",\n          min = 0, max = 1, step = 0.1,\n          value = 0.4\n        ),\n        sliderInput(\n          inputId = ns(\"size\"),\n          label = \"Size:\",\n          min = 0, max = 5, step = 0.5,\n          value = 2.5\n        )\n      )\n  }\n\n\nBoth functions in the dev/ display module has been re-written to add functionality for importing the tidy_movies.fst data file and an option to removing missing values from the graph.\n\n\nshow/hide dev_mod_scatter_ui()\ndev_mod_scatter_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    tags$br(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\n1        \"The data for this application comes from the \",\n          tags$a(\"ggplot2movies\",\n          href = \"https://github.com/hadley/ggplot2movies\"\n          ),\n          \"package\"\n        )\n      )\n    ),\n    tags$div(\n2      checkboxInput(\n        inputId = ns(\"missing\"),\n        label = \"Remove missing\",\n        value = TRUE\n      ),\n      plotOutput(outputId = ns(\"scatterplot\"))\n      )\n    )\n}\n\n\n\n1\n\nAlternate help text for ggplot2movies data\n\n\n2\n\nCheck-box to remove missing values\n\n\n\n\n\n\nshow/hide dev_mod_scatter_server()\ndev_mod_scatter_server &lt;- function(id, var_inputs) {\n    moduleServer(id, function(input, output, session) {\n      # load alternate data\n      all_data &lt;- fst::read_fst(\"tidy_movies.fst\")\n  \n      \n1      graph_data &lt;- reactive({\n        if (input$missing) {\n          graph_data &lt;- tidyr::drop_na(data = all_data)\n        } else {\n          graph_data &lt;- all_data\n        }\n2      }) |&gt;\n        bindEvent(input$missing)\n  \n      inputs &lt;- reactive({\n        plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n      })\n  \n3      observe({\n        output$scatterplot &lt;- renderPlot({\n          plot &lt;- moviesApp::scatter_plot(\n            df = graph_data(),\n            x_var = inputs()$x,\n            y_var = inputs()$y,\n            col_var = inputs()$z,\n            alpha_var = inputs()$alpha,\n            size_var = inputs()$size\n          )\n          plot +\n            ggplot2::labs(\n              title = inputs()$plot_title,\n              x = stringr::str_replace_all(\n                        tools::toTitleCase(inputs()$x), \"_\", \" \"),\n              y = stringr::str_replace_all(\n                        tools::toTitleCase(inputs()$y), \"_\", \" \")\n            ) +\n            ggplot2::theme_minimal() +\n            ggplot2::theme(legend.position = \"bottom\")\n        })\n      }) |&gt;\n        bindEvent(graph_data(), inputs())\n    })\n  }\n\n\n\n1\n\nBuild reactive data based on missing checkbox input\n\n\n2\n\nBind missing input to update when UI changes\n\n\n3\n\nBind plot output to update with variable inputs and ‘missing’ checkbox output\n\n\n\n\napp.R also contains development app UI and server functions.\n\n\nUI and server\nIn devUI(), development modules are paired with package modules (dev_mod_vars_ui() and moviesApp::mod_var_input_server()), and we’ve include an alternate image (bootstrap.png).7\n\n\nshow/hide devUI()\ndevUI &lt;- function() {\n1    addResourcePath(\n      prefix = \"dev\",\n      directoryPath = system.file(\"dev\",\n                                  package = \"moviesApp\")\n    )\n  tagList(\n    bslib::page_fillable(\n      title = \"Movie Reviews (ggplot2movies)\",\n      theme = bslib::bs_theme(\n        bg = \"#043b67\",\n        fg = \"#ffffff\",\n        primary = \"#ffcf22\",\n        secondary = \"#38B44A\",\n        success = \"#32E0C4\",\n        base_font = sass::font_google(\"Ubuntu\"),\n        heading_font = sass::font_google(\"Ubuntu\")\n      ),\n      bslib::layout_sidebar(\n        sidebar = bslib::sidebar(\n2          dev_mod_vars_ui(\"vars\")\n        ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n              tags$div(\n                tags$img(\n3                  src = \"dev/imdb.png\",\n                  height = 80,\n                  width = 110,\n                  style = \"margin:10px 10px\"\n                )\n              )\n            ),\n          bslib::card_body(\n4            dev_mod_scatter_ui(\"plot\")\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n1\n\nAdd alternate path to include image file\n\n2\n\nDevelopment variable input module (UI)\n\n\n3\n\nRefer to alternate image\n\n\n4\n\nDevelopment scatter-plot display module (UI)\n\n\n\n\n\n\nshow/hide devServer()\ndevServer &lt;- function(input, output, session) {\n  \n1  selected_vars &lt;- moviesApp::mod_var_input_server(\"vars\")\n\n2  dev_mod_scatter_server(\"plot\", var_inputs = selected_vars)\n  \n}\n\n\n\n1\n\nmod_var_input_server() exported from moviesApp’s R/ folder\n\n2\n\nDefined in dev/inst/app.R\n\n\n\n\n\n\n\nLaunching inst/dev/\nFinally, the development app is launched with it’s own standalone function (stored in R/ggp2_movies_app.R). The ggp2_movies_app() function is similar to movies_app(), but appDir is set to the location of the development files (which we provide with system.file()).\n\n\n\n\n\n\n\nThis section’s code is in the 11c_inst-dev branch of moviesApp.\n\n\nshow/hide R/ggp2_movies_app.R\n#' Development `ggplot2movies` app standalone function\n#'\n#' Wrapper function for `shinyAppDir()`\n#' \n#' @param test logical, run in `test.mode`? Defaults to `TRUE`.\n#' \n#' @return shiny app\n#' \n#'\n#' @export\nggp2_movies_app &lt;- function(options = list(), run = \"w\") {\n  if (interactive()) {\n    display_type(run = run)\n  } \n    shinyAppDir(\n    appDir = system.file(\"dev\",\n      package = \"moviesApp\"\n    ),\n    options = options\n  )\n}\n\n\n\nAfter loading, documenting, and installing moviesApp, we can run the development version using ggplot2movies_app():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nggp2_movies_app(run = 'p')\n\n\n\n\n\n\n\n(a) ggplot2movies_app()\n\n\nFigure 9.5: inst/dev/ app with dev_movies_ui()\n\n\n\nYou may have noticed that I’ve used a different color and theme for the two development examples above. I’ve found this can be a quick and easy way to differentiate ‘development’ and ‘production’ versions of an application.\n\n\n\nprod/ versions\nIt’s also possible to have a folder dedicated for deploying your application in your app-package.\n\nprod/app/ data\nThis folder can be named something like inst/prod/ or inst/deploy, and it will contain the ‘production’ ready versions of UI and server functions in a single app.R file:\n\ninst/\n  └── prod/\n      └── app\n          └── app.R\n          \n2 directories, 1 file\n\n\n\nprod/app/app.R data\nIn the app.R file, include only a call to shinyApp() with the ui and server function (explicitly namespaced from your app-package):\n\n\nshow/hide prod/app/app.R\nshinyApp(\n  ui = moviesApp::movies_ui(bslib = TRUE), \n  server = moviesApp::movies_server)\n\n\nI used the bslib version, just to differentiate it from the other applications in moviesApp.\n\n\nDeploying inst/prod/app/\nBack in the root app.R file, we’ll use shinyAppDir() and system.file() to return the app object from prod/app/app.R:\n\n\nshow/hide app.R\n# set option to turn off loadSupport() ----\nwithr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        # load package ----\n        library(moviesApp)\n      },\n      error = function(e) {\n        # load R/ folder ----\n        pkgload::load_all()\n      }\n    )\n    # create shiny object from prod/app ----\n    shinyAppDir(appDir = \n        system.file(\"prod/app\", package = \"moviesApp\"))\n  } else {\n    # load R/ folder ----\n    pkgload::load_all()\n    # create shiny object ----\n    shiny::shinyApp(\n      ui = movies_ui,\n      server = movies_server\n    )\n  }\n})\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nTo deploy the app, call rsconnect::deployApp() in the console.\n\nrsconnect::deployApp(appName = 'shinyapppkg')\n\nThe deployment log will look something like this:\n── Preparing for deployment ────────────────────────────────────────────\n✔ Re-deploying \"shinyapppkg\" to \"server: shinyapps.io / username: yourusername\"\nℹ Looking up application with id \"10047601\"...\n✔ Found application &lt;https://mjfrigaard.shinyapps.io/shinyapppkg/&gt;\nℹ Bundling 35 files: .Rbuildignore, app.R, data/movies.rda, data/movies.RData,\n  data-raw/tidy_movies.R, DESCRIPTION, inst/dev/app.R, inst/dev/imdb.png, \n  inst/dev/tidy_movies.fst, inst/extdata/movies.fst, inst/prod/app/app.R, \n  inst/www/bootstrap.png, inst/www/shiny.png, man/display_type.Rd, \n  man/ggp2_movies_app.Rd, man/mod_scatter_display_server.Rd, \n  man/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, …, \n  R/scatter_plot.R, and README.md\nℹ Capturing R dependencies with renv\n✔ Found 72 dependencies\n✔ Created 1,179,590b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 7749936\n── Deploying to server ────────────────────────────────────────────────────────────────────\nWaiting for task: 1341341295\n  building: Parsing manifest\n  building: Building image: 9226179\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9226179\n  deploying: Starting instances\n  rollforward: Activating new instances\n  terminating: Stopping old instances\n── Deployment complete ───────────────────────────────────────────\n✔ Successfully deployed to &lt;https://mjfrigaard.shinyapps.io/shinyapppkg/&gt;\nYou can see a deployed version of this application here\n\n\n\n\n\n\n\nThis section’s code is in the 09d_inst-prod branch of moviesApp.\n\n\n\n\n\n\nUses of inst/ in other packages\n\n\n\n\n\n\nYou can explore the structure of other installed packages to see how they work ‘under the hood’ to gain insight into how they use the inst/ folder.\n\nFor example, the inst/extdata/ folder in the readr package holds a variety of datasets:\n/path/to/install/Library/R/x86_64/4.2/library/readr/\n\nextdata/\n  ├── challenge.csv\n  ├── chickens.csv\n  ├── epa78.txt\n  ├── example.log\n  ├── fwf-sample.txt\n  ├── massey-rating.txt\n  ├── mini-gapminder-africa.csv\n  ├── mini-gapminder-americas.csv\n  ├── mini-gapminder-asia.csv\n  ├── mini-gapminder-europe.csv\n  ├── mini-gapminder-oceania.csv\n  ├── mtcars.csv\n  ├── mtcars.csv.bz2\n  ├── mtcars.csv.zip\n  └── whitespace-sample.txt\n\n1 directory, 15 files\nThese files are used in readr::readr_example()):\n#' Get path to readr example\n#'\n#' readr comes bundled with a number of sample files in its `inst/extdata`\n#' directory. This function make them easy to access\n#'\n#' @param file Name of file. If `NULL`, the example files will be listed.\n#' @export\n#' @examples\n#' readr_example()\n#' readr_example('challenge.csv')\nreadr_example &lt;- function(file = NULL) {\n  if (is.null(file)) {\n    dir(system.file('extdata', package = 'readr'))\n  } else {\n    system.file('extdata', file, package = 'readr', mustWork = TRUE)\n  }\n}"
  },
  {
    "objectID": "external.html#recap",
    "href": "external.html#recap",
    "title": "External files",
    "section": "Recap",
    "text": "Recap\nThis chapter had covered how to include external files and resources (i.e., what was previously stored in the www/ folder of a regular shiny app project) in your app-package with addResourcePath() and system.file().\nWe’ve also covered how to use the inst/ folder to include alternative files, development and production/deployment versions of your app. You can now launch the following applications from moviesApp:\nStandard application with/without test mode\n\nlibrary(moviesApp)\nmovies_app(options = list(test.mode = TRUE))\n# or \nmovies_app(options = list(test.mode = FALSE))\n\nblisb application with/without test mode\nlibrary(moviesApp)\nmovies_app(options = list(test.mode = TRUE), bslib = TRUE)\n# or \nmovies_app(options = list(test.mode = FALSE), bslib = TRUE) \nggplot2movies data application with/without test mode\n\nlibrary(moviesApp)\nggp2_movies_app(options = list(test.mode = TRUE))\n# or \nggp2_movies_app(options = list(test.mode = FALSE))\n\nprod/ application\n\nlibrary(moviesApp)\nrsconnect::deployApp()\n\nIn the next chapter, we’re going to cover testing the code in your shiny app-package.\n\n\n\n\n\n\nRecap: inst & www folders\n\n\n\n\n\n\n\ninst/: the inst/ folder is installed with your app-package and will be accessible to users, so it’s a great location for files you want contained in your app, but don’t fit into the standard R package structure.\n\ninst/ is also a great location for alternative versions of applications (i.e., inst/app/dev or inst/app/prod/).\n\nsystem.file(): constructs a path to files or folders within installed packages and is especially useful when working with external datasets (i.e., inst/extdata/) or other external resources included with your app-package (i.e., inst/www/).\nwww: used for external static resources in shiny apps. shiny will automatically serve files under the www/ directory, but in app-packages we need to explicitly set this location with shiny::addResourcePath()\naddResourcePath(): create a prefix (i.e., path) for a directoryPath of static files to accessible in shiny’s web server:\n# file location\ninst/\n  └── www/\n        └── shiny.png\n# add path to app \naddResourcePath(prefix = 'www', \n                directoryPath = system.file('www', \n                                package = 'moviesApp'))\n# use path without 'inst/' prefix\nshiny::img(src = 'www/shiny.png')"
  },
  {
    "objectID": "external.html#footnotes",
    "href": "external.html#footnotes",
    "title": "External files",
    "section": "",
    "text": "This is a common problem developers encounter when converting shiny app into app-packages. See this popular thread on Posit Community.↩︎\nfs::path_package(package = \"moviesApp\") returns the path to your installed package and fs::dir_tree() function will print a folder tree.↩︎\nRead more about sub-directories to avoid in inst/ in R Packages, 2ed.↩︎\nThe key takeaway here is that the inst/ subfolders and files are available unchanged in the installed version (with the inst/ folder omitted.).↩︎\nYou can read more about adding external resources in the documentation for addResourcePath().↩︎\nWe covered the data-raw/ folder in the Data chapter, and you can read more about it here in R packages, 2ed↩︎\nThis requires exporting mod_var_input_server() with @export in the R/ folder.↩︎"
  },
  {
    "objectID": "tests.html#test-suite",
    "href": "tests.html#test-suite",
    "title": "Tests",
    "section": "Test suite",
    "text": "Test suite\nTest suite starts by showing how to use testthat to create your app-package test infrastructure, then dives into creating test files, and running tests during development."
  },
  {
    "objectID": "tests.html#specifications",
    "href": "tests.html#specifications",
    "title": "Tests",
    "section": "Specifications",
    "text": "Specifications\nSpecifications discusses how to collect and organize user specifications, features, and functional requirements. This chapter also gives example descriptions of features and scenarios in the behavior-driven development format, and how to track specifications and tests in a traceability matrix."
  },
  {
    "objectID": "tests.html#test-tools",
    "href": "tests.html#test-tools",
    "title": "Tests",
    "section": "Test tools",
    "text": "Test tools\nThis chapter introduces test fixtures and helpers. Each tool can contribute to testing your shiny app-package in a unique way (they’re also relatively recent additions to the testthat framework)"
  },
  {
    "objectID": "tests.html#testing-modules",
    "href": "tests.html#testing-modules",
    "title": "Tests",
    "section": "Testing modules",
    "text": "Testing modules\nShiny’s testServer() function can be useful for performing integration tests with module server functions. Testing modules gives examples of using testServer() to verify module communication (i.e., passing data between modules)."
  },
  {
    "objectID": "tests.html#system-tests",
    "href": "tests.html#system-tests",
    "title": "Tests",
    "section": "System tests",
    "text": "System tests\nThe final chapter in this section covers setting up and running system (or end-to-end tests with shinytest2)."
  },
  {
    "objectID": "test_suite.html#testthat-framework",
    "href": "test_suite.html#testthat-framework",
    "title": "Test suite",
    "section": "testthat framework",
    "text": "testthat framework\ntestthat is the standard package for testing in R packages and one of the most widely used and supported packages on CRAN. Its widespread adoption is likely due to its ability to simplify the setup, creation, and execution of unit tests.\nIn our app-packages, we’ll use testthat unit tests to ensure the underlying logic (i.e., non-reactive utility functions) behaves correctly. Combining Shiny’s testServer() function and the shinytest2 package with testthat provides a comprehensive testing suite for our app-package."
  },
  {
    "objectID": "test_suite.html#set-up-with-use_testthat",
    "href": "test_suite.html#set-up-with-use_testthat",
    "title": "Test suite",
    "section": "Set up with use_testthat()",
    "text": "Set up with use_testthat()\nThe testthat package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it’s the third):2\n\nusethis::use_testthat(3)\n\nSetting up your testing infrastructure with use_testthat() does the following (3 is the edition):\n\nIn the DESCRIPTION file, testthat (&gt;= 3.0.0) is listed under Suggests\nConfig/testthat/edition: 3 is also listed in the DESCRIPTION to specify the testthat edition\nA new tests/ folder is created, with a testthat/ subfolder\nThe tests/testthat/testthat.R file is created\n\nWe now have a tests/ folder to store our testthat tests.\n\ntests/\n  ├── testthat/\n1  └── testthat.R\n\n2 directories, 1 file\n\n\n1\n\nReferred to as the ‘test runner,’ because it runs all our tests (do not edit this file)."
  },
  {
    "objectID": "test_suite.html#creating-unit-tests",
    "href": "test_suite.html#creating-unit-tests",
    "title": "Test suite",
    "section": "Creating unit tests",
    "text": "Creating unit tests\nThe standard workflow for writing testthat unit tests consists of the following:\n\nNew tests are created with usethis::use_test():\n\n\nusethis::use_test(\"scatter_plot\") \n\n\ntestthat recommends having a corresponding test file in tests/testthat/ (with the test- prefix) for the files in R/.\n\n\ntest- files\n\nTest files: the IDE will automatically create and open the new test file:\n\n✔ Writing 'tests/testthat/test-scatter_plot.R'\n• Modify 'tests/testthat/test-scatter_plot.R'\n\n\ntest_that() tests\n\nEach new test file contains a boilerplate test_that() test:\n\n\n1test_that(desc = \"multiplication works\", code = {\n \n})\n\n\n1\n\ndesc is the test context (supplied in \"quotes\"), and code is the test code (supplied in {curly brackets}).\n\n\n\n\n\n\nexpect_ations\n\nExpectation typically have two parts: an observed object, and an expected object:\n\n\n1expect_equal(\n2  object = 2 * 2,\n3  expected = 4\n  ) \n\n\n1\n\nA testthat expectation function\n\n\n2\n\nThe output or behavior being tested\n\n\n3\n\nA predefined output or behavior\n\n\n\n\n\nThe observed object is an artifact of some code we’ve written, and it’s being compared against an expected result.\n\n\n\nBDD test functions\ntestthat also has two behavior-driven development (BDD) functions for performing tests: describe() and it().\n\n“Use describe() to verify that you implement the right things and use [it()] to ensure you do the things right.” - testthat documentation\n\n\n1describe(\"Description of feature or specification\",\n      code = { \n2    it(\"Functionality under test\",\n3        code = {\n            expect_equal( \n            object = 2 * 2, \n            expected = 4 \n            )\n        })\n    })\n\n\n1\n\ndescribe() the feature or specification\n\n\n2\n\nCapture it() in a test\n\n\n3\n\nWrite expectations\n\n\n\n\nWe’ll cover BDD more in the next chapter, but for now just know that each call to it() behaves like test_that().\n\n\nRunning tests\n\nAnother devtools habit to adopt is regularly writing and running tests. If you’re using Posit Workbench and have devtools installed, you can test your app-package using the Build pane or the keyboard shortcut: Ctrl/Cmd + Shift + T\n\n\n\n\n\n\nRun all tests\n\n\n\n\nKeyboard shortcuts\nR Packages, 2ed also suggests binding test_active_file() and test_coverage_active_file() to keyboard shortcuts. I highly recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.\n\n\n\ndevtools function\ntest()\n\n\n \n\n\nKeyboard shortcut\nCtrl/Cmd + Shift + T\n\n\n\n\n\n\ntest_active_file()\n\n\n \n\n\nCtrl/Cmd + T\n\n\n\n\n\n\ntest_coverage_active_file()\n\n\n \n\n\nCtrl/Cmd + Shift + R\n\n\n\nWhen the test is run, we’ll see feedback on whether it passes or fails (and occasionally some encouragement):\n\ntest_that(\"multiplication works\", { \n  expect_equal( \n    object = 2 * 2, \n    expected = 4 \n    ) \n})\n## Test passed 🥇"
  },
  {
    "objectID": "test_suite.html#recap",
    "href": "test_suite.html#recap",
    "title": "Test suite",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\n\ntestthat setup\n\nuse_testthat(): sets up testing infrastructure in your app-package\n\n\n\nTest files\n\nuse_test(): creates new test files (with test- prefix). The test file names should generally match the file names be belowR/.\n\n\n\nRunning tests\n\ntest_active_file(): runs tests in the current open test file\ntest_coverage_active_file(): test coverage for the current open test file"
  },
  {
    "objectID": "test_suite.html#footnotes",
    "href": "test_suite.html#footnotes",
    "title": "Test suite",
    "section": "",
    "text": "The ‘Reactivity - An overview’ article gives an excellent description (and mental module) of reactive programming.↩︎\nRead more about changes to the third edition to testthat in R Packages, 2ed↩︎"
  },
  {
    "objectID": "test_specs.html#application-requirements-1",
    "href": "test_specs.html#application-requirements-1",
    "title": "Specifications",
    "section": "Application requirements",
    "text": "Application requirements\nInformation about the various tasks and activities an application is expected to perform in typically stored in some kind of software requirements specification (SRS) document.4 The SRS can include things like distinct design characteristics, budgetary, technological, or timeline restrictions, etc. This document breaks down an application’s intended purpose (i.e., the problem it’s designed to solve) into three general areas: user specifications, features, and functional requirements.\n\nUser Specifications\nThe user specifications are the goals and objectives stakeholders want to achieve with the application. They use terms like ‘deliver value’ and ‘provide insight’ and provide the basis for deriving the application’s features. 5\n\n\nFeatures\nFeatures translate the user expectations into an application capabilities. Generally speaking, features capture the tasks and activities user should “be able to” accomplish with the application (i.e., explore data with a graph).\n\n\nFunctional Requirements\nFunctional requirements are written for developers and provide the technical details on each feature. A single feature often gives rise to multiple functional requirements (these are where users needs come into direct contact with code)6\n\nIn summary\nThe areas above help direct the development process, albeit from slightly different perspectives.\n\nThe user specifications capture the needs and expectations of the end-user.\nThe features describe the high-level capabilities of the application.\nFunctional requirements are the testable, specific actions, inputs, and outputs."
  },
  {
    "objectID": "test_specs.html#application-developemnt",
    "href": "test_specs.html#application-developemnt",
    "title": "Specifications",
    "section": "Application developemnt",
    "text": "Application developemnt\nThe Shiny application development process follows something like the figure below:\n\n\n\nGeneral application development process\n\n\nThe figure above is an oversimplification, but it highlights a common separation (or ‘hand-off’) between users/stakeholders and developers. In the sections below, we’ll look at two common development processes: test-driven and behavior-driven development.\n\nTest-driven development\nIf moviesApp was built using test-driven development (TDD), the process might look something like this:\n\nGather user needs and translate into application features:\n\nDocument the application’s capabilities for exploring movie review variables from IMDB and Rotten Tomatoes.\nInclude feature descriptions for displaying continuous variables (i.e., ‘critics score’ and ‘audience score’) categorical variables (i.e., ‘MPAA’ ), graph visual attributes (size, color, opacity), and an optional plot title.\n\nWrite Tests:\n\nWrite tests to ensure the graph displays relationships between a set of continuous and categorical variables when the app launches.\n\nRun Tests:\n\nBefore writing any code, these tests will fail.\n\nDevelop Features:\n\nWrite UI, server, module, and utility functions for user inputs and graph outputs.\n\nRerun Tests:\n\nIf the graph has been correctly implemented in the application, the tests should pass.\n\nWrite more Tests:\n\nAdd more tests for additional functionalities (e.g., an option to remove missing values from graph).\n\n\nStarting with tests and writing just enough code to get them to pass often results in developing less (but better) code. The drawback to this approach is a strict focus on the function being tested and not the overall objective of the application.\n\n\nBehavior-driven development\nIn behavior-driven development (BDD) (or behavior-driven testing), users and developers work together to understand, define and express application behaviors in non-technical language, 7\n\n“Using conversation and examples to specify how you expect a system to behave is a core part of BDD” - BDD in Action, 2ed\n\nPlacing an emphasis on writing human-readable expectations for the application’s behaviors makes it easier to develop tests that can focus on verifying each user need exists (and is functioning properly). In BDD, the application’s expected capabilities are captured in Features and illustrated with concrete examples, or Scenarios.\n\nFeature\nIn BDD, a Feature describes an implemented behavior or capability in the application, from a user’s perspective. Typically, these are written in the Gherkin format using specific keywords:8\n\nAs a ...\n\nI want ...\n\nSo that ...\n\nBelow is an example Gherkin Feature for the graph in movies_app():\nFeature: Visualization\n    As a user\n    I want to see the changes in the plot\n    So that I can visualize the impact of my customizations\nAs you can see, the feature uses plain language and the wording is user-centric, so it remains accessible to both developers and users (or other non-technical stakeholders).\n\n\nScenario\nA Gherkin Scenario provides a concrete example of how the Feature works and has the following general format:\n\nGiven ...\n\nWhen ...\n\nThen ...\n\nAn example Scenario for movies_app() might be:\n  Scenario: Viewing the Data Visualization\n    Given I have launched the application\n    And it contains movie review data from IMDB and Rotten Tomatoes\n    And the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\n\n\nBackground\nInstead of repeating any pre-conditions in each Scenario (i.e., the steps contained in the “Given” and first “And” statement), we can establish the context with a Background:\n  Background: Launching the application\n    Given I have launched the application\n    And it loads with movie review data from IMDB and Rotten Tomatoes\n    \n  Scenario: Viewing the Data Visualization\n    Given the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\nAdopting the Gherkin format (or something similar) provides a common language to express an application’s behavior:\n\nAs developers, we can work with users and shareholders to write specifications that describe the expected behavior of each Feature\nWhen developing tests, we can group the tests by their Feature and Scenarios\nEach test can execute a step (i.e., the Then statements).\n\nIn the next section we’ll cover how to map test code for each Scenario step with testthat.\n\n\n\nBDD and testthat\ntestthat’s BDD functions (describe() and it()) allow us add Gherkin-style features and scenarios to our test files, ensuring the application remains user-centric while meeting the technical specifications.9\n\ndescribe() a feature\nWe can use the language from our Feature, Background, and Scenario to in the description in the argument of describe():\n\ntestthat::describe(\n  description = \"Feature: Visualization\n                   As a user\n                   I want to see the changes in the plot\n                   So that I can visualize the impact of my customizations\",\n  code = {\n  \n})\n\nWe can also nest describe() calls, which means we can include the Background (or other relevant information):\n\n1describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n    \n2  describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\", \n    code = {   \n               \n      })\n    \n  })\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n\n\n\n\n\nConfirm it() with a test\nInside describe(), we can include multiple it() blocks which “functions as a test and is evaluated in its own environment.”\nIn the example below, we’ll use an it() block to test the example scenario from above:10\n\n1testthat::describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n  \n2  testthat::describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\",\n      code = {\n      \n3    testthat::it(\n      \"Scenario: Viewing the Data Visualization\n         Given the data contains variables like 'Critics Score' and 'MPAA'\n         When I interact with the controls in the sidebar panel\n         Then the graph should update with the selected options\",\n        code = {\n4          # test code\n        })\n      \n    })\n  \n})\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n3\n\nScenario (a concrete examples that illustrates a feature)\n\n4\n\nTest code\n\n\n\n\nIn the scenario above, Then contains the information required for the testthat expectation. This could be expect_snapshot_file() or vdiffr::expect_doppelganger()–whichever makes sense from the user’s perspective.\nThis is an generic example, but hopefully the example tests in the upcoming chapters convey how helpful and expressive the BDD functions can be (or they inspire you to properly implement what I’m attempting to do in your own app-packages).11"
  },
  {
    "objectID": "test_specs.html#traceability-matrix",
    "href": "test_specs.html#traceability-matrix",
    "title": "Specifications",
    "section": "Traceability Matrix",
    "text": "Traceability Matrix\nAfter translating the user needs into functional requirements, we can identify what needs to be tested by building a look-up table (i.e., a matrix).\nI like to store early drafts of the requirements and traceability matrix in a vignette:12\n\nusethis::use_vignette(\"test-specs\")\n\nAdding our first vignette to the vignettes/ folder does the following:\n\nAdds the knitr and rmarkdown packages to the Suggests field in DESCRIPTION13\nSuggests: \n    knitr,\n    rmarkdown\nAdds knitr to the VignetteBuilder field14\nVignetteBuilder: knitr\nAdds inst/doc to .gitignore and *.html, *.R to vignettes/.gitignore\n\nThe first column in the traceability matrix contains the user specifications, which we can ‘trace’ over to the functional requirements and their relevant tests.15\n\n\nTraceability Matrix\n\n\n\n\n\n\n\n\nSpecifications\nFeatures\nRequirements\nTest\n\n\n\n\nS1: The application should source movie review data from platforms like IMDB or Rotten Tomatoes\nF1.1:\nFeature: Movie Review Dataset Variables\nAs a user\nI want to have a dataset with variables from IMDB and Rotten Tomatoes\nIn order to provide comprehensive movie reviews\nBackground:\nGiven the application has access to IMDB and Rotten Tomatoes APIs\nScenario: Movie Review Continuous and Categorical Variables\nWhen the application loads from IMDB and Rotten Tomatoes movie review data\nThen the dataset should include a continuous critic ratings variable\nAnd the dataset should include a continuous audience ratings variable\nAnd the dataset should include a categorical mpaa ratings variable\nAnd the dataset should include a categorical genres variable\n\n\n\n\n\nBuilding a traceability matrix ensures:\n\nAll user specifications have accompanying application features.\nEach feature has been broken down into precise, measurable, and testable functional requirements.\nTests have been written for each functional requirement."
  },
  {
    "objectID": "test_specs.html#recap",
    "href": "test_specs.html#recap",
    "title": "Specifications",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\n\nThis section’s code is in the 12a_tests-specs branch of moviesApp.\nUnderstanding the relationship between user specifications, features, and functional requirements gives us the information we need to build applications that satisfy the technical standards while addressing user needs. Documenting requirements in Gherkin-style features and scenarios allows us to capture the application’s behavior without giving details on how the functionality is implemented.\nIn the next chapter, we’re going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to reduce code executed outside of your tests (i.e., placed above the call to test_that() or it()).\n\n\n\n\n\n\nRecap: testing your app-package\n\n\n\n\n\n\nSpecifications\n\nScoping tests: user specifications outline software goals and needs, and the functional requirements provide the technical details to achieve them.\n\nUser specifications: descriptions of what a user expects the application to do (i.e., the user ‘wish list’ of features they want in the application).\nFeatures: detailed list of the main capabilities and functions the application needs to offer to users.\nFunctional requierments: testable, specific step-by-step instructions for ensuring the application does what it’s supposed to do.\nTraceability matrix: tracking tool for connecting the users ‘wish list’ (i.e, specifications) to what’s being tested."
  },
  {
    "objectID": "test_specs.html#footnotes",
    "href": "test_specs.html#footnotes",
    "title": "Specifications",
    "section": "",
    "text": "Unit tests are covered extensively in R Packages, 2ed and the testthat documentation↩︎\nMastering shiny dedicates an entire Chapter to Testing.) shinytest2 also has excellent documentation (and videos), and I highly recommend reading through those resources.↩︎\nI will cover a few tips and tricks I’ve learned for testing module server functions with testServer() because they’re not in the documentation.↩︎\nRead more about what goes in the Software Requirements Specification↩︎\nUser Specifications are sometimes referred to as “user stories,” “use cases,” or “general requirements”↩︎\n‘Features’ and ‘functional requirements’ are sometimes used interchangeably, but they refer to different aspects of the application. Features are high-level capabilities an application should have, and often contain a collection of smaller functionalities (broken down into the specific functional requirements).↩︎\nRead more about behavior-driven development↩︎\nGherkin is the domain-specific language format used for expressing software behaviors. Tools like Cucumber or SpecFlow maps and executes the Gherkin descriptions against the code to generate a pass/fail report status for each requirement.↩︎\nRead more about describe() and it() in the testthat documentation. and in the appendix.↩︎\nEach it() block contains the expectations (or what you would traditionally include in test_that()).↩︎\nFor an excellent description on the relationships between behavior-driven development, test-driven development, and domain-driven design, I highly recommend BDD in Action, 2ed by John Ferguson Smart and Jan Molack.↩︎\nStoring the traceability matrix in a vignette is great for developers, but using an issue-tracking system with version control is also a good idea, like GitHub Projects or Azure DevOps.↩︎\nWe briefly covered the Suggests field in Dependencies, but in this case it specifically applies to “packages that are not necessarily needed. This includes packages used only in examples, tests or vignettes…” - Writing R Extensions, Package Dependencies↩︎\nThe documentation on VignetteBuilder gives a great example of why knitr and rmarkdown belong in Suggests and not Imports.↩︎\nWhen building tables in vignettes, I highly recommend using the Visual Markdown mode.↩︎"
  },
  {
    "objectID": "test_tools.html#test-scope",
    "href": "test_tools.html#test-scope",
    "title": "Test tools",
    "section": "Test scope",
    "text": "Test scope\nOne of the recent updates to the testthat package (version 3.2.0) emphasizes limiting code that exists outside of our tests.2\n\n“Eliminating (or at least minimizing) top-level code outside of test_that() will have the beneficial effect of making your tests more hermetic. This is basically the testing analogue of the general programming advice that it’s wise to avoid unstructured sharing of state.” - Self-sufficient tests, R Packages, 2ed\n\nCode outside of test_that() usually serves a specific purpose (load or manipulate data, set options, create folders or files, etc). The topics in this chapter will demonstrate how to include these behaviors in our tests without placing code outside of the test scope.\n\n\n\n\n\n\nMocking\n\n\n\n\n\n\nTest mocks are covered in Special Topics, because the example isn’t from our app-package (it comes from the package development masterclass given at posit::conf(2023))."
  },
  {
    "objectID": "test_tools.html#fixtures",
    "href": "test_tools.html#fixtures",
    "title": "Test tools",
    "section": "Fixtures",
    "text": "Fixtures\n\n\n\n\n\n\n\n\nThis section’s code is in the 12b_tests-fixtures branch of moviesApp.\nTest fixtures can be anything used to create repeatable test conditions (data, file paths, functions, etc.). Good test fixtures provide a consistent, well-defined test environment, and then are removed/destroyed when the test is executed. This ensures any changes made during the test don’t persist or interfere with future tests.3\nIn R packages, test fixtures are stored in the tests/testthat/fixtures/ folder:4\n\ntests/\n├── testthat/\n│   └── fixtures/                                         \n└── testthat.R\n\n\nTest data\nLarge static data files are an example of a test fixture.5 Any code used to create test data should be stored with the output file (using a clear naming convention).\nFor example, I’ve stored the code used to create a ‘tidy’ version of the ggplot2movies::movies data along with the output dataset in tests/testthat/fixtures/:\n\ntests\n├── testthat\n│   ├── fixtures\n1│   │   ├── make-tidy_ggp2_movies\n2│   │   └── tidy_ggp2_movies.rds\n│   └── test-scatter_plot.R\n└── testthat.R\n\n3 directories, 4 files\n\n\n1\n\nThe code used to create the test data (make-make_tidy_ggp2_movies.R)\n\n2\n\nThe test data file (i.e., tidy_ggp2_movies.rds):\n\n\n\n\nData files stored in tests/testthat/fixtures/ can be accessed with testthat::test_path() inside each test.\n\n\nExample: test fixture\n\n\n\n\n\n\nBDD refresher: features & scenarios\n\n\n\n\n\nIn BDD, requirements are written plain language ‘feature files’ using a series of keywords:\n\n1Feature:\n\n2  Background:\n3    Given\n    \n4  Scenario:\n5    When\n6    And\n7    Then\n\n\n\n1\n\nHigh-level description (title and description)\n\n\n2\n\nSteps or conditions that exist before each scenario\n\n\n3\n\nUsed to describe the initial context or preconditions for the scenario\n\n\n4\n\nA series of steps outlining a concrete examples that illustrates a feature\n\n\n5\n\nUsed to describe an event, or an action\n\n\n6\n\nUse to combine Given, When, or Then\n\n\n7\n\nUse to verify expected outcomes that are observable by a user\n\n\n\n\nFeature, Background, and Scenario information can be included in nested testthat::describe() blocks, but every Then keyword should have a corresponding testthat::it() call.\nRead more about Gherkin on the Cucumber website..\n\n\n\nBelow is a test that answers the question, ‘does the plot generate without producing an error?’ when using the tidy_ggp2_movies.rds test fixture with the scatter_plot() utility function. This type of test appropriate because we want to confirm the data source (tidy_ggp2_movies) will generate a plot object when passed to the scatter_plot() utility function, not necessarily the specific contents of the graph.6\n\n1testthat::describe(\n  \"Feature: Scatter plot data visualization\n\n     As a film data analyst\n     I want to explore movie review data from IMDB.com\n     So that I can analyze relationships between movie reivew metrics\n\n   Background:\n     Given I have data with IMDB movie reviews\n     And the data contains continuous variables like 'rating'\n     And the data contains categorical variables like 'mpaa'\", \n     code = {\n      \n2    testthat::it(\n      \"Scenario: Scatter plot initial x, y, color values \n         When I launched the Scatter Plot Data Visualization\n         And I have a dataset of movie reviews from IMDB \n         Then the scatter plot should show 'Rating' on the x-axis\n         And the scatter plot should show 'Length' on the y-axis\n         And the points on the scatter plot should be colored by 'MPAA' rating\", \n        code = {\n        \n3    ggp2_scatter_inputs &lt;- list(\n          x = \"rating\",\n          y = \"length\",\n          z = \"mpaa\",\n          alpha = 0.75,\n          size = 3,\n          plot_title = \"Enter plot title\"\n        )\n        \n4    tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n5    app_graph &lt;- scatter_plot(tidy_ggp2_movies,\n      x_var = ggp2_scatter_inputs$x,\n      y_var = ggp2_scatter_inputs$y,\n      col_var = ggp2_scatter_inputs$z,\n      alpha_var = ggp2_scatter_inputs$alpha,\n      size_var = ggp2_scatter_inputs$size\n    )\n6    expect_true(ggplot2::is.ggplot(app_graph))\n  }) \n\n})\n\n\n1\n\nFeature\n\n\n2\n\nScenario\n\n\n3\n\nTest inputs\n\n\n4\n\nTest fixture\n\n\n5\n\nCreate observed object\n\n\n6\n\nExpectation\n\n\n\n\nIf the data tidy_ggp2_movies.rds in tests/testthat/fixtures/ are going to be used repeatedly, it might also make sense to store it in inst/extdata/ or data-raw/. Test fixtures are described in-depth in R Packages, 2ed and in the testthat documentation."
  },
  {
    "objectID": "test_tools.html#helpers",
    "href": "test_tools.html#helpers",
    "title": "Test tools",
    "section": "Helpers",
    "text": "Helpers\n\n\n“Helper files are a mighty weapon in the battle to eliminate code floating around at the top-level of test files.” Testthat helper files, R Packages, 2ed\n\nTest helpers reduce repeated/duplicated test code. In general, objects or values that aren’t large enough to justify storing as static test fixtures can be created with helper functions. Helper functions are stored in tests/testthat/helper.R, which is automatically loaded with devtools::load_all():\n\ntests/\n  ├── testthat/\n1  │   ├── fixtures/\n  │   │   ├── make-tidy_ggp2_movies.R\n  │   │   └── tidy_ggp2_movies.rds\n2  │   ├── helper.R\n3  │   └── test-scatter_plot.R\n  └── testthat.R\n\n\n1\n\nTest fixture scripts and .rds files\n\n\n2\n\nHelper functions\n\n\n3\n\nTest file\n\n\n\n\nTest helpers should only be created if they make testing easier when the tests fail. The article, ‘Why Good Developers Write Bad Unit Tests’, provides great advice on complexity vs. clarity when writing unit tests,\n\n‘think about what will make the problem obvious when a test fails. Refactoring may reduce duplication, but it also increases complexity and potentially obscures information when things break.’\n\nR programmers resist copy + paste programming, and in most cases this makes sense. After all, R is a functional programming language, so it’s tempting to bundle any repeated code into a function and store it in the tests/testthat/helper.R file.\nHowever, when we’re writing tests, it’s more important that tests are easy to read and understand when they fail.\nFor example, consider the ggp2_scatter_inputs inputs passed to the scatter_plot() function in the previous test:\n\nggp2_scatter_inputs &lt;- list(  \n        x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\"\n)            \n\nWe could write a var_inputs() function that stores these values in a list. In our tests, this would allow us to use var_inputs() with the same ‘reactive syntax’ we use with scatter_plot() in the module server function:\n\nvar_inputs &lt;- function() {\n   list(x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\")\n}\nvar_inputs()\n## $x\n## [1] \"rating\"\n## \n## $y\n## [1] \"length\"\n## \n## $z\n## [1] \"mpaa\"\n## \n## $alpha\n## [1] 0.75\n## \n## $size\n## [1] 3\n## \n## $plot_title\n## [1] \"Enter plot title\"\n\nWhile this removes duplicated code, it also makes it less clear for the reader what var_inputs() contains and where it was created (without opening the helper.R file).\n\n1tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n  \napp_graph &lt;- scatter_plot(\n  tidy_ggp2_movies,\n2  x_var = var_inputs()$x,\n  y_var = var_inputs()$y,\n  col_var = var_inputs()$z,\n  alpha_var = var_inputs()$alpha,\n  size_var = var_inputs()$size)\n\ntestthat::expect_true(ggplot2::is.ggplot(app_graph))\n\n\n1\n\nLoad test fixture\n\n\n2\n\nIdentical to the code in mod_scatter_display_server()\n\n\n\n\nIn contrast, the make_ggp2_inputs() function below creates inputs for the scatter_plot() utility function:\n\nmake_ggp2_inputs &lt;- function() {\n  glue::glue_collapse(\"list(x = 'rating',\n     y = 'length',\n     z = 'mpaa',\n     alpha = 0.75,\n     size = 3,\n     plot_title = 'Enter plot title'\n     )\"\n  )\n}\n\nI can call make_ggp2_inputs() in the Console and it will return the list of values to paste into each test:\n\nmake_ggp2_inputs()\nlist(y = 'audience_score', \n     x = 'imdb_rating',\n     z = 'mpaa_rating',\n     alpha = 0.5,\n     size = 2,\n     plot_title = 'Enter plot title'\n    )\n\nThis reduces the number of keystrokes per test, but doesn’t obscure the source of the values in the test.\nglue::glue_collapse() is your friend when you want to quickly reproduce code for your tests. make_var_inputs() creates the list of inputs for testing the original movies data:\n\nmake_var_inputs &lt;- function() {\n  glue::glue_collapse(\"list(y = 'audience_score', \n     x = 'imdb_rating',\n     z = 'mpaa_rating',\n     alpha = 0.5,\n     size = 2,\n     plot_title = 'Enter plot title'\n    )\")\n}\n\n\n\n\n\n\n\nViolating the DRY principle\n\n\n\n\n\n\nIf you have repeated code in your tests, consider the following questions below before creating a helper function:\n\nDoes the code help explain what behavior is being tested?\nWould a helper make it harder to debug the test when it fails?\n\nIt’s more important that test code is obvious than DRY, because it’s more likely you’ll be dealing with this test when it fails (and you’re not likely to remember why all the top-level code is there).\n\n\n\n\n\nTest logger\n\n\n\n\n\n\n\nThis section’s code is in the 12c_tests-helpers branch of moviesApp.\nI prefer test outputs to be verbose, so I usually create a test_logger() helper function that allows me to give more context and information with each test:\n\n# test logger helper\ntest_logger &lt;- function(start = NULL, end = NULL, msg) {\n  if (is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"{msg}\")\n  } else if (!is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n  } else if (is.null(start) & !is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n  } else {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n  }\n}\n\ntest_logger() can be used to ‘log’ the start and end of each test, and it includes a message argument (msg) I’ll use to reference the test description argument in each it() call.7\nI tend to use functions like test_logger() enough to justify placing them in a testing utility file (R/testthat.R) below R/. Including testing functions in the R/ folder also ensures they’re documented (and any dependencies become part of your app-package).8\n\n\nTest development\nWhile developing, using keyboard shortcuts makes it easier to iterate between building fixtures, writing and running tests, and checking code coverage.\n\n\n\n\n\n\n\n\nCtrl/Cmd + T\n\n\n\n\n\n\n\ndevtools:::test_active_file()\n FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-10-27 12:39:23] [ START fixture = tidy_ggp2_movies.rds]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2023-10-27 12:39:23] [ START fixture = tidy_ggp2_movies.rds]\n\nINFO [2023-10-27 12:39:23] [ START data = movies.rda]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nINFO [2023-10-27 12:39:23] [ END data = movies.rda]\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\nTest coverage on active file\n\n\n\n\nExample: snapshots\n\n\n\n\n\n\n\nThis section’s code is in the 12g_tests-snapshots branch of moviesApp.\nWriting tests for graph outputs can be difficult because the “correctness” of a graph is somewhat subjective and requires human judgment. If the expected output we’re interesting in testing is cumbersome to describe programmatically, we can consider using a snapshot tests. Examples of this include UI elements (which are mostly HTML created by Shiny’s UI layout and input/output functions) and data visualizations.9\nIf we want to create a graph snapshot test, the vdiffr package allows us to perform a ‘visual unit test’ by capturing the expected output as an .svg file that we can compare with future versions.\nThe expect_doppelganger() function from vdiffr is designed specifically to work with ‘graphical plots’.\n\nvdiffr::expect_doppelganger(\n      title = \"name of graph\", \n      fig = # ...code to create graph...\n  )\n\nAnother option for using snapshots for testing is the expect_snapshot_file() function 10 but expect_doppelganger() is probably the better option for comparing graph outputs.\nIn this test, I’ll list the Feature in a top-level describe() block, then nest the Scenario for the functional requirement in it() statements (with each snapshot the test will capture). Combining scenarios in the same test file is helpful if we’re trying to keep a 1:1 between the test/testthat/ file names and file names in R/.11\n\n1testthat::it(\n  \"Scenario: Create scatter plot\n      Given I have launched the movie review exploration app,\n      When the scatter plot renders,\n      Then the points on the x axis should represent 'Ratings'\n      And the points on the y axis should represent 'Length'\n      And the points should be colored by 'MPAA' rating\n      And the opacity of the points should be set to '0.5'\n      And the size of the points should be set to '2'\n      And the plot title should be set to 'Enter plot title'\",\n  code = {\n    \n2    test_logger(\n      start = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n\n3    scatter_inputs &lt;- list(\n      x = \"imdb_rating\",\n      y = \"audience_score\",\n      z = \"mpaa_rating\",\n      alpha = 0.5,\n      size = 2,\n      plot_title = \"Enter plot title\"\n    )\n\n4    vdiffr::expect_doppelganger(\n      title = \"Initial x y z axes\",\n      fig = scatter_plot(movies,\n        x_var = scatter_inputs$x,\n        y_var = scatter_inputs$y,\n        col_var = scatter_inputs$z,\n        alpha_var = scatter_inputs$alpha,\n        size_var = scatter_inputs$size\n      ) +\n        ggplot2::labs(\n          title = scatter_inputs$plot_title,\n          x = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$x\n            ), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$y\n            ), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    )\n\n5    test_logger(\n      end = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n    \n  }\n)\n\n\n1\n\nTest scope (T2)\n\n\n2\n\nLog start (T2)\n\n\n3\n\nInitial movies variable inputs for x, y, and z from UI\n\n\n4\n\nSnapshot with initial values\n\n\n5\n\nLog end (T2)\n\n\n\n\n\nTest results also return the output from test_logger() with the context I’ve added on what’s being tested:\nINFO [2023-10-27 10:58:25] [ START snap scatter_plot() = initial x,y,z,size,alpha]\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 3 ]\nINFO [2023-10-27 10:58:25] [ END snap scatter_plot() = initial x,y,z,size,alpha]\n\nINFO [2023-10-27 10:58:25] [ START snap scatter_plot() = updated x,y,z]\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 4 ]\nINFO [2023-10-27 10:58:26] [ END snap scatter_plot() = updated x,y,z]\nWe also see a warning when the snapshot has been saved in the tests/testthat/_snaps/ folder the first time the test is run:\n── Warning (test-scatter_plot.R:124:9): \n      Scenario: Create scatter plot\n          Given I have launched the movie review exploration app,\n          When the scatter plot renders,\n          Then the points on the x axis should represent 'Ratings'\n          And the points on the y axis should represent 'Length'\n          And the points should be colored by 'MPAA' rating\n          And the size of the points should be set to '2'\n          And the opacity of the points should be set to '0.5' ──\nAdding new file snapshot: 'tests/testthat/_snaps/initial-x-y-z-axes.svg'\n\n── Warning (test-scatter_plot.R:186:7): \n      Scenario: Change x, y, color values for plotting\n        When I launch the Scatter Plot Data Visualization\n        And I select the variable 'Audience Score' for the x-axis\n        And I select the variable 'IMDB Rating' for the y-axis\n        And I select the variable 'Critics Rating' for the color\n        Then the scatter plot should show 'Audience Score' on the x-axis\n        And the scatter plot should show 'IMDB Rating' on the y-axis\n        And the points on the scatter plot should be colored by 'Critics Rating' ──\nAdding new file snapshot: 'tests/testthat/_snaps/updated-x-y-color.svg'\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 2 ]\nOn subsequent runs, this warning will disappear (as long as there are no changes to the .svg files).\n\n\n\n\n\n\nReviewing snapshots\n\n\n\n\n\n\nPlacing the functional requirement in the title argument of expect_doppelganger() gives us a clear idea of what the snapshot file should contain.\n\n\n\n\n\n\nAdvice on snapshots\nSnapshots are brittle. The term “brittle” in the context of testing refers to a susceptibility to fail with small changes. Brittleness can produce false negatives test failures (i.e., due to inconsequential changes in the graph) when comparing a new graph to the baseline image.\nBelow is the output from diffobj::diffObj() comparing our custom plotting function (scatter_plot()) against a graph built with analogous ggplot2 code:\n\nggp_graph &lt;- ggplot2::ggplot(mtcars, \n              ggplot2::aes(x = mpg, y = disp)) + \n              ggplot2::geom_point(\n                ggplot2::aes(color = cyl), \n                             alpha = 0.5, \n                             size = 3)\n  \napp_graph &lt;- scatter_plot(mtcars, \n                  x_var = \"mpg\", \n                  y_var = \"disp\", \n                  col_var = \"cyl\", \n                  alpha_var = 0.5, \n                  size_var = 3)\n\ndiffobj::diffObj(ggp_graph, app_graph)\n\n\n\n\n\n\n\ndiffobj::diffObj() on graph outputs\n\n\nFigure 12.1: Graph objects are difficult to use as test objects\n\n\n\nThe output shows us all the potential points of failure when comparing complex objects like graphs (despite the actual outputs appearing identical), so it’s best to limit the number of ‘visual unit tests’ unless they’re absolutely necessary."
  },
  {
    "objectID": "test_tools.html#recap",
    "href": "test_tools.html#recap",
    "title": "Test tools",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: test suite\n\n\n\n\n\n\nShiny app-packages test suite\n\nFixtures: Fixtures prepare the test environment and the initial state. The tidy_ggp2_movies.rds data is a test fixture, and it creates the tidy_ggp2_movies data within the test scope.\nHelpers: If find yourself writing small, reusable pieces of code to perform specific tasks inside your tests, consider converting them into a function in tests/testthat/helper.R."
  },
  {
    "objectID": "test_tools.html#footnotes",
    "href": "test_tools.html#footnotes",
    "title": "Test tools",
    "section": "",
    "text": "The three chapters in R Packages, 2ed, dedicated to testing are Testing basics, Designing your test suite, and Advanced testing techniques↩︎\nRead a summary of the changes to the testthat package on the tidyverse blog↩︎\nFor a concrete example, see this article on self-cleaning tests.↩︎\nThe name ‘fixtures’ isn’t required (you can name this folder anything).↩︎\nCreating a tidied version of ggplot2movies::movies would be costly to re-create with every test, so it’s advised to store it as an static test fixture.↩︎\nSnapshot tests would be more appropriate for answering the question, ‘is the plot visually correct?’.↩︎\nIf you like verbose logging outputs, check out the logger package↩︎\nPlacing common files for testing below R/ is covered in R Packages, 2ed↩︎\nMastering Shiny covers creatng a snapshot file to test UI elements, but also notes this is probably not the best approach.↩︎\nFollow the expect_snapshot_file() example from the testthat documentation↩︎\nmatching files names between R/ and tests/testthat/ keeps our code organized and ensures the devtools::test_coverage_active_file() function works.↩︎"
  },
  {
    "objectID": "test_modules.html#integration-tests",
    "href": "test_modules.html#integration-tests",
    "title": "Testing modules",
    "section": "Integration tests",
    "text": "Integration tests\nIntegration tests verify that functions and components work together, and often involves instantiating multiple objects to interact with each other in a single test.\nWe can combine the BDD functions with testServer() to test reactive interactions between modules. For example, to confirm that the drop-down feature requirement is working (i.e., that user-inputs are updating in the application), we need to test two changes:\n\nValues passed to the UI are returned from mod_var_input_server()\n\nThe reactive values returned from mod_var_input_server() are passed into mod_scatter_display_server() and available as the reactive object inputs()\n\nExample scenarios for these changes are provided below:\nFeature: Scatter Plot Configuration in Movie Review Application\n      As a user \n      I want the initial graph pre-configured with variables and aesthetics,\n      So that I can immediately see a meaningful visualization.\n\nScenario: Scatter plot initial x, y, color values \n         Given the movie review application is loaded\n         When I view the initial scatter plot\n         Then the scatter plot should show 'IMDB Rating' on the x-axis\n         And the scatter plot should show 'Audience Score' on the y-axis\n         And the points on the scatter plot should be colored by 'MPAA Rating'\n         And the opacity of the points should be set to '0.5'\n         And the size of the points should be set to '2'\n         And the plot title should be 'Enter plot title'\n\nsession$returned()\nInside testServer(), we can create a list of graph inputs for mod_var_input_server(), then pass identical values to session$setInputs(), and confirm the returned object with session$returned():\n\n1    shiny::testServer(app = mod_var_input_server, expr = {\n      \n      test_logger(start = \"var_inputs\", msg = \"returned()\")\n      \n      # create list of output vals\n2      test_vals &lt;- list(y = \"imdb_rating\",\n                        x = \"audience_score\",\n                        z = \"mpaa_rating\",\n                        alpha = 0.75,\n                        size = 3,\n                        plot_title = \"Example title\")\n\n      # change inputs\n3      session$setInputs(y = \"imdb_rating\",\n                        x = \"audience_score\",\n                        z = \"mpaa_rating\",\n                        alpha = 0.75,\n                        size = 3,\n                        plot_title = \"Example title\")\n\n      testthat::expect_equal(\n4        object = session$returned(),\n        expected = test_vals\n      )\n\n      test_logger(end = \"T5\", msg = \"F1.2: returned()\")\n      \n})\n\n\n1\n\nCall to testServer()\n\n\n2\n\nCreate output values for comparison\n\n\n3\n\nSet each input using setInputs(input = )\n\n\n4\n\nConfirm returned values against test_vals\n\n\n\n\nThe test above confirms 1) new input values can be passed into the UI, and 2) these values are returned from mod_var_input_server().\n\n\nargs = list()\nNow that we’ve confirmed mod_var_input_server() is returning values, we want to make sure reactive values are read correctly by mod_scatter_display_server().\nIn movies_server(), when we pass selected_vars to the var_inputs argument, we’re not passing the returned values (this is why we don’t need the parentheses). We’re calling on the method (or function) created by the call to reactive() (inside mod_var_input_server()).\nI’ve included the movies_server() function below to refresh our memory of how this should work:1\n\nmovies_server &lt;- function(input, output, session) {\n\n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\n1\n\nCalls return(reactive(list(...)))\n\n\n\n\nWhen we pause execution with Posit Workbench’s debugger we can see the difference between calling selected_vars and selected_vars():2\n\n\n\nBrowse[1]&gt; selected_vars\nreactive({\n    list(\n      y = input$y, \n      x = input$x, \n      z = input$z, \n      alpha = input$alpha, \n      size = input$size, \n      plot_title = input$plot_title\n      )\n})\n\n\n \n\n\nBrowse[1]&gt; selected_vars()\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nIf we’re testing a module function that collects the reactive values, we need to wrap those values in reactive() in the args() argument:\n\nshiny::testServer(\n  app = mod_scatter_display_server,\n  args = list(\n    var_inputs =\n1      shiny::reactive(\n        list( \n            x = \"critics_score\",\n            y = \"imdb_rating\",\n            z = \"mpaa_rating\",\n            alpha = 0.5,\n            size = 2,\n            plot_title = \"Enter Plot Title\"\n          )\n        )\n  ),\n  expr = {\n    test_logger(start = \"display\", msg = \"selected_vars initial values\")\n2    testthat::expect_equal(\n      object = inputs(),\n      expected = list(\n        x = \"critics_score\",\n        y = \"imdb_rating\",\n        z = \"mpaa_rating\",\n        alpha = 0.5,\n        size = 2,\n        plot_title = \"Enter Plot Title\"\n      )\n    )\n    test_logger(end = \"display\", msg = \"selected_vars initial values\")\n})\n\n\n1\n\nList of reactive variable inputs\n\n\n2\n\nCompare inputs() to initial values\n\n\n\n\nI’ve included the example above because it’s not included on the testServer() documentation, and I’ve found this method works well if you want to confirm two modules are communicating (i.e., returning and collecting outputs). System test with shinytest2 are a better option if we’re trying to capture a more comprehensive execution path (i.e., user story) in the application.\n\n\nModule test coverage\nWhen we check the code coverage for the test above, we can see it confirms var_inputs is communicating the reactive values to inputs() in mod_scatter_display_server(), but this test doesn’t execute the call to scatter_plot():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\n\n\n\n\nTesting output$s\nTo confirm the plot is being created properly in mod_scatter_display_server(), we can’t use the ggplot2::is.ggplot() function because the plot is being rendered by renderPlot(). However, we can verify the structure of the output$scatterplot object using any of the following expectations:\n\ntestthat::expect_true(\n  object = is.list(output$scatterplot))\n\ntestthat::expect_equal(\n  object = names(output$scatterplot),\n  expected = c(\"src\", \"width\", \"height\", \"alt\", \"coordmap\"))\n\ntestthat::expect_equal(\n  object = output$scatterplot[[\"alt\"]],\n  expected = \"Plot object\")\n\nIt’s also possible to build the graph inside the test using the same code from the module server function, then confirm it with ggplot2::is.ggplot():\n\n1    plot &lt;- scatter_plot(movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size) +\n    ggplot2::labs(\n      title = inputs()$plot_title,\n      x = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$x), \"_\", \" \"),\n      y = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$y), \"_\", \" \")) +\n    ggplot2::theme_minimal() +\n    ggplot2::theme(legend.position = \"bottom\")\n    \n2    testthat::expect_true(ggplot2::is.ggplot(plot))\n\n\n1\n\nBuild graph (same code from module function)\n\n\n2\n\nConfirm ggplot2 object is built\n\n\n\n\nThis executes the code used build the graph in mod_scatter_display_server():\n\n\n\n\n\nIf we’re still skeptical this test is confirming the plot is being built correctly, we can pass plot to print() in the test and the plot will appear in the Plots pane.\n\n\n\nPassing plot to print() will send the graph to the Plots pane\n\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 10d_tests-modules branch of moviesApp."
  },
  {
    "objectID": "test_modules.html#footnotes",
    "href": "test_modules.html#footnotes",
    "title": "Testing modules",
    "section": "",
    "text": "selected_vars are the reactive plot values returned from mod_var_input_server().↩︎\nWe’ll cover using browser() and the IDE’s debugger in a future chapter.↩︎"
  },
  {
    "objectID": "test_system.html#system-tests",
    "href": "test_system.html#system-tests",
    "title": "System tests",
    "section": "System tests",
    "text": "System tests\n\n“Failure to allow enough time for system test, in particular, is peculiarly disastrous. Since the delay comes at the end of the schedule, no one is aware of schedule trouble until almost the delivery date. Bad news, late and without warning, is unsettling to customers and to managers.” - ‘The Mythical Man-Month’, Frederick P. Brooks Jr.\n\nSystem (or end-to-end) tests simulate real user interactions in a ‘pre-production’ environment to verify the whole application (or system) works.1 Approaches to system testing vary, but in general, we’ll want to run a system test for each feature in our application before a release.\nIf we’ve been documenting our unit and integration tests with BDD feature and scenario descriptions, the system tests can be used to confirm the functional requirements for the primary execution path (or user experience) before release."
  },
  {
    "objectID": "test_system.html#current-tests",
    "href": "test_system.html#current-tests",
    "title": "System tests",
    "section": "Current tests",
    "text": "Current tests\n\n\n\n\n\n\n\n\nGit branch: 12d_tests-modules\n\nThe current files in our tests folder are below:\n\ntests\n├── testthat\n│   ├── fixtures\n│   │   ├── make-tidy_ggp2_movies.R\n│   │   └── tidy_ggp2_movies.rds\n│   ├── helper.R\n│   ├── test-mod_scatter_display.R\n│   ├── test-mod_var_input.R\n│   └── test-scatter_plot.R\n└── testthat.R\n\n3 directories, 7 files\n\nThe output from devtools::test() is below:\n\ndevtools::test()\n\nℹ Testing moviesApp\n✔ | F W  S  OK | Context\n\n⠏ |          0 | mod_scatter_display                                                \nINFO [2023-10-26 10:31:02] [ START display = selected_vars initial values]\n⠋ |          1 | mod_scatter_display                                  \nINFO [2023-10-26 10:31:03] [ END display = selected_vars initial values]\nINFO [2023-10-26 10:31:03] [ START display = scatterplot[['alt']] = 'Plot object']\n⠙ |          2 | mod_scatter_display                     \nINFO [2023-10-26 10:31:03] [ END display = scatterplot[['alt']] = 'Plot object']\nINFO [2023-10-26 10:31:03] [ START display = inputs() creates ggplot2 object]\nINFO [2023-10-26 10:31:03] [ END display = inputs() creates ggplot2 object]\n✔ |          3 | mod_scatter_display\n\n⠏ |          0 | mod_var_input                           \nINFO [2023-10-26 10:31:03] [ START input = initial inputs returned()]\n⠋ |          1 | mod_var_input                       \nINFO [2023-10-26 10:31:03] [ END input = initial inputs returned()]\n✔ |          1 | mod_var_input\n\n⠏ |          0 | scatter_plot                                          \nINFO [2023-10-26 10:31:03] [ START data 2 = fixtures/tidy_ggp2_movies.rds]\n⠋ |          1 | scatter_plot                                          \nINFO [2023-10-26 10:31:03] [ END data 2 = fixtures/tidy_ggp2_movies.rds]\nINFO [2023-10-26 10:31:03] [ START data 1 = data/movies.rda]\nINFO [2023-10-26 10:31:03] [ END data 1 = data/movies.rda]\n✔ |          2 | scatter_plot\n\n══ Results ═════════════════════════════════════════════════════════════════════\nDuration: 1.4 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 6 ]\n\nshinytest2\nshinytest2 requires a few steps to get up and running (most notably the chromote package), but you’ll find excellent documentation on the package website.2\nThe shinytest2::use_shinytest2() performs the following setup steps:\n\n✔ Adding shinytest2::load_app_env() to tests/testthat/setup-shinytest2.R\n✔ Adding *_.new.png to .gitignore\n✔ Adding _\\\\.new\\\\.png$ to .Rbuildignore\n✔ Adding shinytest2 to Suggests field in DESCRIPTION\n\nWe also get some advice on using shinytest2 functions in our code:\n• In your package code, use `rlang::is_installed(\"shinytest2\")` or\n  `rlang::check_installed(\"shinytest2\")` to test if shinytest2 is installed\n• Then directly refer to functions with `shinytest2::fun()`\nAfter setting up shinytest2, be sure you can create a new chromote session like the one below:\n\nlibrary(chromote)\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n(a) Chromium headless browser\n\n\nFigure 14.1: A new Chromote session"
  },
  {
    "objectID": "test_system.html#recording-tests",
    "href": "test_system.html#recording-tests",
    "title": "System tests",
    "section": "Recording tests",
    "text": "Recording tests\nIf we launch the test recorder with shinytest2::record_test(), change the inputs in our application, click on Expect Shiny values and Save test and exit, a test is recorded to a new test file: tests/testthat/test-shinytest2.R\n\n\n\n\n\n(a) Test recorder\n\n\nFigure 14.2: Creating a test with shinytest2::record_test()\n\n\nThe test runs and saves the PNG snapshot and test values to the tests/testthat/_snaps/ folder:\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\n── Warning (test-shinytest2.R:11:3): {shinytest2} recording: feature-01 ──\nAdding new file snapshot: 'tests/testthat/_snaps/feature-01-001_.png'\n\n── Warning (test-shinytest2.R:11:3): {shinytest2} recording: feature-01 ──\nAdding new file snapshot: 'tests/testthat/_snaps/feature-01-001.json'\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\nThe contents of the new test-shinytest2.R test file are below:\n\nlibrary(shinytest2)\ntest_that(\"{shinytest2} recording: feature-01\", {\n  app &lt;- AppDriver$new(name = \"feature-01\", \n                       height = 800, width = 1173)\n  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n  app$set_inputs(`vars-x` = \"critics_score\")\n  app$set_inputs(`vars-z` = \"genre\")\n  app$set_inputs(`vars-alpha` = 0.7)\n  app$set_inputs(`vars-size` = 3)\n  app$set_inputs(`vars-plot_title` = \"New plot title\")\n  app$expect_values()\n})\n\nAs we can see, each action in the test recorder has a corresponding call in the test:\n\nInitialize the AppDriver$new() with the name of the test and the dimensions of the Chromium browser.\n\nChange the y axis (vars-y) to ‘IMBD number of votes’ (imdb_num_votes)\n\nChange the x axis (vars-x) to ‘Critics Score’ (critics_score)\n\nChange the color by (vars-z) to ‘Genre’ (genre)\n\nChange the point opacity (vars-alpha) to ‘0.7’\n\nChange the point size (vars-alpha) to ‘3’\n\nChange the plot title to (vars-plot_title) to ‘New plot title’\n\nWe’ll use this initial test as a template for writing the steps in our test Scenarios.\n\nBDD test templates\nThere are multiple ways to approach your test layout with testthat’s describe(), it() and/or test_that() functions. Below is an example with dedicated Feature and Scenario descriptions, a reference to the feature number in the it() (or test_that()) call:\n\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \ndescribe(\"Scenario: Change dropdown values for plotting\n            Given the movie review application is loaded\n            When I choose the variable [ ] for the x-axis\n            And I choose the variable [ ] for the y-axis\n            And I choose the variable [ ] for the color\n            And I choose the size of the points to be [ ]\n            And I choose the opacity of the points to be [ ]\n            And I enter '[ ]' for the plot title\n           \n            Then the scatter plot should show [ ] on the x-axis\n            And the scatter plot should show [ ] on the y-axis\n            And the points on the scatter plot should be colored by [ ]\n            And the size of the points on the scatter plot should be [ ]\n            And the opacity of the points on the scatter plot should be [ ]\n            And the title of the plot should be '[ ]'\", {\n              \n              it(\"Feature 01\", {\n                    app &lt;- AppDriver$new(name = \"feature-01\", \n                                       height = 800, width = 1173)\n                  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                  app$set_inputs(`vars-x` = \"critics_score\")\n                  app$set_inputs(`vars-z` = \"genre\")\n                  app$set_inputs(`vars-alpha` = 0.7)\n                  app$set_inputs(`vars-size` = 3)\n                  app$set_inputs(`vars-plot_title` = \"New plot title\")\n                  app$expect_values()\n              })\n      })\n})\n\nWith this approach you can create the test file as soon as you have a Feature description (and come back later to fill in the Scenarios and tests).\nAn alternative approach is to use nested describe() functions and include each of the Scenario’s Then steps in the it() or test_that() call (these are what will actually be tested):\n\nlibrary(shinytest2)\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \n  describe(\"Scenario A: Change dropdown values for plotting\n             Given the movie review application is loaded\n             When I choose the variable [ ] for the x-axis\n             And I choose the variable [ ] for the y-axis\n             And I choose the variable [ ] for the color\", {\n        it(\"Then the scatter plot should show [ ] on the x-axis\n             And the scatter plot should show [ ] on the y-axis\n             And the points on the scatter plot should be colored by [ ]\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-a\", \n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                app$set_inputs(`vars-x` = \"critics_score\")\n                app$set_inputs(`vars-z` = \"genre\")\n                app$expect_values()\n       })\n     })\n             \n  describe(\"Scenario B: Change dropdown values for plotting\n              Given the movie review application is loaded\n              When I choose the size of the points to be [ ]\n              And I choose the opacity of the points to be [ ]\n              And I enter '[ ]' for the plot title\", {\n         it(\"Then the size of the points on the scatter plot should be [ ]\n              And the opacity of the points on the scatter plot should be [ ]\n              And the title of the plot should be '[ ]'\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-b\", \n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-alpha` = 0.7)\n                app$set_inputs(`vars-size` = 3)\n                app$set_inputs(`vars-plot_title` = \"New plot title\")\n                app$expect_values()\n        })\n      })\n})\n\nAn important not on this approach is the different names for each AppDriver$new() (otherwise we’d be overwriting the previous snapshot/values).\n\n\nTesting apps in inst/\nIf we want to test a feature for one of the alternative applications in moviesApp, we can pass their location to the app_dir argument of AppDriver$new(). In the test below, the scenario describes changing inputs for x, y, and color, and removing the missing values from the graph:\n\nlibrary(shinytest2)\ndescribe(\n  \"Feature 1: Scatter plot data visualization dropdowns\n     As a film data analyst\n     I want to explore movie review variables from IMDB (ggplot2movies::movies data)\n     So that I can analyze relationships between movie attributes and ratings\", {\n  describe(\n    \"Scenario: Change dropdown values for plotting\n        Given the movie review application is loaded\n        When I choose the variable 'Length' for the x-axis\n        And I choose the variable 'Rating' for the y-axis\n        And I choose the variable 'Genre' for the color\n        And I click the 'Remove missing' checkbox\", code = {\n    it(\"Then the scatter plot should show 'Length' on the x-axis\n        And the scatter plot should show 'Rating' on the y-axis\n        And the points on the scatter plot should be colored by 'Genre'\n        And the missing values should be removed from the plot\", {\n            \n    test_logger(start = 'ggp2movies-feat-01', msg = \"update x, y, z, missing\")\n      \n    app &lt;- AppDriver$new(app_dir = system.file(\"dev\", package = \"moviesApp\"), \n                         name = \"ggp2movies_app-feature-01\", \n                         wait = FALSE, timeout = 30000,\n                         height = 800, width = 1173)\n      app$set_inputs(`vars-y` = \"length\")\n      app$set_inputs(`vars-x` = \"rating\")\n      app$set_inputs(`vars-z` = \"genre\")\n      app$set_inputs(`plot-missing` = TRUE)\n      app$expect_values()\n          \n      test_logger(end = 'ggp2movies-feat-01', msg = \"update x, y, z, missing\")\n      \n      })\n   })\n})\n\nNot that I’ve changed the wait and timeout arguments in AppDriver$new() because this tests takes over 10 seconds to complete (which I can see with my test_logger() output):\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-10-26 12:58:57] [ START ggp2movies-feat-01 = update x, y, z, missing]\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\nINFO [2023-10-26 12:59:09] [ END ggp2movies-feat-01 = update x, y, z, missing]\nWhen I confirm this in the output png file, I can see the x, y, and color values have been changed (and the missing values have been removed).\n\n\n\n\n\n(a) Snapshot png file\n\n\nFigure 14.3: File saved in tests/testthat/_snaps/ggp2movies_app-feature-01-001_.png'"
  },
  {
    "objectID": "test_system.html#test.mode",
    "href": "test_system.html#test.mode",
    "title": "System tests",
    "section": "test.mode",
    "text": "test.mode\nIf you recall, we’ve included an argument in both of our standalone app functions to allow for options to be passed to shinyApp().\n\nmovies_app(options = list())\n\nIf we’re testing our application, we can include the test.mode = TRUE option, which will return any values passed to exportTestValues():\n\nmovies_app(options = list(test.mode = TRUE), run = 'p')\n\nTo export values, place the name of exported reactive values in curly brackets ({}). Below is an example using the inputs() reactive object in the mod_scatter_display_server():\n\nexportTestValues(\n   x = { inputs()$x },\n   y = { inputs()$y },\n   z = { inputs()$z },\n   alpha = { inputs()$alpha },\n   size = { inputs()$size },\n   title = { inputs()$plot_title }\n  )\n\nIn our test, we can create the AppDriver$new() object, extract the values with get_values(), then write tests against any of the exported values:\n\napp &lt;- AppDriver$new(name = \"test-values\",\n                     height = 800, width = 1173,\n                     wait = FALSE, timeout = 300000)\n\ntest_values &lt;- app$get_values()\n\ntest_values[['export']]\n\n$`plot-alpha`\n[1] 0.5\n\n$`plot-size`\n[1] 2\n\n$`plot-title`\n[1] \"\"\n\n$`plot-x`\n[1] \"imdb_rating\"\n\n$`plot-y`\n[1] \"audience_score\"\n\n$`plot-z`\n[1] \"mpaa_rating\"\n\n\n\n\n\n\n\nThis section’s code is in the 12e_tests-system branch of moviesApp."
  },
  {
    "objectID": "test_system.html#recap",
    "href": "test_system.html#recap",
    "title": "System tests",
    "section": "Recap",
    "text": "Recap\nBehavior-driven development (or behavior-driven testing) fills the void between non-technical stakeholders and developers by encouraging natural, descriptive language (often complete sentences) to define and communicate the application requirements.\nCapturing the application’s desired behaviors in Features (As a , I want, So that) and Scenarios (Given, When, Then) provides a testing script that’s clear and easy to follow. Using the BDD format also makes system tests easier to update if the features and scenarios change.\n\n\n\n\n\n\nRecap: System tests\n\n\n\n\n\n\nSystem tests for your shiny app-package\n\nshinytest2: perform system (or end-to-end) tests by installing shinytest2 and running shinytest2::use_shinytest2\n\nrecord_test(): call record_test() to launch your application in the test recorder.\nRecording tests: interact with your application in the test recorder and export values and/or snapshots.\nTest files: record_test() automatically creates a new test file in tests/testthat/\n\nBDD functions: use describe() and it() to add features and sceanrios in test files.\n\ndescribe('Feature...', code = { it('Scenario...', code = { ... })})"
  },
  {
    "objectID": "test_system.html#footnotes",
    "href": "test_system.html#footnotes",
    "title": "System tests",
    "section": "",
    "text": "System tests should strive to replicate the production conditions, even when/if it’s not possible to perfectly replicate the environment.↩︎\nA great place to start is the Getting Started vignette.↩︎"
  },
  {
    "objectID": "frameworks.html#footnotes",
    "href": "frameworks.html#footnotes",
    "title": "Frameworks",
    "section": "",
    "text": "rhino apps aren’t R packages–they’re dependencies are managed with a dependencies.R file and box modules.↩︎"
  },
  {
    "objectID": "golem.html#gap-a-golem-app-package",
    "href": "golem.html#gap-a-golem-app-package",
    "title": "golem",
    "section": "gap (a golem app-package)",
    "text": "gap (a golem app-package)\ngap exports the movies data and the standalone app function, run_app().\n\nlibrary(gap)\ngap::run_app()\n\n\n\n\n\n\n(a) gap movies app\n\n\nFigure 15.1: After loading, documenting, and installing gap, launch the movies with run_app()\n\n\nIn the sections below, I’ll note various features and workflows that differ from standard package (or app-package) development."
  },
  {
    "objectID": "golem.html#dev-scripts",
    "href": "golem.html#dev-scripts",
    "title": "golem",
    "section": "dev scripts",
    "text": "dev scripts\nNew golem apps have a dev/ folder with scripts for setting up your application, development, and launching/deploying.\n\ndev\n├── 01_start.R\n├── 02_dev.R\n└── 03_deploy.R\n\nThe package website has each script available in vignettes: 01_start, 02_dev, 03_deploy\n\nSet up\nThe dev/01_start.R file opens when the new golem app-package launches. Following the steps in 01_start.R sets up the following files, folders, and options in your golem app-package:\n\nDESCRIPTION: golem has a custom function for entering many of the fields we covered in the Packages chapter 1\ngolem has functions that automatically set multiple options in the golem-config.yml 2 and package dependencies 3\nusethis functions are called for a LICENSE4, creating (and building5) a README6 a CODE_OF_CONDUCT.md7, adding a Lifecycle badge8, and the NEWS.md file.9 Many of these functions and files are covered in the Whole App Game chapter.\nIf you aren’t using Git, there’s an option to initiate a Git repo 10\nThe testing infrastructure is set up using the custom golem::use_recommended_tests() function, which creates the necessary testthat folders we covered in the Test suite chapter 11, but also adds a collection of boilerplate tests.\ngolem apps also have custom functions for creating a series of UI 12 and server 13 utility functions (and their accompanying tests).\n\n\n\nDevelopment\nAfter setting up the golem app-package with dev/01_start.R, the dev/02_dev.R file opens and contains the following functions/options for developing your application.\n\nPackage dependencies: imports are managed with the attachment package14\n\n\nCode files: new code files in golem apps can be created with a variety of helper functions. \n\nModules: add_module() adds a .R file with a mod_ prefix (an optional test can be included with the with_test = TRUE argument) \nUtility functions: utility functions can be added with add_utils() or add_fct() (also include the with_test option for tests). golem_utils_* files contain commonly used UI and server functions. \nThe primary app UI and server functions are stored in R/app_ui.R and R/app_server.R. \nThe standalone app function is stored in R/run_app.R. \nR/_disable_autoload.R disables shiny::loadSupport() (an option we covered in the Launch chapter) \nR/app_config.R contains configuration functions:\n\n\napp_sys() is a wrapper for system.file() \nget_golem_config() reads environment variables (i.e., GOLEM_CONFIG_ACTIVE) and the contents of inst/golem-config.yml:\n\n\n\n\nR\n1├── _disable_autoload.R\n2├── app_config.R\n3├── app_server.R\n├── app_ui.R\n4├── data.R\n5├── golem_utils_server.R\n├── golem_utils_ui.R\n6├── mod_plot.R\n├── mod_plot_utils_server.R\n7├── mod_var.R\n8└── run_app.R\n\n1 directory, 11 files\n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nConfigure app functions\n\n3\n\nApp UI and server functions\n\n\n4\n\nData documentation\n\n\n5\n\ngolem utility functions\n\n\n6\n\nScatter plot module\n\n\n7\n\nVariable input module\n\n\n8\n\nStandalone app function\n\n\n\n\n\nExternal files: adding external files is handled with golem_add_external_resources(), which uses the same methods we covered in the External files chapter.15\n\n\nWORDLIST: includes the word ‘golem’ and is an artifact from spellcheck argument in use_recommended_tests(). 16 \napp/ contains the application files. 17 \nextdata/ contains external data files. 18 \ngolem-config.yml is used to set various configuration options. 19\n\n\n\ninst\n├── WORDLIST\n├── app\n│   └── www\n│       ├── favicon.ico\n│       ├── golem-hex.png\n│       └── shiny.png\n├── extdata\n│   └── movies.RData\n└── golem-config.yml\n\n4 directories, 6 files\n\n\nData: the data in golem app-packages function like the data folder and files in a standard R package we covereed in the Data chapter. \n\ndata/: contains the movies.rda file used in the application \ndata-raw/: movies.R reads in data-raw/movies.RData and creates data/movies.rda\n\n\n\ndata\n└── movies.rda\n\n1 directory, 1 file\n\n\ndata-raw\n├── movies.R\n└── movies.RData\n\n1 directory, 2 files\n\n\nDocumentation: the roxygen2 documentation in golem app-package files comes with boilerplate tags and descriptions similar to those covered in the Documentation chapter. \n\nman/: By default, modules created with add_module() aren’t exported 20 \nvignettes/: Package vignettes in golem app-packages operate like vignettes in standard R packages.\n\n\n\nman\n1├── app_server.Rd\n├── app_sys.Rd\n├── app_ui.Rd\n├── get_golem_config.Rd\n├── golem_add_external_resources.Rd\n2├── mod_plot_server.Rd\n├── mod_plot_ui.Rd\n├── mod_var_server.Rd\n├── mod_var_ui.Rd\n3├── movies.Rd\n├── point_plot.Rd\n4└── run_app.Rd\n\n1 directory, 12 files\n\n\n1\n\nThese come ‘pre-packaged’ in golem apps\n\n2\n\nModule and utility functions\n\n\n3\n\nData documentation\n\n4\n\nThe ‘pre-packaged’ standalone app function is the only export from golem apps.\n\n\n\n\n\nvignettes/\n└── tests_and_coverage.Rmd\n\n1 directory, 1 file\n\n\nTests: The testing framework for golem app-packages is set up with golem::use_recommended_tests() in the dev/01_start.R script.21 \n\nA tests/README.md file is created by the covrpage package 22 \ntests/spelling.R adds functionality from the spelling package 23 \ntestthat: The two golem utility function files (golem_utils_server.R, and golem_utils_ui.R) have accompanying tests files. \n\nThe with_test argument creates test files for modules and utility functions. 24\n\n\n\n\ntests\n├── README.md\n├── spelling.R\n├── testthat\n│   ├── _snaps\n1│   ├── test-golem-recommended.R\n2│   ├── test-golem_utils_server.R\n3│   ├── test-golem_utils_ui.R\n4│   ├── test-mod_plot.R\n│   ├── test-mod_plot_utils_server.R\n5│   └── test-mod_var_input.R\n└── testthat.R\n\n3 directories, 9 files\n\n\n1\n\nCreated with: golem::use_recommended_tests()\n\n2\n\nCreated with: golem::use_utils_ui(with_test = TRUE)\n\n3\n\nCreated with: golem::use_utils_server(with_test = TRUE)\n\n4\n\nCreated with: golem::add_module(name = 'plot', with_test = TRUE, export = TRUE, utils = 'server')\n\n5\n\nCreated with: golem::add_module(name = 'var_input', with_test = TRUE, export = TRUE)\n\n\n\n\n\n\nDeployment\nWhen you’re ready to deploy your golem app dev/03_deploy.R file contains a ‘pre deployment checklist’ and multiple options.\n\ndevtools: devtools::check() and devtools::build() are called.25\nRStudio related platforms: golem has functions for RStudio Connect, shinyapps.io, and Shiny server.26\nPosit Connect or : arguments and options for deploying your application using rsconnect::deployApp(). 27"
  },
  {
    "objectID": "golem.html#golem-features",
    "href": "golem.html#golem-features",
    "title": "golem",
    "section": "golem features",
    "text": "golem features\ngolems helper functions and dev scripts make application development fast–I was able to create gap quickly, and all of the supporting packages (covrpage, attachment, spelling) make the development process faster/easier:\n\nI created the two modules (mod_plot and mod_var) with add_module(), the utility function with add_utils()\n\nI added the modules to the app_ui() and app_server()\n\nI moved images into inst/app/www/\n\nThe movies data was added to inst/extdata/, then read into data/ folder with the data-raw/movies.R file.\nI re-ran the attachment::att_amend_desc() to capture any dependencies\n\nFinally I loaded, documented, and installed the gap package.\n\nIf you’ve followed along with the preceding chapters, the golem framework should be familiar. In essence, golem takes many of the package development steps and bundles them into wrapper functions (i.e., add_module() is identical to running usethis::use_r() and usethis::use_test(), then adding an roxygen2 skeleton)."
  },
  {
    "objectID": "golem.html#gap-dependencies",
    "href": "golem.html#gap-dependencies",
    "title": "golem",
    "section": "gap dependencies",
    "text": "gap dependencies\nIt’s also worth noting that using the golem framework adds golem as a dependency:\n\n# in the fw_gap branch of moviesApp\npak::local_deps_explain(deps = 'golem', root = \".\")\n\ngap -&gt; golem \n\nmoviesApp dependencies\n\n\n\n\n\n\n\n\nGit branch: 11d_inst-prod\n\nFor comparison, this is the moviesApp dependency tree (note that using devtools/usethis doesn’t make our app-package depend on these packages).\n\n# in the 11d_inst-prod branch of moviesApp\npak::local_deps_explain(deps = 'devtools', root = \".\")\n\nx devtools\n\n# in the 11d_inst-prod branch of moviesApp\npak::local_deps_explain(deps = 'usethis', root = \".\")\n\nx usethis"
  },
  {
    "objectID": "golem.html#recap",
    "href": "golem.html#recap",
    "title": "golem",
    "section": "Recap",
    "text": "Recap\nThe golem framework is a huge time saver if you’re familiar with the underlying package development processes being bundled and optimized for ‘production grade’ Shiny apps. However, if you’re not familiar with package development, you might end up with app-packages that have bugs you can’t diagnose or fix."
  },
  {
    "objectID": "golem.html#footnotes",
    "href": "golem.html#footnotes",
    "title": "golem",
    "section": "",
    "text": "Fields are filled with golem::fill_desc()↩︎\nOptions are set with with golem::set_golem_options()↩︎\nDependencies are installed with golem::install_dev_deps()↩︎\nCreated using usethis::use_mit_license()↩︎\nBuilt using devtools::build_readme()↩︎\nCreated using usethis::use_readme_rmd()↩︎\nCreated using usethis::use_code_of_conduct()↩︎\nCreated using usethis::use_lifecycle_badge()↩︎\nCreated using usethis::use_news_md()↩︎\nInitialize Git using usethis::use_git()↩︎\nAdd test folder and files using golem::use_recommended_tests()↩︎\nCreate UI utility functions using golem::use_utils_ui()↩︎\nCreate server utility functions using golem::use_utils_server()↩︎\nattachment::att_amend_desc() parses the code under R/ and make sure the DESCRIPTION file is up-to-date↩︎\ngolem_add_external_resources() is a wrapper for golem::add_resource_path(), which is a wrapper for shiny::addResourcePath() (and app_sys() is a wrapper for system.file()).↩︎\nThe use_recommended_tests() is run in the dev/01_start.R file and if spellcheck is TRUE, creates the tests/spelling.R file and the inst/WORDLIST file.↩︎\nthe app/ folder is used to add external resources to the application (similar to the previous versions of moviesApp).↩︎\nThis contains the RData file for the original movies data.↩︎\ngolem apps use a golem-config.yml file for setting various options. These are initially set with set_golem_options() (and based on the config package)↩︎\nThe noRd tag is added to module files created with add_module(), but you can export these functions by setting the export argument to TRUE. @importFrom is used to import NS() and tagList().↩︎\ntest-golem-recommended.R contains the recommended tests for app_ui(), app_server(), app_sys(), and golem-config.yml↩︎\nThe covrpage package is not on CRAN, but the development version always seems to work. Create the tests/README.md file with covrpage::covrpage().↩︎\nThe spelling package will spell check vignettes, packages, etc.↩︎\nwith_test = TRUE) adds tests in the dev/01_start.R script. Code files created with golem::add_module(), golem::add_utils(), and golem::add_fct() will also include a test file if with_test is set to TRUE.↩︎\nThis also includes a call to rhub::check_for_cran(), which may or may not be of concern for your application.↩︎\nThese functions will create and app.R file to launch and deploy your application.↩︎\nIncludes boilerplate for appName, appTitle, appFiles, etc.↩︎"
  },
  {
    "objectID": "leprechaun.html#lap-a-leprechaun-app-package",
    "href": "leprechaun.html#lap-a-leprechaun-app-package",
    "title": "leprechaun",
    "section": "lap (a leprechaun app-package)",
    "text": "lap (a leprechaun app-package)\nlap exports the movies data and the standalone app function, run().\n\nlibrary(lap)\nlap::run()\n\n\n\n\n\n\n(a) lap movies app\n\n\nFigure 16.1: After loading, documenting, and installing lap, launch the movies with run()"
  },
  {
    "objectID": "leprechaun.html#set-up",
    "href": "leprechaun.html#set-up",
    "title": "leprechaun",
    "section": "Set up",
    "text": "Set up\nCreating a new leprechaun app-package can be done with usethis::create_package() (covered in Packages).1\nAfter your app-package is created, leprechaun::scaffold() builds the core app files: 2\n\nCode files: the code files in new leprechaun apps include the following: \n\n_disable_autoload.R: Disables shiny::loadSupport() (covered in Launch) \nassets.R: includes serveAssets() for serving JavaScript files, remove_modules() and get_modules() for adding/removing modules, and the collapse_files() helper function for collapsing files.3 \ninput-handlers.R: leprechaun_handler_df() and leprechaun_handler_list() are helper functions for including data and lists “from Websocket”.4 \nleprechaun-utils.R: includes a make_send_message() function for “send custom messages to the front-end” with the “namespace carried along”. Read below for demonstration of how this is used.5 \nrun.R: the standalone app function for your leprechaun app (covered in Launch). \nserver.R & ui.R are applications primary UI and server functions. \n\nui: contains the application UI and the assets() function (which calls serveAssets() covered above).6 \nserver.R: creates send_message from make_send_message(session) (covered below).7 \n\nzzz.R is a utility function file that holds the .onLoad() function for adding external resources (using methods covered in External files).8\n\n\n\nR\n1├── _disable_autoload.R\n2├── assets.R\n3├── input-handlers.R\n4├── leprechaun-utils.R\n5├── run.R\n6├── server.R\n7├── ui.R\n8└── zzz.R\n\n1 directory, 8 files\n\n\n1\n\nDisables shiny::loadSupport()\n\n\n2\n\nIncludes functions for serving JavaScript files, adding/removing modules, and collapsing files.\n\n3\n\nUtility functions for handling lists and data.frames\n\n\n4\n\nContains the make_send_message() function for ‘send[ing] custom messages to the front-end’\n\n5\n\nStandalone app function\n\n\n6\n\nApp primary server function\n\n\n7\n\nApp primary ui function\n\n\n8\n\nIncludes wrapper for adding external files\n\n\n\n\n\nAdding dependencies: shiny, bslib, htmltools and pkgload should be added to the DESCRIPTION with usethis::use_package() (covered in the Dependencies chapter).\n\n\nImports: \n    bslib,\n    htmltools,\n    shiny\nSuggests: \n    pkgload\n\nThe lap folder structure should look familiar if you’ve been following along with the previous chapters. The standard R package files (DESCRIPTION, NAMESPACE, and .Rproj) are accompanied by a .leprechaun lock file.\n\nlap/\n├── .leprechaun\n├── DESCRIPTION\n├── NAMESPACE\n└── moviesApp.Rproj\n\nThe initial call to leprechaun::scaffold() creates the following folders in the inst/ folder (recall that inst/ contents are available when the package is installed).\n\ninst/\n├── assets\n├── dev\n├── img\n└── run\n    └── app.R\n\n5 directories, 1 file\n\ninst/run/app.R contains a call to leprechaun::build(), pkgload::load_all(), then a call to the standalone app function, run().9"
  },
  {
    "objectID": "leprechaun.html#development",
    "href": "leprechaun.html#development",
    "title": "leprechaun",
    "section": "Development",
    "text": "Development\n\nCode files: new code files in leprechaun apps can be created with usethis::use_r() or with a helper function: \n\nCreate modules with add_module(). Modules created with add_module(\"name\") will have:10 \n\nA module file with a module_name prefix (R/module_name.R)\nA module UI function: nameUI()\nA module server function: name_server()\n\n\nCreate an app.R file with add_app_file(). This includes a call to pkgload::load_all() and run().11 \n\nApp files: R/run.R contains functions for running the app.12 \n\nAdd the modules to R/ui.R and R/server.R. \n\nR/server.R includes a call to send_message by default.13 \nR/ui.R holds the ui() and assets() functions.14 \n\nUtility function: R/utils_scatter_plot.R holds the scatter_plot() utility function.15 \nAdding files: The R/zzz.R file contains the .onLoad() function, which wraps system.file('img', package = 'lap') and addResourcePath() for including external resources. \n\n\n\nR\n├── module_plot_display.R\n├── module_var_input.R\n├── run.R\n├── server.R\n├── ui.R\n└── utils_scatter_plot.R\n\n1 directory, 6 files\n\n\nData files\n\nIncluding data files: the movies.RData data was moved into inst/extdata, then loaded into data/ with the script created with usethis::use_data_raw('movies') (similar to methods covered in the Data chapter):\n\n\ndata-raw/\n└── movies.R\n\n1 directory, 1 file\n\n\n└── extdata\n      └── movies.RData\n1 directory, 1 file\n\n\ndata\n└── movies.rda\n\n1 directory, 1 file\n\n\n\nAdding features\nThe leprechaun workflow involves a combination of use_ functions that are combined with leprechaun::build() to add various functionality to your application. I’ll demonstrate three options in the sections below:\n\nUse packer\nI’ll demo using the make_send_message() from the JavaScript example on the package website:\n\nRun packer::scaffold_leprechaun() \n\nInitializes npm, adds npm scripts, creates srcjs, srcjs/config, webpack, webpack-cli, and webpack-merge \n\nRun leprechaun::use_packer() \nRun leprechaun::build()\n\nThis creates inst/dev/packer.R and inst/assets/index.js.16\n\ninst\n├── assets\n│   └── index.js\n├── dev\n│   └── packer.R\n├── extdata\n│   └── movies.RData\n├── img\n└── run\n    └── app.R\n\nAssign the output from make_send_message() to send_message() in R/server.R, then pass the msgId and text of the message:\n\nserver &lt;- function(input, output, session){\n    ## New code --&gt;\n1  send_message &lt;- make_send_message(session)\n  \n2    send_message(\"show-packer\",\n                  text = \"this message is from your R/server.R file\")\n    \n   selected_vars &lt;- var_input_server(\"vars\")\n\n   plot_display_server(\"plot\", var_inputs = selected_vars)\n   ## New code &lt;--\n\n}\n\n\n1\n\nCreate send_message()\n\n\n2\n\nUse send_message() to send message the UI.\n\n\n\n\nAfter loading, documenting, and installing your app-package:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nRun the application:\n\nlap::run()\n\n\n\n\n\n\n(a) send_message() in lap::run()\n\n\nFigure 16.2: Adding the make_send_message() functionality to R/server.R\n\n\n\n\nAdd images\nAdding images is simplified with the .onLoad() function, which I’ll demonstrate by adding the leprechaun.jpg image file to the UI function.\n\nPlace the leprechaun.jpg file in inst/img/ \nAdd the img/ path to the code to UI:\n\n\ntags$img(\n  src = \"img/leprechaun.jpg\", \n  height = \"25%\", \n  width = \"25%\")\n\n\nrun devtools::load_all(), devtools::document(), and devtools::install(), then run the application with run():\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n\n\n\n(a) leprechaun.jpg in R/ui.R\n\n\nFigure 16.3: Adding images to inst/img/\n\n\n\n\nUse Sass\nTo add Sass styling, I can use leprechaun’s use_sass() function\n\nRun leprechaun::use_sass() \n\na scss/ folder will be created that contains _core.scss and main.scss\n\n\n\nscss\n├── _core.scss\n└── main.scss\n\n1 directory, 2 files\n\n\nThe original _core.scss file is below\n\nhtml{\n    .error {\n        color: red\n    }\n}\n\nChange the color: from red to green (#38B44A) using $accent: #38B44A;\n\n$accent: #38B44A;\n\nhtml{\n    h1 {\n        color: $accent;\n    }\n}\n\nSave this file and run leprechaun::build():17\n\n\nleprechaun::build()\n\n\n✔ Running packer.R\n✔ Bundled       \n✔ Running sass.R\n\n\nOnce again, run devtools::load_all(), devtools::document(), and devtools::install(), then run the application with run():\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n\n\n\n(a)\n\n\nFigure 16.4: Running lap with new Sass"
  },
  {
    "objectID": "leprechaun.html#tests",
    "href": "leprechaun.html#tests",
    "title": "leprechaun",
    "section": "Tests",
    "text": "Tests\nleprechaun doesn’t any specific support for testing (like the golem framework), but we can create tests using any combination of testthat, testServer(), and shinytest2."
  },
  {
    "objectID": "leprechaun.html#lap-dependencies",
    "href": "leprechaun.html#lap-dependencies",
    "title": "leprechaun",
    "section": "lap dependencies",
    "text": "lap dependencies\nIt’s also worth noting that using the leprechaun framework doesn’t add itself as a dependency:\n\n# in the fw_lap branch of moviesApp\npak::local_deps_explain(deps = 'leprechaun', root = \".\")\n\nx leprechaun"
  },
  {
    "objectID": "leprechaun.html#recap",
    "href": "leprechaun.html#recap",
    "title": "leprechaun",
    "section": "Recap",
    "text": "Recap\nleprechaun apps are built using the same methods as app-packages (devtools and usethis), and are intended to be a ‘leaner and smaller’ version of golem.\n\n“it generates code and does not make itself a dependency of the application you build; this means applications are leaner, and smaller”\n\nleprechaun is similar to golem in that it ‘bundles’ various app-package development functions into helper/utility functions. For example, the .onLoad() function saves some time (at the cost of making your app code less clear and explicit).\nleprechaun also relies on external packages like packer to integrate and bundle external code files, so becoming more familiar with these packages will extend what you can build with leprechaun."
  },
  {
    "objectID": "leprechaun.html#footnotes",
    "href": "leprechaun.html#footnotes",
    "title": "leprechaun",
    "section": "",
    "text": "Remember to provide a list of fields to usethis::create_package() for the DESCRIPTION file (or edit this manually).↩︎\nleprechaun::scaffold() has arguments for ui (fluidPage or navbarPage) bs_version (bootstrap version) and overwrite (if you need to start over).↩︎\nLink to R/assets.R file.↩︎\nLink to R/input-handlers.R file.↩︎\nLink to R/leprechaun-utils.R file.↩︎\nLink to R/ui.R file.↩︎\nLink to R/server.R file.↩︎\nLink to R/zzz.R file.↩︎\nLink to inst/run/app.R file.↩︎\nleprechaun modules do not have the same naming conventions as golem (or that I’ve recommended throughout this book).↩︎\npkgload::load_all() has reset set to TRUE and helpers set to FALSE.↩︎\nR/run.R includes functions for running the production (run()) and development (run_dev()) version of the application.↩︎\nmake_send_message() is in R/leprechaun-utils.R.↩︎\nassets() loads the resources called in the R/assets.R file with the serveAssets() function.↩︎\nThe same scatter_plot() function from moviesApp (i.e, imports .data from rlang)↩︎\nUsing packer will download multiple folders into your leprechaun app package root folder (srcjs/, node_modules/, package-lock.json, package.json, webpack.common.js, webpack.dev.js, webpack.prod.js). These are not necessary and can be removed (but do not remove inst/dev/packer.R and inst/assets/index.js).↩︎\nThe scss folder is added to the root directory, but after running leprechaun::build() and creating inst/dev/sass.R, this folder can be removed.↩︎"
  },
  {
    "objectID": "rhino.html#rap-a-rhino-app",
    "href": "rhino.html#rap-a-rhino-app",
    "title": "rhino",
    "section": "rap (a rhino app)",
    "text": "rap (a rhino app)\nThe files in rap are below:\n\n1├── .Rprofile\n2├── .github/\n│   └── workflows\n├── .gitignore\n3├── .lintr\n4├── .renvignore\n├── .rscignore        \n├── README.md\n├── app\n│   ├── js\n│   ├── logic\n│   ├── main.R\n│   ├── static\n│   ├── styles\n│   └── view\n├── app.R\n├── config.yml\n5├── dependencies.R.\n├── moviesApp.Rproj\n6├── renv\n│   ├── .gitignore.   \n│   ├── activate.R\n│   ├── library\n│   ├── settings.json\n│   └── staging\n├── renv.lock\n├── rhino.yml\n└── tests\n    ├── cypress\n    ├── cypress.json\n    └── testthat\n\n24 directories, 31 files\n\n\n1\n\nActivates the renv package\n\n2\n\nCI/CD via GitHub actions\n\n\n3\n\nLintr (from lintr package)\n\n\n4\n\nrenv ignore (works like .gitignore)\n\n\n5\n\nrhino app dependencies\n\n6\n\nrenv library of packages in app project\n\n\n\n\nAs we can see, most of the standard R package folders and files are missing from rap, because rhino applications use the box package for importing dependencies and organizing code.2"
  },
  {
    "objectID": "rhino.html#rhino-features",
    "href": "rhino.html#rhino-features",
    "title": "rhino",
    "section": "rhino features",
    "text": "rhino features\nThe rhino website explains the philosophy behind the application structure above, so I won’t repeat that information here. However, I highly recommend reading the available documentation on rhino and box before deciding to adopt this framework.3"
  },
  {
    "objectID": "rhino.html#box-modules",
    "href": "rhino.html#box-modules",
    "title": "rhino",
    "section": "box modules",
    "text": "box modules\nA box module (not to be confused with a Shiny module) is a collection of .R scripts in a folder. The modules in a new rhino app are stored in the app/logic/ and app/view/ folders:\n\napp/\n1  ├── logic/\n  │   ├── __init__.R\n  │   ├── check-point_plot.R\n  │   ├── data.R\n  │   └── plot.R\n  ├── main.R\n2  └── view/\n      ├── __init__.R\n      ├── display.R\n      └── inputs.R\n\n3 directories, 8 files\n\n\n1\n\nNon-shiny code\n\n\n2\n\nShiny modules and app code\n\n\n\n\n\nExample tidy/logo module\nHere is a quick example of how box modules work:4\n\nBelow I’ll attempt to use the tidyverse_logo() function from the tidyverse package:\n\ntidyverse_logo()\n\nError in tidyverse_logo(): could not find function \"tidyverse_logo\"\n\nThe error is expected, because tidyverse has been installed, but hasn’t been loaded with libaray(tidyverse).\n\nIn a tidy module, I’ll import the tidyverse_logo() from tidyverse by creating a logo.R file and include the following code:\n\nThe code must include #' @export on the preceding line:\n\n\n# contents of tidy/logo.R\n#' @export\nbox::use(\n  tidyverse[tidyverse_logo] \n)\n\n\nNote I did not have to use tidyverse::tidyverse_logo()\n\nTo use the tidy module, I’ll call box::use(tidy/logo), which loads logo into the environment.\n\nbox::use(tidy/logo)\nls(logo)\n\n &lt;module: tidy/logo&gt;\n\nI can use ls() on logo to return the object(s) it imports:\n\n\nls(logo)\n\n[1] \"tidyverse_logo\"\nTo access the tidyverse_logo() function, I can use logo$tidyverse_logo():\n\nlogo$tidyverse_logo()\n\n⬢ __  _    __   .    ⬡           ⬢  . \n / /_(_)__/ /_ ___  _____ _______ ___ \n/ __/ / _  / // / |/ / -_) __(_-&lt;/ -_)\n\\__/_/\\_,_/\\_, /|___/\\__/_/ /___/\\__/ \n     ⬢  . /___/      ⬡      .       ⬢ \nNote that the tidyverse_logo() function is still not loaded outside the logo module\n\ntidyverse_logo()\n\nError in tidyverse_logo(): could not find function \"tidyverse_logo\"\n\nBy explicitly naming the functions you intend to use with box::use(package[function]), box modules remove the need install and load packages with install.packages() and library().5"
  },
  {
    "objectID": "rhino.html#tests",
    "href": "rhino.html#tests",
    "title": "rhino",
    "section": "Tests",
    "text": "Tests\nrhino apps have support for testing with testthat, shiny::testServer(), shinytest2, and Cypress.\n\ntests/\n1├── cypress\n│   └── integration\n│       └── app.spec.js\n├── cypress.json\n2└── testthat\n    └── test-main.R\n\n4 directories, 3 files\n\n\n1\n\nCypress test infrastructure\n\n\n2\n\ntestthat test infrastructure\n\n\n\n\nBelow is the boilerplate test code in the tests/testthat/test-main.R file:\n\n1box::use(\n  shiny[testServer], \n  testthat[...],\n)\n\nbox::use(\n  app/main[...],\n)\n\n2test_that(\"main server works\", {\n  testServer(server, {\n    expect_equal(output$message, \"Hello!\")\n  })\n})\n\n\n1\n\nbox module importing test package functions\n\n2\n\nUsing shiny::testServer() and testthat::test_that() functions in test."
  },
  {
    "objectID": "rhino.html#rhino-dependencies",
    "href": "rhino.html#rhino-dependencies",
    "title": "rhino",
    "section": "rhino dependencies",
    "text": "rhino dependencies\nIn rhino apps, dependencies are managed by renv and the dependencies.R file. The renv package is designed to,\n\n“create[s] and manage[s] project-local R libraries, save[s] the state of these libraries to a ‘lockfile’, and later restore[s] the library as required.” 6\n\nThe rhino::pkg_install() helper function updates both the dependencies.R file and renv library. Using dependencies.R, renv, and box modules removes the need to manage dependencies in a DESCRIPTION or NAMESPACE file.7"
  },
  {
    "objectID": "rhino.html#recap",
    "href": "rhino.html#recap",
    "title": "rhino",
    "section": "Recap",
    "text": "Recap\nrhino takes a novel and innovative approach to developing Shiny applications (and covering all the ways they differ from app-packages is beyond the scope of this book). Feel free to review the code in the fw_rap branch for a better understanding of how the box modules are structured and used within the ui and server.\nThe rhino framework isn’t used as widey golem,8 but it’s been gaining popularity (and has been used in a recent pilot FDA submission).\n\n\n\n\n\n(a) rhino CRAN downloads\n\n\nFigure 17.4: CRAN downloads for rhino, leprechaun, and goelm between 2020-10-31 and 2023-10-31."
  },
  {
    "objectID": "rhino.html#footnotes",
    "href": "rhino.html#footnotes",
    "title": "rhino",
    "section": "",
    "text": "I re-initialize the session on the fw_rap branch so I’m not tempted to load, document, install, or test the code using the IDE.↩︎\nImported dependencies in rhino apps use box modules instead of the DESCRIPTION and NAMESPACE.↩︎\nI highly recommend reading about testing box modules and rhino applications with cypress and shinytest2.↩︎\nI’ve written a blog post on using box modules (outside of a Shiny application).↩︎\n“In fact, box completely replaces the base R library and require functions” - box documentation.↩︎\nAs described in renv’s DESCRIPTION file↩︎\nBe sure to read the renv configuration article for a better understanding on how it works with rhino apps.↩︎\nCheck for yourself on cran-downloads↩︎"
  },
  {
    "objectID": "special_topics.html",
    "href": "special_topics.html",
    "title": "Special topics",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nAll the other stuff…\nend special_topics.qmd"
  },
  {
    "objectID": "debugging.html#strategies",
    "href": "debugging.html#strategies",
    "title": "Debugging",
    "section": "Strategies",
    "text": "Strategies\nPosit Workbench’s debugging tools are covered elsewhere,1 so I’ll keep this chapter focused on what I use to debug Shiny code inside an R package (although these methods will work on any Shiny app):\n\nWrapping browser() in a call to observe()\n\nCapturing reactive values with reactiveValuesToList() and sending output to the UI\n\nThese two methods cover 90% of my debugging needs while developing Shiny apps (and their accompanying tests). In the following sections, I’ll provide examples of how–and when–I use each method."
  },
  {
    "objectID": "debugging.html#debugging-shiny",
    "href": "debugging.html#debugging-shiny",
    "title": "Debugging",
    "section": "Debugging & Shiny",
    "text": "Debugging & Shiny\nThe contents of a Shiny app-package can quickly become a complicated and intertwined combination of utility, module, UI, server, and standalone app functions. During regular development, Posit Workbench’s interactive debugger lets us inspect variables and expressions at runtime, and execute the code line-by-line.\nIn Shiny functions, we can track the execution of reactive expressions and observers, which allows us to unravel reactivity-related issues that are often difficult to diagnose.\n\nbrowser()\nbrowser() pauses code execution and activates the interactive debugger mode in the IDE, allowing us to view objects, execute code, and ‘step through’ each function line.\n\n\nobserve()\nobserve() creates a reactive observer that ‘listens’ for changes to reactive expressions (and executes code in response).\nWrapping browser() with observe() will trigger the debugger when the observer is invalidated, allowing us to interactively examine variables and reactive expressions (within the scope of the observe() function):\n\n\n\n\n\nPosit Workbench’s interactive debugger\n\n\n\nshiny_server_function &lt;- function(input, output, session) {\n\n1    observe({\n2        browser()\n    \n\n    returned_values &lt;- mod_something(\"bla\")\n\n    mod_something_else(\"blabla\", input_values = returned_values)\n    \n    })\n}\n\n\n1\n\nobserve() function scope\n\n\n2\n\nCall to browser() (called at the top of the observe() scope)\n\n\n\n\n\n\n\n\n\n\nDebugging reactivity\n\n\n\n\n\n\nShiny’s reactive model can make debugging challenging because the issues aren’t limited to logic or calculations, but also include the timing, sequence, or creation of reactive values.\n\n\n\n\nDon’t forget to load any debugging calls with devtools::load_all() before re-launching the app:\n\ndevtools::load_all(\".\")\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L"
  },
  {
    "objectID": "debugging.html#debugging-app-functions",
    "href": "debugging.html#debugging-app-functions",
    "title": "Debugging",
    "section": "Debugging app functions",
    "text": "Debugging app functions\n\n\n\n\n\n\n\nThis section’s code is in the spec_topic-debugging-01 branch of moviesApp.\nLet’s start by debugging the scatter plot display in our primary standalone app function, movies_app(). Suppose we’re seeing the following error when we try to run the application from the Console:\n\nmovies_app(test = FALSE)\n\n\n\n\n\n\n(a) Error in movies_app()\n\n\nFigure 18.1: Errors in the UI are not always informative…\n\n\nThe error in the UI is not very descriptive, but fortunately the following warning is also returned in the Console:\nWarning: Error in ggplot2::geom_point: Problem while computing aesthetics.\nℹ Error occurred in the 1st layer.\nCaused by error in `.data[[NULL]]`:\n! Must subset the data pronoun with a string, not `NULL`.\nWhen debugging Shiny apps, my goal is to locate the source of most informative error message. In movies_app(), I know the scatter_plot() function is called from within the scatter plot display module, which is called from movies_server(), so it’s hard to know exactly where this error is coming from:2\n\n█─movies_app\n└─█─movies_server\n  └─█─mod_scatter_display_server \n    └─█─scatter_plot\n\nFirst we’ll add browser() and observe() in the movies_server() function to capture the behaviors of both modules:\n\n\n\n\n\n\n\nThis section’s code is in the spec_topic-debugging-02 branch of moviesApp.\n\nmovies_server &lt;- function(input, output, session) {\n\n1    observe({\n2      browser()\n    \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n    })\n\n}\n\n\n1\n\nObserver scope\n\n\n2\n\nActivate debugger\n\n\n\n\nThen we’ll load the package and display the app in the Viewer pane (below the Console):\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\nℹ shinyViewerType set to pane\nThe application launches, but browser() pauses the execution of the modules and activates the IDE’s debugger:\n\n\n\n\n\n(a) Debugger with call to browser() inside observe()\n\n\nFigure 18.2: Note that the plot hasn’t rendered in the application yet because the call to observe(browser()) suspends the execution of any subsequent code\n\n\nThis allows us to view the objects that are available in movies_server() before the variables are passed to the graph rendering functions.\nIn the Source pane, we can see the call to browser() highlighted (telling us the Browse[1]&gt; location in this function).\n\n\n\n\n\n(a) R/movies_server.R with observe(browser())\n\n\nFigure 18.3: Because browser() was called inside observe(), the execution will pause, and we can interactively examine values\n\n\n\nModule communication\nIn movies_server(), the variable input module returns a reactive list (selected_vars) with the variable names (input$x, input$y, input$z), graph aesthetics (input$alpha and input$size), and an optional plot title (input$plot_title).\n\n█─movies_server \n1└─selected_vars &lt;- mod_var_input_server(\"vars\")\n\n\n1\n\nReactive values returned from variable input module\n\n\n\n\nselected_vars becomes the input for the scatter plot display module (var_inputs):\n\n█─movies_server \n1├─selected_vars &lt;- mod_var_input_server(\"vars\")\n2└─mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n\n\n1\n\nReactive values returned from variable input module\n\n2\n\nVariable inputs passed to scatter plot display module\n\n\n\n\n\nIn the debugger, we want to confirm the returned values from the variable input module, selected_vars, which requires us to execute the next two lines of code:\n\n\n\n\n\n(a) Execute the function line-by-line with n to create selected_vars\n\n\nFigure 18.4: Click the Next icon twice to create selected_vars\n\n\nNow we can inspect selected_vars in the debugger console:\n\n\n\nBrowse[2]&gt; selected_vars\n\n\nreactive({\n  list(y = input$y, x = input$x, z = input$z,\n    alpha = input$alpha, size = input$size,\n    plot_title = input$plot_title\n  )\n}) \n\n\n\nThis output shows that selected_vars (without parentheses) contains the method (i.e., the reactive list of inputs), and not the actual values.\nIf we check selected_vars() (with parentheses) in the debugger, we see this contains the values from the variable input module:\n\n\n\nBrowse[2]&gt; selected_vars()\n\n\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nThese two steps confirm that the UI values are being collected by the variable input module and stored in selected_vars, so the error must be coming from inside the scatter plot display module."
  },
  {
    "objectID": "debugging.html#debugging-modules",
    "href": "debugging.html#debugging-modules",
    "title": "Debugging",
    "section": "Debugging modules",
    "text": "Debugging modules\n\n\n\n\n\n\n\nThis section’s code is in the spec_topic-debugging-03 branch of moviesApp.\nWe’ll repeat a similar process in mod_scatter_display_server(), but include the call to observe(browser()) after moduleServer(). Then we’ll load the package and run the application again:\n\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n    \n1    observe({\n      browser()\n    \n      # module code\n      \n      })\n\n  })\n}\n\n\n1\n\nWrap browser() in observe() and place after the call to moduleServer()\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\n\nVerify module communication\nInside the module, we want to confirm var_inputs() is being created correctly from the selected_var object in movies_server().\n\n\n\nBrowse[2]&gt; var_inputs()\n\n\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\n\n\nVerify variable inputs\nInside the scatter plot display module, the var_inputs argument is used to create a reactive input() object for the graph created by scatter_plot():\n\n2    inputs &lt;- reactive({\n1      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n    })\n\n\n1\n\nVariable inputs (from selected_vars)\n\n\n2\n\ninputs() for scatter_plot()\n\n\n\n\nNow that we’ve confirmed var_inputs() has been created, we’ll verify the values are passed correctly from var_inputs() to inputs() (which is used to create the scatter plot).\nTo do this, we’ll progress through the module function (using n in the debugger console or by clicking Next) until the inputs() reactive has been created,\n\n\n\n\n\n(a) Progressing past inputs() tells us it’s been created\n\n\nFigure 18.5: Use n in the debugger or click Next to progress through the function\n\n\n\n\n\nBrowse[2]&gt; inputs()\n\n\n$x\n[1] \"imdb_rating\"\n\n$y\n[1] \"audience_score\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nThese two steps have shown us 1) the modules are communicating properly, and 2) the scatter plot display module contains the list of reactive values needed to render the graph.\n\n\nVerify graph\n\n\n\n\n\n\n\nThis section’s code is in the spec_topic-debugging-04 branch of moviesApp.\nIf we want to debug the scatter plot output, we need to move our observe(browser()) functions inside the call to renderPlot():\n\noutput$scatterplot &lt;- renderPlot({\n1  observe({\n2    browser()\n\n    \n  })\n})\n\n\n1\n\nObserve scope\n\n\n2\n\nCall to browser()\n\n\n\n\nLoad the package and run the application again:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\nInside renderPlot(), we can progress to the creation of the plot object:\n\n\n\nBrowse[1]&gt; n\n\n\ndebug at moviesApp/R/mod_scatter_display.R#68: \n  plot &lt;- scatter_plot(\n    df = movies, \n    x_var = inputs()$x, \n    y_var = inputs()$y, \n    col_var = inputs()$col, \n    alpha_var = inputs()$alpha, \n    size_var = inputs()$size)\n\n\n\nFrom here we can step inside the scatter_plot() utility function to identify the source of the error:\n\n\n\n\n\n(a) Step into scatter_plot()\n\n\nFigure 18.6: Use s in the debugger console to ‘step into’ scatter_plot()\n\n\nNote the changes in the debugger console when we ‘step into’ scatter_plot():\n\n\n\nBrowse[2]&gt; s\n\n\ndebugging in: \n  scatter_plot(df = movies, \n    x_var = inputs()$x, \n    y_var = inputs()$y, \n    col_var = inputs()$col, \n    alpha_var = inputs()$alpha, \n    size_var = inputs()$size)\n1debug at /moviesApp/R/scatter_plot.R#30:\n{   \n    ggplot2::ggplot(data = df, \n      ggplot2::aes(x = .data[[x_var]], \n                   y = .data[[y_var]], \n                   color = .data[[col_var]])) + \n      ggplot2::geom_point(alpha = alpha_var, \n                          size = size_var)\n}\n\n\n1\n\nLocation of debugger in utility function\n\n\n\n\n\n\n\nBrowse[3]&gt;\n\n\n\nAfter some examination, we can identify the source of the error.3\n\n\n\n\n\n\nDebugging shiny functions\n\n\n\n\n\n\nIf a module or standalone app function is producing a bug (i.e., failing to render an output, producing an error in the Console, etc.), I start by placing a call to browser() (wrapped in shiny::observe()) at the top-level UI/server functions, then procced ‘down’ into the modules."
  },
  {
    "objectID": "debugging.html#exploring-code",
    "href": "debugging.html#exploring-code",
    "title": "Debugging",
    "section": "Exploring code",
    "text": "Exploring code\nobserve() and browser() aren’t only useful for addressing bugs–we can also use the debugger to understand how an application works.\nSuppose it’s been awhile since we’ve looked at the ggplot2movies::movies version of movies_app() (run with ggp2_movies_app()). We can place calls to observe(browser()) in the inst/dev/app.R file, load the package, and run the application to see how it executes.\nWe’ll wrap the code in dev_mod_scatter_server() in observe(), and place a call to browser() before the alternate dataset is loaded:\n\ndev_mod_scatter_server &lt;- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n2      browser()\n\n    # load alternate data\n    all_data &lt;- fst::read_fst(\"tidy_movies.fst\")\n3\n\n\n\n    })\n  })\n})\n\n\n1\n\nObserver scope\n\n\n2\n\nCall to browser()\n\n\n3\n\nAdditional module code omitted\n\n\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nggp2_movies_app(options = list(test.mode = FALSE), run = 'p')\n\nThis will suspend the execution of application before the tidy ggplot2movies::movies data are loaded (tidy_movies.fst), and before the graph is rendered:\n\n\n\n\n\n\n\nDebugging dev_mod_scatter_server()\n\n\n\n\n\n\n\nggp2_movies_app() in interactive debugger\n\n\n\n\n\n\nWe can step through the module function to explore how the alternate data are loaded (and missing values are removed).\n\nVerify app data\nFirst we’ll proceed through the code until tidy_movies.fst is loaded, then confirm it’s structure:\n\n\n\nBrowse[2]&gt; n\nBrowse[2]&gt; n\nBrowse[2]&gt; str(all_data)\n\n\n'data.frame':   46002 obs. of  8 variables: \n $ title     : chr  \"'Til There Was You\" ...\n $ length    : int  113 97 98 98 102 120 ...\n $ year      : int  1997 1999 2002 2004 ...\n $ budget    : int  23000000 16000000 ...\n $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...\n $ votes     : int  799 19095 181 7859 ...\n $ mpaa      : Factor w/ 5 levels \"G\",\"PG\" ...\n $ genre     : Factor w/ 8 levels \"Action\"...\n\n\n\nThis gives us an idea of the total rows before missing are removed.\n\n\nVerfiy missing\nAfter loading all_data, the module creates a reactive graph_data(). We can see graph_data() is ‘bound’ to input$missing, so we’ll confirm the input$missing value:\n\n\n\n\n\n\n\n\nBrowse[2]&gt; input$missing\n\n\n[1] TRUE\n\n\n\nThis tells us ‘Remove missing’ has been selected, and we can verify the missing values have been removed from graph_data():\n\n\n\nBrowse[2]&gt; n\nBrowse[2]&gt; str(graph_data())\n\n\n'data.frame':   1608 obs. of  8 variables: \n $ title     : chr  \"'Til There Was You\" ...\n $ length    : int  113 97 98 98 102 120 ...\n $ year      : int  1997 1999 2002 2004 ...\n $ budget    : int  23000000 16000000 ...\n $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...\n $ votes     : int  799 19095 181 7859 ...\n $ mpaa      : Factor w/ 5 levels \"G\",\"PG\" ...\n $ genre     : Factor w/ 8 levels \"Action\"...\n\n\n\n\n\nVerfiy variable inputs\nNext we’ll confirm the var_inputs() list of graph values from our dev variable input module:\n\n\n\nBrowse[2]&gt; str(var_inputs())\n\n\nList of 6\n $ x         : chr \"year\"\n $ y         : chr \"budget\"\n $ z         : chr \"mpaa\"\n $ alpha     : num 0.4\n $ size      : num 2.5\n $ plot_title: chr \"\"\n\n\n\nvar_inputs() is creates the inputs() reactive for the graph, so we’ll confirm those values, too.\n\n\n\n\n\n\n\n\nBrowse[2]&gt; n\nBrowse[2]&gt; str(inputs())\n\n\nList of 6\n $ x         : chr \"year\"\n $ y         : chr \"budget\"\n $ z         : chr \"mpaa\"\n $ alpha     : num 0.4\n $ size      : num 2.5\n $ plot_title: chr \"\"\n\n\n\n\n\nVerfiy graph\nNow that we have an understanding of the reactive flow inside the app, we’ll render the plot:\n\n\n\nBrowse[2]&gt; n\n\n\n\n\n\n\nUsing browser() to ‘step through’ an application gives us a better understanding of the ‘order of execution’ in our dev scatter plot display module, (and it lets us see how input$missing and bindEvent() are working)."
  },
  {
    "objectID": "debugging.html#debugging-apps",
    "href": "debugging.html#debugging-apps",
    "title": "Debugging",
    "section": "Debugging apps",
    "text": "Debugging apps\n\n\n\n\n\n\n\nThis section’s code is in the spec_topic-debugging-05 branch of moviesApp.\nOne of the best tried and tested methods of debugging is simply adding a cat() or print() call somewhere in your code to print variables or objects to the R console. This is a basic but effective way to track variable changes.\nWe can do something similar in Shiny applications by combining verbatimTextOutput(), renderPrint(), and reactiveValuesToList():\nIn mod_var_input:\n\nPlace a verbatimTextOutput() in the ui function.\n\n\n1    code(\"module reactive values\"),\n2    verbatimTextOutput(outputId = ns(\"mod_vals\"))\n  )\n\n\n1\n\nOptional label\n\n\n2\n\nInclude the ns() for the inputId\n\n\n\n\n\nIn a renderPrint(), use reactiveValuesToList() to gather the inputIds and pass them to print() (I’m actually using lobstr::tree() to give a clearer display).\n\n\n  output$mod_vals &lt;- renderPrint({\n2    lobstr::tree(\n1      reactiveValuesToList(\n        x = input,\n3        all.names = TRUE\n      )\n    )\n  })\n\n\n1\n\nCollect reactive values in module\n\n\n2\n\nPrint these values to the UI\n\n\n3\n\nInclude all reactive objects\n\n\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\n\n\n\n\n\n(a) ‘Print’ in movies_app()\n\n\nFigure 18.7: reactiveValuesToList() printed from mod_var_inputs\n\n\nNow we can see the reactive values from our module in the application sidebar!\n\nExploring app ‘levels’\nWe can also use this ‘print’ method to explore reactive values at various locations in our application. For example, if we wanted to print the reactive values for multiple modules in an app, we can use these methods in the top level movies_ui() and movies_server() functions.\nIn the bslib portion of movies_ui():\n\nAdd verbatimTextOutput() with an optional label\n\ncode(\"reactive values\"),\nverbatimTextOutput(outputId = 'vals')\n)\n\n\nIn movies_server():\n\nCollect all the inputIds with reactiveValuesToList() and print with print() or lobstr::ast()\n\nall_vals &lt;- reactive({\n  reactiveValuesToList(x = input, all.names = TRUE)\n})\n\noutput$vals &lt;- renderPrint({\n  lobstr::tree(all_vals())\n})\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(test = FALSE, run = 'p', bslib = TRUE)\n\n\n\n\n\n\n(a) ‘Print’ in movies_app(bslib = TRUE)\n\n\nFigure 18.8: reactiveValuesToList() printed from movies_ui() and movies_server()\n\n\nHere we can see both levels of reactive values (from the module and the UI/server functions). The handy thing about this method is that the values change when we interact with the application:\n\n\n\n\n\n(a) Changing values in movies_app(bslib = TRUE)\n\n\nFigure 18.9: y and vars-y both update when the UI inputs change"
  },
  {
    "objectID": "debugging.html#recap",
    "href": "debugging.html#recap",
    "title": "Debugging",
    "section": "Recap",
    "text": "Recap\nbrowser() and observe() are powerful tools for debugging your application. Navigating a function using the debugger console gives you control over the execution of each line. If we want to see what’s happening ‘behind the scenes’, we can collect the reactive values and print them in the UI while the app is running.\nThe Shiny documentation also has a list of methods for debugging apps, and learning how to read call stacks (or a stacktrace) will help you debug your shiny app.4"
  },
  {
    "objectID": "debugging.html#footnotes",
    "href": "debugging.html#footnotes",
    "title": "Debugging",
    "section": "",
    "text": "For an introduction to the IDE’s debugging tools, see this Posit article. Debugging is also covered in Advanced R, 2ed and Mastering Shiny.↩︎\nCreate an ‘abstract folder tree’ to help understand an application’s ‘call stack’ with the ast() function from the lobstr package.↩︎\nIn this case, the issue was an incorrect inputId passed to scatter_plot()↩︎\nWatch this video to learn about call stacks and abstract folder trees with lobstr.↩︎"
  },
  {
    "objectID": "test_mocks.html#footnotes",
    "href": "test_mocks.html#footnotes",
    "title": "Test Mocks",
    "section": "",
    "text": "Test mocking functions are a relatively new addition to testthat. Read more in the recent updates to testthat↩︎\nThis example comes from the package development masterclass workshop at posit::conf(2023).↩︎"
  },
  {
    "objectID": "code_tools.html#styler-lintr",
    "href": "code_tools.html#styler-lintr",
    "title": "Code tools",
    "section": "styler & lintr",
    "text": "styler & lintr\nThe styler and lintr packages in R serve related but distinct purposes and have different focuses in their functionality. The primary difference between lintr and styler is that styler can automatically fix any stylistic issues it identifies in your code (rather than just reporting them).\nlintr: lintr is a static code analysis tool used to identify syntax errors, semantic issues, and violations of stylistic guidelines in your code. The package contains a list of ‘linters’ for various potential problems and can be customized according to your needs. lintr is designed to help improve your code’s quality and readability by generating reports in the ‘markers’ pane. Running lintr won’t automatically correct the identified issues (you’ll need to fix the linting issues it reports manually).\nstyler: On the other hand, the purpose of styler is to ensure consistency in the code formatting, which is crucial if you’re working in a team or contributing to open-source projects (like tidyverse packages). The styler package will change your code’s format according to specified style guidelines. These changes include indentation, spaces, and line breaks that adhere to your style guidelines.\nWhile there is some overlap (both packages can help enforce coding style guidelines), lintr is a more general tool for code quality, spotting potential issues and bugs. At the same time, styler focuses on code formatting and can automatically apply fixes. Many developers find combining both can help catch potential issues and ensure a consistent, readable coding style."
  },
  {
    "objectID": "code_tools.html#sinew",
    "href": "code_tools.html#sinew",
    "title": "Code tools",
    "section": "sinew",
    "text": "sinew\nThe sinew package also warrants mentioning because it can help ensure you’re namespacing functions from add-on packages.\nend code_tools.qmd"
  },
  {
    "objectID": "cicd.html#continuous-integration-ci-continuous-deployment-cd",
    "href": "cicd.html#continuous-integration-ci-continuous-deployment-cd",
    "title": "CI/CD",
    "section": "Continuous integration (CI) / continuous deployment (CD)",
    "text": "Continuous integration (CI) / continuous deployment (CD)"
  },
  {
    "objectID": "css.html",
    "href": "css.html",
    "title": "CSS",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience.\n\n\n\n\nend css.qmd"
  },
  {
    "objectID": "js.html",
    "href": "js.html",
    "title": "JavaScript",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience.\n\n\n\n\nend js.qmd"
  },
  {
    "objectID": "github.html#moviesapp",
    "href": "github.html#moviesapp",
    "title": "Appendix A — GitHub",
    "section": "moviesApp",
    "text": "moviesApp\nThe moviesApp repo is a shiny application built outside of a package structure. It was initially created using the New Project Wizard (with a Git repo initialized).\nIf you’re new to GitHub, the steps below will walk you through setting up Git and GitHub from RStudio using the Git pane. The initial files in the project are below:\nmoviesApp/\n  ├── app.R\n  └── moviesApp.Rproj\n\n1 directory, 2 files\nAfter creating the project, head over to GitHub and create am empty repo. You’ll see the following options:\n\n\n\n\n\n\n(a) New repository on GitHub\n\n\nFigure A.1: Empty GitHub repository options\n\n\n\nWe’re interested in the second option, “…push an existing repository from the command line”, but we’re going to use Posit Workbench’s Git pane.\n\nCommit\nCommit these initial changes to the repo using the Commit icon in the Git pane\n\n\n\n\n\n(a) Commit changes\n\n\n\n\n\n(b) First commit\n\n\nFigure A.2: Click on Commit to open the Git window. Stage all the files, add a commit message, and click Commit\n\n\nAdd a commit message and click Commit. This is the equivalent of entering the following commands in the Terminal:\ngit commit -m 'first commit'\n\n\n\n\n\n\nCommit changes in your repository with a specific message\n\n\n\n\n\n\ngit commit -m 'first commit'\n\ngit commit: This command captures a snapshot of the changes in your project’s tracked files and directories. By committing, you’re saving the current state of those files in the Git repository.\n-m: This flag indicates that a commit message will be provided directly from the command line.\n'first commit': This is the commit message associated with this commit. Commit messages are useful for documenting the changes you’ve made, making it easier for others (and your future self) to understand the evolution and purpose of changes in the project.\n\nWhen you run git commit -m 'first commit', you are committing your staged changes (i.e., changes you’ve previously added to the staging area using git add) with the message ‘first commit’.\nThis message is then stored in the Git history, allowing anyone who looks at the commit logs to see a brief description of what was done in that particular commit.\n\n\n\n\nReview the output from the commit.\n\n\n\n\n\n(a) First commit output\n\n\nFigure A.3: The .gitignore, app.R, and moviesApp.Rproj files have been committed to main\n\n\nThis shows the contents of moviesApp are part of the main branch. Now we need to make sure the local branch has a remote (on GitHub at https://github.com/&lt;username&gt;/moviesApp.git).\n\n\n\n\n\n\nRename the currently checked-out branch to main\n\n\n\n\n\n\nThe command git branch -M main is used to rename the currently checked-out branch to main.\nHere’s a breakdown of the command:\n\ngit branch: This command without any arguments would list all the local branches in the current repository. But, with certain options (like -M), you can perform other branch-related operations.\n-M: This option stands for ‘move/rename’ and forcibly renames the branch. If a branch named main already exists, it will be overwritten because of the forceful nature of the -M option. If you want to avoid accidentally overwriting an existing branch, you could use -m (lowercase) instead. The lowercase -m will rename only if the target name doesn’t already exist.\nmain: This is the new name for the currently checked-out branch.\n\nThe command became more common after the industry started transitioning from using master to main as the default branch name for new repositories. Running git branch -M main is a way to rename the master branch to main in existing repositories.\n\n\n\n\n\n\nAdding remotes\nClick the New Branch icon in the Git pane and create a new main branch. Then click on Add Remote… and name the remote origin.\n\n\n\n\n\n(a) Add branch and remote name\n\n\n\n\n\n(b) Add remote URL\n\n\nFigure A.4: Create new main branch to track origin\n\n\nThe Remote URL is the link from the Quick Setup above. After clicking Add and Create, you’ll be asked to checkout or overwrite the existing main branch. In this case, we can select Overwrite (because we’re already on the main branch).\n\n\n\n\n\n\nAdd a new remote to your Git repository\n\n\n\n\n\n\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n\ngit remote: used to manage and set remotes (‘remote repositories’) for your project\nadd: specifies that you want to add a new remote.\norigin: a convention widely used in the Git community is to name the primary remote repository origin.\nhttps://github.com/&lt;username&gt;/&lt;repo&gt;.git: This is the URL to the Git repository (hosted on GitHub). Replace &lt;username&gt; with the GitHub username of the repository owner and &lt;repo&gt; with the name of the repository.\n\nSo, when you run this command, you’re telling Git: ‘I want to add a new remote called origin, and the URL for this remote is https://github.com/&lt;username&gt;/&lt;repo&gt;.git'.’\nAfter executing this command, you can then push to and pull from the repository using this remote by referring to its name (origin). For instance, git push origin master would push your local master branch to the master branch on the origin remote.\n\n\n\n\n\n\n\n\n\n(a) Overwrite main\n\n\n\n\n\n(b) branch main set up to track origin/main\n\n\nFigure A.5: main will now track the remote (origin)\n\n\n\n\n\n\n\n\nPush a local branch (main) to a remote (origin), and set local branch to track remote branch\n\n\n\n\n\n\ngit push -u origin main\n\ngit push: used to push commits from your local repository to a remote repository.\norigin: name of the remote repository you want to push to. When you clone a repo or add a remote using git remote add, it’s common to name the main remote origin (though it could technically be any name).\nmain: name of the branch you’re pushing to the remote repository.\n-u or --set-upstream: When this option is used, it sets a tracking relationship between the local and upstream remote branches. This means that in the future, using git pull or git push doesn’t require specifying the remote or branch (Git will know you’re referring to the origin/main branch).\n\nIn essence, git push -u origin main is saying: ‘Push my ’main’ branch to the ‘origin’ remote, and also set my local ‘main’ branch to track the ‘main’ branch on ‘origin’.\nThe common workflow for setting up Git from the command line is below:\n# make changes \ngit add .\ngit commit 'first commit'\n# set remote on GitHub\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n# rename the current branch to main\ngit branch -M main\n# push and set upstream to origin (remote)\ngit push -u origin main"
  },
  {
    "objectID": "dependency_trees.html#shiny-app-packages",
    "href": "dependency_trees.html#shiny-app-packages",
    "title": "Appendix B — Dependency trees",
    "section": "Shiny app-packages",
    "text": "Shiny app-packages\nAll Shiny app-packages will inherently depend on shiny, so including more dependencies can make developers justifiably uneasy."
  },
  {
    "objectID": "create.html",
    "href": "create.html",
    "title": "Appendix C — Packages FAQ",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience.\n\n\n\n\n\nCan an .Rproj file convert an R project into an R package?\nThe technical answer is no, because the .Rproj only activates the Build pane in the IDE. The tools in the Build pane are directly connected to the devtools package (hence the PackageUseDevtools: Yes in the .Rproj file).\nThe seven mandatory fields are required in the DESCRIPTION to have a functioning R package.\n\n\nI have a DESCRIPTION file with the required fields, but where is the Build pane?\nIf the mandatory fields are added to the DESCRIPTION, but the .Rproj file doesn’t have any of the package configuration fields, then the Build pane will not be displayed (see example below):\n\n\n\n\n\n(a) Build pane tools\n\n\nFigure C.1: Mandatory DESCRIPTION fields with package configuration in .Rproj file\n\n\n\n\nWhat if my .Rproj file is configured to work with a package, but my DESCRIPTION file is missing one (or more) of the required fields?\nSetting the Project build tools in your Project Options is insufficient to convert a project into a package. If the .Rproj file has the package development fields (i.e., Project build tools to Package) but the mandatory fields are missing from the DESCRIPTION file, the Build pane will be triggered:\n\n\n\n\n\n(a) DESCRIPTION\n\n\nFigure C.2: Unchanged DESCRIPTION file after changing .Rproj\n\n\nBut trying to load the code in the R/ folder with Build &gt; Load All (or devtools::load_all()) we return the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n(a) Build pane tools\n\n\nFigure C.3: Attempt to load_all() code in R/ folder\n\n\nThe directory must include a DESCRIPTION file containing the mandatory fields and an .Rproj file with the package configuration fields listed above to be a functional R package.\nRead more about DESCRIPTION file fields in R Packages, 2ed\n\n\n\n\n\n\nRStudio project files\n\n\n\n\n\n\nYou can read more about the benefits of using RStudio projects to configuring project-level options here.\n\n\n\n\n\n\nI have the mandatory fields in my .Rproj file and DESCRIPTION, but still no Build pane?\nTo get the IDE to re-read the .Rproj file, you might have to terminate the session (Session &gt; Terminate R… &gt; Yes)\n\n\n\n\n\n\n\n(a) Session &gt; Terminate\n\n\n\n\n\n\n\n(b) Click Yes\n\n\n\n\nFigure C.4: Terminate your R session\n\n\nThis prompts the IDE to re-read the .Rproj file and trigger the Build pane."
  },
  {
    "objectID": "comparisons.html#footnotes",
    "href": "comparisons.html#footnotes",
    "title": "Appendix D — Comparisons",
    "section": "",
    "text": "Be mindful of the difference in arguments between expectation functions (i.e., expect_equal()) and waldo::compare()↩︎\nThe results from testthat don’t include the differences between old$num and new$num. This is due to the tolerance argument, which can be adjusted in both functions.↩︎"
  },
  {
    "objectID": "bdd.html#specifying-behaviors",
    "href": "bdd.html#specifying-behaviors",
    "title": "Appendix E — Behavior-driven development",
    "section": "Specifying behaviors",
    "text": "Specifying behaviors\nBDD uses a specific format for translating application behavior into into features. These ‘user stories’ are typically written in the Gherkin language and include the following sections:\nFeature: title of feature\n  \n  As a ...\n  I want ...\n  So that ...\n  \n  Scenario 1:\n    When ... \n    And ... \n    Then ...\n    \n  Scenario 2:\n    When ... \n    And ... \n    Then ...\nThe testthat BDD functions can be adapted to use this format, because the description argument a text string and these functions can be nested.\n\ntestthat::describe(description = \"\n  Feature: Scatter Plot Data Visualization\n\n  As a film analyst\n  I want to visualize data on a scatter plot with various inputs\n  So that I can analyze relationships between variables and groups in a customizable way.\n\n  Background:\n    Given the Shiny app is launched\n    And I have a dataset available with continuous and categorical variables\n  \", code = {\n    \n\n  testthat::describe(description = \"\n  Scenario: Select x and y continuous variables for plotting\n    When I select the variable 'input$x' for the x-axis\n    And I select the variable 'input$y' for the y-axis\n    Then the scatter plot should show 'input$x' on the x-axis\n    And 'input$y' on the y-axis\n    \", code = {\n      \n    })\n    \n  })"
  },
  {
    "objectID": "glossary.html#project",
    "href": "glossary.html#project",
    "title": "Appendix F — Glossary of terms",
    "section": "Project",
    "text": "Project\nAny directory of R executable files with an RStudio/Posit workbench project file (.Rproj)."
  },
  {
    "objectID": "glossary.html#package",
    "href": "glossary.html#package",
    "title": "Appendix F — Glossary of terms",
    "section": "Package",
    "text": "Package\nA directory of functions, documentation, and/or data can be installed and loaded into an R session. Packages include the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench."
  },
  {
    "objectID": "glossary.html#app-package",
    "href": "glossary.html#app-package",
    "title": "Appendix F — Glossary of terms",
    "section": "App-package",
    "text": "App-package\nAn app-package is a package containing a shiny application. App-packages have all of the functionality of a standard R package, but also contain the files and folders required to successfully develop, run, and deploy a shiny application."
  },
  {
    "objectID": "glossary.html#utilityhelper-function",
    "href": "glossary.html#utilityhelper-function",
    "title": "Appendix F — Glossary of terms",
    "section": "Utility/helper function",
    "text": "Utility/helper function"
  },
  {
    "objectID": "glossary.html#external-resource",
    "href": "glossary.html#external-resource",
    "title": "Appendix F — Glossary of terms",
    "section": "External resource",
    "text": "External resource"
  },
  {
    "objectID": "glossary.html#module",
    "href": "glossary.html#module",
    "title": "Appendix F — Glossary of terms",
    "section": "Module",
    "text": "Module"
  },
  {
    "objectID": "glossary.html#standalone-app-function",
    "href": "glossary.html#standalone-app-function",
    "title": "Appendix F — Glossary of terms",
    "section": "Standalone app function",
    "text": "Standalone app function"
  }
]