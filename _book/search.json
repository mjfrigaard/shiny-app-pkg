[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "Welcome"
  },
  {
    "objectID": "index.html#what-is-in-this-book",
    "href": "index.html#what-is-in-this-book",
    "title": "Shiny App-Packages",
    "section": "What is in this book",
    "text": "What is in this book\n\n\n\n\n\n\n\nThis book is a resource to help ‘connect the dots’ between building scalable Shiny applications and writing R packages. Adopting R package development practices in the early stages of your Shiny app will improve the reusability, maintainability, and shareability of all your hard work.\nFor continuity, I’ve used code and data from the excellent Building Web Applications with Shiny (BWAS) course. The learning modules in BWAS also serve as ‘prerequisites’ for many of the chapters covered here (if you haven’t completed that course, be sure you understand the topics it covers). You’ll find each section in this book also includes a dedicated GitHub repository and branch for you to follow along."
  },
  {
    "objectID": "index.html#what-is-not-in-this-book",
    "href": "index.html#what-is-not-in-this-book",
    "title": "Shiny App-Packages",
    "section": "What is not in this book",
    "text": "What is not in this book\nThis book isn’t a replacement for Mastering Shiny, R Packages, 2ed (or Writing R Extensions), or Engineering Production-Grade Shiny Apps. I highly suggest bookmarking those resources to return and read when you’d like to learn more about package development.\nI also won’t be recommending a particular Shiny framework or package, but I’ll cover a few popular choices, show you what they are doing ‘under the hood,’ and let you decide if you’d like to adopt some of their practices."
  },
  {
    "objectID": "index.html#what-i-assume-about-you",
    "href": "index.html#what-i-assume-about-you",
    "title": "Shiny App-Packages",
    "section": "What I assume about you",
    "text": "What I assume about you\nIf you’re reading this, I assume you’re comfortable with R, Posit Workbench, Shiny, and the tidyverse. Maybe you haven’t built a ton of applications, but you understand reactivity, and you’re comfortable with the core Shiny concepts (i.e., the UI, server, *_Input(), *_Output(), and render_* functions, etc.)."
  },
  {
    "objectID": "index.html#code-examples",
    "href": "index.html#code-examples",
    "title": "Shiny App-Packages",
    "section": "Code examples",
    "text": "Code examples\nThe code files for each chapter are stored in GitHub repositories. Major code changes are stored in branches. Whenever a new branch or repo is used, you’ll see the Git Branch icon with a link to the repo in the margin.\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 09.2_inst-bslib branch of moviesApp.\n\nIn an effort to make each section accessible and easy to follow, I’ve created an R package for the code examples:\nhttps://mjfrigaard.github.io/shinypak/\nSections also include the code for installing, loading, and launching applications using shinypak:\n\n“Install the shinypak package package to easily launch the applications:”\n# install.packages('pak')\npak::pak('mjfrigaard/shinypak')\nshinypak::launch('09.2_inst-bslib')\n\n\n\n\nshinypak::launch(‘09.2_inst-bslib’)"
  },
  {
    "objectID": "intro.html#why-this-book",
    "href": "intro.html#why-this-book",
    "title": "Introduction",
    "section": "Why this book?",
    "text": "Why this book?\nI started putting this resource together after multiple encounters with Shiny developers who had created impressive, complex apps but struggled to convert them into R packages. This problem often resulted in delays when moving their applications into a production environment.\n\n\nDid you read Mastering Shiny and want to learn more about package development?\n\n\nMastering Shiny is an excellent introduction to the captivating world of Shiny and provides a foundation of best practices for building applications. R packages are introduced in Mastering Shiny, and this chapter is a great place to start. 1 However, to fully understand and appreciate the benefits of developing your Shiny app as an R package, I’ve found it’s helpful to have an example that includes the full suite of the package development tools (loading, documenting, testing, deploying, etc.). That’s what I’ve attempted to do with this book.\n\n\nDid you read R Packages, 2ed and find it difficult to apply package development practices to your shiny application?\n\n\nR Packages, 2ed primarily focuses on creating conventional R packages. This text is the premier reference for implementing the best practices when creating functions, writing documentation, managing package namespaces, and many other fundamental aspects of package development. However, R Packages, 2ed doesn’t cover the complexity of designing interactive user interfaces, server-side computations, or modules. Moreover, testing and debugging a Shiny application differs from the traditional methods used in R packages.2\n\n\nDid you read Engineering Production-Grade Shiny Apps and decide the golem framework wasn’t a good fit for your application?\n\n\ngolem is an ‘opinionated framework for building production-grade Shiny applications’ introduced in Engineering Production-Grade Shiny Apps (or EPGSA) that offers a robust and standardized way to build, maintain, and deploy production-grade Shiny apps. Whether due to the learning curve, overhead, dependencies, legacy code, or your particular deployment constraints, golem might not be the right fit for your situation.3\nA guiding principle throughout this book is,\nAssume someone else will read your code.\nMaking an effort to write clear and simple code is a courtesy to whoever reads your code next (which is typically future you). Clear and straightforward code is especially valid for Shiny applications destined for deployment in a production environment. The standardized and widely accepted way to organize code in R is as an R package.4\nR packages are designed for others to install and use in their R environment. Hence, packages are a standardized way of extending R’s capabilities by adding new functionality (like developing Shiny apps!).\n\n\n\n\n\n\nWhat does it mean to ‘put something into production?’\n\n\n\n\n\n\n‘Production’ usually means passing the code from your personal development environment into your company’s cloud-based server environment, which typically involves bundling your app in a structure that can be shared, installed, tested, and launched.\n\n‘I think the easiest way to think about it for me is that we develop a model in one computational environment–think of this as maybe your laptop or maybe you work in a server environment–still, it’s in one place, and it turns out the software that you need to have installed there is about tuning, training, etc. Putting something into production is getting it out of that computational environment and successfully carrying it over to a new computational environment. For many people, this might be like a cloud computing environment. It might be some kind of server your organization has, and we need to take it, lift it, and then successfully have it working.’ - Julia Silge, What is ‘production’ anyway? MLOps for the curious (SatRdays London 2023)\n\nI’ve added emphasis and edited this for clarity."
  },
  {
    "objectID": "intro.html#packages-help-you",
    "href": "intro.html#packages-help-you",
    "title": "Introduction",
    "section": "Packages help you",
    "text": "Packages help you\nThe first and obvious benefit to structuring your Shiny app as an R package is that it simplifies file and folder management. If every Shiny app project you develop is structured as an R package, it removes the time you spend manually creating directories (or re-orienting yourself to each project’s structure).\nIf you’re using Posit Workbench, the R package structure will give you access to a well-designed IDE for Shiny applications. Posit Workbench has tools to help develop and debug functions, create and run unit tests, store internal and external data, manage dependencies, and write help files and long-form documentation."
  },
  {
    "objectID": "intro.html#packages-help-them",
    "href": "intro.html#packages-help-them",
    "title": "Introduction",
    "section": "Packages help them",
    "text": "Packages help them\n\n“a package [is] the fundamental unit of shareable, reusable, and reproducible R code.” - R Packages, 2ed\n\nIt’s safe to assume the code used to build Shiny apps being deployed to a production environment will be seen (and hopefully used) by others. R packages make sharing your hard work with your colleagues easier because it removes their need to figure out where everything is, how it all fits together, and how it all (hopefully) works."
  },
  {
    "objectID": "intro.html#packages-are-scalable",
    "href": "intro.html#packages-are-scalable",
    "title": "Introduction",
    "section": "Packages are scalable",
    "text": "Packages are scalable\nSuppose you use R to perform analyses, design data visualizations, or build and run reports. If you currently use source() to load any utility functions to perform this work, I suggest putting those functions in a package. Doing this will help extend your mental model from the specific use cases (i.e., “X code performs task Y”) to a model for their more general uses (i.e., “X package performs tasks like Y”).\nGreat R packages define and solve common problems.\nThe beauty of an R package mental model is that you’ll inevitably notice the similarities across common problems. Creating packages that define and solve common problems in your workflow can sometimes be some of the most popular/valuable contributions (see datapasta and reprex)."
  },
  {
    "objectID": "intro.html#how-to-read-this-book",
    "href": "intro.html#how-to-read-this-book",
    "title": "Introduction",
    "section": "How to read this book",
    "text": "How to read this book\nThe chapters in this book (roughly) represent the steps of R package development, but from the lens of an existing shiny application.5 Each topic can be applied when creating new app-packages. Still, in my experience, many Shiny developers have existing applications they’d like to convert into an R package.\nThe first four chapters focus on a the development of Shiny app project and it’s gradual conversion into an app-package:\n\nChapter 1 is a ‘whole game’ for the development of a toy app-package. This chapter gives a high-level overview of the app-package development workflow.6\nIn Chapter 2 we’ll dive into shiny development, focusing on the files and folders found in most Shiny applications.\nR packages are introduced in Chapter 3, and it covers the differences between Shiny app projects, R packages, and Shiny app-packages.\nChapter 4 introduces devtools and the app-package development workflow.\n\nThe next section covers the primary elements of app-package development:\n\nChapter 5 covers documenting the application’s utility functions, modules, UI, server, and standalone app function using roxygen2.\nManaging dependencies (both imports and exports) using the NAMESPACE file is introduced in Chapter 6.\nChapter 7 discusses the storage, format, and documentation of data files your app-package.\nThere are multiple ways to launch an application from an app-package. Chapter 8 covers options to include in the app.R file and your standalone app function.\nChapter 9 covers the many uses of the inst/ folder in R packages. This chapter also covers how to add external files and resources to your application.\n\nWhile developing your application, you’ll want to ensure it’s features are documented and tested. The next five chapters cover testing:\n\nBefore running any tests we need to set up the test suite in our app-package. Chapter 10 briefly covers setting up the testing infrastructure with testthat.\nKnowing what features to implement and what tests to develop reduces the chances of writing code that doesn’t address a user needs. Chapter 11 discusses how to identify user specifications, features, and functional requirements. It also briefly introduces behavior-driven development.\nChapter 12 covers how to include testing tools (fixtures and helpers) in your test suite to ensure isolated yet controllable test conditions.\nReactivity makes testing modules tricky. In Chapter 13, I’ll cover some strategies and approaches for verifying that your modules are communicating correctly with Shiny’s testServer() function.\nChapter 14 introduces performing system (or end-to-end) tests in you app-package with the shinytest2 package.\n\nAfter you’ve developed your Shiny App-Package, you’ll want to deploy it (or put it ‘into production’).\n\nChapter 15 explains how build Docker images and containers using Docker desktop. These topics are also covered in Chapter 18.\nChapter 16 covers continuous integration (CI) / continuous deployment (CD) for Shiny app-packages using GitHub Actions.\nChapter 17 introduces tools to help keep your code base properly formatted and error free (lintr, styler and sinew).\n\nIf you’re Googling ‘what is the best way to build a Shiny application?’ you’ll eventually encounter a Shiny framework. This section contains the development workflow and methods for three popular Shiny application frameworks (golem, leprechaun, and rhino).\n\nChapter 18 covers developing an application using the golem framework.\nFor developers looking for a ‘lightweight’ version of the golem package, Chapter 19 introduces the leprechaun package and development workflow\nThe Chapter 20 covers how to build a rhino application (which is not technically a package, but is still worth including based on it’s popularity and features).\n\nTransitioning from programming in R to building Shiny applications and writing R packages is complicated. It involves a shift in focus, skill set, and development practices. Reactivity and modules are a steep learning curve, especially if you’re also trying to understand how to develop an R package (with an application in it!).7 8\nThe chapters of this book are intended to help with the package development end of that learning curve."
  },
  {
    "objectID": "intro.html#other-resources",
    "href": "intro.html#other-resources",
    "title": "Introduction",
    "section": "Other resources",
    "text": "Other resources\nExcellent resources have been written for Shiny, and it’s also worthwhile to consult the documentation on the core package development tools:\n\ndevtools\n\nusethis\n\nroxygen2"
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "The ‘Converting an existing app’ chapter provides an example of converting a Shiny app into an R Package. However, many of the helpful package development tools aren’t available (i.e., roxygen2 tags, NAMESPACE imports/exports, tests, vignettes, etc.).↩︎\nTesting Shiny apps requires additional packages and tools to ensure an application’s reliability and performance.↩︎\ngolem apps are built as packages. Still, EPGSA assumes the reader is ‘comfortable with building an R package.’ (if you’re familiar with package development, EPGSA is an excellent resource).↩︎\nDavid Neuzerling has a great post on the benefits of structuring your project as a package↩︎\nThe original code and data for the application in this book comes from the Building Web Applications with Shiny (BWAS) course.↩︎\nR Packages, 2ed, has a similar chapter that covers developing standard R packages.↩︎\nEngineering Production-Grade Shiny Apps and the golem package assumes readers “are comfortable with building an R package.”↩︎\nMastering Shiny includes an example for converting an existing application with usethis::use_description(), but not creating a new app-package (i.e., with usethis::create_package()).↩︎"
  },
  {
    "objectID": "whole_game.html#toy-app-package-monthapppkg",
    "href": "whole_game.html#toy-app-package-monthapppkg",
    "title": "1  Whole app game",
    "section": "1.1 Toy app-package: monthAppPkg",
    "text": "1.1 Toy app-package: monthAppPkg\nThe monthAppPkg example we’re going to be developing has been adapted from Mastering Shiny.2"
  },
  {
    "objectID": "whole_game.html#use_description",
    "href": "whole_game.html#use_description",
    "title": "1  Whole app game",
    "section": "1.2 use_description()",
    "text": "1.2 use_description()\nEvery package needs a DESCRIPTION–calling devtools::load_all() without a DESCRIPTION will result in an error. The quickest way to create a description file is with usethis::use_description().3\n\nusethis::use_description(\n  list(Package = 'monthAppPkg',\n       Title = 'An example app-pkg',\n       Version = '0.0.0.9000',\n       Description = 'A shiny application built inside an R package.',\n       \"Authors@R\" = NULL,\n       Author = utils::person(                     \n          given = \"Jane\", \n          family = \"Doe\", \n          role = c(\"aut\", \"cre\")),\n        Maintainer = utils::person(\n          given = \"Jane\", \n          family = \"Doe\",\n          email = \"Jane.Doeh@email.io\"),\n        License = \"GPL-3\"))\n\nI’ve provided values to the fields list so this file isn’t generated with the boilerplate contents. The documentation for use_description() mentions putting this in your .Rprofile if you develop a lot of R packages (or app-packages!).4\nEvery R package needs the following seven fields:\n\nPackage: monthAppPkg\nTitle: An example app-pkg\nVersion: 0.0.0.9000\nAuthor: Jane Doe [aut, cre]\nMaintainer: Jane Doe &lt;Jane.Doeh@email.io&gt;\nDescription: A shiny application built inside an R package.\nLicense: GPL-3\n1\n\n\n1\n\nAlways leave an empty final line in the DESCRIPTION\n\n\n\n\nWe get the following fields for free (they will be required for function documentation and dependency management).\n\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3"
  },
  {
    "objectID": "whole_game.html#use_data",
    "href": "whole_game.html#use_data",
    "title": "1  Whole app game",
    "section": "1.3 use_data()",
    "text": "1.3 use_data()\nTo include the stones data in monthAppPkg, we create a script in data-raw/ with usethis::use_data_raw(\"stones\"), then move the birthstones.csv file into data-raw/, load it into the Global Environment and pass it to usethis::use_data():\n\nusethis::use_data_raw(\"stones\")\n\n✔ Setting active project to '/path/to/monthAppPkg'\n✔ Creating 'data-raw/'\n✔ Adding '^data-raw$' to '.Rbuildignore'\n✔ Writing 'data-raw/stones.R'\n• Modify 'data-raw/stones.R'\n• Finish the data preparation script in 'data-raw/stones.R'\n• Use `usethis::use_data()` to add prepared data to package\nMove birthstones.csv to data-raw/birthstones.csv:\n\nfs::file_move(path = \"birthstones.csv\", new_path = \"data-raw/birthstones.csv\")\n\nContents of data-raw/stones.R:\n\n## code to prepare `stones` dataset goes here\nlibrary(vroom)\nstones &lt;- vroom::vroom(\"data-raw/birthstones.csv\")\nusethis::use_data(stones, overwrite = TRUE)\n\nRows: 12 Columns: 2                                                                                                                                \n── Column specification ──────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): month, stone\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nusethis::use_data(stones)\n\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Setting LazyData to 'true' in 'DESCRIPTION'\n✔ Saving 'stones' to 'data/stones.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nData should be documented using roxygen2,5 which we’ll cover in the data chapter."
  },
  {
    "objectID": "whole_game.html#use_package",
    "href": "whole_game.html#use_package",
    "title": "1  Whole app game",
    "section": "1.4 use_package()",
    "text": "1.4 use_package()\nEvery Shiny app-package will need to import the shiny package as a dependency, which starts by listing it under the Imports field the DESCRIPTION file. We can do this using usethis::use_package().6\n\nusethis::use_package(\"shiny\")\n\n✔ Adding 'shiny' to Imports field in DESCRIPTION\n• Refer to functions with `shiny::fun()`\nWe’re advised to use explicit namespacing (i.e., pkg::fun()), but we can avoid this by importing Shiny’s functions into our package namespace.\nThe @import tag from roxygen2 can be used to import “the entire [shiny] namespace” into monthAppPkg.7"
  },
  {
    "objectID": "whole_game.html#load_all",
    "href": "whole_game.html#load_all",
    "title": "1  Whole app game",
    "section": "1.5 load_all()",
    "text": "1.5 load_all()\nShiny app development typically involves something like the following workflow:\n\nWrite UI code\n\nWrite server code\n\nClick Run App\n\nRinse, repeat\n\nWhen making the switch to app-package development, calling load_all() is somewhat analogous to clicking on the Run App icon–you’ll do it often (more than any other devtools or usethis function).\n\ndevtools::load_all()\n\nThe output we’re looking for from load_all() is straightforward:\nℹ Loading monthAppPkg\nload_all() is similar to calling library, but it’s specifically designed to be used during package development."
  },
  {
    "objectID": "whole_game.html#use_r",
    "href": "whole_game.html#use_r",
    "title": "1  Whole app game",
    "section": "1.6 use_r()",
    "text": "1.6 use_r()\nCreate new .R files under R/ using use_r():\n\nusethis::use_r(\"monthFeedback\")\n\n✔ Setting active project to '/projects/apps/monthAppPkg'\n• Modify 'R/monthFeedback.R'\nBoth UI and server module functions are stored in R/monthFeedback.R and R/birthstone.R. Tests should also be created for each function."
  },
  {
    "objectID": "whole_game.html#use_test",
    "href": "whole_game.html#use_test",
    "title": "1  Whole app game",
    "section": "1.7 use_test()",
    "text": "1.7 use_test()\nCreate new test- files under tests/testthat/ using using use_test():\n\nusethis::use_test(\"monthFeedbackServer\")\n\nThe first time you run use_test(), it will detect if your package has the testthat infrastructure (and create the necessary files if you don’t).8\nCalling use_test() adds the testthat package to the Suggests field in the DESCRIPTION and includes the edition (currently 3).\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\nThe tests/ folder will hold the necessary testing folder and files:\n\ntests/\n├── testthat/\n│   ├── test-birthstoneServer.R\n│   └── test-monthFeedbackServer.R\n└── testthat.R\n\n2 directories, 3 files\n\nTests are covered in Mastering Shiny,9 on the Shiny website,10 and in various testing packages (like shinytest11 and shinytest212)"
  },
  {
    "objectID": "whole_game.html#app.r-contents",
    "href": "whole_game.html#app.r-contents",
    "title": "1  Whole app game",
    "section": "1.8 app.R contents",
    "text": "1.8 app.R contents\nThe contents of app.R have been converted to a standalone app function (monthApp()), which is stored in the R/ folder.\nThe new contents of app.R includes a call to pkgload::load_all() and monthApp():\n\npkgload::load_all(\".\")\nmonthApp()\n\npkgload needs to be listed under Imports in the DESCRIPTION file (just like we did with shiny above).\n\nusethis::use_package(\"pkgload\")\n\n✔ Adding 'pkgload' to Imports field in DESCRIPTION\n• Refer to functions with `pkgload::fun()`\nBecause we’re only going to use load_all() from pkgload, we’ll use explicit namespacing (i.e., pkg::fun()).13\n\n1.8.1 use_package_doc()\nThe use_package_doc() creates the R/[[name]-package].R file, which can be used as a single location for declaring dependencies in monthAppPkg:\n\nusethis::use_package_doc()\n\n✔ Setting active project to 'projects/apps/monthAppPkg'\n✔ Writing 'R/monthAppPkg-package.R'\n• Modify 'R/monthAppPkg-package.R'\nWe’ll use @importFrom to add only the load_all() function to the NAMESPACE.\n\n#' @keywords internal\n\"_PACKAGE\"\n\n## usethis namespace: start\n#' @importFrom pkgload load_all\n## usethis namespace: end\nNULL\n\n\n\n1.8.2 use_build_ignore()\nR packages don’t typically have an app.R file in their root folder, so we’ll let devtools know this file should be ignored by creating a .Rbuildignore and include a pattern that excludes app.R whenever the package is built.\n\nusethis::use_build_ignore(\"app.R\")\n\n✔ Adding '^app\\\\.R$' to '.Rbuildignore'\nIt’s best to let use_build_ignore() handle excluding any files or folders from your package builds because it automatically writes the correct regular expression pattern."
  },
  {
    "objectID": "whole_game.html#license",
    "href": "whole_game.html#license",
    "title": "1  Whole app game",
    "section": "1.9 LICENSE",
    "text": "1.9 LICENSE\nIncluding a LICENSE file can be done with one of the usethis license functions. The license file should match the License field in the DESCRIPTION file (in this case, it’s MIT).\n\nusethis::use_mit_license()\n\nuse_mit_license() will automatically include the LICENSE.md file in the root folder (and includes the necessary pattern in the .Rbuildignore to exclude it from the package builds).\n✔ Adding 'MIT + file LICENSE' to License\n✔ Writing 'LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'"
  },
  {
    "objectID": "whole_game.html#document",
    "href": "whole_game.html#document",
    "title": "1  Whole app game",
    "section": "1.10 document()",
    "text": "1.10 document()\nAll of the files below R/ should include roxygen2 documentation. You can include an Roxygen skeleton in the IDE by clicking on Code &gt; Insert Roxygen Skeleton, or using the keyboard shortcut:\nOption/⌥ + Shift⇧ + Ctrl/Cmd + R\nAfter writing the documentation for the data, modules, and standalone app function, calling devtools::document()() generates the .Rd files and NAMESPACE\n\ndevtools::document()\n\nThe output from document() tells us what files have been created (and if there were any errors in them).14\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nWriting NAMESPACE\nWriting NAMESPACE\nWriting birthstoneUI.Rd\nWriting birthstoneServer.Rd\nWriting monthApp.Rd\nWriting monthFeedbackUI.Rd\nWriting monthFeedbackServer.Rd\n\n1.10.1 NAMESPACE\nThe NAMESPACE file contains the exported functions from monthAppPkg, and the two imports (shiny and pkgload::load_all()):\n# Generated by roxygen2: do not edit by hand\n\nexport(birthstoneServer)\nexport(birthstoneUI)\nexport(monthApp)\nexport(monthFeedbackServer)\nexport(monthFeedbackUI)\nimport(shiny)\nimportFrom(pkgload,load_all)"
  },
  {
    "objectID": "whole_game.html#project-options",
    "href": "whole_game.html#project-options",
    "title": "1  Whole app game",
    "section": "1.11 Project options",
    "text": "1.11 Project options\nIn order to enable the Build pane and keyboard shortcuts in the IDE, we need to update our .Rproj file. We can edit this file using file.edit():\n\nfile.edit(\"monthAppPkg.Rproj\")\n\nIf monthAppPkg was initially built as an RStudio project (i.e., not as a package), the following fields should be included at the bottom of monthAppPkg.Rproj:\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\nThese options are also available under Tools &gt; Project Options … &gt; Build Tools"
  },
  {
    "objectID": "whole_game.html#use_git",
    "href": "whole_game.html#use_git",
    "title": "1  Whole app game",
    "section": "1.12 use_git()",
    "text": "1.12 use_git()\nuse_git() is performed much earlier in R Packages, 2ed, but I’ve saved it for this step because using Git will prompt the IDE to re-initialize and display the Git pane (and it will also read our new settings in the .Rproj file).\n✔ Setting active project to '/projects/apps/monthAppPkg'\n✔ Initialising Git repo\n✔ Adding '.Rproj.user', '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\nThere are 12 uncommitted files:\n* '.gitignore'\n* '.Rbuildignore'\n* 'app.R'\n* 'data/'\n* 'DESCRIPTION'\n* 'LICENSE'\n* 'LICENSE.md'\n* 'man/'\n* 'monthAppPkg.Rproj'\n* 'NAMESPACE'\n* ...\nIs it ok to commit them?\n\n1: Absolutely not\n2: Not now\n3: Absolutely\nWe’ll agree to commit these files to Git:\nSelection: 3\n✔ Adding files\n✔ Making a commit with message 'Initial commit'\n• A restart of RStudio is required to activate the Git pane\nRestart now?\n\n1: Not now\n2: Negative\n3: Absolutely\nRestarting RStudio will activate the Git and Build panes:\n\n\n\nGit Pane\n\n\n\n\n\nBuild Pane\n\n\nThis will also activate the devtools keyboard shortcuts:\n\n1.12.1 devtools keyboard shortcuts\n\n\n\n1.12.1.1 load_all()\nShift + Ctrl/Cmd + L\n\n\n1.12.1.2 document()\nShift + Ctrl/Cmd + D\n\n\n\n\n1.12.1.3 install()\nShift + Ctrl/Cmd + B\n\n\n1.12.1.4 test()\nShift + Ctrl/Cmd + T"
  },
  {
    "objectID": "whole_game.html#install-1",
    "href": "whole_game.html#install-1",
    "title": "1  Whole app game",
    "section": "1.13 install()",
    "text": "1.13 install()\nNow we’re ready to install monthAppPkg with devtools::install(), which produces see the following output in the Build pane:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nDocumentation completed\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source monthAppPkg\n\n* installing to library ‘/path/to/Library/R/x86_64/4.2/library’\n* installing *source* package ‘monthAppPkg’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (monthAppPkg)\nBack in the Console, RStudio will restart and call library(monthAppPkg):\nRestarting R session...\n\n&gt; library(monthAppPkg)\nWe can now launch the app using monthApp()\n\nmonthApp()\n\n\n\n\nOur monthApp() application\n\n\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 01_whole-app-game branch of moviesApp."
  },
  {
    "objectID": "whole_game.html#additional-files",
    "href": "whole_game.html#additional-files",
    "title": "1  Whole app game",
    "section": "1.14 Additional files",
    "text": "1.14 Additional files\nThe following sections cover additional files you should include in your ap-package (but are not required).\n\n1.14.1 use_readme_rmd()\nThe README.md file is usually the initial point of contact for users and contributors looking for information about your app-package. use_readme_rmd() will create a README.Rmd (i.e., the file you’ll edit), which serves as the source document for your README.md.\n\nusethis::use_readme_rmd()\n\nThe README.Rmd pattern is automatically added to the .Rbuildignore, and includes a Git ‘pre-commit’ hook:\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n✔ Writing '.git/hooks/pre-commit'\nThis Git behavior is designed to prevent us from making changes to the README.Rmd and forgetting to re-render the README.md. If you find this behavior confusing or would like to disable it, run the following commands in the Terminal:\n\nrm .git/hooks/pre-commit\n\n\n\n1.14.2 use_news_md()\nA NEWS.md is helpful for logging updates to your app-package and tracking release information.\n\nusethis::use_news_md()\n\nuse_news_md() will also prompt me to add and commit this file to the Git repository:\nThere is 1 uncommitted file:\n* 'NEWS.md'\nIs it ok to commit it?\n\n1: Negative\n2: Yeah\n3: Absolutely not\n\nSelection: 2\n✔ Adding files\n✔ Making a commit with message 'Add NEWS.md'\nThe contents of the NEWS.md are below:\n# monthAppPkg (development version)\n\n* Initial CRAN submission.\nThe 2nd bullet doesn’t apply to monthAppPkg, so I’ll remove it and re-commit/push the NEWS.md file.\n\n\n1.14.3 use_vignette()\nVignettes can be used to store detailed tutorials, explanations of core concepts, use-cases, FAQs and troubleshooting, integration with other packages, etc.\n\nuse_vignette(\"monthAppPkg\")\n\nThe first time we call use_vignette() will prompt usethis to add the following fields in the DESCRIPTION:\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Adding 'knitr' to VignetteBuilder\nThe following files are also included in the .gitignore:\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'"
  },
  {
    "objectID": "whole_game.html#footnotes",
    "href": "whole_game.html#footnotes",
    "title": "1  Whole app game",
    "section": "",
    "text": "The example app comes from the Packages chapter of Mastering Shiny↩︎\nI’ve stored the code for this application in the 01_whole-app-game branch of the moviesApp repository (to avoid confusing it with the actual application repo for this chapter).↩︎\nThe Whole Game chapter of R Packages, 2ed begins with the usethis::create_package() function, which calls usethis::use_description() internally.↩︎\nAt the time this was written, there are over 4,000 hits with the boilerplate value for Description (i.e., \"What the package does\"), which is a sign of how much usethis has been adopted (and how often people forget to come back and edit their DESCRIPTION file).↩︎\nView the documented stones dataset here on GitHub.↩︎\nWhenever you use a function from another package, start by running usethis::use_package() to ensure it’s in the DESCRIPTION file.↩︎\nI’ve included @import shiny above the definition of our standalone app function (R/movies_app.R), which means I don’t need to add shiny:: when using Shiny functions belowR/.↩︎\nYou can also set up the testthat infrastructure by calling usethis::use_testthat()↩︎\nThe Testing chapter in Mastering Shiny covers unit tests with testthat, shiny::testServer(), and the shinytest package.↩︎\nSee the ‘Server Function Testing’ article on the Shiny website for more information on testServer()↩︎\nCheck the shinytest package website and video tutorial for more information on testing your app.↩︎\nshinytest2 is an updated verison of shinytest with excellent documentation and videos.↩︎\nWe typically call devtools::load_all(), but using pkgload reduces the number of dependencies included with devtools. Read more about pkgload in the ‘Conscious uncoupling’ of devtools.↩︎\nThe files created by document() rely on the roxygen2 package (and should not be edited manually).↩︎"
  },
  {
    "objectID": "shiny.html#sec-shiny-projects",
    "href": "shiny.html#sec-shiny-projects",
    "title": "2  Shiny",
    "section": "2.1 Shiny apps",
    "text": "2.1 Shiny apps\nReactivity is the underlying process that allows Shiny apps to update and respond to user interactions automatically. Developing Shiny apps involves harnessing the connection between inputs, reactivity, and outputs to control and predict the application’s behavior.\nShiny programming differs from regular R programming in several key aspects:\n\nAn Event-driven UI: Shiny apps require developers to design and develop a user interface (UI). User experience (UX) design is an entirely separate field, but as Shiny developers, we need to know enough to allow users to interact with and navigate our apps. The UI also captures each ‘event,’ meaning that the user’s actions (such as button clicks or input changes) trigger the application’s inputs, updates, or outputs.\n\nRegular R programming often involves executing predefined steps or functions without direct interaction or responses to user events.\n\nA Reactive Server: In Shiny, the application’s behavior is determined by the dependencies between reactive inputs (i.e., the inputIds), reactive values, and outputs (i.e., the outputIds), allowing for automatic updates and propagation of changes throughout the application.\n\nIn standard R programming, we typically define a series of sequential steps (i.e., functions) that operate on data to generate output to the console or a typesetting system for technical and scientific publications (model results, graphs, tables, etc.) without accounting for reactivity or downstream changes.\n\n\nLearning reactivity can be challenging when you start, but fortunately, there are excellent tutorials and articles to help you along the way!\n\n\nLaunch app with the shinypak package:\n\nlaunch('02.1_shiny-app')\n\nIf you’re creating a new application using the New Project Wizard, you’ll see the following:\n\n\n\n\n\n(a) New Shiny app\n\n\nFigure 2.1: New Shiny app project\n\n\nSelect the location of your Shiny app project, then pick a name and decide whether you want to use Git or renv (I’ll be using Git).\n\n\n\n\n\n(a) Shiny app info\n\n\nFigure 2.2: New Shiny app project in a Git repository\n\n\nAfter clicking Create Project, a new session will open with your project files.\nNote that the only items in the new Shiny app project are app.R and the moviesApp.Rproj file.\n\nmoviesApp/\n    ├── app.R\n    └── moviesApp.Rproj\n\n1 directory, 2 files\n\n\n2.1.1 Boilerplate app.R\napp.R initially contains a boilerplate application, which we can launch by clicking on the Run App button:\n\n\n\n\n\nClick on Run App\n\n\n\n\n\n\n\n(a) Old Faithful geyser app\n\n\nFigure 2.3: Boilerplate Old Faithful geyser app in new Shiny projects\n\n\nThe boilerplate ‘Old Faith Geyser Data’ app is a perfect example of what Shiny can do with a single app.R file, but we’ll want to exchange this code for a slightly more advanced application (because most Shiny apps grow beyond an app.R file)."
  },
  {
    "objectID": "shiny.html#sec-introduce-movie-review-app",
    "href": "shiny.html#sec-introduce-movie-review-app",
    "title": "2  Shiny",
    "section": "2.2 Movie review data app",
    "text": "2.2 Movie review data app\nMost Shiny applications move beyond a single app.R file. Knowing how to store any utility functions, data, documentation, and metadata will set you up for success as you transition to storing your app in an R package.\n\n\nLaunch app with the shinypak package:\n\nlaunch('02.2_movies-app')\n\nI’m going to work through an example of some intermediate/advanced Shiny app features using the application from the Building Web Applications with Shiny course. This app is a great use case for the following reasons:\n\nIt has multiple input types that are collected in the UI\nThe graph output can be converted to a utility function\nThe app loads an external data file when it’s launched\nThe code is accessible (and comes from a trusted source)\n\n\n2.2.1 App\nThe code below replaces the boilerplate ‘Old Faith Geyser Data’ app in app.R:\n\n2.2.1.1 app.R\n\n\nshow/hide movie review Shiny app\nui &lt;- shiny::fluidPage(\n  theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\n        \"The data represent\",\n        nrow(movies),\n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"\n      ),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n      shiny::p(shiny::em(\n        \"The code for this Shiny application comes from\",\n        shiny::a(\"Building Web Applications with shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"\n        )\n      ))\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- shiny::reactive({\n    tools::toTitleCase(input$plot_title)\n  }) |&gt;\n    shiny::bindEvent(input$update_plot_title,\n      ignoreNULL = FALSE,\n      ignoreInit = FALSE\n    )\n\n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n      df = movies,\n      x_var = input$x,\n      y_var = input$y,\n      col_var = input$z,\n      alpha_var = input$alpha,\n      size_var = input$size\n    ) +\n      ggplot2::labs(title = new_plot_title()) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\n\n2.2.2 Additional files\nI’ve added the scatter_plot() utility function in a new utils.R file:\n\n2.2.2.1 utils.R\n\n\nshow/hide scatter_plot()\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n2.2.2.2 movies.RData\nThe movies.RData dataset contains reviews from IMDB and Rotten Tomatoes\nYou can download these data here\n\n\n\n2.2.3 Updated movies app project contents\nThe moviesApp project now contains the following files:\n\nmoviesApp/\n  ├── app.R\n  ├── movies.RData\n  ├── moviesApp.Rproj\n  └── utils.R\n\n2 directories, 4 files\n\nTo run the movies app, we need to load the data and source the utils.R file by adding the code below to the top of the app.R file:\nAfter installing the packages below, add a comment (#) in front of these lines.\nI’ve placed the header below in the top of the app.R file:\n\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# data -----------------------------------------\nload(\"movies.RData\")\n\n# utils ----------------------------------------\nsource(\"utils.R\")\n\n\n1\n\nComment out these lines after installing pkgs\n\n\n\n\nClicking on Run App displays the movie review app:\n\n\n\n\n\n\n(a) movies app\n\n\nFigure 2.4: Movie review app"
  },
  {
    "objectID": "shiny.html#sec-shiny-folders",
    "href": "shiny.html#sec-shiny-folders",
    "title": "2  Shiny",
    "section": "2.3 Project folders",
    "text": "2.3 Project folders\nNow that we have a slightly more complex application in app.R, I’ll add a few project folders we can include in our project that have unique built-in behaviors. These folders will help organize your files and make additional resources available to your app.\n\n\nLaunch app with the shinypak package:\n\nlaunch('02.3_proj-app')\n\n\n2.3.1 R/\nIf your Shiny app relies on utility or helper functions (outside the app.R file), you can place this code in an R/ folder. Any .R files in the R/ folder will be automatically sourced when the application is run.\n\n\n\n\n\n\nPlace utils.R in R/ folder\n\n\n\n\n\nI’ve moved the utils.R file into the R/ folder in moviesApp:\n\nmoviesApp/\n     └── R/\n         └── utils.R\n\n1 directory, 1 file\n\n\n\n\nThe function that makes this process (i.e., sourcing any .R files in an R/ folder) possible is loadSupport(). We’ll return to this function in a later chapter, because the R/ folder has a similar behavior (but different function) in R packages.1\n\n\n2.3.2 www/\nWhen you run a Shiny application, any static files (i.e., resources) under a www/ directory will automatically be made available within the application. This folder stores images, CSS or JavaScript files, and other static resources.\n\n\n\n\n\n\nCreate www/ folder and download image\n\n\n\n\n\nI’ve downloaded the Shiny logo (shiny.png) and stored it in the www/ folder.\n\nmoviesApp/\n     └── www/\n           └── shiny.png\n\n1 directory, 1 file\n\nIn the section below, we’ll reference shiny.png directly in the UI.\n\n\n\nFollowing the conventional folder structure will also help set you up for success when/if you decide to convert it into an app-package."
  },
  {
    "objectID": "shiny.html#sec-shiny-files",
    "href": "shiny.html#sec-shiny-files",
    "title": "2  Shiny",
    "section": "2.4 Project files",
    "text": "2.4 Project files\n\n2.4.1 README.md\nIncluding a README.md file in your root folder is a good practice for any project. README.md should contain relevant documentation for running app.R.\n\n\n\n\n\n\nCreate README.md\n\n\n\n\n\nI’ve included the content below in the README.md file\n# movies app\n\nThe original code and data for this Shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`moviesApp` branches](https://github.com/mjfrigaard/moviesApp/branches/all).\n\n\n\n\n\n2.4.2 DESCRIPTION\nDESCRIPTION files play an essential role in R packages, but they are also helpful in Shiny projects if I want to deploy the app in showcase mode.\n\n\n\n\n\n\nCreate DESCRIPTION\n\n\n\n\n\nI’ve included the content below in DESCRIPTION:\n\nType: shiny\nTitle: movies app\nAuthor: John Smith\nDisplayMode: Showcase                                                 \n                                                                      \n\n\n\n\n\n\n\nIt’s always a good idea to leave at least one &lt;empty final line&gt; in your DESCRIPTION file.\n\nAfter adding README.md and a DESCRIPTION file (listing DisplayMode: Showcase), the movies app will display the code and documentation when the app launches.2"
  },
  {
    "objectID": "shiny.html#sec-shiny-code-files",
    "href": "shiny.html#sec-shiny-code-files",
    "title": "2  Shiny",
    "section": "2.5 Project code",
    "text": "2.5 Project code\nThe following two items are considered best practices because they make your app more scalable by converting app.R into functions.\n\n2.5.1 Modules\nShiny modules are a ‘pair of UI and server functions’ designed to compartmentalize input and output IDs into distinct namespaces,\n\n‘…a namespace is to an ID as a directory is to a file…’ - shiny::NS() help file.\n\nModule UI functions typically wrap the layout, input, and output functions in shiny::tagList(). Module server functions typically contain the ‘backend’ code in a Shiny server function. Both the UI and server module functions are linked by an id argument, which is created using shiny::NS() (namespace) in the UI function and called in the server function with shiny::moduleServer().\n\n2.5.1.1 Variable inputs module\nmod_var_input_ui() creates a dedicated namespace for the inputIds with shiny::NS():\n\n2.5.1.1.1 R/mod_var_input.R\n\n\nshow/hide mod_var_input_ui()\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n1      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n2      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n3      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n4      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n5      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n6      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\nmod_var_input_server() returns these values in a reactive list with shiny::reactive():\n\n\nshow/hide mod_var_input_server()\nmod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n1            \"y\" = input$y,\n2            \"x\" = input$x,\n3            \"z\" = input$z,\n4            \"alpha\" = input$alpha,\n5            \"size\" = input$size,\n6            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\n\n\n\n2.5.1.2 Scatter-plot display module\nmod_scatter_display_ui() creates a dedicated namespace for the plot outputId (as \"scatterplot\"), along with some help text:\n\n2.5.1.2.1 R/mod_scatter_display.R\n\n\nshow/hide mod_scatter_display_ui()\nmod_scatter_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\"The data for this application comes from the \",\n        shiny::tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))\n      ),\n1    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n1\n\nNamespaced module id for plot in UI\n\n\n\n\nThe code to render the output$scatterplot is contained in the nested call to shiny::moduleServer() in mod_scatter_display_server():\nAfter 1) loading the movies data, 2) assembling the returned values from mod_var_input_server(), and creating the input() reactive, 3) the scatter_plot() utility function creates the plot object and adds the plot_title() and theme:\n\n\nshow/hide mod_scatter_display_server()\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    \n1    load(\"movies.RData\")\n\n2    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n3    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n4      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(\n                  tools::toTitleCase(\n                      inputs()$x),\n                  \"_\", \" \"),\n          y = stringr::str_replace_all(\n                  tools::toTitleCase(\n                    inputs()$y),\n                \"_\", \" \")\n        ) + \n5        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n1\n\nloading the movies data\n\n2\n\nassembling the returned values from mod_var_input_server(), and creating the input() reactive\n\n3\n\nscatter_plot() utility function creates the plot object\n\n4\n\nadds the plot_title()\n\n5\n\nadd theme to layers\n\n\n\n\nBoth UI and server module functions are combined into a single .R file, and all modules are placed in the R/ folder so they are sourced when the application is run.\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n └── utils.R\n\n\n\n\n\n2.5.2 Standalone app function\nBoth module functions are combined in the ui and server arguments of shiny::shinyApp(). The id arguments (\"vars\" and \"plot\") connect the UI functions to their server counterparts, and the output from mod_var_input_server() is the var_inputs argument in mod_scatter_display_server().\nThe call to shiny::shinyApp() is wrapped in the movies_app() function and placed in app.R.\n\n2.5.2.0.1 app.R\n\n\nshow/hide movies_app() in app.R\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\n2library(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nmovies_app &lt;- function() { \n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n3          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n4          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n5      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n6      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nmovies_app()\n\n\n\n1\n\nHeader (comment this out after the packages are installed)\n\n2\n\nLoad packages\n\n\n3\n\nVariable input UI module\n\n4\n\nGraph display UI module\n\n5\n\nVariable input server module\n\n6\n\nGraph display server module\n\n\n\n\nNow, I can run the app with movies_app().\n\n\n\n\n\n\n(a) Movie reviews app\n\n\nFigure 2.5: View a deployed version here.\n\n\n\nThe deployed files of moviesApp are below:\n\nmoviesApp/ # 02.3_proj-app branch\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── moviesApp.Rproj\n├── rsconnect/\n│   └── shinyapps.io/\n│       └── user/\n│           └── moviesApp.dcf\n└── www/\n    └── shiny.png\n\n6 directories, 10 files\n\n\n\nThe rsconnect/ folder has been removed from the 02.3_proj-app branch."
  },
  {
    "objectID": "shiny.html#sec-adv-shiny-projects",
    "href": "shiny.html#sec-adv-shiny-projects",
    "title": "2  Shiny",
    "section": "2.6 Additional features",
    "text": "2.6 Additional features\nBelow are two additional ‘optional’ features that can be included with your Shiny application (I consider these ‘optional’ because they’re use depends on the specific needs and environment for each application).\n\n2.6.1 Global variables/functions with global.R\nPlacing a global.R file in your root folder (or in the R/ directory) causes this file to be sourced only once when the Shiny app launches, rather than each time a new user connects to the app. global.R is commonly used for initializing variables, loading libraries, loading large data sets and/or performing initial calculations.\n\n\n\n\n\n\nUsing global.R\n\n\n\n\n\nI could place the header from app.R in global.R to ensure these packages are loaded before the application launches:\n\n\nshow/hide contents of R/global.R\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n\nglobal.R can be placed in the R/ folder\n\nR/\n├── global.R\n├── mod_scatter_display.R\n├── mod_var_input.R\n└── utils.R\n\n1 directory, 4 files\n\nOr in the project root folder\n\n├── DESCRIPTION\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── global.R\n├── man\n├── movies.RData\n├── moviesApp.Rproj\n└── www\n    └── shiny.png\n\n4 directories, 10 files\n\nIn both locations, it will be sourced before launching the application.\n\n\n\nglobal.R can be used to maintain efficiency and consistency across application sessions.\n\n\n2.6.2 Project dependencies with renv\nIf you use renv, keep track of your dependencies by regularly running renv::status() and renv::snapshot().\n\n\n\n\n\n\nUsing renv\n\n\n\n\n\nStart by initiating renv with renv::init(), then run renv::status() to check which packages have been added to the lockfile:\n\nrenv::status()\n\n\n\nshow/hide example renv::status() output\nThe following package(s) are in an inconsistent state:\n\n package      installed recorded used\n colorspace   y         n        y   \n fansi        y         n        y   \n farver       y         n        y   \n ggplot2      y         n        y   \n gtable       y         n        y   \n isoband      y         n        y   \n labeling     y         n        y   \n lattice      y         n        y   \n MASS         y         n        y   \n Matrix       y         n        y   \n mgcv         y         n        y   \n munsell      y         n        y   \n nlme         y         n        y   \n pillar       y         n        y   \n pkgconfig    y         n        y   \n RColorBrewer y         n        y   \n scales       y         n        y   \n shinythemes  y         n        y   \n tibble       y         n        y   \n utf8         y         n        y   \n vctrs        y         n        y   \n viridisLite  y         n        y   \n\n\nTake a ‘snapshot’ to capture the current package dependencies:\n\nrenv::snapshot()\n\n\n\nshow/hide example renv::snapshot() output\nThe following package(s) will be updated in the lockfile:\n\n# CRAN --------------------------------------------------\n- lattice        [* -&gt; 0.21-8]\n- MASS           [* -&gt; 7.3-60]\n- Matrix         [* -&gt; 1.5-3]\n- mgcv           [* -&gt; 1.8-42]\n- nlme           [* -&gt; 3.1-162]\n- vctrs          [* -&gt; 0.6.3]\n\n# RSPM --------------------------------------------------\n- colorspace     [* -&gt; 2.1-0]\n- fansi          [* -&gt; 1.0.4]\n- farver         [* -&gt; 2.1.1]\n- ggplot2        [* -&gt; 3.4.2]\n- gtable         [* -&gt; 0.3.3]\n- isoband        [* -&gt; 0.2.7]\n- labeling       [* -&gt; 0.4.2]\n- munsell        [* -&gt; 0.5.0]\n- pillar         [* -&gt; 1.9.0]\n- pkgconfig      [* -&gt; 2.0.3]\n- RColorBrewer   [* -&gt; 1.1-3]\n- scales         [* -&gt; 1.2.1]\n- shinythemes    [* -&gt; 1.2.0]\n- tibble         [* -&gt; 3.2.1]\n- utf8           [* -&gt; 1.2.3]\n- viridisLite    [* -&gt; 0.4.2]\n\nDo you want to proceed? [Y/n]: y\n\n- Lockfile written to '~/path/to/moviesApp/renv.lock'."
  },
  {
    "objectID": "shiny.html#recap",
    "href": "shiny.html#recap",
    "title": "2  Shiny",
    "section": "2.7 Recap",
    "text": "2.7 Recap\nThis chapter has covered some differences between developing Shiny apps and regular R programming, creating new Shiny projects in Posit Workbench, and some practices to adopt that can make the transition to app-packages a little easier. The code used in this chapter is stored in the moviesApp repository.\n\n\n\n\n\n\nRecap\n\n\n\n\n\n\n\nPlacing utility or helper files in an R/ folder removes the need to call source() in app.R.\nImages, CSS, JavaScript, and other static resources can be stored in www/ and Shiny will serve these files when the application is run.\nREADME.md files can document the application’s description, purpose, requirements, etc.\nDESCRIPTION files provide metadata and include fields that affect application deployment (i.e., DisplayMode: Showcase)\nConverting the application code into functions (modules and standalone app functions) creates a ‘division of labor’ for each component, which makes it easier to think about and work on them independently.\nFinally, if you’re using renv, run renv::status() and renv::snapshot() to manage dependencies\n\n\n\n\n\nIn the next chapter, I’ll cover what makes a package a package, and some do’s and don’ts when converting a developed Shiny application into an R package."
  },
  {
    "objectID": "shiny.html#footnotes",
    "href": "shiny.html#footnotes",
    "title": "2  Shiny",
    "section": "",
    "text": "Shiny introduced these features in version 1.3.2.9001, and you can read more about them in the section titled, ‘The R/ directory’ in App formats and launching apps↩︎\nRead more about showcase mode here↩︎"
  },
  {
    "objectID": "packages.html#r-packages",
    "href": "packages.html#r-packages",
    "title": "3  Packages",
    "section": "3.1 R packages ",
    "text": "3.1 R packages \nR packages can be easily shared, reused, and reproduced because they all have a familiar structure, and each folder and file plays an essential role in extending R’s capabilities.2\nBelow is a folder tree with some of the typical files and folders found in R packages:\n\n&lt;R package&gt;/\n    ├── DESCRIPTION\n    ├── &lt;R package&gt;.Rproj\n    ├── LICENSE \n    ├── LICENSE.md \n    ├── NAMESPACE \n    ├── NEWS.md\n    ├── README.Rmd\n    ├── README.md\n    ├── renv.lock\n    ├── R/\n    ├── man/\n    ├── tests/\n    ├── data/ \n    ├── data-raw/ \n    ├── vignettes/ \n    ├── inst/ \n    └── renv/\n  \n\nThis chapter will cover the minimum requirements for an R package, so you can handle both creating new Shiny app-packages and converting existing Shiny projects into Shiny app-packages.\n\n3.1.1 Functional R packages\nIf you’ve done some research on R packages, you’ve probably encountered one (or both) of the following statements,\n\n‘RStudio [Posit Workbench] and devtools consider any directory containing DESCRIPTION to be a package’ - R Packages, 2ed (Chapter 9, DESCRIPTION)\n‘all a project needs to be a package is a directory of R/ files and a DESCRIPTION file.’ - Mastering Shiny (Chapter 20, Packages)\n\nThe moviesApp directory has:\n\n\n\n\n\n\nan .Rproj project file\na DESCRIPTION file\nan R/ directory\n\n\n\nmoviesApp/\n1├── DESCRIPTION\n2├── moviesApp.Rproj\n3├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n└── www/\n    └── shiny.png\n\n4 directories, 9 files\n\n\n1\n\nDESCRIPTION file\n\n\n2\n\n.Rproj file\n\n\n3\n\nR/ folder with .R files\n\n\n\n\n\n\nSo, is moviesApp a functioning R package?\n\n3.1.1.1 Can we load it with devtools?\nPackage development kicks off with the load_all() function from devtools, which is similar to calling library() (we’ll cover this function extensively in the devtools chapter).\nHowever, when we attempt to load the code in the R/ folder with load_all(), we see the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n(a) Load All Error\n\n\nFigure 3.1: devtools is looking for the Package field in our DESCRIPTION file\n\n\n\n\n3.1.1.2 Can we use the Build pane?\nFunctioning R packages also have access to the Build pane, which allows us to quickly load, install, and test code.\nWhen we open moviesApp, the Build pane is not displayed in the IDE:\n\n\n\n\n\n(a) moviesApp IDE\n\n\nFigure 3.2: The Build pane is normally between Connections and Git.\n\n\nAs we’ve just learned, the presence of the DESCRIPTION file and an R/ folder are insufficient to turn a Shiny app project into a functioning R package that can be installed and loaded into an R session and has access to the Build pane in the IDE.\n\n“A project needs a DESCRIPTION file with specific fields, a directory of R/ files, and a properly configured .Rproj file to be a functioning R package.”\n\nLet’s see how each of these requirements work together to convert the contents of moviesApp from a Shiny project into a Shiny app-package.\n\n\n3.1.2 DESCRIPTION\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.1_description')\n\nThe official R documentation3 lists the following required fields for the DESCRIPTION in R packages:\n\nThe ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and ‘Maintainer’ fields are mandatory.\n\nBelow is an example DESCRIPTION file for moviesApp with the mandatory fields:4\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\n\n\n\n\nAuthor and Maintainer fields\n\n\n\n\n\nNote that the Author and Maintainer fields require additional information beyond first and last name (i.e., John Smith). These can be created with the utils::person() function:\n\n# Author\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  role = c(\"aut\", \"cre\"))\n## [1] \"John Smith [aut, cre]\"\n# Maintainer\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  email = \"John.Smith@email.io\")\n## [1] \"John Smith &lt;John.Smith@email.io&gt;\"\n\n\n\n\nAfter adding the mandatory fields to the DESCRIPTION file, devtools::load_all() runs without the previous error, but the IDE still doesn’t display the Build pane:\n\n\n\n\n\n\n(a) moviesApp IDE\n\n\nFigure 3.3: Where is the Build pane?"
  },
  {
    "objectID": "packages.html#r-projects",
    "href": "packages.html#r-projects",
    "title": "3  Packages",
    "section": "3.2 R Projects ",
    "text": "3.2 R Projects \n.Rproj files are plain text files with various settings for the IDE. We were able to run devtools::load_all() above without the presence of the Build pane because the IDE displays the Build pane after reading the fields in the .Rproj file.\nThe quickest way to access the fields in the .Rproj file is under Tools &gt; Project Options….\n\n3.2.1 R Project options\nTools &gt; Project Options… provide access to the project-level options. For example, fields 2 - 4 are available under General, 5 - 8 affect the Code options, and the final two fields deal with Sweave.\n\n\n\n\n\n(a) moviesApp.Rproj fields\n\n\nFigure 3.4: Field settings from moviesApp.Rproj file\n\n\nThe default settings were created when we selected the Shiny app project from the New Project Wizard in the last chapter.\n\n\n3.2.2 Build tools\nI’ve placed the .Rproj file from moviesApp with the example .Rproj file from R Packages, (2ed) side-by-side so you can compare them below:5\n\n\n\n\n\n(a) .Rproj files\n\n\nFigure 3.5: Comparison of moviesApp.Rproj file and .Rproj file in R Packages, 2ed\n\n\nI’ve circled the fields in the .Rproj file that illustrate it’s configured to work with an R package. Note that in moviesApp, the Project build tools are initially set to (None) under Build Tools:\n\n\n\n\n\n(a) moviesApp.Rproj build tools\n\n\nFigure 3.6: Build tool settings in moviesApp.Rproj file\n\n\nChanging the Project build tools option to Package will set the default Build Tools options:6\n\n\n\n\n\n(a) Default package build tools\n\n\nFigure 3.7: Default build tool settings\n\n\nThe links between the Build Tools options and fields in moviesApp.Rproj are in the figure below:\n\n\n\n\n\n(a) moviesApp.Rproj build tool fields\n\n\nFigure 3.8: Default build tool settings in moviesApp.Rproj file\n\n\n\nBuildType: Package tells the IDE moviesApp is an R package and triggers the Build pane.\nPackageUseDevtools: Yes links the options in the Build pane to the devtools package.\nThe PackageInstallArgs are complicated, but I’ve included some information about them in the callout block below (and you can read more in the official R documentation)\nThe fourth option (PackageRoxygenize) is available under Generate documentation with Roxygen &gt; Use roxygen to generate:\n\nThese options affect the documentation in an R package. To match the example from R Packages, 2ed above, make sure Rd files, Collate field, and NAMESPACE file are selected and click OK.\n\n\n\n\n\n\n\n(a) PackageRoxygenize in .Rproj file\n\n\nFigure 3.9: roxygen2 build settings\n\n\nAfter clicking OK, the IDE will automatically reboot, and the additional fields will be added to the bottom of the moviesApp.Rproj:\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.2_rproj')\n\n\nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\n                                            \n\n\n\n\n\n\n\nWhat is --no-multiarch --with-keep.source?\n\n\n\n\n\n\n\n--no-multiarch: refers to the option for the package installer to only compile the package for the architecture of the current R session. By default, R tries to compile packages for 32-bit and 64-bit architectures if running in a 64-bit R session on Windows. This flag can help avoid problems if a package can only be compiled on one architecture. Read more here.\n--with-keep.source: In R, when a function is created, its body can be stored in two ways: 1) as a parsed but unevaluated expression and 2) as a character string containing the function’s source code. By default, only the parsed expression is kept. If –with-keep.source is specified, R will also keep the source code as a character string, which can be helpful for debugging and tools that analyze or modify source code. Read more here.\n\n\n\n\n\n\n\n3.2.3 The Build pane\nWhen the new session starts, the new project-level options activate the Build pane in the IDE, and I can check the R package functionality by loading the code with Build &gt; Load All\n\n\n\n\n\n(a) Load the code in the R/ folder\n\n\nFigure 3.10: Identical to running devtools::load_all()\n\n\nI should see the following in the Console:\nℹ Loading moviesApp\nThere you have it–moviesApp is a functional app-package!\n\n\n3.2.4 Functional app-packages\nIn a functional app-package :\n\nThe DESCRIPTION file contains the seven mandatory fields7, making running the necessary devtools functions possible.\n\n\nThe .Rproj file contains the three package configuration fields8, which makes the Build pane accessible and functional.\n\nThink of the two items above as a two-part process: the DESCRIPTION requires specific fields, and the IDE requires .Rproj fields to trigger the Build pane.\n\n\n\n\n\n\n(a) Shiny app-package (with DESCRIPTION and Build pane)\n\n\nFigure 3.11: Fully functional Shiny app-package"
  },
  {
    "objectID": "packages.html#creating-app-packages",
    "href": "packages.html#creating-app-packages",
    "title": "3  Packages",
    "section": "3.3 Creating app-packages ",
    "text": "3.3 Creating app-packages \nThe Posit documentation lists the following way(s) to create R packages:9\n\n\nCall usethis::create_package().\nIn Posit Workbench, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\n\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 03.3_create-package branch of moviesApp.\n\ncreate_package() is a great option if you’re looking for a way to quickly create or convert your Shiny project into a Shiny app-package. In the following sections I’ll cover some suggestions for using create_package().10\n\n3.3.1 New Shiny app-packages\nIf you haven’t written any code and want to create a new Shiny app-package, create_package() is the quickest way to get started.\nFirst, install devtools:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\ndevtools automatically loads usethis\nLoading required package: usethis\nAssuming your current working directory is where you want your new Shiny app-package, call usethis::create_package() with the path argument set to getwd()\n\nusethis::create_package(path = getwd())\n\nThis call launches a series of actions:\n\nFirst, the active project is set to whatever was given to the path argument.\n✔ Setting active project to 'path/to/newApp'\nThe R/ folder and DESCRIPTION/ file are created:\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\nThe NAMESPACE and .Rproj files are created:\n✔ Writing 'NAMESPACE'\n✔ Writing 'newApp.Rproj'\nThe .Rproj is added to the .Rbuildignore file, the .Rproj.user folder is added to the .gitignore and .Rbuildignore files.\n✔ Adding '^newApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\nA new session is opened from the new .Rproj file:\n✔ Opening 'path/to/newApp/' in new RStudio session\n\nWhen the new session opens, newApp has the following contents:\n\nnewApp/\n  ├── .Rbuildignore\n  ├── .Rproj.user/\n  ├── .gitignore\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── newApp.Rproj\n\nYou’re now free to develop newApp. Store and document any .R files in the R/ folder, edit the DESCRIPTION file with details about the application, read through R Packages and Mastering Shiny, and add the Shiny code to complete your Shiny app-package.\n\n\n3.3.2 Converting Shiny projects\nIf you already have a Shiny app project that needs to be converted into a Shiny app-package, you can also use create_package(path = getwd()) in your root folder, but I recommend using the following arguments:\n\n3.3.2.1 DESCRIPTION arguments\n\nfields: these are arguments passed to usethis::use_description(). If the fields argument is empty, a boilerplate DESCRIPTION file is created (similar to this one).\n\nThese boilerplate fields in the DESCRIPTION work, but I’ve found some of the fields are unnecessary (i.e., I’ve never needed Authors@R: or ORCID) and inevitably require revision, so I’d prefer to handle this during the creation process (and remove the risk of forgetting to change it later).\nAll fields should be passed in a list() as field = 'value' pairs.\n\n\nusethis::use_description(\n    list(Package = 'moviesApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review Shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"))\n\n\nA few fields require specially formatted values (see the utils::person() examples below).\n\nutils::person(\"John\", \"Smith\", \n              email = \"John.Smith@email.io\", \n              role = c(\"aut\", \"cre\"))\n\n[1] \"John Smith &lt;John.Smith@email.io&gt; [aut, cre]\"\n\n\n\nTwo additional arguments from use_description() are passed to create_package():\n\ncheck_name: verifies your Shiny app-package name is valid for CRAN, so we can set this to FALSE (unless you’re planning on submitting to CRAN)\nroxygen2: is TRUE by default and adds the fields required to use roxygen2 (which I won’t cover here because we’ll cover documentation in-depth in a future chapter).\n\n\n\n\n\n\n\n\nWARNING: Don’t use usethis::create_package('.')!\n\n\n\n\n\n\nWhen converting your existing Shiny app project into a Shiny app-package with usethis::create_package(), don’t use '.' in the path argument:\nusethis::create_package('.')\nThis will return the following warning about creating nested projects, and ask if you want to proceed anyway:\nNew project 'moviesApp' is nested inside an existing project\n'./', which is rarely a good idea. If this is unexpected, \nthe here package has a function,\n`here::dr_here()` that reveals why './' is regarded as a\nproject.\n  \nDo you want to create anyway?\n\n1: Yes\n2: No way\n3: Not now\nWe can avoid this warning altogether by passing getwd() to the path argument, so I recommend cancelling the project creation:\nSelection: 2\nError: Cancelling project creation.\n\n\n\n\n\n\n3.3.2.2 IDE arguments\n\nrstudio: adds the necessary Build Tools fields in the .Rproj file (leave as TRUE)\nopen: can be set to FALSE because we don’t need RStudio/Posit Workbench to open in a new session\n\n\nusethis::create_package(\n  path = getwd(),\n  fields = list(Package = 'moviesApp',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review Shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"),\n  roxygen = TRUE,\n  check_name = FALSE, \n  rstudio = TRUE,\n  open = FALSE)\n\nAfter running usethis::create_package() with the arguments above, the IDE will present us with a few prompts to confirm:\nOverwrite pre-existing file 'DESCRIPTION'?\nOverwrite pre-existing file 'moviesApp.Rproj'?\nThe Shiny app-package structure is below:\n\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── moviesApp.Rproj\n└── www\n    └── Shiny.png\n\n3 directories, 10 files\n\nThe DESCRIPTION file (shown below) has a few additional fields (Encoding, Roxygen, and RoxygenNote) we didn’t include when we converted moviesApp above, but we will cover these in the upcoming chapters.\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith &lt;John.Smith@email.io&gt; [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('03.3_create-package')"
  },
  {
    "objectID": "packages.html#recap",
    "href": "packages.html#recap",
    "title": "3  Packages",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered the mandatory fields in the DESCRIPTION file and the R package configuration fields in .Rproj. We also covered creating and converting Shiny app projects using the usethis::create_package() function.\n\n\n\n\n\n\nRecap: Packages!\n\n\n\n\n\n\n\nThe DESCRIPTION file ultimately controls whether you have a functional Shiny app-package.\n\nThe mandatory fields are Package, Version, License, Description, Title, Author, and Maintainer.\n\nusethis::create_package() can be used to create a new R package and to convert an existing Shiny project into a Shiny app-package.\nThe IDE reads Posit Workbench (.Rproj) files and determines R session settings at the project-level (i.e., working directory, workspace, history, code formatting, etc.)\n\nPackage development settings can be accessed via Project Options &gt; Build Tools.\n\n\n\n\n\n\nIn the next chapter, I’ll cover how you can quickly Load, Document, and Install your package!"
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "3  Packages",
    "section": "",
    "text": "Shiny app project features are covered in Section 2.3 and Section 2.4 of the previous chapter.↩︎\nFortunately, Shiny app-packages don’t require all the files and folders displayed in the folder tree to gain the functionality and benefits of an R package.↩︎\nThe mandatory fields are covered in Writing R Extensions, ‘The DESCRIPTION file’↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎\n.Rproj files are covered in the What makes an RStudio Project? section of R Packages (2 ed)↩︎\nThe initial Build Tools settings (i.e., (None)) should help explain the absence of any R package development fields in the moviesApp.Rproj when we compared it to the version in R Packages, 2ed (i.e., BuildType, PackageUseDevtools, PackageInstallArgs, and PackageRoxygenize).↩︎\nThe mandatory fields DESCRIPTION fields are: Package, Version, License, Description, Title, Author, and Maintainer↩︎\nThe .Rproj package configuration fields are BuildType: Package, PackageUseDevtools: Yes, and PackageInstallArgs: --no-multiarch --with-keep.source.↩︎\nThis information comes from the Writing R Packages documentation for Posit Workbench.↩︎\nusethis::create_package() is covered in the ‘Fundamental development workflows’ chapter of R Packages, 2ed↩︎"
  },
  {
    "objectID": "development.html#developing-packages-with-devtools",
    "href": "development.html#developing-packages-with-devtools",
    "title": "4  Development",
    "section": "4.1 Developing packages with devtools",
    "text": "4.1 Developing packages with devtools\n\n“One package to rule them all.” - Not the devtools development team\n\nIf you’re new to package development, having a little background on the devtools package is helpful. Earlier versions of devtools contained most of the functions used for package development. In version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\n\nThe usethis package contains the functions for creating package folders and files (.R files, tests, vignettes, etc.). usethis is also automatically loaded when you call library(devtools).\nLoading and building your app-package is handled by pkgload and pkgbuild\nFor app-packages destined for CRAN, the R CMD check is handled by rcmdcheck and revdepcheck\nInstalling packages from non-CRAN repositories (i.e., install_github()) is handled by remotes\n\nYou don’t have to install all of these packages (they will be loaded with devtools), but the information is essential because it affects the dependencies in your app-package:\n\n‘Package developers who wish to depend on devtools features should also pay attention to which package the functionality is coming from and depend on that rather than devtools. In most cases, packages should not depend on devtools directly.’ - devtools 2.0.0, tidyverse blog\n\nWe will cover this topic more in the dependencies chapter."
  },
  {
    "objectID": "development.html#building-moviesapp",
    "href": "development.html#building-moviesapp",
    "title": "4  Development",
    "section": "4.2 Building moviesApp",
    "text": "4.2 Building moviesApp\nLet’s assume we’re continuing with the app project we converted manually in the 03.1_description branch of moviesApp (the files and folders are below).\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 03.1_description branch of moviesApp.\n\n\nmoviesApp/ # 03.1_description branch\n  ├── DESCRIPTION\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── moviesApp.Rproj\n  └── www\n      └── shiny.png\n\n4 directories, 9 files\n\nWe’re backing up to the branch we created by manually editing the DESCRIPTION file to show the connection between the devtools functions and specific fields in the DESCRIPTION file.1\n\n4.2.1 DESCRIPTION\nThe version of moviesApp in this branch has a DESCRIPTION file with the seven mandatory fields:\n\n# in Terminal\n$ cat DESCRIPTION \nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data Shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\n4.2.2 moviesApp.Rproj\nHowever, the .Rproj file is still configured to work with a Shiny project:2\n\n# in Terminal\n$ cat moviesApp.Rproj \nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX"
  },
  {
    "objectID": "development.html#package-development-habits",
    "href": "development.html#package-development-habits",
    "title": "4  Development",
    "section": "4.3 Package development habits",
    "text": "4.3 Package development habits\nThe differences between developing an R package and a Shiny app can be boiled down to a handful habits, each of which calls a devtools function:\n\n\nI’ll use bold to indicate each devtools habit and accompanying function.\n\nLoad all the functions and data in your app-package with load_all()\nDocument the app-package functions and data with document()\nInstall the app-package with install()\n\nIn the sections below, I’ll cover each function and my opinion about how it should be used when your Shiny app becomes an app-package.3\n\n\n\n\n\n\nKeyboard shortcuts\n\n\n\n\n\n\nI strongly recommend using the keyboard shortcuts for each devtools function. Shortcuts reduce typing and bundle all those keystrokes into a single action. They also create a kind of ‘muscle memory’ for each step.\n\n\n\n\n\n4.3.1 Load\nInstall devtools\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\nusethis is automatically loaded/attached with devtools.\nLoading required package: usethis\n\n‘load_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management’ - Benefits of load_all(), R Packages, 2ed\n\nload_all() is the most common devtools function we’ll use during development because we should load the package when anything changes in the R/ folder.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\n\ndevtools::load_all()\n\nUsing load_all() is similar to calling library(moviesApp) because it loads the code in R/ along with any data files. load_all() is also designed for iteration (unlike using source()), and when it’s successful, the output is a single informative message:\nℹ Loading moviesApp\n\n\n4.3.2 Document\nThe document() function from devtools serves two purposes:\n\nWriting the package NAMESPACE file\nCreates the help files in the man/ folder\n\ndevtools is smart enough to recognize the first time document() is called, so when I initially run it in the Console, it prompts me that the roxygen2 version needs to be set in the DESCRIPTION file:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\ndevtools::document()\n\nℹ Updating moviesApp documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\ndevtools relies on roxygen2 for package documentation, so the RoxygenNote field is required in the DESCRIPTION. You may have noticed calling document() also calls load_all(), which scans the loaded package contents for special documentation syntax before writing the NAMESPACE file (we’ll cover the NAMESPACE in the chapter on Dependencies).\nℹ Loading moviesApp\nWriting NAMESPACE\nIf we open the NAMESPACE file, we see it’s empty (and that we shouldn’t edit this file by hand).\n\n\n\n\n\n(a) NAMESPACE\n\n\nFigure 4.1: Initial NAMESPACE file\n\n\nThe last few output lines warn us to include the Encoding field in the DESCRIPTION. devtools won’t automatically add Encoding (like it did with RoxygenNote above), so we’ll need to add it to the DESCRIPTION file manually:\nWarning message:\nroxygen2 requires Encoding: \"UTF-8\"\nℹ Current encoding is NA \n\nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data Shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\n1Encoding: UTF-8\n2\n\n\n1\n\nThe Encoding value shouldn’t include quotes like the warning message above (i.e., UTF-8)\n\n\n2\n\nAlways leave an empty final line in the DESCRIPTION\n\n\n\n\nAfter adding the required fields to the DESCRIPTION file,4 we’ll document() the package again using the keyboard shortcut:\nIn the Build pane, we see the following:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nDocumentation completed\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\n\n\n4.3.3 Install\nThe final package development habit to adopt is regularly installing the package with devtools::install().\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\ndevtools::install()\n\ninstall() will prompt the following output in the Build pane:\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source moviesApp\n\n* installing to library ‘/path/to/local/install/moviesApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘moviesApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\nNo man pages found in package  ‘moviesApp’ \n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (moviesApp)\nThere are a few connections worth making in this initial install() output:\n\nThe first line in the output should look familiar–we saw both of these settings in the moviesApp.Rproj file from the previous chapter\nPackageInstallArgs: --no-multiarch --with-keep.source\nNo man pages found in package 'moviesApp' tells us none of the code in R/ has adequately been documented (which we’ll cover in the roxygen2 chapter)\ninstall() attempts to install the package from the *source* files and a ‘bundle’ or source tarball file (i.e., .tar.gz)\nhelp files are built, along with other documentation (like vignettes)\nDONE (moviesApp) means moviesApp was successfully installed!\n\nInstall a package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\nLaunch app with the shinypak package:\n\nlaunch('04_devtools')\n\n\n\n4.3.4 Check?\ndevtools::check() performs a series of checks to ensure a package meets the standards set by CRAN. You can consider check() as a ‘quality control’ function for documentation, NAMESPACE dependencies, unnecessary or non-standard folders and files, etc. R Packages recommends using check() often, but I agree with the advice in Mastering Shiny on using check() with app-packages,\n\n‘I don’t recommend that you [call devtools::check()] the first time, the second time, or even the third time you try out the package structure. Instead, I recommend that you get familiar with the basic structure and workflow before you take the next step to make a fully compliant package.’\n\nHowever, I’ve included an example of running check() on moviesApp in the callout box below to demonstrate how it works.\n\n\n\n\n\n\nRunning devtools::check()\n\n\n\n\n\n\ndevtools::check()\n\nThe output from check() can be rather lengthy (it’s pretty comprehensive!), and it provides feedback on each item in the form of a note (N), warning (W), or error (E).\n==&gt; devtools::check()\n\nDuration: 15.3s\n\nN  checking top-level files\n   Non-standard files/directories found at top level:\n     ‘app.R’ ‘movies.RData’\n\nW  checking dependencies in R code ...\n   '::' or ':::' imports not declared from:\n     ‘ggplot2’ ‘shiny’ ‘stringr’\n\nN  checking R code for possible problems (3.1s)\n   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n     variable ‘movies’\n   scatter_plot: no visible binding for global variable ‘.data’\n   Undefined global functions or variables:\n     .data movies\n\nW  checking for missing documentation entries ...\n   Undocumented code objects:\n     ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n     ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n   All user-level objects in a package should have documentation entries.\n   See chapter ‘Writing R documentation files’ in the ‘Writing R\n   Extensions’ manual.\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nA summary of each item is below:\n\nchecking top-level files: This note refers to the two non-standard (i.e., not typically found in an R package) files, app.R and movies.RData.\nchecking dependencies in R code: This warning tells I need to namespace functions from add-on packages (in this case, ggplot2, shiny, and stringr)\nchecking R code for possible problems: This item refers to the call to load the movies data in the module server function (mod_scatter_display_server).\nchecking for missing documentation entries: This is warning me that the module functions aren’t properly documented and refers me to the official R documentation.\n\nEach of these items is also printed under the ── R CMD check results heading:\nDuration: 15.3s\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' imports not declared from:\n    ‘ggplot2’ ‘shiny’ ‘stringr’\n\n❯ checking for missing documentation entries ... WARNING\n  Undocumented code objects:\n    ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n    ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n  All user-level objects in a package should have documentation entries.\n  See chapter ‘Writing R documentation files’ in the ‘Writing R\n  Extensions’ manual.\n\n❯ checking top-level files ... NOTE\n  Non-standard files/directories found at top level:\n    ‘app.R’ ‘movies.RData’\n\n❯ checking R code for possible problems ... NOTE\n  mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n    variable ‘movies’\n  scatter_plot: no visible binding for global variable ‘.data’\n  Undefined global functions or variables:\n    .data movies\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nIf you’re submitting your app-package to CRAN (or want to use check() for other reasons), follow the suggested workflow for check():\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check() or press Shift + Ctrl/Cmd + E\nFix the first problem.\nRepeat until there are no more problems.’\n\n\nI’ve found a good habit for when to check() to be:\nAfter adding a bug fix or feature, check a package and keep any notes, warnings, or errors from accumulating."
  },
  {
    "objectID": "development.html#other-package-files",
    "href": "development.html#other-package-files",
    "title": "4  Development",
    "section": "4.4 Other package files",
    "text": "4.4 Other package files\nYou might notice additional ‘hidden’ files in your new app-package: .gitignore, .Rbuildignore, and .Rprofile:\n\n4.4.1 .gitignore\n.gitignore will ignore some of the standard hidden files created by R or RStudio. The initial contents will include something like the following:\n\n.Rproj.user\n.Rhistory\n.RData\n.Ruserdata\n.DS_Store # for mac users \n\n\n\n4.4.2 .Rbuildignore\n.Rbuildignore includes files that we need to have in our app-package, but don’t conform to the standard R package structure (and shouldn’t be included when building our app-package from the source files).\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n\nNote the regular expression syntax for detecting file patterns.\n\n\n4.4.3 .Rprofile\nThe .Rprofile is specific to the user (you) The might include options for loading packages or tests:\n\nif (interactive()) {\n  require(usethis, quietly = TRUE)\n}\noptions(shiny.testmode = TRUE)\n\n\n\nRecap\nCreating an app-package involves adopting some new devtools habits, and the initial contents of moviesApp hopefully helped demonstrate the purpose of each function.\n\n\n\n\n\n\nRecap: Package development habits\n\n\n\n\n\n\nAfter installing and loading devtools:\n\nLoad the package whenever changes occur in the R/ folder.\n\nCtrl/Cmd + Shift + L load all the code in the package.\n\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\n\nCtrl/Cmd + Shift + D record the documentation and dependencies.\n\nInstall the package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\nCtrl/Cmd + Shift + B confirms the package can be installed.\n\n\nHabits require repetition to develop, and I hope the workflow above can be applied to your Shiny app-packages, provided you’re using devtools and Posit workbench.\n\n\n\n\nThe following section will cover documenting functions with roxygen2"
  },
  {
    "objectID": "development.html#footnotes",
    "href": "development.html#footnotes",
    "title": "4  Development",
    "section": "",
    "text": "If you create or convert your Shiny app project with usethis::create_package(), a few fields (i.e., Roxygen and RoxygenNote) are added automatically without explaining their role or purpose.↩︎\nIf you created your Shiny app using the New Project Wizard, your .Rproj file has been configured to work with project, not a package.↩︎\nThe topics covered in this section shouldn’t be considered a replacement for the ‘Whole Game’ chapter in R packages (2 ed) or the ‘Workflow’ section of Mastering Shiny (and I highly recommend reading both).↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎"
  },
  {
    "objectID": "app_packages.html#review-chapters-1---4",
    "href": "app_packages.html#review-chapters-1---4",
    "title": "App-packages",
    "section": "Review Chapters 1 - 4",
    "text": "Review Chapters 1 - 4\nLet’s briefly review what we’ve covered in the last four chapters:\n\nWhole app game (Chapter 1)\nChapter 1 walks through the ‘whole game’ of the app-package development workflow. The application in this example comes from the Packages chapter of Mastering Shiny.\n\n\n\n\n\n\nChapter 1: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 1 (Whole app game) is stored in the following repository:\n\nmonthAppPkg\n\n\n\n\n\n\n\nShiny (Chapter 2)\nThe Shiny chapter covered\n\nBasic Shiny projects (Section 2.1)\nShiny app folders (Section 2.3) and files (Section 2.4)\nShiny modules (Section 2.5.1) and standalone app functions (Section 2.5.2), and\nOther ‘pre-package’ advanced practices (Section 2.6) you may have adopted in your Shiny app.\n\n\n\n\n\n\n\nChapter 2: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 2 (Shiny) is stored in the following branches:\n\nmain: Contains a new Shiny app project created from the New Project Wizard (with Old Faithful Geyser Data)\n02a_movies-app: The boilerplate app in app.R is replaced with the code for the movie review application, and the scatter_plot() utility function is added to utils.R and movies.RData is added to the project.\n02b_proj-app contains an ‘fully developed’ Shiny app project with the following contents:\n\nDESCRIPTION file\n\nREADME.md file\n\nR/ folder\n\nModules: two module files are created in the R/ folder (mod_var_input.R and mod_scatter_display.R)\n\nStandalone app function: the code in app.R is converted to a standalone app function: movies_app()\nUtility function: Move utils.R into the R/ folder\n\n\nThe www/ folder contains the image file (shiny.png)\n\nDeployment: The rsconnect/ folder contains files for deploying to shinyapps.io\n\n\n\n\n\n\n\n\nPackages (Chapter 3)\nPackages illustrates what separates R projects from R packages. This chapter covers:\n\nthe essential ingredients of an R package (Section 3.1.1)\nhow to create a new Shiny app-package (Section 3.3.1) and\nconvert an existing Shiny app (Section 3.3.2) into an app-package.\n\n\n\n\n\n\n\nChapter 3: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 3 (Packages) is stored in the following branches:\n\n02b_proj-app is an ‘advanced’ package from the previous chapter\n03a_description is a branch from 02b_proj-app and adds the seven mandatory DESCRIPTION fields.\n03b_rproj is a branch from 03a_description and manually converts the Shiny app project to a Shiny app-package using the .Rproj file.\n03c_create-package is a branch from 03b_rproj and creates a package using usethis::create_package()\n\n\n\n\n\n\n\nDevelopment (Chapter 4)\nChapter 4 introduced the devtools package and its core functions:\n\nload_all() (Section 4.3.1)\ndocument() (Section 4.3.2), and\ninstall() (Section 4.3.3)\n\n\n\n\n\n\n\nChapter 4: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 4 (Development) is stored in the following branch:\n\n04_devtools is a branch from the manually converted app-package in 03b_rproj"
  },
  {
    "objectID": "app_packages.html#app-packages",
    "href": "app_packages.html#app-packages",
    "title": "App-packages",
    "section": "App-packages",
    "text": "App-packages\nWe now have two branches of moviesApp with a functioning app-package:\n\nIn the 06_devtools branch (Section 4.3.3), moviesApp was converted to a package by manually adding the required fields to the DESCRIPTION file, then running the key devtools development functions (load_all(), document(), and install())\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\n1\n\n\n1\n\nAlways leave an empty line in the DESCRIPTION\n\n\n\n\nIn the 06_create-package branch (Section 3.3.2), we used the usethis::create_package() function to convert moviesApp into a package.\n\nPackage: moviesApp\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review Shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\n\nThe only difference between these two branches lies in the DESCRIPTION files–in the 06_create-package branch, the Roxygen: list(markdown = TRUE) field was added (which we will cover in the upcoming Documentation chapter).\nThe following chapters will continue with app-package development, emphasizing developing a Shiny application within a package structure. A preview of each topic covered in the upcoming chapters is provided below.\n\nDocumentation (Chapter 5)\nChapter 5 covers documenting your app-package code in the R/ folder:\n\nroxygen2 basics:\n\nRequired tags:\n\n@title, @description, @details, @param, @return, and @examples\n\n\nApp-package tags for modules and standalone app functions:\n\n@seealso, @family, and @section\n\n\n\n\n\nDependencies (Chapter 6)\nChapter 6 dives into dependencies. We’ll cover how to export functions and objects from your app-packages for others to use, and how to handle functions from add-on (i.e., external) packages.\n\nExporting functions from your package namespace\n\n@export/export()\n\n\nImporting functions from add-on packages into your package namespace\n\n@import/import(), @importFrom/importFrom()\n\n\nThe Imports field in the DESCRIPTION\n\nusethis::use_package()\n\n\n\n\nData (Chapter 7)\nData covers how to include datasets in your app-package namespace, and the various kinds of data in R packages.\n\nDocumenting data with\n\nroxygen2: @format, \\describe, \\item\n\n\nLocation of data files: data/ vs. data-raw/ vs. inst/extdata/\n\n\n\nLaunch (Chapter 8)\nThe Launch chapter covers how to 1) run your application during development, how to run your app using a standalone app function, and 3) how to deploy your application to shinyapps.io.\n\nWhat goes in app.R?\n\nshinyApp() vs. shinyAppDir() vs. runApp()\n\nrsconnect::deployApp()\n\n\n\n\nExternal files (Chapter 9)\nExternal files covers how to include external resources (i.e. the images, CSS, html, or other files that are typically included in the www/ folder and served when you run your Shiny app). This chapter also covers other uses for the isnt/ folder in app-packages.\n\nwww/ vs. inst/\nsystem.file()\naddResourcePath()"
  },
  {
    "objectID": "document.html#sec-intro-roxygen2",
    "href": "document.html#sec-intro-roxygen2",
    "title": "5  Documentation",
    "section": "5.1 roxygen2 basics",
    "text": "5.1 roxygen2 basics\nroxygen2 connects the package code (i.e., the .R files in the R/ folder) to its documentation files (i.e., the .Rd files in the man/ folder):\n\n\n\n\n\n(a) roxygen2\n\n\nFigure 5.1: roxygen2 creates man/ documentation\n\n\nThe two pieces of roxygen2 syntax to know are comment blocks and tags:\n\nComment blocks are any lines beginning with #'\n#' \n#' \n#' \nTags begin with @\n#' \n#' @tag\n#' \n\nWhen documenting functions, roxygen2 tags and comment blocks are placed directly above any functions stored in R/.\n#' \n#' @tag\n#' \nmy_fun &lt;- function() {\n  \n}\nIn the following sections, we’ll cover roxygen2 basics using examples for the scatter_plot() function found in R/utils.R.\n\n\n\n\n\n\nInserting roxygen2 skeletons\n\n\n\n\n\n\nYou can insert an roxygen2 skeleton into your function using Code &gt; Insert Roxygen Skeleton\n\n\n\nStandard roxygen2 skeleton\n\n\n\n\n\n\n\n5.1.1 markdown = TRUE\nWhen we created our app-package with usethis::create_package(), support for markdown formatting in package help files is automatically included by adding Roxygen: list(markdown = TRUE) to the DESCRIPTION file:\n\nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data Shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nDisplayMode: Showcase\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\n1\n\n\n1\n\nAlways leave at least one empty final line in your DESCRIPTION file.\n\n\n\n\n\n\n5.1.2 @title & @description\nThe first two sections of roxygen2 documentation are the title and description. These sections don’t require tags–roxygen2 will detect each section as long as there is at least one #' line separating them (and their contents don’t extend past the length indicated in parentheses below):\n#' function title (one line)\n#'\n#' A short description... (one paragraph)\n#' \nThe @title and @description for the scatter_plot() function stored in R/utils.R might look like this:\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n\n\n\n\n\n\nFunction @description and @details\n\n\n\n\n\nIf the contents in the @description for a function requires more complicated formatting than a single paragraph (i.e., multiple paragraphs, lists, etc.), you can use the @details tag:\n#' Create scatter plot  \n#' \n#' @description\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' @details\n#' `scatter_plot()` is a custom `ggplot2` function written to handle string arguments from reactive inputs (i.e., `input$x` or `input$y`). \n\n\n\n\n\n5.1.3 @param & @return\nDocument function arguments and outputs with @param and @return:\n\n@param: should include the name and description of each function input (i.e., their type and what they do)\n#' @param name description of its action\n\nRead more here\n\n@return: these describe the type (or class) and structure of the function output\n#' @return type/structure of the output\n\nRead more here\n\n\nBelow are examples for @param and @return in the scatter_plot() function stored in R/utils.R:\n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\nTo view how the roxygen2 syntax will appear in the .Rd file, I’ll document moviesApp:\n\n\nTo reduce the amount of repetitive code, I’ll just be showing the keyboard shortcuts for each devtools function from this point forward\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nI can see the scatter_plot.Rd file is written to the man/ folder:\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nWriting scatter_plot.Rd\nDocumentation completed\nShiny apps often contain utility functions in helper.R or utils.R files. Storing non-shiny code in these files isn’t a bad practice (in fact, it’s encouraged in Mastering Shiny). However, if we’re following the advice in R Packages,1 we should rename R/utils.R to R/scatter_plot.R so it matches man/scatter_plot.Rd as we transition to an app-package.2\n\n\n\n\n\n\nR/utils.R &gt;&gt; R/scatter_plot.R\n\n\n\n\n\n\nFrom now on, I’ve renamed R/utils.R to R/scatter_plot.R, so it aligns with the naming conventions in other R packages.\nFor a deep dive on R/utils.R files in R packages, I recommend reading Dissecting R Package “Utility Belts”\n\n\n\n\nR documentation (.Rd) files have a formatting style similar to (La)TeX (but roxygen2 saves us from having to learn this syntax). When we open man/scatter_plot.Rd, we see it contains the following:\n\n\n\n\n\n\n(a) .Rd file\n\n\nFigure 5.2: R documentation file\n\n\n\n\n\n\n\n\n\n.Rd file syntax\n\n\n\n\n\n\nroxygen2 graciously generates the scatter_plot.Rd file (and warns us not to edit it by hand).\n\n\n\nroxygen2 tag syntax in .Rd file\n\n\nNote the following items were added without needing tags:\n\n\\name: the name of the function (as it appears in the index)\n\\alias: used to group ‘topics’ and provides a look-up in the package index\n\\arguments: function arguments (header)\n\n\\item: description of argument\n\n\nThe following two items are a result of the markdown syntax we used:\n\n\\href: used for hyperlinks\n\\code: code formatting\n\n\n\n\n\nTo view the help file, I can enter ?scatter_plot in the console:\n\n?scatter_plot\n\nAnd an informative message tells me that the development version scatter_plot.Rd is being rendered:\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n\n(a) Help file\n\n\nFigure 5.3: Help file\n\n\n\nPreviewing the development documentation is a great way to verify the content in each .Rd file meets expectations.\n\n\n5.1.4 @examples\n@examples are unique because they include executable code demonstrating how a function works. In the Posit Workbench IDE, @examples are especially helpful because they come with a ‘single click’ hyperlink (the @examples from ggplot2::aes() are below):\n\n\n\n\n\n\n\n\n(a) Run examples hyperlink\n\n\n\n\n\n\n\n\n\n(b) Executed @examples code\n\n\n\n\nFigure 5.4: Run examples in help files\n\n\n\nThe syntax to create an example for scatter_plot() is below:\n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n\n\n\n\n\n\nTab-completion for @tags\n\n\n\n\n\n\nIf you’re documenting your package functions in Posit Workbench, tab-completion is your friend! The help text displayed with each tag ensures you’re including the correct version (see @example vs. @examples below).\n\n\n\nTab completion for @example\n\n\n\n\n\nTab completion for @examples\n\n\nRead more here.\n\n\n\n\nTo preview the @examples in the help file, I’ll document() and open the development .Rd file:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n?scatter_plot\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n\n\n(a) @examples in .Rd preview\n\n\nFigure 5.5: Preview of examples\n\n\n\nThe Run examples hyperlink won’t be active in the .Rd file preview, but reviewing the code in @examples allows me to correct any errors or typos early.\nThe scatter_plot() function has a documented Title, Description, Usage, Arguments, Value, and Examples. I consider these tags the minimum documentation to include for functions I’m making available to other users."
  },
  {
    "objectID": "document.html#sec-document-app-functions",
    "href": "document.html#sec-document-app-functions",
    "title": "5  Documentation",
    "section": "5.2 Documenting app functions",
    "text": "5.2 Documenting app functions\nYour app-package will likely contain at least two functions specific to shiny: modules and a standalone app function. roxygen2 has a few tags that can make the documentation for these functions more informative for readers.\n\n5.2.1 Documenting modules\nBelow are a few things to consider when documenting module functions:\n\nModules typically have two functions in a single .R file: one for the UI and a counterpart in the server.\nEvery module function will include at least one @param for the shared id.\nReturned objects are critical in shiny’s reactive context, so I recommend extending the description to include whether or not the returned output is reactive.\nIf the returned output is an input (i.e. @param) for another function, link to that documentation functions with @seealso or @family.\n\nBelow are some examples from the moviesApp modules.\n\n\n5.2.2 @seealso\nWhen documenting modules, think of the audience as someone looking to understand the execution path through the application. In moviesApp(), the inputs are collected with the var_input module and then passed to the scatter_display module.\nI use @seealso to connect mod_var_input_ui() to its server function counterpart. The hyperlink to mod_var_input_server() from mod_var_input_ui() is created by placing the destination function in square brackets [fun()]:\n#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n#' @seealso [mod_var_input_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n@seealso creates a hyperlink readers can use to open the next module in the execution path.\n\n\n\n\n\n(a) @seealso link\n\n\nFigure 5.6: Link values from var_input to scatter_display\n\n\nIn mod_var_input_server(), a link can be made to mod_scatter_display_server() (the module function collecting the returned values) using the square brackets in the @return section (without @seealso):\n#' Variable input module (server)\n#'\n#' @param id server module id\n#' \n#' @seealso [mod_var_input_ui()]\n#'\n#' @return reactive inputs are returned in a `list()`: \n#'  * `\"y\" = input$y`\n#'  * `\"x\" = input$x`\n#'  * `\"z\" = input$z`\n#'  * `\"alpha\" = input$alpha`\n#'  * `\"size\" = input$size`\n#'  * `\"plot_title\" = input$plot_title`\n#'  \n#' These become in the `var_inputs()` argument in [mod_scatter_display_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) mod_var_input_ui()\n\n\n\n\n \n\n\n\n\n\n(b) mod_var_input_server()\n\n\n\n\nFigure 5.7: Link values from var_input to scatter_display\n\n\n\n\n\n5.2.3 @family\nModule functions can also be grouped into families using @family {\"description\"}. Below is an example of grouping the “scatter plot module functions” into a family:\n#' Scatter plot display module (UI)\n#'\n#' @param id UI module id\n#' \n#'\n#' @return module UI (HTML)\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n5.2.4 @section\nThe @section tag will create a level two header (##/&lt;h2&gt;&lt;/h2&gt;) section, which can help organize topics (like how to use an input or argument).\n@seealso can also be used to link back to the scatter_plot() utility function:\n#' Scatter plot display module (server)\n#' \n#'\n#' @param id server module id \n#' @param var_inputs returned reactive list from [mod_var_input_server()].\n#' \n#' @section Referring to `var_inputs`: \n#' Refer to the reactive returned values from `mod_var_input_server()` as:\n#'  * `var_inputs()$x`\n#'  * `var_inputs()$y`\n#'  * `var_inputs()$z`\n#'  * `var_inputs()$alpha`\n#'  * `var_inputs()$size`\n#'  * `var_inputs()$plot_title`\n#' \n#'\n#' @return rendered plot and title output from [scatter_plot()]\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@family in mod_scatter_display_ui()\n\n\n\n\n\n\n\n@seealso in mod_scatter_display_server()\n\n\n\n\n\n\nThe figure above shows how the @seealso links can create a path for the graph parameters through the var_input and scatter_display modules. It also demonstrates how @family groups the scatter_display UI and server functions.\nThe scatter_plot() utility function should also include a @seealso tag for the module function it’s used in.\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscatter_plot() in mod_scatter_display_server()\n\n\n\n\n\n\n\n@seealso in scatter_plot()\n\n\n\n\n\n\nThe goal when cross-referencing functions in your app-package is for anyone reading your documentation to follow the links and better understand any modules, their inputs, reactive values, and outputs.\nIn this case, linking to the scatter_plot() function gives readers an interactive example to preview the output.\n\n\n5.2.5 Standalone app functions\nSplitting the code in app.R into separate functions has multiple benefits:\n\nDeveloping and loading a function is easier if stored in the R/ folder.\nHaving a dedicated UI, server, and app function means we can develop them independently.\nA standalone app function makes storing multiple applications in the same app-package possible.\n\nI’ve split the UI and server from movies_app() into separate movies_ui() and movies_server() below.\n\n5.2.5.1 UI & Server functions\nThe movies_ui() doesn’t have any arguments–the only change is wrapping the shiny::fluidPage() in shiny::tagList():\n\nmovies_ui &lt;- function() {\n  shiny::tagList(\n    shiny::fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nmovies_server() is written to be passed to the server argument in shinyApp():\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\n5.2.5.1.1 usage\nI’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). I’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n#' Movies UI function\n#' \n#' UI function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_ui()\n\n\n\nThe documentation for movies_server() is very similar to the Ui function–each module server function is documented in it’s own @section.\nStill, I’ll include a @section for Communication that describes how values are passed between mod_var_input_server() and mod_scatter_display_server().\n#' Movies server function\n#' \n#' Server function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#' \n#' ```\n#' shinyApp(movies_ui, movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in [movies_ui()]   \n#'  * server is stored in `movies_server()`\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_server()] returns following reactive values:\n#'  * `x`\n#'  * `y`\n#'  * `z`\n#'  * `alpha`\n#'  * `size`\n#'  * `plot_title`\n#' \n#' @seealso [mod_var_input_ui()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_server()] displays the `ggplot2` graph with the [scatter_plot()] function.\n#' \n#' @seealso [mod_scatter_display_ui()]\n#' \n#' @section Communication: \n#' The output from [mod_var_input_server()] should be supplied to the \n#' `var_inputs` argument of [mod_scatter_display_server()].\n#\n#' @return `server` argument in `shiny::shinyApp()`\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_server()\n\n\n\n\n\n\n5.2.5.2 movies_app()\nThe standalone app function (movies_app()) automatically calls shinyApp(), with the movies_ui and movies_server functions supplied to ui and server (without parentheses).\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nThe documentation for the standalone app function can be minimal–as long as it provides links to the UI and server.\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return Shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_app()\n\n\n\nI’ll change the contents of app.R to the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nNow that we’ve documented everything in R/, we’ll run load(), document(), and install():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\ndevtools::load_all(\".\")\nℹ Loading moviesApp\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nDocumentation completed\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source moviesApp\n\n* installing to library ‘/path/to/local/install/moviesApp-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘moviesApp’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (moviesApp)\nIn the Console, we should see the following:\nRestarting R session...\n\n&gt; library(moviesApp)\nThe roxygen2 documentation for moviesApp is saved in the 02-roxygen branch. As we can see, calling devtools::document() generates the .Rd files in the man/ folder for each function in the R/ folder:\n\n\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n ├── movies_app.R\n ├── movies_server.R\n ├── movies_ui.R\n └── utils.R\n\n1 directory, 6 files\n\n\nman/\n  ├── mod_scatter_display_server.Rd\n  ├── mod_scatter_display_ui.Rd\n  ├── mod_var_input_server.Rd\n  ├── mod_var_input_ui.Rd\n  ├── movies_app.Rd\n  ├── movies_server.Rd\n  ├── movies_ui.Rd\n  └── scatter_plot.Rd\n\n1 directory, 8 files"
  },
  {
    "objectID": "document.html#recap",
    "href": "document.html#recap",
    "title": "5  Documentation",
    "section": "5.3 Recap",
    "text": "5.3 Recap\nGood documentation aims to make it as easy as possible for others (and future you) to understand what your function does and how to use it.\n\n\nLaunch app with the shinypak package:\n\nlaunch('05_roxygen2')\n\nBelow is a recap of the topics covered in this chapter.\n\n\n\n\n\n\nroxygen2 recap\n\n\n\n\n\n\nThis chapter covered:\n\nFunction @title and @description: The @title should be a short one-line description of the function, followed by a more detailed paragraph @description. These tags should give users an idea of what the function does (you can also use @details)\nArguments (@param) and outputs (@return): List all function arguments with @param. Include the argument type (e.g., integer, character, etc.) and a brief description of what the argument does. Be sure to mention any default or optional arguments. Function outputs should be listed with @return and describe the type or class of the object, whether or not it’s reactive, and mention any related functions.\nExamples: @examples provide executable R code that captures how the function is used in your app-package. These are incredibly valuable for new users trying to understand how a function (and your app-package) works.\n\nApp-package specific considerations:\n\nConnect functions with@seealso and @family: Use @seealso to provide links to related functions (i.e., modules) so users can click through a ‘guided tour’ of your application’s code–group similar functions using @family {description}.\nGive more info with @sections: Use @section to give in-depth explanations and specific details about how a function works, including any information about the @usage or its @params.\n@usage: This field will be automatically generated by roxygen2, but in some circumstances, it makes sense to set it to NULL and describe a function’s use explicitly.\n\n\n\n\n\nIn the next section, we’ll use roxygen2 to manage our app-package dependencies."
  },
  {
    "objectID": "document.html#footnotes",
    "href": "document.html#footnotes",
    "title": "5  Documentation",
    "section": "",
    "text": "‘most of our packages have a utils.R file (Section 6.1) that contains small utility functions that are useful internally, but aren’t part of the core purpose of those packages. We don’t export such functions.’↩︎\nHaving a 1:1 match on function and file names will also make writing and running tests easier.↩︎"
  },
  {
    "objectID": "dependencies.html#identifying-dependencies",
    "href": "dependencies.html#identifying-dependencies",
    "title": "6  Dependencies",
    "section": "Identifying dependencies",
    "text": "Identifying dependencies\nThe first step in managing dependencies is identifying which add-on packages moviesApp relies on.1 Our goal is to limit the dependencies to only those critical to the functioning of our app, because each additional dependency is a potential point of failure (should this package become unavailable or significantly change).\nIn the last chapter, we moved and documented the standalone app function (movies_app()) in the R/ folder. The app.R file now only contains the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nIdeally, we’ll want to replace these calls to libary(), but first we have to make sure the functions we’re using in these packages will be available in moviesApp.\nWhen we run the contents of app.R, we see the following:\n&gt; library(moviesApp)\n&gt; # pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n&gt; # install.packages(pkgs, quiet = TRUE)\n&gt; \n&gt; # packages ------------------------------------\n&gt; library(shiny)\n&gt; library(shinythemes)\n&gt; library(stringr)\n&gt; library(ggplot2)\n&gt; library(rlang)\n&gt; \n&gt; # movies_app ------------------------------------\n&gt; movies_app()\nError in movies_app() : could not find function \"movies_app\"\nWhy can’t R find the \"movies_app\" function in app.R?\nLet’s recap what we’ve done so far:\n\n\n\napp.R\n\napp.R loads the necessary packages and calls movies_app()\n\n\n\n\nmoviesApp/\n    └── app.R\n\n\n\n\n\n\nR/\n\nThe R/movies_app.R file contains the code and documentation for movies_app()\n\n\n\n\nmoviesApp/\n    └── R/\n        └── movies_app.R\n\n\n\n\n\n\nman/\n\nroxygen2 is generating the man/movies_app.Rd file\n\n\n\n\nmoviesApp/\n    └── man/\n          └── movies_app.Rd"
  },
  {
    "objectID": "dependencies.html#sec-depends-exports",
    "href": "dependencies.html#sec-depends-exports",
    "title": "6  Dependencies",
    "section": "6.1 Exports",
    "text": "6.1 Exports\nThe error above is telling us that despite having documentation for movies_app() in the R/ folder and generating the corresponding .Rd file in man/, movies_app() isn’t being exported from moviesApp.\nThe exact cause of the error above becomes more apparent when we try to explicitly namespace movies_app() from moviesApp:\n\nmoviesApp::movies_app()\n\nError: 'movies_app' is not an exported object from 'namespace:moviesApp'\n\n\nLaunch app with the shinypak package:\n\nlaunch('06.1_pkg-exports')\n\nTo make the movies_app() function available to users of our package, we need to export it. We export functions by including the @export tag in the roxygen2 comment block (above the function we want to export):\n\n@export: The function name (my_func) is not required.\n\n#' @export my_func \n#' my_func &lt;- function() {\n#' \n#' }\n\n\nRead more here\n\n\n\n6.1.1 Exporting movies_app()\nLet’s start by exporting the movies_app() function from moviesApp by placing the @export tag above the function in R/movies_app.R:\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return Shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#' @export\n#' \nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nIn app.R, we’ll replace the calls to library() with a single call to library(moviesApp)\n\n# packages ------------------------------------\nlibrary(moviesApp)\n\n# movies_app ------------------------------------\nmovies_app()\n\nWe’ll load, document, and install the package to generate the NAMESPACE changes:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nNow, when we run the code app.R, we see the following:\n\n\n\nmovies_app()\n\n\n\n\nWe’ve lost the Shiny icon (www/shiny.png) in the UI, but we’ll address this in the inst/ & www/ chapter.\nmovies_app() launches our application!\n\n\nThe NAMESPACE file now contains a single export (movies_app), and when we enter moviesApp:: in the Console, we see the movies_app() function help file in the tab completion.\n\n\n\n\n\n\n\n\n(a) updated NAMESPACE\n\n\n\n\n\n\n\n(b) moviesApp namespace\n\n\n\n\nFigure 6.1: The movies_app() is now part of the moviesApp namespace\n\n\n\n\n\n6.1.2 What @export does\nWe’ll pause here to notice a few things about what @export does. After loading, documenting, and installing moviesApp, the NAMESPACE is updated with export(movies_app), and the Console automatically calls library(moviesApp).\nls() returns “the names of the objects in the specified environment, so we can use it to confirm the movies_app() function is the only export from moviesApp:\n\nls(name = \"package:moviesApp\")\n\n[1] \"movies_app\"\n\n6.1.2.1 The search() list\nlibrary(moviesApp) attaches moviesApp to the search list. We can view all the attached packages in the string returned from search():\n\"package:moviesApp\" %in% search()\n[1] TRUE\nWhat about the functions from add-on packages movies_app() relies on, like ggplot2?\nLet’s check to see if ggplot2 is also attached to the search() list:\n\nc(\"package:ggplot2\") %in% search()\n\n[1] FALSE\nWhy does this matter? Because if these packages aren’t attached to the search() list, we can’t call their functions the way we would if we’d used library().\nFor example, if we try to use ggplot2 to build a plot (similar to the one we have in the app), we see the following:\n\nggplot(data = mtcars, \n  aes(x = disp, y = mpg)) + \n  geom_point()\n\nError in ggplot(data = mtcars, \n              aes(x = disp, y = mpg)) : \n  could not find function \"ggplot\"\nIf we want to use functions from the packages moviesApp relies on, we need to explicitly namespace these functions from their original package namespaces (i.e., pkg::fun()):\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nWe can use ggplot2 if we explicitly namespace it’s functions\n\n\n\n\n\n\n\n\n\n\n\nAccessing add-on package functions\n\n\n\n\n\n\nWhen a user loads moviesApp with library(moviesApp), any add-on package functions used in exports are available to users if they use pkg::fun() (or if they load the package themselves with library()).\n\n\n\n\nAccess to add-on package functions has implications for the other functions in moviesApp–for example, the scatter_plot() function uses ggplot2 functions. But we’re not exporting scatter_plot(), so when we attempt to run the examples, we see the following error:\n\n\n\n\n\n\n\n\n(a) Examples in scatter_plot()\n\n\n\n\n\n\n\n(b) Error in scatter_plot() examples\n\n\n\n\nFigure 6.2: Examples in scatter_plot() function without exporting\n\n\n\nExamples for ‘moviesApp::scatter_plot’\nThe message at the top of the Help pane is informative because it tells us that despite scatter_plot() being functional when we run movies_app(), it’s not part of the package namespace (and thus, not accessible to users in the help file).\n\n\n6.1.2.2 Exporting scatter_plot()\nLet’s add the @export tag to R/scatter_plot.R so it’s exported from moviesApp.\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n#' @export\n#' \n\nAfter loading, documenting, and installing moviesApp, the NAMESPACE is updated with the export() directive:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nThe contents of the updated NAMESPACE file are below (and moviesApp:: in the Console now displays the scatter_plot() help file in the tab completion):\n\n\n\n\n\n\n\n\n(a) @export the scatter_plot function\n\n\n\n\n\n\n\n(b) moviesApp::scatter_plot()\n\n\n\n\nFigure 6.3: scatter_plot() is now part of the moviesApp namespace\n\n\n\nBelow, we confirm users can access the help file for scatter_plot() and run the examples:\n\n\n\n\n\n(a) scatter_plot() examples\n\n\nFigure 6.4: Running examples in ?scatter_plot\n\n\n\n\n6.1.2.3 loadedNamespaces()\nWe’ve already confirmed that ggplot2 isn’t attached with moviesApp (and hence, it is not included in the search() list)\n\nc(\"package:ggplot2\") %in% search()\n\n[1]  FALSE\nHowever, we can access the functions we used the pkg::fun() syntax with because those functions are included in the loaded namespaces (which we can view with loadedNamespaces())\n\nc(\"ggplot2\") %in% loadedNamespaces()\n\n[1] TRUE\n\n\n\n\n\n\nAccessing non-exported functions\n\n\n\n\n\n\nWhat about functions that aren’t exported from moviesApp?\nFunctions that are not exported (i.e., do not include the @export tag) are still accessible after installing and loading a package using the pkg:::fun()\n\n\n\n\n\n\n\n6.1.3 What to @export\n\n‘Always err on the side of caution, and simplicity. It’s easier to give people more functionality than it is to take away stuff they’re used to’ - What to export, R Packages, 2ed\n\nWhen determining which functions to export, consider the question: “When a user installs and loads moviesApp, what functions do I want to be available?”\nIn app-packages, I take the following general approach:\n\nStart by exporting only the standalone app function (movies_app())\nSelectively export modules and/or functions that perform distinct tasks with potentially reusable functionality (i.e., generate specific UI components, perform data processing tasks, etc.).\n\nYou’ll rarely want to export everything, but it might be helpful if the primary audience for your app-package is other developers within your organization. See the Low-key @exports with @keywords internal box below for exporting functions without including them in your package index.\n\n\n\n\n\n\nLow-key @exports with @keywords internal\n\n\n\n\n\n\nIf you’d like function to be exported, but not listed in the package index, you can combine @export with @keywords internal. These should be used in combination,\n#' @export\n#' \n#' @keywords internal\nFor example, adding @export and @keywords internal to R/scatter_plot.R will make the function accessible to users:\n\n\n\n\n\nAnd include the help file:\n\n\n\n\n\nHowever, if a user were to click on the Index for moviesApp (at the bottom of the help file)\n\n\n\n\n\nscatter_plot is not listed:"
  },
  {
    "objectID": "dependencies.html#sec-depends-imports",
    "href": "dependencies.html#sec-depends-imports",
    "title": "6  Dependencies",
    "section": "6.2 Imports",
    "text": "6.2 Imports\n\n\nLaunch app with the shinypak package:\n\nlaunch('06.2_pkg-imports')\n\nManaging imports is slightly more involved than exports because imported dependencies can live in DESCRIPTION and the NAMESPACE:\n\nThe DESCRIPTION file handles package-level dependencies, specifying which add-on packages our app-package uses.\nThe NAMESPACE manages function-level access, importing functions from add-on packages to be used in our app-package, and–as we’ve seen above–exporting functions from our app-package for others to use.\n\n\n6.2.1 Package-level depencencies\nThe DESCRIPTION file manages dependencies with three fields: Depends, Imports, and Suggests. 2\n\n6.2.1.1 Depends\nPackages listed under Depends are essential for our app-package to work. These packages will be attached before our package when library(moviesApp) is called.\n\n\n6.2.1.2 Imports\nPackages listed under Imports are necessary for our app-package to work. These packages are loaded (but not attached) when our app-package is installed.\n\nMost add-on packages belong under the Imports field (i.e., functions from these packages are used in the code below R/).\n\n\n\n6.2.1.3 Suggests\nThe Suggests field should include any packages that enhance our app-package, but aren’t necessary for the basic functionality. This might include packages used in examples, vignettes, tests, etc.\n\n\n\n6.2.2 Function-level access\nFunction-level access is managed using namespace-qualified references (or ‘explicit namespacing’) in the code below R/. The NAMESPACE can also be used to include add-on packages or functions with the @import and @importFrom tags.3\n\n6.2.2.1 pkg::fun()\nRefer to add-on package functions using pkg::fun() syntax in the code below R/.\n\n\n6.2.2.2 @importFrom\n@importFrom should be used when 1) “You can’t call an operator from another package via ::” 2) “importing a function makes your code much more readable” (not easier to write)\n\n\n6.2.2.3 @import\n@import should be used if “you make such heavy use of so many functions from another package that you want to import its entire namespace”\n\n\n\n6.2.3 Imports in moviesApp\nThe workflow I use to manage add-on dependencies comes from the advice in the roxygen2 documentation.4\n\nInclude the add-on package to the Imports field with usethis::use_package()\nRefer to add-on functions using explicit namespacing (i.e., pkg::fun()) in the code beneath R/\n\nWe have some special considerations for the imports in moviesApp:\n\nA substantial portion of the code in moviesApp comes from shiny, so we’ll remove the explicit namespacing and place the @import tag in R/movies_app.R5\n\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shinyApp()`\n#'\n#' @return Shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#' \n1#' @import shiny\n#'\n#' @export \n#' \n\n\n1\n\nImport entire shiny package namespace\n\n\n\n\n\n.data can’t be exported using ::, so we’ll include @importFrom for the use of .data in R/scatter_plot.R\nThe ggplot2 package has over 400 functions, so we don’t want to import the entire package with @import. Adding the package to the Imports field and using namespace-qualified references.6\n\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `moviesApp()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n1#' @importFrom rlang .data\n#' \n#' @export\n#' \n\n\n1\n\nImport a the .data operator from rlang\n\n\n\n\n\nAfter adding all add-on packages to the DESCRIPTION with usethis::use_package(), then deciding if/where to use @importFrom and @import, we’ll load, document, and install moviesApp:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nWhen we review the updated NAMESPACE and DESCRIPTION files, we should see the following:\n\n\n\n\n\n\n\n(a) Updated NAMESPACE with @import and @importFrom\n\n\n\n\n\n\n\n(b) Updated DESCRIPTION with all Imports\n\n\n\n\nFigure 6.5: roxygen2 will update the NAMESPACE, but usethis::use_package() is needed to update the DESCRIPTION\n\n\nWhen we run movies_app(), we see the application launches and we can still run the scatter_plot() examples:\n\n\n\n\n\n\n\n(a) movies_app() works\n\n\n\n\n\n\n\n(b) Examples in ?scatter_plot\n\n\n\n\nFigure 6.6: Confirming we still have full functionality in moviesApp\n\n\n\n\n6.2.4 What happened in moviesApp?\nThe figure below attempts to capture some of confusion between the dependencies listed in the NAMESPACE and the Imports field in the DESCRIPTION file.7\n\n\n\n\n\n(a) roxygen2 does not connect the NAMESPACE to the DESCRIPTION\n\n\nFigure 6.7: devtools::document() (or Ctrl/Cmd + Shift + D) updates the NAMESPACE with any @import, @importFrom or @export tags. However, no changes are made to the DESCRIPTION file.\n\n\nLet’s confirm we’re still only exporting movies_app() and scatter_plot() from moviesApp:\n\nls(name = \"package:moviesApp\")\n\n[1] \"movies_app\"   \"scatter_plot\"\nGreat. Now we’ve listed five packages in the Imports field of the DESCRIPTION file:\nImports: \n    ggplot2,\n    rlang,\n    shiny,\n    shinythemes,\n    stringr\n\n6.2.4.1 The search() list\nAre these packages on the search list?\n\npkgs &lt;- c(\"package:ggplot2\", \"package:rlang\", \n          \"package:shiny\", \"package:shinythemes\", \n          \"package:stringr\")\npkgs %in% search()\n\n[1] FALSE FALSE FALSE FALSE FALSE\nThis demonstrates that none of these packages are attached with moviesApp. However, the rlang and shiny packages are included in the loadedNamespaces() (because we included them with @import/@importFrom).\n\npkgs &lt;- c(\"ggplot2\", \"rlang\", \"shiny\", \n          \"shinythemes\", \"stringr\")\npkgs %in% loadedNamespaces()\n\n[1] FALSE  TRUE  TRUE FALSE FALSE\nWe can still access the add-on package functions in moviesApp using the pkg::fun() syntax:\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nggplot2 functions are still available if we explicitly namespace"
  },
  {
    "objectID": "dependencies.html#more-information-on-imports",
    "href": "dependencies.html#more-information-on-imports",
    "title": "6  Dependencies",
    "section": "6.3 More information on imports",
    "text": "6.3 More information on imports\nI’ve provided a handful of useful tips on package imports below:\nHow can I include an add-on package to my DESCRIPTION file?\n\nusethis::use_package() automatically adds a package in the Imports section, and has options for specifying the minimum version\n\nWill users of my app-package have access to the packages listed in the Imports field of my DESCRIPTION file?\n\nlibrary(moviesApp) loads the namespace of imported packages, but they are not attached to the search() path8\n\nHow can I tell the difference between functions written by a package author and imported functions in the code below R/?\n\nUsing pkg::fun() makes calls to add-on packages explicit and easy to differentiate from the native functions developed in moviesApp9\n\nWhat does the NAMESPACE do when my package is installed by a user?\n\nManaging the NAMESPACE ensures your app-package works when it’s installed and loaded on another machine, because R will read your package namespace to find what it imports and exports10\n\nWhere should I place the @importFrom tag in the code below R/?\n\nPlace the @importFrom pkg fun tag directly above the code using the add-on function.\nYou can also consolidate all @import and @importFrom tags into a single package doc file (i.e., R/[moviesApp]-package.R) by calling usethis::use_package_doc().\n\nShould I be using @importFrom or @import from?\n\nPrefer @importFrom over @import (but try to avoid using either 11 12)\n\nWhere can I find more information about package namespaces and imports?\n\nImports are described briefly in R Packages, 2ed13 and covered in-depth in Advanced R, 2ed14 \n\n“Each namespace has an imports environment that can contain bindings to functions used by the package that are defined in another package.”\n\n“The imports environment is controlled by the package developer with the NAMESPACE file. Specifically, directives such as importFrom() and imports() populate this environment”\n\n\nIn order for app-package to work, users needs to have access to any add-on packages that are called in the code below R/. Knowing when, why, how and what happens to imports helps you decide how to fit these habits into your package development workflow."
  },
  {
    "objectID": "dependencies.html#checking-dependencies",
    "href": "dependencies.html#checking-dependencies",
    "title": "6  Dependencies",
    "section": "6.4 Checking dependencies",
    "text": "6.4 Checking dependencies\nWith all the moving parts in dependency management, it can be easy to forget if you’ve documented everything correctly. So far we haven’t covered using devtools::check() as part of your app-package habits (which is fine), but this is one area it’s particularly helpful.\nFor example, if I had listed shiny as an import using the @import tag (resulting in the import(shiny) directive in the NAMESPACE), devtools::check() would produce the following error:\n── R CMD check results ────────────────────────── moviesApp 0.0.0.9000 ────\nDuration: 7.4s\n\n❯ checking package dependencies ... ERROR\n  Namespace dependency missing from DESCRIPTION Imports/Depends entries: ‘shiny’\n  \n  See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’\n  manual.\n\n1 error ✖ | 0 warnings ✔ | 0 notes ✔\nError: R CMD check found ERRORs\nExecution halted\n\nExited with status 1."
  },
  {
    "objectID": "dependencies.html#recap",
    "href": "dependencies.html#recap",
    "title": "6  Dependencies",
    "section": "6.5 Recap",
    "text": "6.5 Recap\nBelow are the main takeaways from managing the imports and exports from your app-package:\n\n\n\n\n\n\nDependencies recap\n\n\n\n\n\n\nThis chapter covered:\n\nExports: Aim for a balance between simplicity and utility when deciding which functions to export (i.e., what functions should be available to users who install your package). Export objects from using @export\nImports: Use pkg::fun() syntax when you use add-on package functions and include them in the Imports field of the DESCRIPTION file. App-packages use so many shiny functions it makes sense to include @import shiny to 1) ensure all of these functions are available, and 2) you won’t need to use pkg::fun().\n\nDESCRIPTION Imports This field lists the packages your app-package uses. All add-on packages used in the R/ folder must be listed in the Imports field. These functions can be called using the pkg::fun() syntax (or with @importFrom()). Functions from these packages will be available for your package, but not for the user unless they use the :: operator or load the package themselves with library().\nNAMESPACE imports: The @import/@importFrom tags make the functions from add-on packages available to your package. Favor using @importFrom over @import for add-on package functions (the only exception being shiny, which you’d want to use @import).\n\n\nThe Imports field in the DESCRIPTION handles package-level dependencies (and it is managed manually or with usethis::use_package()), while the NAMESPACE handles function-level access (with @export and @import/@importFrom).\n\n\n\n\nIf you’d like to read more about package dependencies, I recommend Writing R Extensions (specifically the sections on dependencies 15 and namespaces 16).\nIn the next section, we’ll cover how the ensure the app.R file runs our application!"
  },
  {
    "objectID": "dependencies.html#footnotes",
    "href": "dependencies.html#footnotes",
    "title": "6  Dependencies",
    "section": "",
    "text": "I’ve made this process somewhat easier by explicitly namespacing all of the add-on package functions in moviesApp (i.e., with pkg::fun()).↩︎\nAdditional fields exists (i.e., Remotes), but these are special circumstances.↩︎\nRead more about this in the section titled, ‘In code below R/’ in R Packages, 2ed↩︎\n“if you are using just a few functions from another package, we recommending adding the package to the Imports: field of the DESCRIPTION file and calling the functions explicitly using ::, e.g., pkg::fun()”…“If the repetition of the package name becomes annoying you can @importFrom and drop the pkg::fun()”. Read more in the Importing functions section on the package website:↩︎\nUsing @import is not generally considered best practice, but it makes sense for app-packages: …for Shiny apps, I recommend using @import shiny to make all the functions in the Shiny package easily available. Mastering Shiny, R CMD check”↩︎\nRead more about using ggplot2 in packages in the section titled, ‘Referring to ggplot2 functions’↩︎\nSee the section titled, ‘Confusion about Imports’ in R Packages, 2ed, “Listing a package in Imports in DESCRIPTION does not ‘import’ that package.”↩︎\nUsers can access functions from add-on packages with the pkg::fun syntax↩︎\n“Our recommended default is to call external functions using the package::function() syntax” - R Packages, 2ed↩︎\nThe namespace controls the search strategy for variables used by functions in the package. If not found locally, R searches the package namespace first, then the imports, then the base namespace and then the normal search path (so the base namespace precedes the normal search rather than being at the end of it). - Writing R Extensions↩︎\n“Using importFrom selectively rather than Imports is good practice and recommended notably when importing from packages with more than a dozen exports and especially from those written by others (so what they export can change in future).” - Specifying imports and exports.↩︎\n“Specifically, we recommend that you default to not importing anything from [add-on packages] into your namespace. This makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future. This also eliminates any concerns about name conflicts between [add-on packages] and your package.” - R Packages, 2ed↩︎\nSee the Function lookup inside a package section of R Packages, 2ed↩︎\nSee the Package environments and the search path of Advanced R, 2ed↩︎\nSee section 1.1.3 Package Dependencies in Writing R Extensions↩︎\nSee section 1.5, Package namespaces in Writing R Extensions↩︎"
  },
  {
    "objectID": "data.html#app-package-data",
    "href": "data.html#app-package-data",
    "title": "7  Data",
    "section": "7.1 App-package data",
    "text": "7.1 App-package data\nData in R packages are typically stored in one of three folders: data/, data-raw/, and inst/extdata/. The folder you use will depend on the format, accessibility, and intended purpose of the data file.1"
  },
  {
    "objectID": "data.html#sec-data-data",
    "href": "data.html#sec-data-data",
    "title": "7  Data",
    "section": "7.2 The data/ folder",
    "text": "7.2 The data/ folder\nThe primary location for data is the data/ folder. Objects in data/ folder are available in your package namespace when it’s installed and loaded, and can be accessed with the :: syntax. See the example below of the storms data from dplyr:\n\nlibrary(dplyr)\nhead(dplyr::storms)\n## # A tibble: 6 × 13\n##   name   year month   day  hour   lat  long status\n##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; \n## 1 Amy    1975     6    27     0  27.5 -79   tropi…\n## 2 Amy    1975     6    27     6  28.5 -79   tropi…\n## 3 Amy    1975     6    27    12  29.5 -79   tropi…\n## 4 Amy    1975     6    27    18  30.5 -79   tropi…\n## 5 Amy    1975     6    28     0  31.5 -78.8 tropi…\n## 6 Amy    1975     6    28     6  32.4 -78.7 tropi…\n## # ℹ 5 more variables: category &lt;dbl&gt;, wind &lt;int&gt;,\n## #   pressure &lt;int&gt;,\n## #   tropicalstorm_force_diameter &lt;int&gt;,\n## #   hurricane_force_diameter &lt;int&gt;\n\n\n7.2.0.1 LazyData\nData files become part of a package when they’re added to the data/ folder and LazyData: true is added to the DESCRIPTION file.\n\nLazyData: true: the data is only loaded into memory if it is explicitly accessed by the user or a function in the package. Until then, only the dataset names is loaded. This practice user-friendly and is the default for most R packages.\nLazyData: false (or omitted): accessing a data file from the package requires explicitly loading it using the data() function.\n\nFiles in data/ should be in the .rda or .RData format. Below are the steps for adding movies to moviesApp:\n\nMove the movies.RData file into a newly created the data/ folder:\n\n\nmoviesApp/\n    └──data/\n        └── movies.RData\n\n\nInclude LazyData: true in the DESCRIPTION file (I’ve added it above Imports:):\n\n\nPackage: moviesApp\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nLazyData: true\nImports:\n  shiny,\n  ggplot2,\n  rlang,\n  stringr,\n  tools\n\n\nLoad, document, and install.\n\nCtrl/Cmd + Shift + L\nℹ Loading moviesApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nDocumentation completed\nCtrl/Cmd + Shift + B\nIn the Build pane, you’ll notice a few new ** data lines of output after adding data:\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\nWe can check to see if movies has been included in moviesApp using the package::data syntax:\n\n\n\n\n\n(a) roxygen2\n\n\nFigure 7.1: movies is now part of moviesApp\n\n\n\n\n7.2.0.2 usethis::use_data()\nIf you’d prefer to store data using the .rda format, the usethis package has the use_data() function that will automatically store an object in data/ in the .rda format.\nTo use usethis::use_data(), we can load the movies data into the global environment with load(\"movies.RData\"), then run usethis::use_data(movies):\n\nusethis::use_data(movies)\n\n✔ Setting active project to '/path/to/moviesApp'\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Saving 'movies' to 'data/movies.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nThe Depends: field is added to the DESCRIPTION file with an R version (this ensures the data files will be loaded)\nDepends: \n    R (&gt;= 2.10)\n(this function will also add LazyData: true to the DESCRIPTION)\n\n\n7.2.1 Documenting data/\nDocumenting data can be tedious, but it’s worth the effort if you’ll be sharing your package with collaborators. There are multiple ways to store dataset documentation. A common approach is to create a data.R file in the R/ folder.2\n\nfs::file_create(\"R/data.R\")\n\nIn data.R, we provide a @title, @description, and @details for the data (with or without the tags), followed by @format:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)   \n#'\n#' @format\n\n\n7.2.1.1 @format\nThe text following @format is a one-sentence description of the data (with it’s dimensions).\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#' \n#' @format A data frame with [] rows and [] variables:\n\n\n\n7.2.1.2 \\describe & \\item\nEach variable (column) in the data is documented with a combination of \\describe and \\item (pay close attention to the curly brackets):\n\n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n\nAfter closing the curly brackets in \\describe, place the name of the data in quotes (\"movies\") on the following line.\nBelow is the documentation for the first five columns in the movies dataset:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#' }\n#'\n\"movies\"\n\nIf we load and document moviesApp, we can see a preview of the help file:\nCtrl/Cmd + Shift + L\nℹ Loading moviesApp\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating moviesApp documentation\nℹ Loading moviesApp\nWriting movies.Rd\nDocumentation completed\n\n?movies\n\n\n\n\n\n\n(a) The movies help file\n\n\nFigure 7.2: Documentation for the movies dataset\n\n\nI’ve provided documentation for the full movies dataset below.\n\n\nshow/hide full movies data documenation\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#'  \\item{studio}{name of studio, chr}\n#'  \\item{thtr_rel_date}{Theatre release date, POSIXct, min = 1970-05-19 21:00:00, max = 2014-12-24 21:00:00}\n#'  \\item{thtr_rel_year}{Theatre release year, num, min = 1970, max = 2014}\n#'  \\item{thtr_rel_month}{Theatre release month, num, min = 1, max =12}\n#'  \\item{thtr_rel_day}{Theatre release day, num, min = 1, max =31}\n#'  \\item{dvd_rel_date}{DVD release date, POSIXct, min = 1991-03-27 21:00:00, max = 2015-03-02 21:00:00}\n#'  \\item{dvd_rel_year}{DVD release year, num, min = 1991, max = 2015}\n#'  \\item{dvd_rel_month}{DVD release month, num, min = 1, max = 12}\n#'  \\item{dvd_rel_day}{DVD release day, num, min = 1, max = 31}\n#'  \\item{imdb_rating}{Internet movie database rating, avg = 6.49, sd = 1.08}\n#'  \\item{imdb_num_votes}{Internet movie database votes, avg = 57533, sd = 112124}\n#'  \\item{critics_rating}{Rotten tomatoes rating, fct (Certified Fresh, Fresh, Rotten)}\n#'  \\item{critics_score}{Rotten tomatoes score, avg = 57.7, sd = 28.4}\n#'  \\item{audience_rating}{Audience rating, fct (Spilled, Upright)}\n#'  \\item{audience_score}{Audience score, avg = 62.4, sd = 20.2}\n#'  \\item{best_pic_nom}{Best picture nomination, fct (no, yes)}\n#'  \\item{best_pic_win}{Best picture win, fct (no, yes)}\n#'  \\item{best_actor_win}{Best actor win, fct (no, yes)}\n#'  \\item{best_actress_win}{Best actress win, fct (no, yes)}\n#'  \\item{best_dir_win}{Best director win, fct (no, yes)}\n#'  \\item{top200_box}{Top 20 box-office, fct (no, yes)}\n#'  \\item{director}{Name of director, chr}\n#'  \\item{actor1}{Name of leading actor, chr}\n#'  \\item{actor2}{Name of supporting actor, chr}\n#'  \\item{actor3}{Name of #3 actor, chr}\n#'  \\item{actor4}{Name of #4 actor, chr}\n#'  \\item{actor5}{Name of #5 actor, chr}\n#'  \\item{imdb_url}{IMDB URL}\n#'  \\item{rt_url}{Rotten tomatoes URL}\n#' }\n#'\n\"movies\"\n\n\n\n\n\n7.2.2 Using movies\nAfter documenting the movies data in data.R, we’ll remove the call to load() in the mod_scatter_display_server() function and replace it with a direct call to the dataset:\n\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n\n  inputs &lt;- reactive({\n    plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n  })\n  output$scatterplot &lt;- renderPlot({\n    plot &lt;- scatter_plot(\n1      df = movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size\n    )\n    plot +\n      ggplot2::labs(\n        title = inputs()$plot_title,\n        x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n        y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n      ) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n})\n}\n\n\n1\n\nThe movies data from our package namespace\n\n\n\n\nAfter loading, documenting, and installing the package, we see the following application:\n\n\n\n\n\n\n(a) movies_app() with movies data file\n\n\nFigure 7.3: moviesApp::movies in movies_app()\n\n\n\n\n7.2.2.1 More data/ examples\nTo illustrate other options for data documentation, we’ll use the dplyr package. dplyr stores its data in the data/ folder:\ndata/\n├── band_instruments.rda\n├── band_instruments2.rda\n├── band_members.rda\n├── starwars.rda\n└── storms.rda\nThe documentation for the datasets in dplyr are stored in R/ using a data- prefix:\nR/\n├── data-bands.R\n├── data-starwars.R\n└── data-storms.R\nThe three band_ datasets have documented in a single file, data-bands.R:\n\n\nshow/hide documentation for dplyr::band_ datasets\n# from the dplyr github repo: \n# https://github.com/tidyverse/dplyr/blob/main/R/data-bands.R\n# \n#' Band membership\n#'\n#' These data sets describe band members of the Beatles and Rolling Stones. They\n#' are toy data sets that can be displayed in their entirety on a slide (e.g. to\n#' demonstrate a join).\n#'\n#' `band_instruments` and `band_instruments2` contain the same data but use\n#' different column names for the first column of the data set.\n#' `band_instruments` uses `name`, which matches the name of the key column of\n#' `band_members`; `band_instruments2` uses `artist`, which does not.\n#'\n#' @format Each is a tibble with two variables and three observations\n#' @examples\n#' band_members\n#' band_instruments\n#' band_instruments2\n\"band_members\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments2\"\n\n\nIn the example above, note that two of the datasets (band_instruments and band_instruments2) have the @format set to NULL, and define the help search name with @rdname. The @examples tag can be used to view the dataset when users click ‘Run Examples’\nEither method works–what’s important is that each dataset in your package has documentation.\n\n\n\n\n\n\nDocumenting data in data/\n\n\n\n\n\nDocumenting data requires the following roxygen2 structure:\n#' \n#' @title single-sentence describing [data]\n#' \n#' @description\n#' Single-paragraph describing [data]\n#' \n#' @format [data] number of rows and columns:\n#' \\describe{\n#'  \\item{variable}{description}\n#'  \\item{variable}{description}\n#' }\n#'\n\"[data]\"\nReplace [data] with the name of your dataset."
  },
  {
    "objectID": "data.html#sec-data-data-raw",
    "href": "data.html#sec-data-data-raw",
    "title": "7  Data",
    "section": "7.3 The data-raw/ folder",
    "text": "7.3 The data-raw/ folder\nThe data-raw folder is not an official directory in the standard R package structure, but it’s a common location for any data processing or cleaning scripts, and the raw data file for datasets stored in data/.3\n\n\n\n\n\n\nScripts for creating movies data\n\n\n\n\n\n\nThe code used to produce the movies dataset in the data/ directory might* come from this GitHub repo. If so, the data-raw folder is where the data processing and preparation scritps would be stored (along with a copy of the data in .csv format) before saving a copy in the data/ folder.\n*I say ‘might’ because it’s not clear if the movies.RData is the output from these .R files (although many of the column names match).\n\n\n\n\n\n7.3.1 More data-raw/ examples\nIf we look at the data in the dplyr package again, we can see the data-raw/ folder contains a combination of .R and .csv files:\ndata-raw/\n├── band_members.R\n├── starwars.R\n├── starwars.csv\n└── storms.R\n\n1 directory, 4 files\nIn this example, the starwars.R script downloads & prepares starwars, then saves a .csv copy of the data in data-raw."
  },
  {
    "objectID": "data.html#sec-data-inst-extdata",
    "href": "data.html#sec-data-inst-extdata",
    "title": "7  Data",
    "section": "7.4 The inst/extdata/ folder",
    "text": "7.4 The inst/extdata/ folder\nThe extdata folder (inside inst/) can be used for external datasets in other file formats (.csv, .tsv, .txt, .xlsx, etc).4 The data files in inst/extdata/ aren’t directly loadable using the package::data syntax or the data() function like with the data/ directory. These files can be imported using the file path accessor function, system.file().\nFor example, if we create the inst/extdata/ and save a copy of movies as a .fst file:\n\nlibrary(fs)\nlibrary(tibble)\nlibrary(fst)\n\n\nfst package v0.9.8\n\n\nfs::dir_create(\"inst/extdata/\")\nfst::write_fst(\n  x = movies, \n  path = \"inst/extdata/movies.fst\", \n  compress = 75)\n\n\nfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\n\nThen load, document, and install moviesApp:\nCtrl/Cmd + Shift + L / D / B\nWe can import movies.fst using system.file() to create a path to the file:\n\ntibble::as_tibble(\n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"moviesApp\")\n    )\n  )\n\n# A tibble: 651 × 34\n   title  title_type genre runtime mpaa_rating studio thtr_rel_date      \n   &lt;chr&gt;  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;  &lt;dttm&gt;             \n 1 Filly… Feature F… Drama      80 R           Indom… 2013-04-18 21:00:00\n 2 The D… Feature F… Drama     101 PG-13       Warne… 2001-03-13 21:00:00\n 3 Waiti… Feature F… Come…      84 R           Sony … 1996-08-20 21:00:00\n 4 The A… Feature F… Drama     139 PG          Colum… 1993-09-30 21:00:00\n 5 Malev… Feature F… Horr…      90 R           Ancho… 2004-09-09 21:00:00\n 6 Old P… Documenta… Docu…      78 Unrated     Shcal… 2009-01-14 21:00:00\n 7 Lady … Feature F… Drama     142 PG-13       Param… 1985-12-31 21:00:00\n 8 Mad D… Feature F… Drama      93 R           MGM/U… 1996-11-07 21:00:00\n 9 Beaut… Documenta… Docu…      88 Unrated     Indep… 2012-09-06 21:00:00\n10 The S… Feature F… Drama     119 Unrated     IFC F… 2012-03-01 21:00:00\n# ℹ 641 more rows\n# ℹ 27 more variables: thtr_rel_year &lt;dbl&gt;, thtr_rel_month &lt;dbl&gt;,\n#   thtr_rel_day &lt;dbl&gt;, dvd_rel_date &lt;dttm&gt;, dvd_rel_year &lt;dbl&gt;,\n#   dvd_rel_month &lt;dbl&gt;, dvd_rel_day &lt;dbl&gt;, imdb_rating &lt;dbl&gt;,\n#   imdb_num_votes &lt;int&gt;, critics_rating &lt;fct&gt;, critics_score &lt;dbl&gt;,\n#   audience_rating &lt;fct&gt;, audience_score &lt;dbl&gt;, best_pic_nom &lt;fct&gt;,\n#   best_pic_win &lt;fct&gt;, best_actor_win &lt;fct&gt;, best_actress_win &lt;fct&gt;, …\n# ℹ Use `print(n = ...)` to see more rows\nWe’ll cover inst/ and system.file() in more detail in the next chapter.\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 07_data branch of moviesApp."
  },
  {
    "objectID": "data.html#recap",
    "href": "data.html#recap",
    "title": "7  Data",
    "section": "7.5 Recap",
    "text": "7.5 Recap\nIt’s common for shiny apps to require data, so knowing how to store and access these files in your app-package will make it easier to load and reproducible in other environments. Here are a few other things to consider when including data in your app-package:\n\n\n\n\n\n\nRecap: Package data files\n\n\n\n\n\n\n\ndata/: All data files stored in data/ will be ‘lazy loaded’ (see below) when the package is installed and loaded.\nLoading: include the LazyData: true field in the DESCRIPTION file so the data is only loaded when it’s used (and it increases package loading speed).\nSize: large data files can inflate the size of your app-package, making it harder for users to download and install. CRAN also has a size limit for packages (if you plan on submitting your app-package).\nFormat: data files in data/ must be either .rda or .RData format.\nDocumentation: document the data files in either a single R/data.R file or individual .R files. Documentation should include the following roxygen2 format:\n#' \n#' @title \n#' \n#' @description\n#' \n#' @format \n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n#'\n'data'\ninst/extdata/: Store external data in the inst/extdata/ directory and access it using system.file(). This can be helpful if your app-package needs access to data files that are not R objects. For faster loading, consider the fst or feather formats."
  },
  {
    "objectID": "data.html#footnotes",
    "href": "data.html#footnotes",
    "title": "7  Data",
    "section": "",
    "text": "Read more about the data folder in the ‘Data in packages’ section of Writing R Extenstions and the ‘Data’ chapter of R Packages, 2ed.↩︎\nThe ggplot2 package has a great example of documenting datasets in the R/data.R file↩︎\nRead more about the data-raw folder in R Packages, 2ed↩︎\nRead more about the inst/extdata/ folder in R Packages, 2ed↩︎"
  },
  {
    "objectID": "launch.html#running-apps",
    "href": "launch.html#running-apps",
    "title": "8  Launch",
    "section": "8.1 ‘Running’ apps",
    "text": "8.1 ‘Running’ apps\nAs we can see in the image below, the Run App icon is available in the Source pane:\n\n\n\n\n\n(a) app.R in main branch\n\n\nFigure 8.1: Run App icon in app.R of main branch\n\n\nIf we load the code in R/ with load_all(), then click on Run App, we see this calls runApp() in the Console, but this also produces a warning:\n\n\n\n\n\n(a) Calling runApp() in main\n\n\nFigure 8.2: The application is launched (with the loadSupport() warning)\n\n\nLet’s jump further back to the 05_roxygen2 branch of moviesApp. This is the first version of the app-package with movies_app() in the R/ folder (see below).\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 05_roxygen2 branch of moviesApp.\n\n\nR/\n├── mod_scatter_display.R\n├── mod_var_input.R\n1├── movies_app.R\n├── movies_server.R\n├── movies_ui.R\n└── utils.R\n\n1 directory, 6 files\n\n\n1\n\nmovies_app() standalone function in R/ folder\n\n\n\n\nBy placing the call to shinyApp() into the R/ folder, we no longer have the Run App icon in the app.R file:\n\n\n\n\n\n(a) app.R in 05_roxygen2 branch\n\n\nFigure 8.3: No Run App icon in app.R of 05_roxygen2 branch\n\n\nIn the 05_roxygen2 branch, the movies_app() function hasn’t been exported, so we should expect the following error when we run the contents of app.R:\nError in movies_app() : could not find function \"movies_app\"\nHowever, calling runApp() from the Console still launches the app.\n\n\n\n\n\n(a) runApp() with 05_roxygen2 branch\n\n\nFigure 8.4: Calling runApp() in the Console of 05_roxygen2 branch"
  },
  {
    "objectID": "launch.html#loadsupport-warning",
    "href": "launch.html#loadsupport-warning",
    "title": "8  Launch",
    "section": "8.2 loadSupport() warning",
    "text": "8.2 loadSupport() warning\nThis behavior might be surprising to you–runApp() can launch the application in moviesApp, even without the standalone app function exported from the package namespace (but it still produces the loadSupport() warning).\n\n\n\n\n\n\nWarning in loadSupport\n\n\n\n\n\n\n\nshiny::runApp()\n\n\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL):\n  Loading R/ subdirectory for Shiny application, but this directory \n  appears to contain an R package. \n  Sourcing files in R/ may cause unexpected behavior.\n\n\n\n\n\nThe warning in the Console is telling us loadSupport() has detected that moviesApp is a package, but it’s still sourcing the R/ subdirectory.1\nThe examples above demonstrate the differences between calling shinyApp() and runApp(), and the tensions between having a standalone app function in an R package vs. having an app.R file in a Shiny project.\nIn the following sections, we’ll compare shinyApp(), shinyAppDir(), and runApp() to determine which one to use in R/movies_app.R and the app.R file."
  },
  {
    "objectID": "launch.html#shiny-launch-functions",
    "href": "launch.html#shiny-launch-functions",
    "title": "8  Launch",
    "section": "8.3 Shiny launch functions",
    "text": "8.3 Shiny launch functions\n\nshinyApp(), shinyAppDir(), or runApp()\nDuring development, the IDE provides the Run App icon for launching the application.\n\n\n\nThe Run App icon in the Source pane calls runApp())\n\n\nAs we’ve seen, Run App calls runApp(), even when we have a call to shinyApp() in the app.R file. This might make you wonder,\n“Why even include a call to shinyApp() if the app is being launched with runApp()?”\nLet’s review what happens when we call shinyApp(), shinyAppDir(), and runApp():\n\n8.3.1 shinyApp()\n\n\n\n\n\n\nshinyApp()\n\n\n\n\n\n\n\n\n\nshinyApp(): Creates and launches an app defined inline within the call itself (or with UI and server functions passed as arguments).\n\n\nshinyApp(\n  ui = fluidPage(\n    # UI elements\n  ),\n  server = function(input, output) {\n    # Server logic\n  }\n)\n\n\n\n\n\n\n\nOne of the key features of shinyApp() is the creation of the shiny.appobj (a shiny app object):\n\napp &lt;- shinyApp(ui = movies_ui, \n                server = movies_server)\nstr(app)\n\nIf we look at the structure of the returned object from shinyApp(), we see the shiny.appobj includes the appDir under appOptions:\n\nList of 5\n $ httpHandler     :function (req)  \n $ serverFuncSource:function ()  \n $ onStart         : NULL\n $ options         : list()\n $ appOptions      :List of 2\n1  ..$ appDir       : chr \"/path/to/moviesApp\"\n  ..$ bookmarkStore: NULL\n2 - attr(*, \"class\")= chr \"shiny.appobj\"\n\n\n1\n\nappDir is the first argument of runApp()\n\n\n2\n\nA shiny app object\n\n\n\n\nThis is why runApp() works with any .R file creating a shiny app object.\n\n\n8.3.2 shinyAppDir()\n\n\n\n\n\n\nshinyAppDir()\n\n\n\n\n\n\n\n\n\nshinyAppDir(): Launches an app from a directory (with an app.R or ui.R/server.R files).\n\n\nshinyAppDir(\n  appDir = \"path/to/app/\", \n  options = list())\n\n\n\n\n\n\n\nshinyAppDir() is similar to shinyApp(), but is designed to use a “path to directory that contains a Shiny app.”\nIn practice, we can use shinyAppDir() with a returned object from shinyApp():\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server\n      )\napp$appOptions$appDir\n\n\n[1] \"path/to/moviesApp\"\n\nThis path can be passed to the appDir argument (along with any shiny options).\n\nshinyAppDir(\n  appDir = app$appOptions$appDir,\n  options(test.mode = TRUE)\n)\n\n\n\n8.3.3 runApp()\n\n\n\n\n\n\nrunApp()\n\n\n\n\n\n\n\n\n\nrunApp(): A generalized way to launch your app–it can run apps defined inline, or from a directory.\n\n\nrunApp(\n  appDir = \"path/to/app/\",\n  test.mode = TRUE/FALSE)\n\n\n\n\n\n\n\nThe reason we’re able to call runApp() in the Console to launch both applications above is because it’s versatile:\n\n\n\nrunApp()\nCan launch an app from a directory (i.e., from ui.R/server.R, or a app.R):\n\n\nIn moviesApp\n# In console\nrunApp()\n\n\n\n\nWorks with a path to an .R file that creates a shiny.appobj:2\n\n\nrunApp(appDir = \"path/to/moviesApp\")\n\n\n\n\nCan also use a shiny.appobj directly:\n\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server)\nrunApp(appDir = app)\n\n\n\nThis final method does not produce the loadSupport() warning because a Shiny object (shiny.appobj) has already been created, and runApp() is essentially calling print(app) in the Console.\n\nRecap\nshinyApp() is typically used to create apps within an interactive R session, while shinyAppDir() runs a Shiny app stored in a directory (containing an app.R file (or ui.R and server.R files). runApp() also launches apps in a directory, but it’s versatility makes it suitable for running apps in various formats, either defined inline or in separate directories.3"
  },
  {
    "objectID": "launch.html#standalone-options",
    "href": "launch.html#standalone-options",
    "title": "8  Launch",
    "section": "8.4 Standalone options",
    "text": "8.4 Standalone options\nBelow I’ll cover some options to consider when writing a standalone app function.\n\n8.4.1 if (interactive())\nThe first thing we’ll include is a check to see if there is a “human operator to interact with” with base::interactive():\n\nif (interactive()) {\n  \n} else {\n   \n}\n\nYou have probably seen control flow like this in shiny help file examples (like flowLayout() below):\n\n\n\n\n\n(a) if (interactive()) in flowLayout() example\n\n\nFigure 8.5: Running examples ‘interactively’ let’s us see the app demo beneath the code\n\n\nif (interactive()) allows us to distinguish between launching the app from a Posit Workbench session (i.e., during development) and deploying the application (i.e., publishing the application on Posit Connect).\n\n\n8.4.2 options argument\nAn options argument can be passed to shinyApp() or shinyAppDir(). For example, one of the Shiny options we could include in our standalone app function is test.mode:\n\n‘Should the application be launched in test mode? This is only used for recording or running automated tests. Defaults to the shiny.testmode option, or FALSE if the option is not set.’\n\ntest.mode lets us export values from our application when we’re running tests (which we’ll cover in-depth in the Tests section).\nWe’ll make options an argument (defaulting to an empty list()) in our updated movies_app() function.\n\nmovies_app &lt;- function(options = list()) {\n    shinyApp(\n1      ui = movies_ui(),\n      server = movies_server,\n2      options = options\n      )\n}\n\n\n1\n\nBuild the shiny app object with movies_ui and movies_server\n\n\n2\n\nInclude options list\n\n\n\n\n\n\n8.4.3 shinyViewerType\nI’ve written display_type() helper function to control where the Shiny app is launched. The run argument in display_type() takes the following options:\n\n\"p\" = Viewer Pane\n\n\"w\" = IDE Window\n\n\"b\" = External browser\n\nThe option to access configuration is shiny.launch.browser:4\n\ndisplay_type &lt;- function(run = \"w\") {\n  if (run == \"p\") {\n    options(shiny.launch.browser = .rs.invokeShinyPaneViewer)\n  } else if (run == \"b\") {\n    options(shiny.launch.browser = .rs.invokeShinyWindowExternal) \n  } else if (run == \"w\") {\n    options(shiny.launch.browser = .rs.invokeShinyWindowViewer) \n  } else {\n    options(shiny.launch.browser = NULL)\n  }\n    shinyViewerType &lt;- getOption('shiny.launch.browser') |&gt; \n                        attributes() |&gt; \n                        unlist() |&gt; \n                        unname()\n    cli::cli_alert_info(\"shinyViewerType set to {shinyViewerType}\")\n}\n\n\nSet option\n\nGet option\n\nPrint option to console\n\nThe roxygen2 documentation for display_type() is below:\n\n\nshow/hide roxygen2 for R/display_type.R\n#' Shiny app display mode helper\n#'\n#' @param run where to launch app: \n#'  * `\"p\"` = launch in viewer pane \n#'  * `\"b\"` = launch in external browser  \n#'  * `\"w\"` = launch in window (default)\n#'\n#' @return notification of `shinyViewerType` option\n#' \n#' @export\n#'\n\n\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe cli package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('cli').\n\n\n\n\n\n\n8.4.4 Updated movies_app()\nIn movies_app(), I’ll add the interactive() check, display_type(), and test.mode option:\n\nmovies_app &lt;- function(options = list(), run = \"w\") {\n1  if (interactive()) {\n2    display_type(run = run)\n  }\n3    shinyApp(\n      ui = movies_ui(),\n      server = movies_server,\n      options = options\n    )\n}\n\n\n1\n\nCheck if interactive (Workbench) launch\n\n\n2\n\nSet shinyViewerType option with display_type()\n\n\n3\n\nLaunch app\n\n\n\n\nAfter loading, documenting, and installing the package, I can test my new standalone app function:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\n\n\n\n\n(a) updated movies_app() function\n\n\nFigure 8.6: The updated movies_app() function launches the application in the window (without the loadSupport() warning)\n\n\nNow we can see movies_app() is launching the application without the loadSupport() warning. We can also adjust the test and run arguments to see make sure these are implemented correctly:\n\n\n\n\n\n(a) test and run arguments in movies_app()\n\n\nFigure 8.7: Launching movies_app() in Viewer pane and test.mode"
  },
  {
    "objectID": "launch.html#sec-launch-app-dot-r",
    "href": "launch.html#sec-launch-app-dot-r",
    "title": "8  Launch",
    "section": "8.5 app.R options",
    "text": "8.5 app.R options\nYour app.R file should contain any options or settings that you’ll use during development. There are multiple ways to launch an application from app.R, and I encourage you to explore the options below to find a method that works for your workflow/environment.\n\n8.5.1 !interactive() == TRUE\nNon-interactive behaviors\nWhat if the session isn’t interactive?\nIn this case, we’ll divert all regular output to the standard error stream.\n\n\n8.5.2 stderr()\nThe sink() function “diverts R output to a connection”, so the code below sends the output that would normally print to the console to the where error messages are written.\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n} else {\n   \n}\n\nThis is useful in a non-interactive settings if we want to re-direct the error output for the console text-mode connection.\n\n\n8.5.3 tryCatch()\ntryCatch() is used for ‘catching conditions’ during the execution of an expression (expr =):\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(moviesApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   \n}\n\nIn this case, if library(moviesApp) throws an error, the function specified after error = is executed (i.e., pkgload::load_all()).5\nWritten this way, in a non-interactive R session, app.R will re-direct the error output and attempt to load and attach moviesApp, and if this fails, app.R will attempt to load all the files in the R/ folder.\n\n\npkgload\n\n\n\n\n\n\nNew dependency!\n\n\n\n\n\n\nThe pkgload package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('pkgload').\n\n\n\n\nIf the session is interactive (i.e., !interactive() == FALSE), we want app.R to load all the code in the R/ folder with pkgload::load_all().6\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(moviesApp)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   pkgload::load_all()\n}\n\n\n\n8.5.4 withr\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nThe withr package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('withr').\n\n\n\n\nThe withr package is designed to ‘run code with safely and temporarily modified global state’, and it comes in handy when launching shiny apps. For example, I want to turn off the loadSupport() behavior when launching the app from app.R.7\nI can use withr::with_options() to accomplish this using the following new and code arguments\n\nnew: a named list of the new options and their values\n\ncode: the ’Code to execute in the temporary environment\n\nI want to place the withr::with_options() at the top of app.R and pass contents of app.R into the code argument. Just to be sure no options for shiny.autoload.r previously exist, I’ll also set this option to NULL before executing the rest of the code.\n\n1withr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n2  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        library(moviesApp)\n      },\n      error = function(e) {\n        pkgload::load_all()\n      }\n    )\n3  } else {\n    pkgload::load_all()\n  }\n4    moviesApp::movies_app(\n      options = list(test.mode = TRUE), run = 'p')\n})\n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nDefine non-interactive behaviors\n\n\n3\n\nDefine interactive behaviors\n\n\n4\n\nLaunch app (with options)\n\n\n\n\nNow that we’ve updated the app.R account for the app-package structure, we should load, document, and install moviesApp and run it’s contents:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\n\n8.5.5 Updated app.R\nWhen we send the contents of app.R to the Console, the loadSupport() options are applied before running the app:\n\n\nLaunch app with the shinypak package:\n\nlaunch('08_launch-app')\n\n\n\n\n\n\n(a) Sending app.R to Console\n\n\nFigure 8.8: The application is launched without the loadSupport() warning\n\n\n\n\n\n\n\n\nR/_disable_autoload.R\n\n\n\n\n\n\nIn the documentation for loadSupport(), you’ll find a second option for removing the R/ directory sourcing behavior: placing a _disable_autoload.R file in the R/ directory (this is also one of the behaviors of the golem framework, which we will cover in the following chapters).\nBoth methods work–this chapter demonstrates a way to remove the loadSupport() warning without having to add this file."
  },
  {
    "objectID": "launch.html#deploying-the-app",
    "href": "launch.html#deploying-the-app",
    "title": "8  Launch",
    "section": "8.6 Deploying the app",
    "text": "8.6 Deploying the app\nTo deploy the app, I can click on the Publish icon:\n\n\n\n\n\n(a) Click on the Publish icon\n\n\nFigure 8.9: Send app.R to Console and click Publish\n\n\nMake sure all the files in the package are selected, then click Publish\n\n\n\n\n\n(a) Publishing apps to shinyapps.io\n\n\nFigure 8.10: Publish the entire package to shinyapps.io\n\n\nThe Deploy pane will open and you’ll see a deployment log as your application is sent to the server:\n\n\nshow/hide deployment log\n── Preparing for deployment ────────────────────────────────────────────────────\nℹ Creating application on server...\n✔ Created application with id 10026672\nℹ Bundling 24 files: .Rbuildignore, app.R, DESCRIPTION, launch.R, movies.RData, NAMESPACE, README.md, www/shiny.png, man/display_type.Rd, man/mod_scatter_display_server.Rd, man/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, man/mod_var_input_ui.Rd, man/movies_app.Rd, man/movies_server.Rd, man/movies_ui.Rd, man/scatter_plot.Rd, R/display_mode.R, …, R/movies_ui.R, and R/scatter_plot.R\nℹ Capturing R dependencies with renv\n✔ Found 63 dependencies\n✔ Created 258,028b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 7740376\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1340526445\n  building: Parsing manifest\n  building: Building image: 9212796\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9212796\n  deploying: Starting instances\n  rollforward: Activating new instances\n  unstaging: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://yourusername.shinyapps.io/app-name/&gt;\nDeployment completed: https://yourusername.shinyapps.io/app-name//\n\n\n\n8.6.1 Deploy log\nOn shinyapps.io, the deployment log shows the loadSupport() warning persists (but the application still deploys). The server-side warning is a known issue.8\n Container event from container-8858897: start\n Running on host: ec51aa0bf0bc\n Running as user: uid=10001(shiny) gid=10001(shiny) groups=10001(shiny)\n Connect version: 2023.09.0\n LANG: C.UTF-8\n Working directory: /srv/connect/apps/moviesApp\n Using R 4.3.1\n R.home(): /opt/R/4.3.1/lib/R\n Content will use current R environment\n R_LIBS: (unset)\n .libPaths(): /opt/R/4.3.1/lib/R/library\n shiny version: 1.7.5.1\n httpuv version: 1.6.12\n rmarkdown version: (none)\n knitr version: (none)\n jsonlite version: 1.8.7\n RJSONIO version: (none)\n htmltools version: 0.5.7.9000\n reticulate version: (none)\n Using pandoc: /opt/connect/ext/pandoc/2.16\n\n Starting R with process ID: '36'\n Shiny application starting ...\n Warning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL) :\n  Loading R/ subdirectory for Shiny application, but this directory appears to contain an R package. \n  Sourcing files in R/ may cause unexpected behavior.\n ℹ Loading moviesApp\n Running application in test mode.\n \n Listening on http://127.0.0.1:45567\n Container event from container-8858897: stop"
  },
  {
    "objectID": "launch.html#recap-1",
    "href": "launch.html#recap-1",
    "title": "8  Launch",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some options for launching your app within your app-package. We went over what to include in the standalone app function and the app.R file, the differences between shinyApp(), shinyAppDir() and runApp(), but it’s worth exploring these topics further (especially if you plan on having more than one apps in your package).\n\n\n\n\n\n\nRecap: launching your app\n\n\n\n\n\n\nshinyApp():\n\nshinyApp() doesn’t care about file structure, so it’s useful for quick prototyping or if the app is in a single .R script. It’s also more portable because you can share your app with a single .R script.\n\nIt’s possible to bundle shinyApp() in a wrapper function to integrate within an R package (like we’ve done with movies_app()).\nshinyApp() returns a shiny app object, which can be useful if you want to explore the app structure programmatically (i.e., testing).\n\n\nshinyAppDir():\n\nshinyAppDir() launches an app from a directory, and is useful if an app is spread across multiple files and folders.\n\nrunApp()\n\nrunApp() a more generalized way to launch an app. It works with:\n\napps contained in a directory (i.e., runApp('path/to/app')\napps in separate ui.R and server.R files (or a single app.R file)\na shiny app object (passed to the appDir argument).\n\nClicking on Run App will run the application with runApp() if is detects a file (or files) that creates a shiny object.\n\n\n\n\n\nIn the following chapter, we’re going to cover how to ensure movies.Data becomes part of the moviesApp namespace."
  },
  {
    "objectID": "launch.html#footnotes",
    "href": "launch.html#footnotes",
    "title": "8  Launch",
    "section": "",
    "text": "If you recall, we covered the loadSupport() function in Chapter 2.↩︎\nShiny’s examples are run using runApp()↩︎\nIt’s worthwhile to read the documentation on shinyApp(), shinyAppDir(), and runApp().↩︎\nThe shiny.launch.browser options are covered in this blog post by Garrick Aden-Buie, and I’ve combined them into a run argument in movies_app()↩︎\npkgload is part of the conscious uncoupling of the devtools package we learned about back in Chapter 6.↩︎\npkgload::load_all() is the function that’s actually called when we run devtools::load_all() (or use Ctrl/Cmd + Shift + L), and this is somewhat analogous to running library(moviesApp)↩︎\nYou can read more about the shiny.autoload.r option and loadSupport() in this article↩︎\nYou can learn more about this warning by reading these posts on StackOverflow (How can I deploy my shiny app as a package? Problem with directory when deploying app on shinyapps), and this post on Posit Community (Errors when deploying app on shinyapps.io).↩︎"
  },
  {
    "objectID": "external.html#external-files",
    "href": "external.html#external-files",
    "title": "9  External files",
    "section": "9.1 External files",
    "text": "9.1 External files\nWhen we launch our app using the standalone app function, we see the following:\n\nmovies_app(run = 'p')\n\n\n\n\n\n\n\n(a) movies_app() without logo\n\n\nFigure 9.1: www/shiny.png is not accessible when we launch the app\n\n\n\nThe shiny.png logo in www/ is not being loaded into the UI when the application is launched. Serving the contents of www was previously being handled automatically by the Shiny framework, but now that moviesApp is an R package, we’ll need to explicitly tell the application where to find these resources.1\n\n9.1.1 Package files\nWhile developing, we are used to interacting with our app-package from the Files pane:\n\n\n\n\n\n(a) ‘Source’ files moviesApp in Files pane\n\n\nFigure 9.2: The working directory of moviesApp\n\n\nHowever, when we run install() (or use Ctrl/Cmd + Shift + B), the output in the Build pane gives us the location of our installed package:\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source moviesApp\n\n1* installing to library ‘/path/to/installed/package/moviesApp/’\n* installing *source* package ‘moviesApp’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** inst\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE \n\n\n1\n\nThis is the location of the installed version of moviesApp\n\n\n\n\nOur app-package … installed\nIf we were to moviesApp to the path above, we’d see the files and folders in our installed package. Below are folder trees for our source package and our installed package:2\n\n\n\n\nsource/moviesApp/\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── data.R\n│   ├── display_type.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── movies_app.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   └── scatter_plot.R\n├── README.md\n├── app.R\n├── data\n│   ├── movies.RData\n│   └── movies.rda\n├── inst\n│   └── extdata\n│       └── movies.fst\n├── man\n│   ├── display_type.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── movies_app.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   └── scatter_plot.Rd\n├── moviesApp.Rproj\n└── www\n    └── shiny.png\n\n\n\n\ninstalled/moviesApp/\n├── DESCRIPTION\n├── INDEX\n├── Meta\n│   ├── Rd.rds\n│   ├── data.rds\n│   ├── features.rds\n│   ├── hsearch.rds\n│   ├── links.rds\n│   ├── nsInfo.rds\n│   └── package.rds\n├── NAMESPACE\n├── R\n│   ├── moviesApp\n│   ├── moviesApp.rdb\n│   └── moviesApp.rdx\n├── data\n│   ├── Rdata.rdb\n│   ├── Rdata.rds\n│   └── Rdata.rdx\n├── extdata\n│   └── movies.fst\n├── help\n│   ├── AnIndex\n│   ├── aliases.rds\n│   ├── moviesApp.rdb\n│   ├── moviesApp.rdx\n│   └── paths.rds\n└── html\n    ├── 00Index.html\n    └── R.css\n\n\n\n\nThe installed version of moviesApp has many of the same files as the ‘source’ version we’ve been working with (i.e., NAMESPACE and DESCRIPTION). It also might surprise you to see that many of the source files aren’t included in the installed version of moviesApp (.R, .Rd files. etc.).\nViewing the contents of your installed package should help demystify what happens when we run devtools::install() and give you a better idea of how system.file() works.3\n\n“The contents of the inst/ subdirectory will be copied recursively to the installation directory. Subdirectories of inst/ should not interfere with those used by R (currently, R/, data/, demo/, exec/, libs/, man/, help/, html/ and Meta/, and earlier versions used latex/, R-ex/).” - Writing R extensions, Package subdirectories\n\n\n\n9.1.2 system.file()\nsystem.file() gives us access to the package files on installation (i.e., the files we saw in the folder tree above). In the data chapter, we used system.file() to access the movies.fst file in inst/extdata/:\n\nfst::read_fst(\n  path = system.file(\"extdata/\", \"movies.fst\", \n                     package = \"moviesApp\")\n  )\n\nAs we can see, the movies.fst has two locations: the ‘source’ package location, and the ‘installed’ location.\n\n\n\nSource package files\ninst/\n  └── extdata/\n        └── movies.fst\n\n\nInstalled package files\n└── extdata/\n      └── movies.fst\n\n\n\nsystem.file() is accessing movies.fst from the installed location.4\nTo include the contents of www/ in our app-package, we’ll need to move www/ into inst/, then access it’s contents with system.file() and addResourcePath().\n\n\n9.1.3 addResourcePath()\nThe addResourcePath() function will add a “directory of static resources to Shiny’s web server.” In moviesApp, want to add the www directory that includes the shiny.png file.5\n\n\n\nCurrent www location\n├── inst\n│   └── extdata\n│       └── movies.fst\n└── www\n    └── shiny.png\n\n\n \n\n\n9.1.3.1 New www location\ninst/\n  ├── extdata/\n  │   └── movies.fst\n  └── www/\n      └── shiny.png\n\n\n\nIn R/movies_ui.R function, we’ll include the addResourcePath() at the top of the tagList() and reference the image in img() using only the subfolder in the path:\n\nmovies_ui &lt;- function() {\n  addResourcePath(\n1    prefix = 'www',\n2    directoryPath = system.file('www', package = 'moviesApp'))\n  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n3            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\n\n1\n\nPrefix (or folder name) of installed location\n\n\n2\n\nPath to installed package files\n\n\n3\n\nReference to installed package image file\n\n\n\n\nAfter loading, documenting, and installing, the application now includes the image file.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('09.1_inst-www')\n\n\nlibrary(moviesApp)\nmovies_app(run = 'p')\n\n\n\n\n\n\n\n(a) movies_app() with logo\n\n\nFigure 9.3: inst/www accessible with addResourcePath()\n\n\n\nApps in inst/\nThe inst/ folder can also be used to store files we’re using in alternate versions of our application. This can include alternate images, CSS styling, JS scripts, data files, or even entirely different apps!"
  },
  {
    "objectID": "external.html#sec-external-inst-bslib",
    "href": "external.html#sec-external-inst-bslib",
    "title": "9  External files",
    "section": "9.2 bslib layouts",
    "text": "9.2 bslib layouts\nWe can use inst/ to store alternative files and configure our UI function to test different layouts. In the example below, I’ve included a second optional UI layout from the bslib package in movies_ui().\n\n\nLaunch app with the shinypak package:\n\nlaunch('09.2_inst-bslib')\n\nThe bslib argument includes an alternate image file (stored in inst/www/bootstrap.png):\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nRemember to include the bslib and sass packages to your DESCRIPTION with usethis::use_package().\n\n\n\n\n\n\nshow/hide movies_ui()\nmovies_ui &lt;- function(bslib = FALSE) {\n1  addResourcePath(\n    prefix = 'www', \n    directoryPath = system.file('www', package = 'moviesApp'))\n  if (isFALSE(bslib)) {\n2  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n  } else {\n3    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            open = TRUE,\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n4                  img(src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\")\n              ),\n             bslib::card_body(\n               div(\n                 mod_scatter_display_ui(\"plot\")\n               )\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n\n1\n\nInclude inst/www resources\n\n\n2\n\nStandard fluidPage()\n\n\n3\n\nbslib layout\n\n\n4\n\nReference to alternate image (bootstrap.png)\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nThis alternate version of movies_app() uses the same modules and utility functions as the previous versions, but when bslib = TRUE, the app displays the alternate UI layout:\n\nmovies_app(run = 'p', bslib = TRUE)\n\n\n\n\n\n\n\n(a) movies_app() with logo\n\n\nFigure 9.4: inst/www/bootstrap.png image from movies_ui()\n\n\n\nThe example above was a simple, but using inst/ to hold alternate features (i.e., images or custom .html, .css, .sass, .js code) that can be easily displayed with an optional argument is a great tool for demonstrating features to users and stakeholders."
  },
  {
    "objectID": "external.html#sec-external-inst-dev",
    "href": "external.html#sec-external-inst-dev",
    "title": "9  External files",
    "section": "9.3 dev data",
    "text": "9.3 dev data\nIt’s not uncommon to be working on multiple ‘development’ versions of an application in the same package. In these situations, we might want to begin developing our application in the inst/dev folder:\n\n\nLaunch app with the shinypak package:\n\nlaunch('09.3_inst-dev')\n\n\ninst/dev/\n  ├── app.R\n  ├── tidy_movies.fst\n  └── imdb.png\n\n1 directory, 3 files\n\n\n9.3.1 tidy_movies data\nThe ‘development’ application in moviesApp uses a tidy version of the ggplot2movies::movies data, which we created in the data-raw/tidy_movies.R file.6\n\n\nshow/hide data-raw/tidy_movies.R\n## code to prepare `ggp2movies` dataset goes here\n# pkgs &lt;- c('ggplot2movies', 'tidyr', 'dplyr', 'stringr', 'fst')\n# install.packages(pkgs, quiet = TRUE)\n\n# load packages --------------------\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(fst)\n\n# tidy_movies\ntidy_movies &lt;- ggplot2movies::movies |&gt;\n  tidyr::pivot_longer(c(Action:Short),\n    names_to = \"genre_key\",\n    values_to = \"genre_value\"\n  ) |&gt;\n  dplyr::mutate(genre_value = as.logical(genre_value)) |&gt;\n  dplyr::select(\n    title, genre_key, genre_value, length,\n    year, budget, avg_rating = rating, votes, mpaa\n  ) |&gt;\n  dplyr::filter(genre_value == TRUE) |&gt;\n  dplyr::group_by(title) |&gt;\n  dplyr:::mutate(\n    genres = paste0(genre_key, collapse = \", \")\n  ) |&gt;\n  dplyr::select(\n    title, genres, length, year,\n    budget, avg_rating, votes, mpaa\n  ) |&gt;\n  dplyr::ungroup() |&gt;\n  dplyr::distinct(.keep_all = TRUE) |&gt;\n  dplyr::mutate(\n    genres = dplyr::na_if(x = genres, \"\"),\n    genre = dplyr::case_when(\n                stringr::str_detect(genres, \",\") ~ 'Multiple genres',\n                TRUE ~ genres),\n    genre = factor(genre),\n    mpaa = dplyr::na_if(x = mpaa, y = \"\"),\n    mpaa = factor(mpaa,\n      levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n      labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"))\n    ) |&gt; \n  dplyr::select(-genres)\n# save to inst/dev/\nfst::write_fst(x = tidy_movies, path = \"inst/dev/tidy_movies.fst\")\n\n\n\n\n9.3.2 dev code\nIn inst/dev/, we’ve placed the application modules in an app.R file. Any of the functions from moviesApp can be used in the dev/ modules with explicit namespacing (i.e., moviesApp::scatter_plot()).\ndev_mod_vars_ui() contains choices for the names in the tidy_movies data, but there’s no need to re-write the mod_var_input_server() function.\n\n\nshow/hide dev_mod_vars_ui()\ndev_mod_vars_ui &lt;- function(id) {\n      ns &lt;- NS(id)\n      tagList(\n        textInput(\n          inputId = ns(\"plot_title\"),\n          label = \"Plot title\",\n          placeholder = \"Enter plot title\"\n        ),\n        selectInput(\n          inputId = ns(\"y\"),\n          label = \"Y-axis:\",\n          choices = c(\n            \"Year\" = \"year\",\n            \"Length\" = \"length\",\n            \"Budget\" = \"budget\",\n            \"Rating\" = \"avg_rating\",\n            \"Votes\" = \"votes\"\n          ),\n          selected = \"budget\"\n        ),\n        selectInput(\n          inputId = ns(\"x\"),\n          label = \"X-axis:\",\n          choices = c(\n            \"Year\" = \"year\",\n            \"Length\" = \"length\",\n            \"Budget\" = \"budget\",\n            \"Rating\" = \"avg_rating\",\n            \"Votes\" = \"votes\"\n          ),\n          selected = \"year\"\n        ),\n        selectInput(\n          inputId = ns(\"z\"),\n          label = \"Color by:\",\n          choices = c(\n            \"MPAA\" = \"mpaa\",\n            \"Genre\" = \"genre\"\n          ),\n          selected = \"mpaa\"\n        ),\n        sliderInput(\n          inputId = ns(\"alpha\"),\n          label = \"Alpha:\",\n          min = 0, max = 1, step = 0.1,\n          value = 0.4\n        ),\n        sliderInput(\n          inputId = ns(\"size\"),\n          label = \"Size:\",\n          min = 0, max = 5, step = 0.5,\n          value = 2.5\n        )\n      )\n  }\n\n\nBoth functions in the dev/ display module has been re-written to add functionality for importing the tidy_movies.fst data file and an option to removing missing values from the graph.\n\n\nshow/hide dev_mod_scatter_ui()\ndev_mod_scatter_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    tags$br(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\n1        \"The data for this application comes from the \",\n          tags$a(\"ggplot2movies\",\n          href = \"https://github.com/hadley/ggplot2movies\"\n          ),\n          \"package\"\n        )\n      )\n    ),\n    tags$div(\n2      checkboxInput(\n        inputId = ns(\"missing\"),\n        label = \"Remove missing\",\n        value = TRUE\n      ),\n      plotOutput(outputId = ns(\"scatterplot\"))\n      )\n    )\n}\n\n\n\n1\n\nAlternate help text for ggplot2movies data\n\n\n2\n\nCheck-box to remove missing values\n\n\n\n\n\n\nshow/hide dev_mod_scatter_server()\ndev_mod_scatter_server &lt;- function(id, var_inputs) {\n    moduleServer(id, function(input, output, session) {\n      # load alternate data\n      all_data &lt;- fst::read_fst(\"tidy_movies.fst\")\n  \n      \n1      graph_data &lt;- reactive({\n        if (input$missing) {\n          graph_data &lt;- tidyr::drop_na(data = all_data)\n        } else {\n          graph_data &lt;- all_data\n        }\n2      }) |&gt;\n        bindEvent(input$missing)\n  \n      inputs &lt;- reactive({\n        plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n      })\n  \n3      observe({\n        output$scatterplot &lt;- renderPlot({\n          plot &lt;- moviesApp::scatter_plot(\n            df = graph_data(),\n            x_var = inputs()$x,\n            y_var = inputs()$y,\n            col_var = inputs()$z,\n            alpha_var = inputs()$alpha,\n            size_var = inputs()$size\n          )\n          plot +\n            ggplot2::labs(\n              title = inputs()$plot_title,\n              x = stringr::str_replace_all(\n                        tools::toTitleCase(inputs()$x), \"_\", \" \"),\n              y = stringr::str_replace_all(\n                        tools::toTitleCase(inputs()$y), \"_\", \" \")\n            ) +\n            ggplot2::theme_minimal() +\n            ggplot2::theme(legend.position = \"bottom\")\n        })\n      }) |&gt;\n        bindEvent(graph_data(), inputs())\n    })\n  }\n\n\n\n1\n\nBuild reactive data based on missing checkbox input\n\n\n2\n\nBind missing input to update when UI changes\n\n\n3\n\nBind plot output to update with variable inputs and ‘missing’ checkbox output\n\n\n\n\napp.R also contains development app UI and server functions.\nIn devUI(), development modules are paired with package modules (dev_mod_vars_ui() and moviesApp::mod_var_input_server()), and we’ve include an alternate image (bootstrap.png).7\n\n\nshow/hide devUI()\ndevUI &lt;- function() {\n1    addResourcePath(\n      prefix = \"dev\",\n      directoryPath = system.file(\"dev\",\n                                  package = \"moviesApp\")\n    )\n  tagList(\n    bslib::page_fillable(\n      title = \"Movie Reviews (ggplot2movies)\",\n      theme = bslib::bs_theme(\n        bg = \"#043b67\",\n        fg = \"#ffffff\",\n        primary = \"#ffcf22\",\n        secondary = \"#38B44A\",\n        success = \"#32E0C4\",\n        base_font = sass::font_google(\"Ubuntu\"),\n        heading_font = sass::font_google(\"Ubuntu\")\n      ),\n      bslib::layout_sidebar(\n        sidebar = bslib::sidebar(\n2          dev_mod_vars_ui(\"vars\")\n        ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n              tags$div(\n                tags$img(\n3                  src = \"dev/imdb.png\",\n                  height = 80,\n                  width = 110,\n                  style = \"margin:10px 10px\"\n                )\n              )\n            ),\n          bslib::card_body(\n4            dev_mod_scatter_ui(\"plot\")\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n1\n\nAdd alternate path to include image file\n\n2\n\nDevelopment variable input module (UI)\n\n\n3\n\nRefer to alternate image\n\n\n4\n\nDevelopment scatter-plot display module (UI)\n\n\n\n\n\n\nshow/hide devServer()\ndevServer &lt;- function(input, output, session) {\n  \n1  selected_vars &lt;- moviesApp::mod_var_input_server(\"vars\")\n\n2  dev_mod_scatter_server(\"plot\", var_inputs = selected_vars)\n  \n}\n\n\n\n1\n\nmod_var_input_server() exported from moviesApp’s R/ folder\n\n2\n\nDefined in dev/inst/app.R\n\n\n\n\n\n\n9.3.3 Launch dev\nFinally, the development app is launched with it’s own standalone function (stored in R/ggp2_movies_app.R). The ggp2_movies_app() function is similar to movies_app(), but appDir is set to the location of the development files (which we provide with system.file()).\n\n\nLaunch app with the shinypak package:\n\nlaunch('09.3_inst-dev')\n\n\n\nshow/hide R/ggp2_movies_app.R\n#' Development `ggplot2movies` app standalone function\n#'\n#' Wrapper function for `shinyAppDir()`\n#' \n#' @param test logical, run in `test.mode`? Defaults to `TRUE`.\n#' \n#' @return shiny app\n#' \n#'\n#' @export\nggp2_movies_app &lt;- function(options = list(), run = \"w\") {\n  if (interactive()) {\n    display_type(run = run)\n  } \n    shinyAppDir(\n    appDir = system.file(\"dev\",\n      package = \"moviesApp\"\n    ),\n    options = options\n  )\n}\n\n\n\nAfter loading, documenting, and installing moviesApp, we can run the development version using ggplot2movies_app():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nggp2_movies_app(run = 'p')\n\n\n\n\n\n\n\n(a) ggplot2movies_app()\n\n\nFigure 9.5: inst/dev/ app with dev_movies_ui()\n\n\n\nYou may have noticed that I’ve used a different color and theme for the two development examples above. I’ve found this can be a quick and easy way to differentiate ‘development’ and ‘production’ versions of an application."
  },
  {
    "objectID": "external.html#sec-external-inst-prod",
    "href": "external.html#sec-external-inst-prod",
    "title": "9  External files",
    "section": "9.4 Production (prod)",
    "text": "9.4 Production (prod)\nIt’s also possible to have a folder dedicated for deploying your application in your app-package.\n\n\nLaunch app with the shinypak package:\n\nlaunch('09.4_inst-prod')\n\n\n9.4.1 prod data\nThis folder can be named something like inst/prod/ or inst/deploy, and it will contain the ‘production’ ready versions of UI and server functions in a single app.R file:\n\ninst/\n  └── prod/\n      └── app\n          └── app.R\n          \n2 directories, 1 file\n\n\n\n9.4.2 prod/app/app.R\nIn the app.R file, include only a call to shinyApp() with the ui and server function (explicitly namespaced from your app-package):\n\n\nshow/hide prod/app/app.R\nshinyApp(\n  ui = moviesApp::movies_ui(bslib = TRUE), \n  server = moviesApp::movies_server)\n\n\nI used the bslib version, just to differentiate it from the other applications in moviesApp.\n\n\n9.4.3 Deploying prod\nBack in the root app.R file, we’ll use shinyAppDir() and system.file() to return the app object from prod/app/app.R:\n\n\nshow/hide app.R\n# set option to turn off loadSupport() ----\nwithr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        # load package ----\n        library(moviesApp)\n      },\n      error = function(e) {\n        # load R/ folder ----\n        pkgload::load_all()\n      }\n    )\n    # create shiny object from prod/app ----\n    shinyAppDir(appDir = \n        system.file(\"prod/app\", package = \"moviesApp\"))\n  } else {\n    # load R/ folder ----\n    pkgload::load_all()\n    # create shiny object ----\n    shiny::shinyApp(\n      ui = movies_ui,\n      server = movies_server\n    )\n  }\n})\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nTo deploy the app, call rsconnect::deployApp() in the console.\n\nrsconnect::deployApp(appName = 'shinyapppkg')\n\nThe deployment log will look something like this:\n── Preparing for deployment ────────────────────────────────────────────\n✔ Re-deploying \"shinyapppkg\" to \"server: shinyapps.io / username: yourusername\"\nℹ Looking up application with id \"10047601\"...\n✔ Found application &lt;https://mjfrigaard.shinyapps.io/shinyapppkg/&gt;\nℹ Bundling 35 files: .Rbuildignore, app.R, data/movies.rda, data/movies.RData,\n  data-raw/tidy_movies.R, DESCRIPTION, inst/dev/app.R, inst/dev/imdb.png, \n  inst/dev/tidy_movies.fst, inst/extdata/movies.fst, inst/prod/app/app.R, \n  inst/www/bootstrap.png, inst/www/shiny.png, man/display_type.Rd, \n  man/ggp2_movies_app.Rd, man/mod_scatter_display_server.Rd, \n  man/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, …, \n  R/scatter_plot.R, and README.md\nℹ Capturing R dependencies with renv\n✔ Found 72 dependencies\n✔ Created 1,179,590b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 7749936\n── Deploying to server ────────────────────────────────────────────────────────────────────\nWaiting for task: 1341341295\n  building: Parsing manifest\n  building: Building image: 9226179\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9226179\n  deploying: Starting instances\n  rollforward: Activating new instances\n  terminating: Stopping old instances\n── Deployment complete ───────────────────────────────────────────\n✔ Successfully deployed to &lt;https://mjfrigaard.shinyapps.io/shinyapppkg/&gt;\nYou can see a deployed version of this application here\n\n\n\n\n\n\nUses of inst/ in other packages\n\n\n\n\n\n\nYou can explore the structure of other installed packages to see how they work ‘under the hood’ to gain insight into how they use the inst/ folder.\n\nFor example, the inst/extdata/ folder in the readr package holds a variety of datasets:\n/path/to/install/Library/R/x86_64/4.2/library/readr/\n\nextdata/\n  ├── challenge.csv\n  ├── chickens.csv\n  ├── epa78.txt\n  ├── example.log\n  ├── fwf-sample.txt\n  ├── massey-rating.txt\n  ├── mini-gapminder-africa.csv\n  ├── mini-gapminder-americas.csv\n  ├── mini-gapminder-asia.csv\n  ├── mini-gapminder-europe.csv\n  ├── mini-gapminder-oceania.csv\n  ├── mtcars.csv\n  ├── mtcars.csv.bz2\n  ├── mtcars.csv.zip\n  └── whitespace-sample.txt\n\n1 directory, 15 files\nThese files are used in readr::readr_example()):\n#' Get path to readr example\n#'\n#' readr comes bundled with a number of sample files in its `inst/extdata`\n#' directory. This function make them easy to access\n#'\n#' @param file Name of file. If `NULL`, the example files will be listed.\n#' @export\n#' @examples\n#' readr_example()\n#' readr_example('challenge.csv')\nreadr_example &lt;- function(file = NULL) {\n  if (is.null(file)) {\n    dir(system.file('extdata', package = 'readr'))\n  } else {\n    system.file('extdata', file, package = 'readr', mustWork = TRUE)\n  }\n}"
  },
  {
    "objectID": "external.html#recap",
    "href": "external.html#recap",
    "title": "9  External files",
    "section": "Recap",
    "text": "Recap\nThis chapter had covered how to include external files and resources (i.e., what was previously stored in the www/ folder of a regular Shiny app project) in your app-package with addResourcePath() and system.file().\nWe’ve also covered how to use the inst/ folder to include alternative files, development and production/deployment versions of your app. You can now launch the following applications from moviesApp:\nStandard application with/without test mode\n\nlibrary(moviesApp)\nmovies_app(options = list(test.mode = TRUE))\n# or \nmovies_app(options = list(test.mode = FALSE))\n\nblisb application with/without test mode\nlibrary(moviesApp)\nmovies_app(options = list(test.mode = TRUE), bslib = TRUE)\n# or \nmovies_app(options = list(test.mode = FALSE), bslib = TRUE) \nggplot2movies data application with/without test mode\n\nlibrary(moviesApp)\nggp2_movies_app(options = list(test.mode = TRUE))\n# or \nggp2_movies_app(options = list(test.mode = FALSE))\n\nprod/ application\n\nlibrary(moviesApp)\nrsconnect::deployApp()\n\nIn the next chapter, we’re going to cover testing the code in your shiny app-package.\n\n\n\n\n\n\nRecap: inst & www folders\n\n\n\n\n\n\n\ninst/: the inst/ folder is installed with your app-package and will be accessible to users, so it’s a great location for files you want contained in your app, but don’t fit into the standard R package structure.\n\ninst/ is also a great location for alternative versions of applications (i.e., inst/app/dev or inst/app/prod/).\n\nsystem.file(): constructs a path to files or folders within installed packages and is especially useful when working with external datasets (i.e., inst/extdata/) or other external resources included with your app-package (i.e., inst/www/).\nwww: used for external static resources in shiny apps. shiny will automatically serve files under the www/ directory, but in app-packages we need to explicitly set this location with shiny::addResourcePath()\naddResourcePath(): create a prefix (i.e., path) for a directoryPath of static files to accessible in shiny’s web server:\n# file location\ninst/\n  └── www/\n        └── shiny.png\n# add path to app \naddResourcePath(prefix = 'www', \n                directoryPath = system.file('www', \n                                package = 'moviesApp'))\n# use path without 'inst/' prefix\nshiny::img(src = 'www/shiny.png')"
  },
  {
    "objectID": "external.html#footnotes",
    "href": "external.html#footnotes",
    "title": "9  External files",
    "section": "",
    "text": "This is a common problem developers encounter when converting shiny app into app-packages. See this popular thread on Posit Community.↩︎\nfs::path_package(package = \"moviesApp\") returns the path to your installed package and fs::dir_tree() function will print a folder tree.↩︎\nRead more about sub-directories to avoid in inst/ in R Packages, 2ed.↩︎\nThe key takeaway here is that the inst/ subfolders and files are available unchanged in the installed version (with the inst/ folder omitted.).↩︎\nYou can read more about adding external resources in the documentation for addResourcePath().↩︎\nWe covered the data-raw/ folder in the Data chapter, and you can read more about it here in R packages, 2ed↩︎\nThis requires exporting mod_var_input_server() with @export in the R/ folder.↩︎"
  },
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "Tests",
    "section": "",
    "text": "Tests\nWe’re now ready to test the code and features in our app-package. The next section covers the following topics:"
  },
  {
    "objectID": "tests.html#review-chapters-5---9",
    "href": "tests.html#review-chapters-5---9",
    "title": "Tests",
    "section": "Review Chapters 5 - 9",
    "text": "Review Chapters 5 - 9\nLet’s briefly review what we’ve covered in the last five chapters:\n\nDocumentation (Chapter 5)\nIn the Documentation chapter we covered:\n\nAn introduction to the roxygen2 (Section 5.1) package, and\nSome tips for documenting app-package functions (Section 5.2)\n\n\n\n\n\n\n\nChapter 5: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 5 (Documentation) is stored in the following branche(s):\n\n05_roxygen2\n\n\n\n\n\n\n\nDependencies (Chapter 6)\nDependencies walked through\n\nHow to give users of our app-package access to it’s functions (i.e., exports (Section 6.1)), and\nWhat to do with the functions we use from other packages in the R/ folder (i.e., imports (Section 6.2))\n\n\n\n\n\n\n\nChapter 6: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 6 (Dependencies) is stored in the following branche(s):\n\n&lt;branch&gt;\n\n\n\n\n\n\n\nData (Chapter 7)\nData covered the three common locations for data in R packages:\n\ndata/ (Section 7.2),\ndata-raw/ (Section 7.3), and\ninst/extdata/ (Section 7.4)\n\n\n\n\n\n\n\nChapter 7: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 7 (Data) is stored in the following branche(s):\n\n&lt;branch&gt;\n\n\n\n\n\n\n\nLaunch (Chapter 8)\nLaunch described the differences between\n\nshinyApp() (Section 8.3.1),\nrunApp() (Section 8.3.3), and\nshinyAppDir() (Section 8.3.2)\n\nThis chapter also provided some options to include in app.R (Section 8.5) and the standalone app function (Section 8.4.4).\n\n\n\n\n\n\nChapter 8: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 8 (Launch) is stored in the following branche(s):\n\n&lt;branch&gt;\n\n\n\n\n\n\n\nExternal files (Chapter 9)\nExternal files covered how to include external files and/or resources in your app (i.e., those previously stored in www/):\n\nCombining system.file() (Section 9.1.2) and addResourcePath() (Section 9.1.3), and\nThe various uses of the inst/ folder (Chapter 9) \n\nAlternative images and layout options (Section 9.1.2) \nDevelopment versions of your application using alternative data and modules (Section 9.3) \nA production version of your application (Section 9.4)\n\n\n\n\n\n\n\n\nChapter 9: GitHub Branches\n\n\n\n\n\n\nThe code for Chapter 9 (External files) is stored in the following branche(s):\n\n&lt;branch&gt;"
  },
  {
    "objectID": "tests.html#test-suite",
    "href": "tests.html#test-suite",
    "title": "Tests",
    "section": "Test suite",
    "text": "Test suite\nTest suite starts by showing how to create the testthat infrastructure (Section 10.2) then, dives into\n\nCreating test files (Section 10.3);\nThe mechanics unit tests (Section 10.3.2) and expectations (Section 10.3.3);\nRunning tests during development (Section 10.3.5)\n\nThis chapter also introduces keyboard shortcuts for testing (Section 10.3.6) and testthat’s behavior-driven development functions (Section 10.3.4)."
  },
  {
    "objectID": "tests.html#specifications",
    "href": "tests.html#specifications",
    "title": "Tests",
    "section": "Specifications",
    "text": "Specifications\nSpecifications discusses how to collect and organize user specifications, features, and functional requirements. This chapter also gives example descriptions of features and scenarios in the behavior-driven development format, and how to track specifications and tests in a traceability matrix."
  },
  {
    "objectID": "tests.html#test-tools",
    "href": "tests.html#test-tools",
    "title": "Tests",
    "section": "Test tools",
    "text": "Test tools\nThis chapter introduces test fixtures and helpers. Each tool can contribute to testing your shiny app-package in a unique way (they’re also relatively recent additions to the testthat framework)"
  },
  {
    "objectID": "tests.html#testing-modules",
    "href": "tests.html#testing-modules",
    "title": "Tests",
    "section": "Testing modules",
    "text": "Testing modules\nShiny’s testServer() function can be useful for performing integration tests with module server functions. Testing modules gives examples of using testServer() to verify module communication (i.e., passing data between modules)."
  },
  {
    "objectID": "tests.html#system-tests",
    "href": "tests.html#system-tests",
    "title": "Tests",
    "section": "System tests",
    "text": "System tests\nThe final chapter in this section covers setting up and running system (or end-to-end tests with shinytest2)."
  },
  {
    "objectID": "test_suite.html#testthat-framework",
    "href": "test_suite.html#testthat-framework",
    "title": "10  Test suite",
    "section": "10.1 testthat framework",
    "text": "10.1 testthat framework\ntestthat is the standard package for testing in R packages and one of the most widely used and supported packages on CRAN. Its widespread adoption is likely due to its ability to simplify the setup, creation, and execution of unit tests.\nIn our app-packages, we’ll use testthat unit tests to ensure the underlying logic (i.e., non-reactive utility functions) behaves correctly. Combining Shiny’s testServer() function and the shinytest2 package with testthat provides a comprehensive testing suite for our app-package."
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-use-testthat",
    "href": "test_suite.html#sec-tests-suite-use-testthat",
    "title": "10  Test suite",
    "section": "10.2 Setting up testthat tests",
    "text": "10.2 Setting up testthat tests\nThe testthat package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it’s the third):2\n\nusethis::use_testthat(3)\n\nSetting up your testing infrastructure with use_testthat() does the following (3 is the edition):\n\nIn the DESCRIPTION file, testthat (&gt;= 3.0.0) is listed under Suggests\nConfig/testthat/edition: 3 is also listed in the DESCRIPTION to specify the testthat edition\nA new tests/ folder is created, with a testthat/ subfolder\nThe tests/testthat/testthat.R file is created\n\nWe now have a tests/ folder to store our testthat tests.\n\ntests/\n  ├── testthat/\n1  └── testthat.R\n\n2 directories, 1 file\n\n\n1\n\nReferred to as the ‘test runner,’ because it runs all our tests (do not edit this file)."
  },
  {
    "objectID": "test_suite.html#sec-tests-suite-use-test",
    "href": "test_suite.html#sec-tests-suite-use-test",
    "title": "10  Test suite",
    "section": "10.3 Creating unit tests",
    "text": "10.3 Creating unit tests\nThe standard workflow for writing testthat unit tests consists of the following:\nNew tests are created with usethis::use_test():\n\nusethis::use_test(\"scatter_plot\") \n\n\ntestthat recommends having a corresponding test file in tests/testthat/ (with the test- prefix) for the files in R/.\n\n\n10.3.1 test- files\nTest files: the IDE will automatically create and open the new test file:\n✔ Writing 'tests/testthat/test-scatter_plot.R'\n• Modify 'tests/testthat/test-scatter_plot.R'\n\n\n10.3.2 test_that() tests\nEach new test file contains a boilerplate test_that() test:\n\n1test_that(desc = \"multiplication works\", code = {\n \n})\n\n\n1\n\ndesc is the test context (supplied in \"quotes\"), and code is the test code (supplied in {curly brackets}).\n\n\n\n\n\n\n10.3.3 expect_ations\nExpectation typically have two parts: an observed object, and an expected object:\n\n1expect_equal(\n2  object = 2 * 2,\n3  expected = 4\n  ) \n\n\n1\n\nA testthat expectation function\n\n\n2\n\nThe output or behavior being tested\n\n\n3\n\nA predefined output or behavior\n\n\n\n\nThe observed object is an artifact of some code we’ve written, and it’s being compared against an expected result.\n\n\n10.3.4 BDD test functions\ntestthat also has two behavior-driven development (BDD) functions for performing tests: describe() and it().\n\n“Use describe() to verify that you implement the right things and use [it()] to ensure you do the things right.” - testthat documentation\n\n\n1describe(\"Description of feature or specification\",\n      code = { \n2    it(\"Functionality under test\",\n3        code = {\n            expect_equal( \n            object = 2 * 2, \n            expected = 4 \n            )\n        })\n    })\n\n\n1\n\ndescribe() the feature or specification\n\n\n2\n\nCapture it() in a test\n\n\n3\n\nWrite expectations\n\n\n\n\nWe’ll cover BDD more in the next chapter, but for now just know that each call to it() behaves like test_that().\n\n\n10.3.5 Running tests\nAnother devtools habit to adopt is regularly writing and running tests. If you’re using Posit Workbench and have devtools installed, you can test your app-package using the Build pane or the keyboard shortcut: Ctrl/Cmd + Shift + T\n\n\n\n\n\nRun all tests\n\n\n\n\n10.3.6 Keyboard shortcuts\nR Packages, 2ed also suggests binding test_active_file() and test_coverage_active_file() to keyboard shortcuts. I highly recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.\n\n\n\ndevtools function\ntest()\n\n\n \n\n\nKeyboard shortcut\nCtrl/Cmd + Shift + T\n\n\n\n\n\n\ntest_active_file()\n\n\n \n\n\nCtrl/Cmd + T\n\n\n\n\n\n\ntest_coverage_active_file()\n\n\n \n\n\nCtrl/Cmd + Shift + R\n\n\n\nWhen the test is run, we’ll see feedback on whether it passes or fails (and occasionally some encouragement):\n\ntest_that(\"multiplication works\", { \n  expect_equal( \n    object = 2 * 2, \n    expected = 4 \n    ) \n})\n## Test passed 🥳"
  },
  {
    "objectID": "test_suite.html#recap",
    "href": "test_suite.html#recap",
    "title": "10  Test suite",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRECAP   \n\n\n\n\n\n\ntestthat setup\n\nuse_testthat(): sets up testing infrastructure in your app-package\n\nTest files\n\nuse_test(): creates new test files (with test- prefix). The test file names should generally match the file names be belowR/.\n\nBDD test functions\n\ndescribe(): Feature descriptions and any relevant background information\nit(): Scenarios and test code with expectations (Then statement = functional requirement).\n\nRunning tests\n\ntest_active_file(): runs tests in the current open test file\ntest_coverage_active_file(): test coverage for the current open test file"
  },
  {
    "objectID": "test_suite.html#footnotes",
    "href": "test_suite.html#footnotes",
    "title": "10  Test suite",
    "section": "",
    "text": "The ‘Reactivity - An overview’ article gives an excellent description (and mental module) of reactive programming.↩︎\nRead more about changes to the third edition to testthat in R Packages, 2ed↩︎"
  },
  {
    "objectID": "test_specs.html#application-requirements",
    "href": "test_specs.html#application-requirements",
    "title": "11  Specifications",
    "section": "11.1 Application requirements",
    "text": "11.1 Application requirements\nInformation about the various tasks and activities an application is expected to perform in typically stored in some kind of software requirements specification (SRS) document.4 The SRS can include things like distinct design characteristics, budgetary, technological, or timeline restrictions, etc. This document breaks down an application’s intended purpose (i.e., the problem it’s designed to solve) into three general areas: user specifications, features, and functional requirements.\n\n11.1.1 User Specifications\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 11_tests-specs branch of moviesApp.\n\nThe user specifications are the goals and objectives stakeholders want to achieve with the application. They use terms like ‘deliver value’ and ‘provide insight’ and provide the basis for deriving the application’s features. 5\n\n\n11.1.2 Features\nFeatures translate the user expectations into an application capabilities. Generally speaking, features capture the tasks and activities user should “be able to” accomplish with the application (i.e., explore data with a graph).\n\n\n11.1.3 Functional Requirements\nFunctional requirements are written for developers and provide the technical details on each feature. A single feature often gives rise to multiple functional requirements (these are where users needs come into direct contact with code)6\n\nIn summary\nThe areas above help direct the development process, albeit from slightly different perspectives.\n\nThe user specifications capture the needs and expectations of the end-user.\nThe features describe the high-level capabilities of the application.\nFunctional requirements are the testable, specific actions, inputs, and outputs."
  },
  {
    "objectID": "test_specs.html#application-developemnt",
    "href": "test_specs.html#application-developemnt",
    "title": "11  Specifications",
    "section": "11.2 Application developemnt",
    "text": "11.2 Application developemnt\nThe Shiny application development process follows something like the figure below:\n\n\n\nGeneral application development process\n\n\nThe figure above is an oversimplification, but it highlights a common separation (or ‘hand-off’) between users/stakeholders and developers. In the sections below, we’ll look at two common development processes: test-driven and behavior-driven development.\n\nTest-driven development\nIf moviesApp was built using test-driven development (TDD), the process might look something like this:\n\nGather user needs and translate into application features:\n\nDocument the application’s capabilities for exploring movie review variables from IMDB and Rotten Tomatoes.\nInclude feature descriptions for displaying continuous variables (i.e., ‘critics score’ and ‘audience score’) categorical variables (i.e., ‘MPAA’ ), graph visual attributes (size, color, opacity), and an optional plot title.\n\nWrite Tests:\n\nWrite tests to ensure the graph displays relationships between a set of continuous and categorical variables when the app launches.\n\nRun Tests:\n\nBefore writing any code, these tests will fail.\n\nDevelop Features:\n\nWrite UI, server, module, and utility functions for user inputs and graph outputs.\n\nRerun Tests:\n\nIf the graph has been correctly implemented in the application, the tests should pass.\n\nWrite more Tests:\n\nAdd more tests for additional functionalities (e.g., an option to remove missing values from graph).\n\n\nStarting with tests and writing just enough code to get them to pass often results in developing less (but better) code. The drawback to this approach is a strict focus on the function being tested and not the overall objective of the application.\n\n\nBehavior-driven development\nIn behavior-driven development (BDD) (or behavior-driven testing), users and developers work together to understand, define and express application behaviors in non-technical language, 7\n\n“Using conversation and examples to specify how you expect a system to behave is a core part of BDD” - BDD in Action, 2ed\n\nPlacing an emphasis on writing human-readable expectations for the application’s behaviors makes it easier to develop tests that can focus on verifying each user need exists (and is functioning properly). In BDD, the application’s expected capabilities are captured in Features and illustrated with concrete examples, or Scenarios.\n\nFeature\nIn BDD, a Feature describes an implemented behavior or capability in the application, from a user’s perspective. Typically, these are written in the Gherkin format using specific keywords:8\n\nAs a ...\n\nI want ...\n\nSo that ...\n\nBelow is an example Gherkin Feature for the graph in movies_app():\nFeature: Visualization\n    As a user\n    I want to see the changes in the plot\n    So that I can visualize the impact of my customizations\nAs you can see, the feature uses plain language and the wording is user-centric, so it remains accessible to both developers and users (or other non-technical stakeholders).\n\n\nScenario\nA Gherkin Scenario provides a concrete example of how the Feature works and has the following general format:\n\nGiven ...\n\nWhen ...\n\nThen ...\n\nAn example Scenario for movies_app() might be:\n  Scenario: Viewing the Data Visualization\n    Given I have launched the application\n    And it contains movie review data from IMDB and Rotten Tomatoes\n    And the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\n\n\nBackground\nInstead of repeating any pre-conditions in each Scenario (i.e., the steps contained in the “Given” and first “And” statement), we can establish the context with a Background:\n  Background: Launching the application\n    Given I have launched the application\n    And it loads with movie review data from IMDB and Rotten Tomatoes\n    \n  Scenario: Viewing the Data Visualization\n    Given the data contains variables like 'Critics Score' and 'MPAA'\n    When I interact with the controls in the sidebar panel\n    Then the graph should update with the selected options\nAdopting the Gherkin format (or something similar) provides a common language to express an application’s behavior:\n\nAs developers, we can work with users and shareholders to write specifications that describe the expected behavior of each Feature\nWhen developing tests, we can group the tests by their Feature and Scenarios\nEach test can execute a step (i.e., the Then statements).\n\nIn the next section we’ll cover how to map test code for each Scenario step with testthat."
  },
  {
    "objectID": "test_specs.html#bdd-and-testthat",
    "href": "test_specs.html#bdd-and-testthat",
    "title": "11  Specifications",
    "section": "11.3 BDD and testthat",
    "text": "11.3 BDD and testthat\ntestthat’s BDD functions (describe() and it()) allow us add Gherkin-style features and scenarios to our test files, ensuring the application remains user-centric while meeting the technical specifications.9\n\n11.3.1 describe() a feature\nWe can use the language from our Feature, Background, and Scenario to in the description in the argument of describe():\n\ntestthat::describe(\n  description = \"Feature: Visualization\n                   As a user\n                   I want to see the changes in the plot\n                   So that I can visualize the impact of my customizations\",\n  code = {\n  \n})\n\nWe can also nest describe() calls, which means we can include the Background (or other relevant information):\n\n1describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n    \n2  describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\", \n    code = {   \n               \n      })\n    \n  })\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n\n\n\n\n\n11.3.2 Confirm it() with a test\nInside describe(), we can include multiple it() blocks which “functions as a test and is evaluated in its own environment.”\nIn the example below, we’ll use an it() block to test the example scenario from above:10\n\n1testthat::describe(\n  \"Feature: Visualization\n      As a user\n      I want to see the changes in the graph\n      So that I can visualize the impact of my customizations.\", \n  code = {\n  \n2  testthat::describe(\n    \"Background: Launching the application\n        Given I have launched the application\n        And it loads with movie review data from IMDB and Rotten Tomatoes\",\n      code = {\n      \n3    testthat::it(\n      \"Scenario: Viewing the Data Visualization\n         Given the data contains variables like 'Critics Score' and 'MPAA'\n         When I interact with the controls in the sidebar panel\n         Then the graph should update with the selected options\",\n        code = {\n4          # test code\n        })\n      \n    })\n  \n})\n\n\n1\n\nBDD Feature (title and description)\n\n\n2\n\nBackground (preexisting conditions before each scenario)\n\n3\n\nScenario (a concrete examples that illustrates a feature)\n\n4\n\nTest code\n\n\n\n\nIn the scenario above, Then contains the information required for the testthat expectation. This could be expect_snapshot_file() or vdiffr::expect_doppelganger()–whichever makes sense from the user’s perspective.\nThese are generic examples, but hopefully the tests in the upcoming chapters convey how helpful and expressive BDD functions can be (or they inspire you to properly implement what I’m attempting to do in your own app-packages).11"
  },
  {
    "objectID": "test_specs.html#traceability-matrix",
    "href": "test_specs.html#traceability-matrix",
    "title": "11  Specifications",
    "section": "11.4 Traceability Matrix",
    "text": "11.4 Traceability Matrix\nAfter translating the user needs into functional requirements, we can identify what needs to be tested by building a look-up table (i.e., a matrix).\nI like to store early drafts of the requirements and traceability matrix in a vignette:12\n\nusethis::use_vignette(\"test-specs\")\n\nAdding our first vignette to the vignettes/ folder does the following:\n\nAdds the knitr and rmarkdown packages to the Suggests field in DESCRIPTION13\nSuggests: \n    knitr,\n    rmarkdown\nAdds knitr to the VignetteBuilder field14\nVignetteBuilder: knitr\nAdds inst/doc to .gitignore and *.html, *.R to vignettes/.gitignore\n\nThe first column in the traceability matrix contains the user specifications, which we can ‘trace’ over to the functional requirements and their relevant tests.15\n\n\nTraceability Matrix\n\n\n\n\n\n\n\n\nSpecifications\nFeatures\nRequirements\nTest\n\n\n\n\nS1: The application should source movie review data from platforms like IMDB or Rotten Tomatoes\nF1.1:\nFeature: Movie Review Dataset Variables\nAs a user\nI want to have a dataset with variables from IMDB and Rotten Tomatoes\nIn order to provide comprehensive movie reviews\nBackground:\nGiven the application has access to IMDB and Rotten Tomatoes APIs\nScenario: Movie Review Continuous and Categorical Variables\nWhen the application loads from IMDB and Rotten Tomatoes movie review data\nThen the dataset should include a continuous critic ratings variable\nAnd the dataset should include a continuous audience ratings variable\nAnd the dataset should include a categorical mpaa ratings variable\nAnd the dataset should include a categorical genres variable\n\n\n\n\n\nBuilding a traceability matrix ensures:\n\nAll user specifications have accompanying application features.\nEach feature has been broken down into precise, measurable, and testable functional requirements.\nTests have been written for each functional requirement."
  },
  {
    "objectID": "test_specs.html#recap",
    "href": "test_specs.html#recap",
    "title": "11  Specifications",
    "section": "Recap",
    "text": "Recap\n\n\nLaunch app with the shinypak package:\n\nlaunch('11_tests-specs')\n\nUnderstanding the relationship between user specifications, features, and functional requirements gives us the information we need to build applications that satisfy the technical standards while addressing user needs. Documenting requirements in Gherkin-style features and scenarios allows us to capture the application’s behavior without giving details on how the functionality is implemented.\nIn the next chapter, we’re going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to reduce code executed outside of your tests (i.e., placed above the call to test_that() or it()).\n\n\n\n\n\n\nRecap: testing your app-package\n\n\n\n\n\n\nSpecifications\n\nScoping tests: user specifications outline software goals and needs, and the functional requirements provide the technical details to achieve them.\n\nUser specifications: descriptions of what a user expects the application to do (i.e., the user ‘wish list’ of features they want in the application).\nFeatures: detailed list of the main capabilities and functions the application needs to offer to users.\nFunctional requierments: testable, specific step-by-step instructions for ensuring the application does what it’s supposed to do.\nTraceability matrix: tracking tool for connecting the users ‘wish list’ (i.e, specifications) to what’s being tested."
  },
  {
    "objectID": "test_specs.html#footnotes",
    "href": "test_specs.html#footnotes",
    "title": "11  Specifications",
    "section": "",
    "text": "Unit tests are covered extensively in R Packages, 2ed and the testthat documentation↩︎\nMastering shiny dedicates an entire Chapter to Testing.) shinytest2 also has excellent documentation (and videos), and I highly recommend reading through those resources.↩︎\nI will cover a few tips and tricks I’ve learned for testing module server functions with testServer() because they’re not in the documentation.↩︎\nRead more about what goes in the Software Requirements Specification↩︎\nUser Specifications are sometimes referred to as “user stories,” “use cases,” or “general requirements”↩︎\n‘Features’ and ‘functional requirements’ are sometimes used interchangeably, but they refer to different aspects of the application. Features are high-level capabilities an application should have, and often contain a collection of smaller functionalities (broken down into the specific functional requirements).↩︎\nRead more about behavior-driven development↩︎\nGherkin is the domain-specific language format used for expressing software behaviors. Tools like Cucumber or SpecFlow maps and executes the Gherkin descriptions against the code to generate a pass/fail report status for each requirement.↩︎\nRead more about describe() and it() in the testthat documentation. and in the appendix.↩︎\nEach it() block contains the expectations (or what you would traditionally include in test_that()).↩︎\nFor an excellent description on the relationships between behavior-driven development, test-driven development, and domain-driven design, I highly recommend BDD in Action, 2ed by John Ferguson Smart and Jan Molack.↩︎\nStoring the traceability matrix in a vignette is great for developers, but using an issue-tracking system with version control is also a good idea, like GitHub Projects or Azure DevOps.↩︎\nWe briefly covered the Suggests field in Dependencies, but in this case it specifically applies to “packages that are not necessarily needed. This includes packages used only in examples, tests or vignettes…” - Writing R Extensions, Package Dependencies↩︎\nThe documentation on VignetteBuilder gives a great example of why knitr and rmarkdown belong in Suggests and not Imports.↩︎\nWhen building tables in vignettes, I highly recommend using the Visual Markdown mode.↩︎"
  },
  {
    "objectID": "test_tools.html#sec-test-fixtures",
    "href": "test_tools.html#sec-test-fixtures",
    "title": "12  Test tools",
    "section": "12.1 Fixtures",
    "text": "12.1 Fixtures\n\nTest fixtures can be anything used to create repeatable test conditions (data, file paths, functions, etc.). Good test fixtures provide a consistent, well-defined test environment, and then are removed/destroyed when the test is executed. This ensures any changes made during the test don’t persist or interfere with future tests.5\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.1_tests-fixtures')\n\nIn R packages, test fixtures are stored in the tests/testthat/fixtures/ folder:6\n\ntests/\n├── testthat/\n│   └── fixtures/                                         \n└── testthat.R\n\n\n12.1.1 Test data\nLarge static data files are an example of a test fixture.7 Any code used to create test data should be stored with the output file (using a clear naming convention).\nFor example, I’ve stored the code used to create a ‘tidy’ version of the ggplot2movies::movies data along with the output dataset in tests/testthat/fixtures/:\n\ntests\n├── testthat\n│   ├── fixtures\n1│   │   ├── make-tidy_ggp2_movies\n2│   │   └── tidy_ggp2_movies.rds\n│   └── test-scatter_plot.R\n└── testthat.R\n\n3 directories, 4 files\n\n\n1\n\nThe code used to create the test data (make-make_tidy_ggp2_movies.R)\n\n2\n\nThe test data file (i.e., tidy_ggp2_movies.rds):\n\n\n\n\nData files stored in tests/testthat/fixtures/ can be accessed with testthat::test_path() inside each test.\n\n\n12.1.2 Example: test fixture\nBelow is a test that answers the question, ‘does the plot generate without producing an error?’ when using the tidy_ggp2_movies.rds test fixture with the scatter_plot() utility function. This type of test appropriate because we want to confirm the data source (tidy_ggp2_movies) will generate a plot object when passed to the scatter_plot() utility function, not necessarily the specific contents of the graph.8\n\n1testthat::describe(\n  \"Feature: Scatter plot data visualization\n\n     As a film data analyst\n     I want to explore movie review data from IMDB.com\n     So that I can analyze relationships between movie reivew metrics\n\n   Background:\n     Given I have data with IMDB movie reviews\n     And the data contains continuous variables like 'rating'\n     And the data contains categorical variables like 'mpaa'\", \n     code = {\n      \n2    testthat::it(\n      \"Scenario: Scatter plot initial x, y, color values \n         When I launched the Scatter Plot Data Visualization\n         And I have a dataset of movie reviews from IMDB \n         Then the scatter plot should show 'Rating' on the x-axis\n         And the scatter plot should show 'Length' on the y-axis\n         And the points on the scatter plot should be colored by 'MPAA' rating\", \n        code = {\n        \n3    ggp2_scatter_inputs &lt;- list(\n          x = \"rating\",\n          y = \"length\",\n          z = \"mpaa\",\n          alpha = 0.75,\n          size = 3,\n          plot_title = \"Enter plot title\"\n        )\n        \n4    tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n5    app_graph &lt;- scatter_plot(tidy_ggp2_movies,\n      x_var = ggp2_scatter_inputs$x,\n      y_var = ggp2_scatter_inputs$y,\n      col_var = ggp2_scatter_inputs$z,\n      alpha_var = ggp2_scatter_inputs$alpha,\n      size_var = ggp2_scatter_inputs$size\n    )\n6    expect_true(ggplot2::is.ggplot(app_graph))\n  }) \n\n})\n\n\n1\n\nFeature\n\n\n2\n\nScenario\n\n\n3\n\nTest inputs\n\n\n4\n\nTest fixture\n\n\n5\n\nCreate observed object\n\n\n6\n\nExpectation\n\n\n\n\nIf the data tidy_ggp2_movies.rds in tests/testthat/fixtures/ are going to be used repeatedly, it might also make sense to store it in inst/extdata/ or data-raw/. Test fixtures are described in-depth in R Packages, 2ed and in the testthat documentation."
  },
  {
    "objectID": "test_tools.html#sec-test-helpers",
    "href": "test_tools.html#sec-test-helpers",
    "title": "12  Test tools",
    "section": "12.2 Helpers",
    "text": "12.2 Helpers\n\n\n“Helper files are a mighty weapon in the battle to eliminate code floating around at the top-level of test files.” Testthat helper files, R Packages, 2ed\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('12.2_tests-helpers')\n\nTest helpers reduce repeated/duplicated test code. In general, objects or values that aren’t large enough to justify storing as static test fixtures can be created with helper functions. Helper functions are stored in tests/testthat/helper.R, which is automatically loaded with devtools::load_all():\n\ntests/\n  ├── testthat/\n1  │   ├── fixtures/\n  │   │   ├── make-tidy_ggp2_movies.R\n  │   │   └── tidy_ggp2_movies.rds\n2  │   ├── helper.R\n3  │   └── test-scatter_plot.R\n  └── testthat.R\n\n\n1\n\nTest fixture scripts and .rds files\n\n\n2\n\nHelper functions\n\n\n3\n\nTest file\n\n\n\n\nTest helpers should only be created if they make testing easier when the tests fail. The article, ‘Why Good Developers Write Bad Unit Tests’, provides great advice on complexity vs. clarity when writing unit tests,\n\n‘think about what will make the problem obvious when a test fails. Refactoring may reduce duplication, but it also increases complexity and potentially obscures information when things break.’\n\nR programmers resist copy + paste programming, and in most cases this makes sense. After all, R is a functional programming language, so it’s tempting to bundle any repeated code into a function and store it in the tests/testthat/helper.R file.\nHowever, when we’re writing tests, it’s more important that tests are easy to read and understand when they fail.\nFor example, consider the ggp2_scatter_inputs inputs passed to the scatter_plot() function in the previous test:\n\nggp2_scatter_inputs &lt;- list(  \n        x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\"\n)            \n\nWe could write a var_inputs() function that stores these values in a list. In our tests, this would allow us to use var_inputs() with the same ‘reactive syntax’ we use with scatter_plot() in the module server function:\n\nvar_inputs &lt;- function() {\n   list(x = \"rating\",\n        y = \"length\",\n        z = \"mpaa\",\n        alpha = 0.75,\n        size = 3,\n        plot_title = \"Enter plot title\")\n}\nvar_inputs()\n## $x\n## [1] \"rating\"\n## \n## $y\n## [1] \"length\"\n## \n## $z\n## [1] \"mpaa\"\n## \n## $alpha\n## [1] 0.75\n## \n## $size\n## [1] 3\n## \n## $plot_title\n## [1] \"Enter plot title\"\n\nWhile this removes duplicated code, it also makes it less clear for the reader what var_inputs() contains and where it was created (without opening the helper.R file).\n\n1tidy_ggp2_movies &lt;- readRDS(test_path(\"fixtures\",\n                                \"tidy_ggp2_movies.rds\"))\n  \napp_graph &lt;- scatter_plot(\n  tidy_ggp2_movies,\n2  x_var = var_inputs()$x,\n  y_var = var_inputs()$y,\n  col_var = var_inputs()$z,\n  alpha_var = var_inputs()$alpha,\n  size_var = var_inputs()$size)\n\ntestthat::expect_true(ggplot2::is.ggplot(app_graph))\n\n\n1\n\nLoad test fixture\n\n\n2\n\nIdentical to the code in mod_scatter_display_server()\n\n\n\n\nIn contrast, the make_ggp2_inputs() function below creates inputs for the scatter_plot() utility function:\n\nmake_ggp2_inputs &lt;- function() {\n  glue::glue_collapse(\"list(x = 'rating',\n     y = 'length',\n     z = 'mpaa',\n     alpha = 0.75,\n     size = 3,\n     plot_title = 'Enter plot title'\n     )\"\n  )\n}\n\nI can call make_ggp2_inputs() in the Console and it will return the list of values to paste into each test:\n\nmake_ggp2_inputs()\nlist(y = 'audience_score', \n     x = 'imdb_rating',\n     z = 'mpaa_rating',\n     alpha = 0.5,\n     size = 2,\n     plot_title = 'Enter plot title'\n    )\n\nThis reduces the number of keystrokes per test, but doesn’t obscure the source of the values in the test.\nglue::glue_collapse() is your friend when you want to quickly reproduce code for your tests. make_var_inputs() creates the list of inputs for testing the original movies data:\n\nmake_var_inputs &lt;- function() {\n  glue::glue_collapse(\"list(y = 'audience_score', \n     x = 'imdb_rating',\n     z = 'mpaa_rating',\n     alpha = 0.5,\n     size = 2,\n     plot_title = 'Enter plot title'\n    )\")\n}\n\n\n\n\n\n\n\nViolating the DRY principle\n\n\n\n\n\n\nIf you have repeated code in your tests, consider the following questions below before creating a helper function:\n\nDoes the code help explain what behavior is being tested?\nWould a helper make it harder to debug the test when it fails?\n\nIt’s more important that test code is obvious than DRY, because it’s more likely you’ll be dealing with this test when it fails (and you’re not likely to remember why all the top-level code is there).\n\n\n\n\n\n12.2.1 Test logger\nI prefer test outputs to be verbose, so I usually create a test_logger() helper function that allows me to give more context and information with each test:\n\n# test logger helper\ntest_logger &lt;- function(start = NULL, end = NULL, msg) {\n  if (is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"{msg}\")\n  } else if (!is.null(start) & is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n  } else if (is.null(start) & !is.null(end)) {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n  } else {\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n    cat(\"\\n\")\n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n  }\n}\n\ntest_logger() can be used to ‘log’ the start and end of each test, and it includes a message argument (msg) I’ll use to reference the test description argument in each it() call.9\nI tend to use functions like test_logger() enough to justify placing them in a testing utility file (R/testthat.R) below R/. Including testing functions in the R/ folder also ensures they’re documented (and any dependencies become part of your app-package).10\n\n\n12.2.2 Test development\nWhile developing, using keyboard shortcuts makes it easier to iterate between building fixtures, writing and running tests, and checking code coverage.\n\n\n\n\n\n\n\n\nCtrl/Cmd + T\n\n\n\n\n\n\n\ndevtools:::test_active_file()\n FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-10-27 12:39:23] [ START fixture = tidy_ggp2_movies.rds]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2023-10-27 12:39:23] [ START fixture = tidy_ggp2_movies.rds]\n\nINFO [2023-10-27 12:39:23] [ START data = movies.rda]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nINFO [2023-10-27 12:39:23] [ END data = movies.rda]\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\nTest coverage on active file\n\n\n\n\n12.2.3 Example: snapshots\nWriting tests for UI outputs can be difficult because their “correctness” is somewhat subjective and requires human judgment. If the expected output we’re interesting in testing is cumbersome to describe programmatically, we can consider using a snapshot tests. Examples of this include UI elements (which are mostly HTML created by Shiny’s UI layout and input/output functions) and data visualizations.11\nI’ve included a small UI function (text_logo()) in the R/ folder of moviesApp:\n\ntext_logo &lt;- function(size = 'h3') {\n  if (any(size %in% c(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"))) {\n  HTML(\n    paste0(\n    \"&lt;span&gt;\\n\", \n      paste0(\"  &lt;\", size, \"&gt;\", collapse = \"\"), \"\\n\",\n      \"    &lt;code&gt;√\\\\/--‹(•_•)›--√\\\\/&lt;/code&gt;\\n\", \n      paste0(\"  &lt;\", size, \"/&gt;\", collapse = \"\"), \"\\n\",\n    \"&lt;/span&gt;\\n\"\n      )\n    )\n  } else {\n    rlang::abort(paste(size, \"isnt supported\", sep = \" \"))\n  }\n}\n\nThis function generates the HTML so we can include a small logo in the UI.12\n\n\n\nThe output in the UI:\n\n\n\n\n  \n    √\\/--‹(•_•)›--√\\/\n  \n\n\n\n\n\n\n\nThe pre-rendered HTML:\n\n\n&lt;span&gt;\n  &lt;h3&gt;\n    &lt;code&gt;√\\/--‹(•_•)›--√\\/&lt;/code&gt;\n  &lt;/h3&gt;\n&lt;/span&gt;\n\n\n\nReviewing the entire HTML contents of movies_ui() to see if text_logo() is working isn’t practical, but we can store it’s results in a snapshot file using expect_snapshot(). In tests/testthat/test-text_logo.R, I’ll write the following tests:13\n\n\n\n\n\n\nWarning: snapshots and multiple line descriptions\n\n\n\n\n\n\nIt’s important to include any multiple-line text in the describe() block when creating snapshots with expect_snapshot(). Multiline text in the desc of test_that() will always overwrite the snapshot file.\nThank you to @LDSamson for bringing this to my attention!\nSee this issue for more information.\n\n\n\n\n\nConfirm the default size argument:\n\ndescribe(\n    \"Scenario: Generating a logo with default size\n    Given the user did not specify a [size] in text_logo()\n    When text_logo() is invoked without a [size] argument\n    Then the correct HTML for a ['h3'] text logo is returned\",\n    code = {\n\n    test_that(\"text_logo()\", code = {\n      test_logger(start = \"snap\", msg = \"text_logo()\")\n      expect_snapshot(text_logo())\n      test_logger(end = \"snap\", msg = \"text_logo()\")\n    })\n  })\n\nConfirm a new size argument:\n\n  describe(\n    \"Scenario: Generating a logo of a specified size\n    Given the user wants a ['h1'] sized text logo\n    When text_logo(size = 'h1') is invoked \n    Then the correct HTML for a ['h1'] text logo is returned\", \n    code = {\n\n    test_that(\"text_logo('h1')\", code = {\n      test_logger(start = \"snap\", msg = \"text_logo('})')\")\n      expect_snapshot(text_logo(\"h1\"))\n      test_logger(start = \"snap\", msg = \"text_logo('h1')\")\n    })  \n  })\n\nConfirm an invalid size argument:\n\ndescribe(\n  \"Scenario: Attempting to generate a logo with an invalid size\n  Given the user specifies an invalid [size] for the text logo\n  When text_logo() is invoked with an invalid [size] argument\n  Then an error is returned stating the [size] is not recognized\", \n  code = {\n  test_that(\"text_logo('invalid')\", code = {\n    test_logger(start = \"snap\", msg = \"text_logo('invalid')\")\n    expect_error(text_logo(\"massive\"), NULL)\n    test_logger(end = \"snap\", msg = \"text_logo('invalid')\")\n    })\n  })\n\n\nWhen I test this file, I see the following results and output from test_logger() along with two warnings about the creating of the snapshot files:\n\ndevtools:::test_active_file()\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-11-17 08:50:55] [ START snap = text_logo()]\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 1 ]\nINFO [2023-11-17 08:50:55] [ END snap = text_logo()]\n\nINFO [2023-11-17 08:50:55] [ START snap = text_logo('h1')]\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 2 ]\nINFO [2023-11-17 08:50:55] [ START snap = text_logo('h1')]\n\nINFO [2023-11-17 08:50:55] [ START snap = text_logo('invalid')]\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 3 ]\nINFO [2023-11-17 08:50:55] [ END snap = text_logo('invalid')]\n── Warning (test-text_logo.R:13:7): text_logo() ──\nAdding new snapshot:\nCode\n  text_logo()\nOutput\n  &lt;span&gt;\n    &lt;h3&gt;\n      &lt;code&gt;√\\/--‹(•_•)›--√\\/&lt;/code&gt;\n    &lt;/h3&gt;\n  &lt;/span&gt;\n\n── Warning (test-text_logo.R:22:7): text_logo('h1') ──\nAdding new snapshot:\nCode\n  text_logo(\"h1\")\nOutput\n  &lt;span&gt;\n    &lt;h1&gt;\n      &lt;code&gt;√\\/-‹(•_•)›-√\\/&lt;/code&gt;\n    &lt;/h1&gt;\n  &lt;/span&gt;\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 3 ]\n\n\n12.2.4 Reviewing _snaps/\nSnapshots are stored in the tests/testthat/_snaps/ folder. The output from expect_snapshot_file() is a markdown file with contents similar to what we saw above in the warning message. Should the markdown file contents change in future test runs, the tests will fail and we’ll be prompted to review the changes. 14\nFor example, if the &lt;span&gt; changed to a &lt;div&gt; in text_logo() and caused a test failure, I could review the changes in tests/testthat/_snaps/text_logo.md with testthat::snapshot_review('text_logo'):\n\n\n\n\n\n(a) testthat::snapshot_review('text_logo')\n\n\nFigure 12.1: Click Accept: Accepting snapshot: 'tests/testthat/_snaps/text_logo.md'\n\n\n\n\n\n\n\n\nMocking\n\n\n\n\n\n\nTest mocks are covered in Special Topics, because the example isn’t from our app-package (it comes from the package development masterclass given at posit::conf(2023))."
  },
  {
    "objectID": "test_tools.html#recap",
    "href": "test_tools.html#recap",
    "title": "12  Test tools",
    "section": "Recap",
    "text": "Recap\n\n\n\n\n\n\nRecap: test suite\n\n\n\n\n\n\nShiny app-packages test tools\n\nFixtures: Fixtures prepare the test environment and the initial state. The tidy_ggp2_movies.rds data is a test fixture, and it creates the tidy_ggp2_movies data within the test scope.\nHelpers: If find yourself writing small, reusable pieces of code to perform specific tasks inside your tests, consider converting them into a function in tests/testthat/helper.R.\nSnapshots: Test complex outputs using snapshots, but cautiously. Snapshots are susceptibile to failure with small (sometimes inconsequential) changes, which produce false negatives test failures."
  },
  {
    "objectID": "test_tools.html#footnotes",
    "href": "test_tools.html#footnotes",
    "title": "12  Test tools",
    "section": "",
    "text": "The three chapters in R Packages, 2ed, dedicated to testing are Testing basics, Designing your test suite, and Advanced testing techniques↩︎\nRead a summary of the changes to the testthat package on the tidyverse blog↩︎\nthese tips (and more!) were covered in the Package Development Masterclass delivered at posit::conf(2023)↩︎\nRead more about creating code snippets on the Posit website.↩︎\nFor a concrete example, see this article on self-cleaning tests.↩︎\nThe name ‘fixtures’ isn’t required (you can name this folder anything).↩︎\nCreating a tidied version of ggplot2movies::movies would be costly to re-create with every test, so it’s advised to store it as an static test fixture.↩︎\nSnapshot tests would be more appropriate for answering the question, ‘is the plot visually correct?’.↩︎\nIf you like verbose logging outputs, check out the logger package↩︎\nPlacing common files for testing below R/ is covered in R Packages, 2ed↩︎\nGraph snapshots are covered in Chapter 23.↩︎\nThis is a simple example, but I chose it because it needs some tricky escape characters to work.↩︎\nMastering Shiny covers creatng a snapshot file to test UI elements, but also notes this is probably not the best approach.↩︎\nWe’ll encounter this folder again in the Chapter 14 on system tests with shinytest2.↩︎"
  },
  {
    "objectID": "test_modules.html#integration-tests",
    "href": "test_modules.html#integration-tests",
    "title": "13  Testing modules",
    "section": "13.1 Integration tests",
    "text": "13.1 Integration tests\nIntegration tests verify that functions and components work together, and often involves instantiating multiple objects to interact with each other in a single test.\nWe can combine the BDD functions with testServer() to test reactive interactions between modules. For example, to confirm that the drop-down feature requirement is working (i.e., that user-inputs are updating in the application), we need to test two changes:\n\nValues passed to the UI are returned from mod_var_input_server()\n\nThe reactive values returned from mod_var_input_server() are passed into mod_scatter_display_server() and available as the reactive object inputs()\n\n\n\n\n\n\n\nBDD refresher: features & scenarios\n\n\n\n\n\n\nIn BDD, requirements are written plain language ‘feature files’ using a series of keywords:\n\n1Feature:\n  As a\n  I want\n  So that\n  \n2  Background:\n3    Given\n    And\n    \n4  Scenario:\n5    When\n6    And\n7    Then\n\n\n\n1\n\nHigh-level description (title and description)\n\n\n2\n\nSteps or conditions that exist before each scenario\n\n\n3\n\nUsed to describe the initial context or preconditions for the scenario\n\n\n4\n\nA series of steps outlining a concrete examples that illustrates a feature\n\n\n5\n\nUsed to describe an event, or an action\n\n\n6\n\nUse to combine Given, When, or Then\n\n\n7\n\nUse to verify expected outcomes that are observable by a user\n\n\n\n\nFeature and Background information can be included in nested describe() blocks, but every Scenario (i.e., Then) keyword should have a corresponding it() or test_that() call.\nRead more about Gherkin on the Cucumber website..\n\n\n\n\nThe feature, background, and scenario for the changes in mod_var_input_server() are provided below:\n\ndescribe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n      As a user \n      I want the initial graph pre-configured with variables and aesthetics,\n      So that I can change the inputs and see a meaningful visualization.\", \n  code = {\n  \n  describe(\n    \"Background: Initial scatter plot x, y, color values \n         Given the movie review application is loaded\n         And the scatter plot initial x-axis value is [IMDB Rating] \n         And the scatter plot initial y-axis value is [Audience Score]\n         And the scatter plot initial color value is [MPAA Rating]\n         And the initial opacity of the points is set to [0.5]\n         And the initial size of the points is set to [2]\n         And the initial plot title is set to [Enter plot title]\", code = {\n           \n  it(\"Scenario: Changing scatter plot x, y, color values\n       Given the movie review application is loaded\n       When I choose the [Critics Score] variable for the x-axis\n       And I choose the [Runtime] variable for the y-axis\n       And I choose the [Title type] variable for color\n       Then the scatter plot should show [Critics score] on the x-axis\n       And the scatter plot should show [Runtime] on the y-axis\n       And the points on the scatter plot should be colored by [Title type]\n       And the opacity of the points should be set to [0.5]\n       And the size of the points should be set to [2]\n       And the plot title should be [Enter plot title]\", code = {\n         \n         shiny::testServer(app = mod_var_input_server, expr = {\n            \n           # test code ----- \n           \n         })  \n       })\n    })\n})\n\n\n13.1.1 session$returned()\nInside testServer(), we can create a list of initial graph inputs for mod_var_input_server(), then pass identical values to session$setInputs(), and confirm the returned object with session$returned():1\n\n1    shiny::testServer(app = mod_var_input_server, expr = {\n      \n      test_logger(start = \"var_inputs\", msg = \"initial returned()\")\n      \n      # create list of output vals\n2      test_vals &lt;- list(y = \"imdb_rating\",\n                        x = \"audience_score\",\n                        z = \"mpaa_rating\",\n                        alpha = 0.75,\n                        size = 3,\n                        plot_title = \"Example title\")\n\n      # change inputs\n3      session$setInputs(y = \"imdb_rating\",\n                        x = \"audience_score\",\n                        z = \"mpaa_rating\",\n                        alpha = 0.75,\n                        size = 3,\n                        plot_title = \"Example title\")\n\n      testthat::expect_equal(\n4        object = session$returned(),\n        expected = test_vals\n      )\n\n      test_logger(end = \"var_inputs\", msg = \"initial returned()\")\n      \n})\n\n\n1\n\nCall to testServer()\n\n\n2\n\nCreate output values for comparison\n\n\n3\n\nSet each input using setInputs(input = )\n\n\n4\n\nConfirm returned values against test_vals\n\n\n\n\nThe test above confirms the initial values can be passed and returned from mod_var_input_server().\n\n\n13.1.2 session$flushReact()\nIf we want to test changing inputs, we should call session$flushReact() to remove the values set by session$setInputs() 2\n\n1shiny::testServer(app = mod_var_input_server, expr = {\n    # flush reactives\n2    session$flushReact()\n    test_logger(start = \"var_inputs\", msg = \"updated returned()\")\n    # set inputs\n3    session$setInputs(y = \"critics_score\",\n                      x = \"runtime\",\n                      z = \"title_type\",\n                      alpha = 0.5,\n                      size = 2,\n                      plot_title = \"Enter plot title\")\n\n4    testthat::expect_equal(object = session$returned(),\n      expected = list(y = \"critics_score\",\n                      x = \"runtime\",\n                      z = \"title_type\",\n                      alpha = 0.5,\n                      size = 2,\n                      plot_title = \"Enter plot title\"))\n    \n    test_logger(end = \"var_inputs\", msg = \"updated returned()\")\n})\n\n\n1\n\nCall to testServer()\n\n\n2\n\nFlush reactives from previous expect_equal()\n\n3\n\nSet changed input values using setInputs(input = )\n\n\n4\n\nConfirm returned values against session$returned()\n\n\n\n\nThe final result of running test_active_file() on test-mod_var_input.R is below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-11-08 20:00:39] [ START var_inputs = initial returned()]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2023-11-08 20:00:39] [ END var_inputs = initial returned()]\n\nINFO [2023-11-08 20:00:39] [ START var_inputs = updated returned()]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nINFO [2023-11-08 20:00:39] [ END var_inputs = updated returned()]\n\n\n13.1.3 args = list()\nNow that we’ve confirmed mod_var_input_server() is returning the initial updated values, we want to make sure reactive values are passed correctly into mod_scatter_display_server().\nIn movies_server(), when we pass selected_vars to the var_inputs argument, we’re not passing the returned values (this is why we don’t need the parentheses). We’re calling on the method (or function) created by the call to reactive() (inside mod_var_input_server()).\nI’ve included the movies_server() function below to refresh our memory of how this should work:3\n\nmovies_server &lt;- function(input, output, session) {\n\n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\n1\n\nCalls return(reactive(list(...)))\n\n\n\n\nWhen we pause execution with Posit Workbench’s debugger we can see the difference between calling selected_vars and selected_vars():\n\n\n\nBrowse[1]&gt; selected_vars\nreactive({\n    list(\n      y = input$y, \n      x = input$x, \n      z = input$z, \n      alpha = input$alpha, \n      size = input$size, \n      plot_title = input$plot_title\n      )\n})\n\n\n \n\n\nBrowse[1]&gt; selected_vars()\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nWe’ll cover using browser() and the IDE’s debugger in the debugging chapter.\nThe feature and scenario for the functionality above is captured in testthat’s BDD functions below:\n\ndescribe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n      As a user \n      I want the initial graph pre-configured with variables and aesthetics,\n      So that I can immediately see a meaningful visualization.\",\n  code = {\n    it(\n      \"Scenario: Scatter plot initial x, y, color values \n         Given the movie review application is loaded\n         When I view the initial scatter plot\n         Then the scatter plot should show 'IMDB Rating' on the x-axis\n         And the scatter plot should show 'Audience Score' on the y-axis\n         And the points on the scatter plot should be colored by 'MPAA Rating'\n         And the size of the points should be set to '2'\n         And the opacity of the points should be set to '0.5'\n         And the plot title should be 'Enter plot title'\",\n      code = {\n        \n      })\n  })\n\nInside testServer(), if we’re testing a module function that collects the reactive values, we need to wrap those values in reactive() in the args() argument: 4\n\nshiny::testServer(\n  app = mod_scatter_display_server,\n  args = list(\n    var_inputs =\n1      shiny::reactive(\n        list( \n            x = \"critics_score\",\n            y = \"imdb_rating\",\n            z = \"mpaa_rating\",\n            alpha = 0.5,\n            size = 2,\n            plot_title = \"Enter Plot Title\"\n          )\n        )\n  ),\n  expr = {\n    test_logger(start = \"display\", msg = \"selected_vars initial values\")\n2    testthat::expect_equal(\n      object = inputs(),\n      expected = list(\n        x = \"critics_score\",\n        y = \"imdb_rating\",\n        z = \"mpaa_rating\",\n        alpha = 0.5,\n        size = 2,\n        plot_title = \"Enter Plot Title\"\n      )\n    )\n    test_logger(end = \"display\", msg = \"selected_vars initial values\")\n})\n\n\n1\n\nList of reactive variable inputs\n\n\n2\n\nCompare inputs() to initial values\n\n\n\n\nI’ve included the example above because it’s not included on the testServer() documentation, and I’ve found this method works well if you want to confirm two modules are communicating (i.e., returning and collecting outputs). System test with shinytest2 are a better option if we’re trying to capture a more comprehensive execution path (i.e., user scenario) in the application.\n\n\n13.1.4 Module test coverage\nWhen we check the code coverage for the test above, we can see it confirms var_inputs is communicating the reactive values to inputs() in mod_scatter_display_server(), but this test doesn’t execute the call to scatter_plot():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + R\n\n\n\n\n\n\n\n\ndevtools:::test_coverage_active_file()\n\n\n\n\n\n\n\n\n13.1.5 Testing output$s\nTo confirm the plot is being created properly in mod_scatter_display_server(), we can’t use the ggplot2::is.ggplot() function because the plot is being rendered by renderPlot(). However, we can verify the structure of the output$scatterplot object using any of the following expectations:\n\ntestthat::expect_true(\n  object = is.list(output$scatterplot))\n\ntestthat::expect_equal(\n  object = names(output$scatterplot),\n  expected = c(\"src\", \"width\", \"height\", \"alt\", \"coordmap\"))\n\ntestthat::expect_equal(\n  object = output$scatterplot[[\"alt\"]],\n  expected = \"Plot object\")\n\nIt’s also possible to build the graph inside the test using the same code from the module server function, then confirm it with ggplot2::is.ggplot():\n\n1    plot &lt;- scatter_plot(movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size) +\n    ggplot2::labs(\n      title = inputs()$plot_title,\n      x = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$x), \"_\", \" \"),\n      y = stringr::str_replace_all(\n              tools::toTitleCase(inputs()$y), \"_\", \" \")) +\n    ggplot2::theme_minimal() +\n    ggplot2::theme(legend.position = \"bottom\")\n    \n2    testthat::expect_true(ggplot2::is.ggplot(plot))\n\n\n1\n\nBuild graph (same code from module function)\n\n\n2\n\nConfirm ggplot2 object is built\n\n\n\n\nThis executes the code used build the graph in mod_scatter_display_server():\n\n\n\n\n\nIf we’re still skeptical this test is confirming the plot is being built correctly, we can pass plot to print() in the test and the plot will appear in the Plots pane.\n\n\n\nPassing plot to print() will send the graph to the Plots pane\n\n\n\n\n\n\nLaunch app with the shinypak package:\n\nlaunch('13_tests-modules')"
  },
  {
    "objectID": "test_modules.html#footnotes",
    "href": "test_modules.html#footnotes",
    "title": "13  Testing modules",
    "section": "",
    "text": "Read more about returned values in the section titled, ‘Modules with return values’ in the Shiny documentation.↩︎\nRead more about flushing reactive values in the section titled, ‘Flushing Reactives’ in the Shiny documentation.↩︎\nselected_vars are the reactive plot values returned from mod_var_input_server().↩︎\nRead more about adding parameters to testServer() in the section titled, ‘Modules with additional parameters’ in the Shiny documentation.↩︎"
  },
  {
    "objectID": "test_system.html#current-tests",
    "href": "test_system.html#current-tests",
    "title": "14  System tests",
    "section": "14.1 Current tests",
    "text": "14.1 Current tests\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 13_tests-modules branch of moviesApp.\n\nThe current files in our tests folder are below:\n\ntests\n├── testthat\n│   ├── fixtures\n│   │   ├── make-tidy_ggp2_movies.R\n│   │   └── tidy_ggp2_movies.rds\n│   ├── helper.R\n│   ├── test-mod_scatter_display.R\n│   ├── test-mod_var_input.R\n│   └── test-scatter_plot.R\n└── testthat.R\n\n3 directories, 7 files\n\nThe output from devtools::test() is below:\n\ndevtools::test()\n\nℹ Testing moviesApp\n✔ | F W  S  OK | Context\n\n⠏ |          0 | mod_scatter_display                                                \nINFO [2023-10-26 10:31:02] [ START display = selected_vars initial values]\n⠋ |          1 | mod_scatter_display                                  \nINFO [2023-10-26 10:31:03] [ END display = selected_vars initial values]\nINFO [2023-10-26 10:31:03] [ START display = scatterplot[['alt']] = 'Plot object']\n⠙ |          2 | mod_scatter_display                     \nINFO [2023-10-26 10:31:03] [ END display = scatterplot[['alt']] = 'Plot object']\nINFO [2023-10-26 10:31:03] [ START display = inputs() creates ggplot2 object]\nINFO [2023-10-26 10:31:03] [ END display = inputs() creates ggplot2 object]\n✔ |          3 | mod_scatter_display\n\n⠏ |          0 | mod_var_input                           \nINFO [2023-10-26 10:31:03] [ START input = initial inputs returned()]\n⠋ |          1 | mod_var_input                       \nINFO [2023-10-26 10:31:03] [ END input = initial inputs returned()]\n✔ |          1 | mod_var_input\n\n⠏ |          0 | scatter_plot                                          \nINFO [2023-10-26 10:31:03] [ START data 2 = fixtures/tidy_ggp2_movies.rds]\n⠋ |          1 | scatter_plot                                          \nINFO [2023-10-26 10:31:03] [ END data 2 = fixtures/tidy_ggp2_movies.rds]\nINFO [2023-10-26 10:31:03] [ START data 1 = data/movies.rda]\nINFO [2023-10-26 10:31:03] [ END data 1 = data/movies.rda]\n✔ |          2 | scatter_plot\n\n══ Results ═════════════════════════════════════════════════════════════════════\nDuration: 1.4 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 6 ]\n\n14.1.1 shinytest2\nshinytest2 requires a few steps to get up and running (most notably the chromote package), but you’ll find excellent documentation on the package website.2\nThe shinytest2::use_shinytest2() performs the following setup steps:\n\n✔ Adding shinytest2::load_app_env() to tests/testthat/setup-shinytest2.R\n✔ Adding *_.new.png to .gitignore\n✔ Adding _\\\\.new\\\\.png$ to .Rbuildignore\n✔ Adding shinytest2 to Suggests field in DESCRIPTION\n\nWe also get some advice on using shinytest2 functions in our code:\n• In your package code, use `rlang::is_installed(\"shinytest2\")` or\n  `rlang::check_installed(\"shinytest2\")` to test if shinytest2 is installed\n• Then directly refer to functions with `shinytest2::fun()`\nAfter setting up shinytest2, be sure you can create a new chromote session like the one below:\n\nlibrary(chromote)\nb &lt;- ChromoteSession$new()\nb$view()\n\n\n\n\n\n\n(a) Chromium headless browser\n\n\nFigure 14.1: A new Chromote session"
  },
  {
    "objectID": "test_system.html#recording-tests",
    "href": "test_system.html#recording-tests",
    "title": "14  System tests",
    "section": "14.2 Recording tests",
    "text": "14.2 Recording tests\nIf we launch the test recorder with shinytest2::record_test(), change the inputs in our application, click on Expect Shiny values and Save test and exit, a test is recorded to a new test file: tests/testthat/test-shinytest2.R\n\n\n\n\n\n(a) Test recorder\n\n\nFigure 14.2: Creating a test with shinytest2::record_test()\n\n\nThe test runs and saves the PNG snapshot and test values to the tests/testthat/_snaps/ folder:\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\n── Warning (test-shinytest2.R:11:3): {shinytest2} recording: feature-01 ──\nAdding new file snapshot: 'tests/testthat/_snaps/feature-01-001_.png'\n\n── Warning (test-shinytest2.R:11:3): {shinytest2} recording: feature-01 ──\nAdding new file snapshot: 'tests/testthat/_snaps/feature-01-001.json'\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\n\n\n\n\n\n\nloadSupport() warning with shinytest2\n\n\n\n\n\n\nAfter setting up shinytest2, the tests/testthat/setup-shinytest2.R file contains a call to shinytest2::load_app_env(). This runs automatically with shinytest2 tests and produces a familiar warning:\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears\n  to contain an R package. Sourcing files in R/ may cause unexpected behavior.\nWe covered this warning message in the Launch chapter, and it’s being addressed in a future release of shinytest2\n\n\n\n\nThe contents of the new test-shinytest2.R test file are below:\n\nlibrary(shinytest2)\ntest_that(\"{shinytest2} recording: feature-01\", {\n  app &lt;- AppDriver$new(name = \"feature-01\", \n                       height = 800, width = 1173)\n  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n  app$set_inputs(`vars-x` = \"critics_score\")\n  app$set_inputs(`vars-z` = \"genre\")\n  app$set_inputs(`vars-alpha` = 0.7)\n  app$set_inputs(`vars-size` = 3)\n  app$set_inputs(`vars-plot_title` = \"New plot title\")\n  app$expect_values()\n})\n\nAs we can see, each action in the test recorder has a corresponding call in the test:\n\nInitialize the AppDriver$new() with the name of the test and the dimensions of the Chromium browser.\n\nChange the y axis (vars-y) to ‘IMBD number of votes’ (imdb_num_votes)\n\nChange the x axis (vars-x) to ‘Critics Score’ (critics_score)\n\nChange the color by (vars-z) to ‘Genre’ (genre)\n\nChange the point opacity (vars-alpha) to ‘0.7’\n\nChange the point size (vars-alpha) to ‘3’\n\nChange the plot title to (vars-plot_title) to ‘New plot title’\n\nWe’ll use this initial test as a template for writing the steps in our test Scenarios.\n\n14.2.1 BDD test templates\nThere are multiple ways to approach your test layout with testthat’s describe(), it() and/or test_that() functions. Below is an example with dedicated Feature and Scenario descriptions, a reference to the feature number in the it() (or test_that()) call:\n\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \ndescribe(\"Scenario: Change dropdown values for plotting\n            Given the movie review application is loaded\n            When I choose the variable [ ] for the x-axis\n            And I choose the variable [ ] for the y-axis\n            And I choose the variable [ ] for the color\n            And I choose the size of the points to be [ ]\n            And I choose the opacity of the points to be [ ]\n            And I enter '[ ]' for the plot title\n           \n            Then the scatter plot should show [ ] on the x-axis\n            And the scatter plot should show [ ] on the y-axis\n            And the points on the scatter plot should be colored by [ ]\n            And the size of the points on the scatter plot should be [ ]\n            And the opacity of the points on the scatter plot should be [ ]\n            And the title of the plot should be '[ ]'\", {\n              \n              it(\"Feature 01\", {\n                    app &lt;- AppDriver$new(name = \"feature-01\", \n                                       height = 800, width = 1173)\n                  app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                  app$set_inputs(`vars-x` = \"critics_score\")\n                  app$set_inputs(`vars-z` = \"genre\")\n                  app$set_inputs(`vars-alpha` = 0.7)\n                  app$set_inputs(`vars-size` = 3)\n                  app$set_inputs(`vars-plot_title` = \"New plot title\")\n                  app$expect_values()\n              })\n      })\n})\n\nWith this approach you can create the test file as soon as you have a Feature description (and come back later to fill in the Scenarios and tests).\nAn alternative approach is to use nested describe() functions and include each of the Scenario’s Then steps in the it() or test_that() call (these are what will actually be tested):\n\nlibrary(shinytest2)\ndescribe(\"Feature 1: Scatter plot data visualization dropdowns\n           As a film data analyst\n           I want to explore variables in the movie review data\n           So that I can analyze relationships between movie reivew sources\", {\n             \n  describe(\"Scenario A: Change dropdown values for plotting\n             Given the movie review application is loaded\n             When I choose the variable [ ] for the x-axis\n             And I choose the variable [ ] for the y-axis\n             And I choose the variable [ ] for the color\", {\n        it(\"Then the scatter plot should show [ ] on the x-axis\n             And the scatter plot should show [ ] on the y-axis\n             And the points on the scatter plot should be colored by [ ]\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-a\", \n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-y` = \"imdb_num_votes\")\n                app$set_inputs(`vars-x` = \"critics_score\")\n                app$set_inputs(`vars-z` = \"genre\")\n                app$expect_values()\n       })\n     })\n             \n  describe(\"Scenario B: Change dropdown values for plotting\n              Given the movie review application is loaded\n              When I choose the size of the points to be [ ]\n              And I choose the opacity of the points to be [ ]\n              And I enter '[ ]' for the plot title\", {\n         it(\"Then the size of the points on the scatter plot should be [ ]\n              And the opacity of the points on the scatter plot should be [ ]\n              And the title of the plot should be '[ ]'\", {\n              app &lt;- AppDriver$new(name = \"feature-01-senario-b\", \n                                     height = 800, width = 1173)\n                app$set_inputs(`vars-alpha` = 0.7)\n                app$set_inputs(`vars-size` = 3)\n                app$set_inputs(`vars-plot_title` = \"New plot title\")\n                app$expect_values()\n        })\n      })\n})\n\nAn important not on this approach is the different names for each AppDriver$new() (otherwise we’d be overwriting the previous snapshot/values).\n\n\n14.2.2 Testing apps in inst/\nIf we want to test a feature for one of the alternative applications in moviesApp, we can pass their location to the app_dir argument of AppDriver$new(). In the test below, the scenario describes changing inputs for x, y, and color, and removing the missing values from the graph:\n\nlibrary(shinytest2)\ndescribe(\n  \"Feature 1: Scatter plot data visualization dropdowns\n     As a film data analyst\n     I want to explore movie review variables from IMDB (ggplot2movies::movies data)\n     So that I can analyze relationships between movie attributes and ratings\", {\n  describe(\n    \"Scenario: Change dropdown values for plotting\n        Given the movie review application is loaded\n        When I choose the variable ['Length'] for the x-axis\n        And I choose the variable ['Rating'] for the y-axis\n        And I choose the variable ['Genre'] for the color\n        And I click the ['Remove missing'] checkbox\", code = {\n    it(\"Then the scatter plot should show ['Length'] on the x-axis\n        And the scatter plot should show ['Rating'] on the y-axis\n        And the points on the scatter plot should be colored by ['Genre']\n        And the missing values should be removed from the plot\", {\n            \n    test_logger(start = 'ggp2movies-feat-01', msg = \"update x, y, z, missing\")\n      \n    app &lt;- AppDriver$new(app_dir = system.file(\"dev\", package = \"moviesApp\"), \n                         name = \"ggp2movies_app-feature-01\", \n                         wait = FALSE, timeout = 30000,\n                         height = 800, width = 1173)\n      app$set_inputs(`vars-y` = \"length\")\n      app$set_inputs(`vars-x` = \"rating\")\n      app$set_inputs(`vars-z` = \"genre\")\n      app$set_inputs(`plot-missing` = TRUE)\n      app$expect_values()\n          \n      test_logger(end = 'ggp2movies-feat-01', msg = \"update x, y, z, missing\")\n      \n      })\n   })\n})\n\nNot that I’ve changed the wait and timeout arguments in AppDriver$new() because this tests takes over 10 seconds to complete (which I can see with my test_logger() output):\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-10-26 12:58:57] [ START ggp2movies-feat-01 = update x, y, z, missing]\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 1 ]\nINFO [2023-10-26 12:59:09] [ END ggp2movies-feat-01 = update x, y, z, missing]\nWhen I confirm this in the output png file, I can see the x, y, and color values have been changed (and the missing values have been removed).\n\n\n\n\n\n(a) Snapshot png file\n\n\nFigure 14.3: File saved in tests/testthat/_snaps/ggp2movies_app-feature-01-001_.png'"
  },
  {
    "objectID": "test_system.html#test.mode",
    "href": "test_system.html#test.mode",
    "title": "14  System tests",
    "section": "14.3 test.mode",
    "text": "14.3 test.mode\nIf you recall, we’ve included an argument in both of our standalone app functions to allow for options to be passed to shinyApp().\n\nmovies_app(options = list())\n\nIf we’re testing our application, we can include the test.mode = TRUE option, which will return any values passed to exportTestValues():\n\nmovies_app(options = list(test.mode = TRUE), run = 'p')\n\nWe can also include this in our .Rprofile as:3\n\noptions(shiny.testmode = TRUE)\n\nTo export values, place the name of exported reactive values in curly brackets ({}). Below is an example using the inputs() reactive object in the mod_scatter_display_server():\n\nexportTestValues(\n   x = { inputs()$x },\n   y = { inputs()$y },\n   z = { inputs()$z },\n   alpha = { inputs()$alpha },\n   size = { inputs()$size },\n   title = { inputs()$plot_title }\n  )\n\nIn our test, we can create the AppDriver$new() object, extract the values with get_values(), then write tests against any of the exported values:\n\napp &lt;- AppDriver$new(name = \"test-values\",\n                     height = 800, width = 1173,\n                     wait = FALSE, timeout = 300000)\n\ntest_values &lt;- app$get_values()\n\ntest_values[['export']]\n\n$`plot-alpha`\n[1] 0.5\n\n$`plot-size`\n[1] 2\n\n$`plot-title`\n[1] \"\"\n\n$`plot-x`\n[1] \"imdb_rating\"\n\n$`plot-y`\n[1] \"audience_score\"\n\n$`plot-z`\n[1] \"mpaa_rating\"\n\n\nLaunch app with the shinypak package:\n\nlaunch('14_tests-system')"
  },
  {
    "objectID": "test_system.html#recap",
    "href": "test_system.html#recap",
    "title": "14  System tests",
    "section": "Recap",
    "text": "Recap\nBehavior-driven development (or behavior-driven testing) fills the void between non-technical stakeholders and developers by encouraging natural, descriptive language (often complete sentences) to define and communicate the application requirements.\nCapturing the application’s desired behaviors in Features (As a , I want, So that) and Scenarios (Given, When, Then) provides a testing script that’s clear and easy to follow. Using the BDD format also makes system tests easier to update if the features and scenarios change.\n\n\n\n\n\n\nRecap: System tests\n\n\n\n\n\n\n\nSystem tests for your shiny app-package\n\nshinytest2: perform system (or end-to-end) tests by installing shinytest2 and running shinytest2::use_shinytest2\n\nrecord_test(): call record_test() to launch your application in the test recorder.\nRecording tests: interact with your application in the test recorder and export values and/or snapshots.\nTest files: record_test() automatically creates a new test file in tests/testthat/\n\nBDD functions: use describe() and it() to add features and sceanrios in test files.\ndescribe('Feature...', code = {\n    it('Scenario...', code = { ... })\n})"
  },
  {
    "objectID": "test_system.html#footnotes",
    "href": "test_system.html#footnotes",
    "title": "14  System tests",
    "section": "",
    "text": "System tests should strive to replicate the production conditions, even when/if it’s not possible to perfectly replicate the environment.↩︎\nA great place to start is the Getting Started vignette.↩︎\nWe covered the .Rprofile in Section 4.4.3.↩︎"
  },
  {
    "objectID": "deploy.html#docker",
    "href": "deploy.html#docker",
    "title": "Deploy",
    "section": "Docker",
    "text": "Docker\n\nThis chapter covers how Docker can simplify setting up your R environment and reduce the “it works on my machine” problem.\n\nWe’ll introduce how Docker provides a consistent environment for the application, ensuring it works seamlessly across different computers.\nWe’ll cover building our Shiny app-package inside a Docker image, which can be launched into a virtual container."
  },
  {
    "objectID": "deploy.html#continuous-integration-and-deployment-with-github-actions",
    "href": "deploy.html#continuous-integration-and-deployment-with-github-actions",
    "title": "Deploy",
    "section": "Continuous Integration and Deployment with GitHub Actions",
    "text": "Continuous Integration and Deployment with GitHub Actions\n\nWe’ll introduce Continuous Integration (CI) and Continuous Deployment (CD), essential practices for modern software development. CI/CD automates the process of testing and deploying your applications.\nThis chapter will cover how GitHub Actions (a relatively new feature within the popular code hosting platform GitHub) can automate the testing and deployment of your R Shiny app-package."
  },
  {
    "objectID": "deploy.html#code-quality-tools",
    "href": "deploy.html#code-quality-tools",
    "title": "Deploy",
    "section": "Code Quality Tools",
    "text": "Code Quality Tools\n\nMaintaining high-quality, readable code is crucial. This chapter introduces lintr and styler, two tools specifically for R.\n\nlintr: A tool that checks your R code for potential issues and improvements.\nstyler: This tool automatically formats your R code, ensuring it is clean and follows consistent style guidelines.\n\nThis chapter will also cover packages for ensuring your app-package has properly documented/managed dependencies and follows ‘best practices.’"
  },
  {
    "objectID": "docker.html#sec-what-is-docker",
    "href": "docker.html#sec-what-is-docker",
    "title": "15  Docker",
    "section": "15.1 What is Docker?",
    "text": "15.1 What is Docker?\nTwo terms to know when working with Docker are container and image. Containers and images work together but they serve different purposes in the Docker ecosystem.\nImage: A Docker image is a lightweight, standalone, and executable file that includes everything needed to run an application, including the code, runtime, system tools, libraries, and settings.\nContainers: A Docker container is a runtime instance of a Docker image. When you run an image, Docker creates a container from that image. A Docker image can exist without a container, but all containers must be instantiated from an image.\n\n15.1.1 How they work\nImagine your computer as a building. In this building, your operating system (OS) is like a big kitchen where everyone cooks. If someone (a software application) needs the oven at a specific temperature or requires a particular ingredient, this can interfere with what someone else (i.e., other applications) wants to cook. This situation is somewhat analogous to the competition for resources software applications can have while running on a particular machine.\nDocker containers are like individual, self-contained mini-kitchens containing appliances, ingredients, and utensils. Each mini-kitchen can operate independently, regardless of what’s happening in the others. Docker images can contain different ‘recipes’ for software applications, and each application can have different requirements (dependencies, libraries, versions, etc.).2\nDocker images are created through a build process, which uses a Dockerfile (a text file containing a series of instructions) to define how the image should be constructed. For a Shiny app, all of the application’s dependencies are stored inside the container, which ensures consistency across environments. The container also isolates the image (and the application) from the host system."
  },
  {
    "objectID": "docker.html#installing-docker",
    "href": "docker.html#installing-docker",
    "title": "15  Docker",
    "section": "15.2 Installing Docker",
    "text": "15.2 Installing Docker\nFollow the instructions found on the Docker website to install Docker Desktop. I’ll be demonstrating how to use Docker on a macOS (but it’s available on most operating systems).\nAfter installation, Docker Desktop will initially show no active images/containers:3\n\n\n\nDocker Desktop Containers (Mac)\n\n\nAfter installing Docker, the development process for your Shiny app-package doesn’t change until you’re ready to deploy your application."
  },
  {
    "objectID": "docker.html#sec-dockerfile",
    "href": "docker.html#sec-dockerfile",
    "title": "15  Docker",
    "section": "15.3 The Dockerfile",
    "text": "15.3 The Dockerfile\nWe’ll be using the moviesApp example from the previous chapter as an example (the folder/file structure is below):\n\n\nLaunch app with the shinypak package:\n\nlaunch('15_docker')\n\n\n\nview app-package folder tree\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── data.R\n│   ├── display_type.R\n│   ├── ggp2_movies_app.R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   ├── movies_app.R\n│   ├── movies_server.R\n│   ├── movies_ui.R\n│   ├── scatter_plot.R\n│   └── testthat.R\n├── README.md\n├── app.R\n├── data\n│   ├── movies.RData\n│   └── movies.rda\n├── data-raw\n│   └── tidy_movies.R\n├── inst\n│   ├── dev\n│   │   ├── app.R\n│   │   ├── imdb.png\n│   │   └── tidy_movies.fst\n│   ├── extdata\n│   │   └── movies.fst\n│   ├── prod\n│   │   └── app\n│   │       └── app.R\n│   └── www\n│       ├── bootstrap.png\n│       └── shiny.png\n├── man\n│   ├── display_type.Rd\n│   ├── ggp2_movies_app.Rd\n│   ├── mod_scatter_display_server.Rd\n│   ├── mod_scatter_display_ui.Rd\n│   ├── mod_var_input_server.Rd\n│   ├── mod_var_input_ui.Rd\n│   ├── movies.Rd\n│   ├── movies_app.Rd\n│   ├── movies_server.Rd\n│   ├── movies_ui.Rd\n│   ├── scatter_plot.Rd\n│   └── test_logger.Rd\n├── moviesApp.Rproj\n├── tests\n│   ├── testthat\n│   │   ├── fixtures\n│   │   │   ├── make-tidy_ggp2_movies.R\n│   │   │   └── tidy_ggp2_movies.rds\n│   │   ├── helper.R\n│   │   ├── setup-shinytest2.R\n│   │   ├── test-app-feature-01.R\n│   │   ├── test-ggp2_app-feature-01.R\n│   │   ├── test-mod_scatter_display.R\n│   │   ├── test-mod_var_input.R\n│   │   ├── test-scatter_plot.R\n│   │   └── test-shinytest2.R\n│   └── testthat.R\n└── vignettes\n    └── test-specs.Rmd\n\n15 directories, 49 files\n\n\nWhen our application is ready to deploy, we’ll create a Dockerfile, which is a plain-text file (no extension). Dockerfiles are a blend of commands, numeric values, and character strings with the following general conventions:\n\nEach line in the Dockerfile starts with an instruction. These aren’t case-sensitive, but it’s common practice to capitalize each command.\nComments or explanatory notes begin with #. These will be ignored by the Docker engine.\n\nBelow are two lines from the Dockerfile found in the excellent post titled, R Shiny Docker: How To Run Shiny Apps in a Docker Container. This is a great place to familiarize yourself with deploying a non-package Shiny application with Docker.4\n\n# build image \nFROM rocker/shiny\n\n# create location for app\nRUN mkdir /home/shiny-app\n\nAs you can see, the Dockerfile combines instructions (FROM, RUN) with command-line arguments (mkdir). You don’t have to be a command-line expert to write a Dockerfile (but knowing a few can get you out of a jam 5).\n\n15.3.1 Create image\nDocker files start by building an image. In our case, we want an image configured to run R, which has been provided for us by the generous folks at the rocker project.\nThe Shiny rocker image is for Shiny apps:\n\nFROM rocker/shiny\n\n\n\n15.3.2 Install dependencies\nUse RUN and R -e to install dependencies for our app in the container from CRAN.6\n\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\"))'\n\n\n\n15.3.3 Create location for app\n\nRUN mkdir creates a new /deploy directory in the container\nADD . /deploy copies the files from the current directory (on the host machine) into the /deploy directory inside the container\nWORKDIR /deploy sets the /deploy directory as the working directory for any subsequent instructions.\n\n\nRUN mkdir /deploy\nADD . /deploy\nWORKDIR /deploy\n\n\n\n15.3.4 Install app-package\nremotes::install_local() will the R package specified in the local directory (where our Shiny app-package lives), without upgrading dependencies.\n\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\n\n\n\n15.3.5 Clean up\nRUN rm -rf /deploy cleans up and reduces the size of the container.\n\nRUN rm -rf /deploy\n\n\n\n15.3.6 Expose port\nMake our Shiny app available on EXPOSE 8180.\n\nEXPOSE 8180\n\n\n\n15.3.7 Launch app\nWhen the container starts, set Shiny to listen on port 8180, then launch the Shiny app from our moviesApp package. The port we exposed in the Dockerfile should match the shiny.port option.\n\nCMD R -e \"options('shiny.port'=8180,shiny.host='0.0.0.0');library(moviesApp);moviesApp::movies_app()\""
  },
  {
    "objectID": "docker.html#build-image",
    "href": "docker.html#build-image",
    "title": "15  Docker",
    "section": "15.4 Build image",
    "text": "15.4 Build image\nThe final Dockerfile we’ll use to launch our application is below:\n\nFROM rocker/shiny\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\"))'\nRUN mkdir /deploy\nADD . /deploy\nWORKDIR /deploy\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nRUN rm -rf /deploy\nEXPOSE 8180\nCMD R -e \"options('shiny.port'=8180,shiny.host='0.0.0.0');library(moviesApp);moviesApp::movies_app()\"\n\nTo build the Docker image and create a new container, run the docker build command in the Terminal with a tag (-t), a name for the image (movies-app-docker-demo), and the location (.):\n\ndocker build -t movies-app-docker-demo .\n\nAs the docker image builds you’ll see the output in the Terminal:\n\n\n\n\n\nAfter the image is built, we’ll see a new container listed in Docker desktop:\n\n\n\n\n\nNew Docker containers are named using a random combination of adjectives and famous scientists’ surnames (unless the --name flag is added). Change the name of a Docker image with docker rename &lt;old_name&gt; &lt;new_name&gt;:\n\ndocker rename great_yalow movies_app\n\n\n15.4.1 Running the container\nAfter building the image, we can run the new container using docker run\n\ndocker run -p 8180:8180 movies-app-docker-demo\n\nIn the Terminal, we’ll see an R session initialize, and the R function calls from the last line of our Dockerfile:\n\nR version 4.3.2 (2023-10-31) -- \"Eye Holes\"\nCopyright (C) 2023 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n&gt; options('shiny.port'=8180,shiny.host='0.0.0.0');library(moviesApp);moviesApp::movies_app()\nLoading required package: shiny\n\nListening on http://0.0.0.0:8180\n\nCopy the hyperlink above and place it in the browser to view the application:\n\n\n\n\n\nEach Docker container is created from the image (which is specified in the Dockerfile). The image serves as a blueprint for the containers, and we could create multiple containers from the same image:\n\n\n\nRunning and stopping Docker containers"
  },
  {
    "objectID": "docker.html#docker-golem",
    "href": "docker.html#docker-golem",
    "title": "15  Docker",
    "section": "15.5 Docker & golem",
    "text": "15.5 Docker & golem\nThe golem package has multiple functions for building Docker files and images. There are a few notable points to make about some of the Docker images created with golem:\n\ngolem’s Docker functions can produce multiple Docker files (golem::add_dockerfile_with_renv() creates a tmp/deploy folder and adds the following files)\n\n\nView deploy/ folder\ndeploy/\n  ├── Dockerfile\n  ├── Dockerfile_base\n  ├── README\n  ├── gap_0.0.0.9000.tar.gz\n  └── renv.lock.prod\n\n\ngolem’s Docker files typically use the R build from rocker (and include a version):\n\n\nView R version build\nFROM rocker/verse:4.3.2\n\n\ngolem Docker files might also include additional commands for installing/updating command-line (linux) tools for downloading/exchanging data:\n\n\nView apt-get commands\nRUN apt-get update && apt-get install -y  libcurl4-openssl-dev libicu-dev libssl-dev libxml2-dev make pandoc zlib1g-dev\n\n\nThey also usually the remotes package to specify the version of each package and whether to upgrade (or not):\n\n\nView remotes::install_version()\nRUN R -e 'install.packages(\"remotes\")'\nRUN Rscript -e 'remotes::install_version(\"rlang\",upgrade=\"never\",version=\"1.1.2\")'\nRUN Rscript -e 'remotes::install_version(\"stringr\",upgrade=\"never\",version=\"1.5.1\")'\nRUN Rscript -e 'remotes::install_version(\"shiny\",upgrade=\"never\",version =\"1.8.0\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2\",upgrade=\"never\",version=\"3.4.4\")'\n\n\n\n\n\n\n\n\n\nRUN R -e vs RUN Rscript -e\n\n\n\n\n\n\nBoth R -e and RUN Rscript -e will execute R expressions from the command line.\n\nR -e is straightforward and typically used to evaluate a single expression (i.e., install.packages())\nRUN Rscript -e is more commonly used for running scripts or more specialized commands:\n\npkgs &lt;- c('glue', 'cli')\ninstall.packages(pkgs)\n\n\n\n\nThere are additional differences, but these are important if you want to include additional requirements or control the version of R (or a package dependency). golem’s Docker images are more (you guessed it) opinionated, but every time I’ve used one it works right “out of the box.”"
  },
  {
    "objectID": "docker.html#docker-in-app-packages",
    "href": "docker.html#docker-in-app-packages",
    "title": "15  Docker",
    "section": "15.6 Docker in app-packages",
    "text": "15.6 Docker in app-packages\nYou can include a Dockerfile in an app-package by adding it to the .Rbuildignore file.7\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n^moviesApp\\.Rcheck$\n^moviesApp.*\\.tar\\.gz$\n^moviesApp.*\\.tgz$\n^Dockerfile$\n\nThis will ensure it won’t interfere with your app-package builds. Docker also has it’s own ignore file (.dockerignore), which can include similar contents to the .gitignore:\n\n.RData\n.Rhistory\n.git\n.gitignore\nmanifest.json\nrsconnect/\n.Rproj.user\n\nNote that if you include a .dockerignore file, you should also include this pattern in the .Rbuildignore:\n\n^.*\\.Rproj$\n^\\.Rproj\\.user$\n^moviesApp\\.Rcheck$\n^moviesApp.*\\.tar\\.gz$\n^moviesApp.*\\.tgz$\n^Dockerfile$\n^\\.dockerignore$"
  },
  {
    "objectID": "docker.html#recap",
    "href": "docker.html#recap",
    "title": "15  Docker",
    "section": "15.7 Recap",
    "text": "15.7 Recap\nThis has been a brief overview of using Docker to deploy your Shiny App-Package. Docker files are used to build images, which defines an environment for the Shiny application to run. The container is the actual running instance of that environment.\n\nDocker images are immutable, meaning they do not change. Once an image is created, it remains unchanged inside a container.\nDocker containers can be started, stopped, moved, and deleted, but each time a container is run, it’s created from an image.\n\nDocker is covered again in the golem chapter and on the Shiny frameworks supplemental website. If you’d like to learn more, Appsilon has a great introduction to Docker (mentioned above).8 I also found the Dockerizing shiny applications post helpful. 9"
  },
  {
    "objectID": "docker.html#footnotes",
    "href": "docker.html#footnotes",
    "title": "15  Docker",
    "section": "",
    "text": "Read more about Docker in the official documentation.↩︎\nDocker containers are similar to virtual machine environments (like VMware), but don’t use a significant portion of the hardware system’s resources.↩︎\nIf you follow the Docker ‘Walkthroughs’ in the Learning Center, you might see the welcome-to-docker container listed.↩︎\nI’ve altered the comments of the original Dockerfile, so be sure to read the entire blog post before copying + pasting this into your workflow.↩︎\nI love the help files on https://linuxize.com/, and this tutorial is a nice introduction to the command-line.↩︎\nWe’ll need remotes to install our app-package locally (i.e., with remotes::install_local(upgrade=\"never\")).↩︎\n.Rbuildignore includes files that we need to have in our app-package, but don’t conform to the standard R package structure (and shouldn’t be included when building our app-package from the source files).↩︎\nAppsilon has a few posts on Docker: ‘R Shiny Docker: How To Run Shiny Apps in a Docker Container’ and ‘Renv with Docker: How to Dockerize a Shiny Application with an Reproducible Environment’↩︎\nThis is the second post in a series (see the first post here).↩︎"
  },
  {
    "objectID": "cicd.html#sec-gha",
    "href": "cicd.html#sec-gha",
    "title": "16  CI/CD",
    "section": "16.1 GitHub Actions",
    "text": "16.1 GitHub Actions\n\n\n\nGitHub Actions (or Actions, for short) is a feature provided by GitHub that enables automation of various development workflows. These workflows are defined in YAML files and can automate some of the repetitive tasks in the development lifecycle, right within a GitHub repository.\n\n\n\n\n\nGitHub Actions\n\n\n\n\n\nActions allow us to create custom workflows to automatically build, test, and deploy our code. Workflows can be triggered by a push to a branch, a pull request, a specific time schedule, or another GitHub event.\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.1_cicd-style')\n\n\n16.1.1 Workflow fields\nThe YAML workflow file configures and defines the automated tasks run in a GitHub repository. Workflows typically include fields for building, testing, and deploying code, and are structured into several key sections:\n\n16.1.1.1 on\n\n“An event is a specific activity in a repository that triggers a workflow run.”\n\n\n\n\non defines the event(s) that trigger the workflow. Triggers can be push and/or pull events to specific branches, creating a release, commenting on an issue, or even configured to run at scheduled times.\n\n\n \n\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\n\n\n\n\n16.1.1.2 name\n\n\n\nname is an optional field to identify a workflow in the Actions tab of the GitHub repository. If name is not provided, GitHub will use the file path.\n\n\n \n\n\nname: shiny\n\n\n\n\n\n16.1.1.3 jobs\n\n“A job is a set of steps in a workflow that is executed on the same runner.”\n\n\n\n\nThe job and it’s identifier (check) are used to reference the runner, in this example it’s ubuntu-latest.\n\n\n \n\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n\n\nThe matrix directive can be used to run jobs across different operating systems, programming language versions, etc. (fail-fasle: false means the workflow will continue running even if one of the matrix jobs fails).\njobs:\n  check:\n    runs-on: ${{ matrix.config.os }}\n\n    name: ${{ matrix.config.os }} (${{ matrix.config.r }})\n\n    strategy:\n      fail-fast: false\n      matrix:\n        config:\n          - {os: macos-latest,   r: 'release'}\n          - {os: windows-latest, r: 'release'}\n          - {os: ubuntu-latest,   r: 'release'}\n\n\n16.1.1.4 steps\n\n“Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step.”\n\n\n\n\nsteps define a series of tasks or actions that the job will execute. These steps check out the code, set up an R environment, and installs a local package\n\n\n \n\n\nsteps:\n    - uses: actions/checkout@v2\n\n    - name: Set up R\n      uses: r-lib/actions/setup-r@v2\n\n    - name: Install package\n      run: |\n        install.packages('remotes')\n        remotes::install_local('.')\n      shell: Rscript {0}\n      \n\n\n\n\n\n\n\n\n\nWhat is shell: Rscript {0}?\n\n\n\n\n\n\n  name: Install packages\n  run: |\n    pkgs &lt;- c('glue', 'cli')\n    install.packages(pkgs)\n  shell: Rscript {0}\nThe command install.packages(pkgs) is run as an R script:\n\nshell specifies which command-line interpreter (bash, pwsh, python, or Rscript) to use for the run commands\nRscript is the command-line tool provided by R to execute R scripts and commands in a non-interactive environment.\n{0} is a placeholder for the R commands written in the run section.\n\n\n\n\n\n\n\n16.1.1.5 Comments\nLines beginning with # will not be executed. It’s common to provide 1) a reference to the workflow source (r-lib/actions in this case) and 2) a link for help with debugging build failures.\n# Workflow derived from https://github.com/r-lib/actions/tree/v2/examples\n# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help\n\n\n\n16.1.2 Workflow permissions\nIn order for workflows to run, we’ll need to make sure Actions have read and write permissions. We can do this by clicking on the repository’s Settings tab, then expand the Actions menu and select General:\n\n\n\nRepository Action settings\n\n\nIn the General settings, we want to confirm the workflow has Read and write permissions permissions (if this needs to be been changed, be sure to click Save).\n\n\n\nWorkflow permissions\n\n\nNow our workflows can commit and push changes to the repository.\n\n\n16.1.3 use_github_action()\nIn R packages, we can set up the GitHub Action infrastructure with usethis::use_github_action(). The name can be any of the workflow files available at r-lib/actions. The first workflow we’ll be demonstrating can be used to automate the code style in an app-package.\n\nusethis::use_github_action(\"style\")\n\n\n✔ Setting active project to '/projects/apps/moviesApp'\n✔ Creating '.github/'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/style.yaml@v2' to '.github/workflows/style.yaml'\n\nThe output tells us a local .github/workflows/style.yaml file has been copied from the r-lib/actions/examples/style.yaml@v2 into the .github/workflows folder:\n\n.github/\n  └── workflows\n    └── style.yaml\n\n2 directories, 1 file\n\nThe documentation for the style.yaml@v2 file tells us this workflow,\n\n“styles the R code in a package, then commits and pushes the changes to the same branch.”\n\nThe code styling in this workflow is handled by the styler package, which “formats your code according to the tidyverse style guide.”\nThree functions in the 16.1_cicd-style branch have altered to have zero style (R/display_type.R, R/mod_var_input.R, and R/test_logger.R). You can copy the code for these functions in the chunk below:2\n\n\nshow/hide no-style code\n# display_type ----\ndisplay_type &lt;- function(run = \"w\") {\n  \n  if (run == \"p\") {\n    \n    options(shiny.launch.browser = .rs.invokeShinyPaneViewer)\n    \n  } else if (run == \"b\") {\n    \n    options(shiny.launch.browser = .rs.invokeShinyWindowExternal)\n    \n  } else if (run == \"w\") {\n    \n    options(shiny.launch.browser = .rs.invokeShinyWindowViewer)\n    \n  } else {\n    \n    options(shiny.launch.browser = NULL)\n    \n  }\n\n  shinyViewerType &lt;- getOption(\"shiny.launch.browser\") |&gt;\n    attributes() |&gt; unlist() |&gt; unname()\n\n  cli::cli_alert_info(\"shinyViewerType set to {shinyViewerType}\")\n}\n\n# mod_var_input_ui ----\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"), selected = \"audience_score\"\n    ),\n    selectInput(inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"), selected = \"imdb_rating\"\n    ),\n    selectInput(inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"), selected = \"mpaa_rating\"\n    ),\n    sliderInput(inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1, value = 0.5\n    ),\n    sliderInput(\n      inputId = ns(\"size\"),\n      label = \"Size:\", min = 0, max = 5, value = 2\n    ),\n    textInput(inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n# test_logger ----\ntest_logger &lt;- function(start = NULL, end = NULL, msg) {\n  \n  if (is.null(start) & is.null(end)) {\n    \n    cat(\"\\n\")\n    \n    logger::log_info(\"{msg}\")\n    \n    } else if (!is.null(start) & is.null(end)) {\n    \n    cat(\"\\n\")\n    \n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n  \n    } else if (is.null(start) & !is.null(end)) {\n      \n    cat(\"\\n\")\n      \n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n    \n    } else {\n      \n    cat(\"\\n\")\n      \n    logger::log_info(\"\\n[ START {start} = {msg}]\")\n    \n    cat(\"\\n\")\n    \n    logger::log_info(\"\\n[ END {end} = {msg}]\")\n    \n    }\n  \n}\n\n\nWe’ll make one small change to style.yaml before pushing it to GitHub. Instead of having the workflow automatically commit and push the styled code changes to the same branch, we’ll limit the code styling to the 16.1_cicd-style branch:\non:\n  push:\n    branches: [16.1_cicd-style]\n    paths: [\"**.[rR]\", \"**.[qrR]md\", \"**.[rR]markdown\", \"**.[rR]nw\", \"**.[rR]profile\"]\nThis change ensures our style workflow will be triggered only for pushes to the specified branches (and when changes are made to files with the specified extensions in path).\nAfter saving these changes to .github/workflows/style.yaml, we’ll add, commit, and push the changes to GitHub,\n\ngit add .\ngit commit -m \"updates to style workflow\"\n\n\n[16.1_cicd-style 899bd38] updates to style workflow\n 4 files changed, 43 insertions(+), 45 deletions(-)\n\n\ngit push\n\n\nEnumerating objects: 17, done.\nCounting objects: 100% (17/17), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (8/8), done.\nWriting objects: 100% (9/9), 950 bytes | 25.00 KiB/s, done.\nTotal 9 (delta 6), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (6/6), completed with 6 local objects.\nTo https://github.com/mjfrigaard/moviesApp.git\n   d366e0f..899bd38  16.1_cicd-style -&gt; 16.1_cicd-style\n\nIf we view the Actions tab, we’ll see the workflow listed with the name of our commit message:\n\n\n\nCurrently running workflows\n\n\nClicking on the workflow reveals the following:\n\n\n\nname of running workflow\n\n\nThe style widget contains each step in the workflow file. If we click on it we can see each step executed in real-time. Below we can see the dependency lockfile from pak:\n\n\n\nInstall dependencies workflow step running\n\n\nThe actual styling comes is in the Style step:\n\n\n\nStyle, Commit and push changes, Post install dependencies, Post checkout repo, and Post Cache Styler workflow steps running\n\n\nWhen the workflow has finished, we can pull the style changes to our local branch and view the styled files:3\n\ngit pull\n\n\nremote: Enumerating objects: 4, done.\nremote: Counting objects: 100% (4/4), done.\nremote: Total 4 (delta 3), reused 4 (delta 3), pack-reused 0\nUnpacking objects: 100% (4/4), 450 bytes | 56.00 KiB/s, done.\nFrom https://github.com/mjfrigaard/moviesApp\n   899bd38..0ad97cf  16.1_cicd-style -&gt; origin/16.1_cicd-style\nUpdating 899bd38..0ad97cf\nFast-forward\n R/display_type.R  | 13 +++----------\n R/mod_var_input.R | 30 ++++++++++++++++++++----------\n R/test_logger.R   | 30 ++++++++++--------------------\n 3 files changed, 33 insertions(+), 40 deletions(-)"
  },
  {
    "objectID": "cicd.html#a-shiny-workflow",
    "href": "cicd.html#a-shiny-workflow",
    "title": "16  CI/CD",
    "section": "16.2 A Shiny workflow",
    "text": "16.2 A Shiny workflow\nWe’ll be adapting the example GitHub Action workflow file for deploying a Shiny application. Before we get to the workflow file, we need to address a few settings and configurations that need to take place outside of the workflow file.\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.2_cicd-shiny')\n\n\n16.2.1 Creating repository secrets\nWe need to make sure our rsconnect secrets are stored with the GitHub repository (so we can access them from within the workflow file). To do this, we’re going to return to the Settings tab on the moviesApp repository, expand Secrets and variables under Security, and select Actions:4\n\n\n\nSecrets and variables for moviesApp repository\n\n\nUse New repository secret to create three new secrets: RSCONNECT_USER, RSCONNECT_TOKEN, and RSCONNECT_SECRET. You can access these in your shinyapps.io account:\n\n\n\nToken and Secret from shinyapps.io\n\n\nWhen you’re finished, should see the following three Repository secrets:\n\n\n\nRepository secrets in moviesApp\n\n\n\n\n16.2.2 Enable private repositories\nWe also need to make sure our shinyapps.io account allows us to install from private GitHub repositories during a workflow deployment. We can do this in the Profile menu item in our dashboard:\n\n\n\nUpdate Authentication in shinyapps.io profile\n\n\nClicking Update Authentication will open your Posit profile settings, where you can enable private repositories.\n\n\n\nPrivate repo access also enabled\n\n\n\n\n16.2.3 Generate renv.lock\nThe documentation for ‘Shiny App Deployment’ indicates we need to create a renv lockfile in the 16.2_cicd-shiny branch.5\nWe can create the lockfile with the code below:\n\ninstall.packages('renv')\nrenv::init(force = TRUE)\n\n\nThis project contains a DESCRIPTION file.\nWhich files should renv use for dependency discovery in this project? \n\n1: Use only the DESCRIPTION file. (explicit mode)\n2: Use all files in this project. (implicit mode)\n\nWe’re going to use the explicit mode, because the dependencies in the DESCRIPTION should be all that’s needed to run and deploy the application.\n\nSelection: 1\n\n\n- Using 'explicit' snapshot type. Please see `?renv::snapshot` for more details.\n\nThis project already has a private library. What would you like to do? \n\n1: Activate the project and use the existing library.\n2: Re-initialize the project with a new library.\n3: Abort project initialization.\n\nWe will start fresh and create a new project library:\n\nSelection: 2\n- Resolving missing dependencies ...\n\nAfter renv has discovered and installed the dependencies, the R session will restart and we’ll see the following new folder/files:\n\n1├── .Rprofile\n├── renv/\n│   ├── activate.R\n2│   └── settings.json\n3└── renv.lock\n\n\n1\n\n.Rprofile contains a call to source(\"renv/activate.R\"), which manages the project-level dependencies\n\n\n2\n\nrenv settings\n\n\n3\n\nrenv lockfile\n\n\n\n\nWhen using renv in package development, we want to be sure to run renv::install() and renv::update():\n\nrenv::install()\n\n\n- There are no packages to install.\n\n\nrenv::update()\n\n\n- Checking for updated packages ... Done!\n- All packages appear to be up-to-date.\n\n\n\n16.2.4 shiny-deploy.yaml\nWe can include the ‘Shiny App Deployment’ workflow file in moviesApp with usethis::use_github_action(\"shiny-deploy\"):6\n\nusethis::use_github_action(\"shiny-deploy\")\n\n\n✔ Creating '.github/'\n✔ Adding '^\\\\.github$' to '.Rbuildignore'\n✔ Adding '*.html' to '.github/.gitignore'\n✔ Creating '.github/workflows/'\n✔ Saving 'r-lib/actions/examples/shiny-deploy.yaml@v2' to '.github/workflows/shiny-deploy.yaml'\n\nThis example workflow file is designed to deploy a Shiny application to a server. We’re going to make a few changes to shiny-deploy.yaml so it will deploy the application stored in the 16.2_cicd-shiny branch.\nThe example shiny workflow includes calls to rsconnect::setAccountInfo() and rsconnect::deployApp(). We’ll perform a sanity check and confirm we can deploy the application using the information we’ve collected:\n\nStart by entering your rsconnect info:\n\ninstall.packages('rsconnect')\nrsconnect::setAccountInfo(\n  name = \"mjfrigaard\",\n  token = \"YOUR TOKEN\", \n  secret = \"YOUR SECRET\")\n\n\nThen try to deploy the application using rsconnect::deployApp():\n\n\nlibrary(moviesApp)\nrsconnect::deployApp(\n  appName = \"moviesAppCICD\",\n  account = \"mjfrigaard\",\n  server = \"shinyapps.io\",\n  forceUpdate = TRUE)\n\n\nReading the deployment log will tells us if the secret, token, configuration, and lockfile are all working:\n\n\n\n── Preparing for deployment ──────────────────────────────────────────────────\n✔ Deploying \"moviesAppCICD\" using \"server: shinyapps.io / username: mjfrigaard\"\nℹ Bundling 50 files: .github/workflows/shiny-deploy.yaml, .Rbuildignore, ..., \ntests/testthat.R, and vignettes/test-specs.Rmd\nℹ Capturing R dependencies with renv\n✔ Found 99 dependencies\n✔ Created 2,431,325b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 8130675\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1372980209\n  building: Processing bundle: 8130675\n  building: Building image: 9770352\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9770352\n  deploying: Starting instances\n  unstaging: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://mjfrigaard.shinyapps.io/moviesAppCICD/&gt;\n\nMaking sure my application will deploy locally with the code I plan on putting in a workflow file makes me confident it run when it’s triggered. Below we’ll adapt the .github/workflows/shiny-deploy.yaml file to deploy moviesApp.\n\n16.2.4.1 Trigger\n\n\n\non:\n  push:\n    branches: [16.2_cicd-shiny]\n    \nname: shiny\n\n\n\nThe event we want the workflow triggered on is a push to the 16.2_cicd-shiny branch\n\nWe’ll change the name to shiny\n\n\n\n\n\n\n16.2.4.2 Jobs\n\n\n\njobs:\n  shiny-deploy:\n    runs-on: ubuntu-latest\n    env:\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\n\n\njobs remains unchanged, but the identifier should match the name. 7\n\n\n\n\n\n\n16.2.4.3 Steps\n\n\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: r-lib/actions/setup-pandoc@v2\n\n      - uses: r-lib/actions/setup-r@v2\n        with:\n          use-public-rspm: true\n\n      - uses: r-lib/actions/setup-renv@v2\n\n      - name: Install rsconnect\n        run: install.packages(\"rsconnect\")\n        shell: Rscript {0}\n\n\n\nCheck out the repository code\n\nSet up Pandoc for document conversions\n\nSet up R environment\n\nuse-public-rspm is the public RStudio package manager\n\n\nSet up renv to manage the project-specific dependencies captured in renv.lock\n\nInstall rsconnect the step to deploy our app to the Shiny server\n\nrun installs the rsconnect package\n\n\n\n\n\nNow we’re ready to update the information in our .github/workflows/shiny-deploy.yaml file.\n\n\n\n  - name: Authorize and deploy app\n    env: \n      APPNAME: moviesAppCICD\n      ACCOUNT: mjfrigaard\n      SERVER: shinyapps.io \n\n\n\nAuthorize and deploy app defines the step to deploy our Shiny app\n\nenv sets up the environment variables APPNAME, ACCOUNT, and SERVER\n\n\n\n\nThe final run step sets the account information using rsconnect::setAccountInfo() and deploys the app to the specified server using rsconnect::deployApp():\n    run: |\n      rsconnect::setAccountInfo(\"${{ secrets.RSCONNECT_USER }}\", \"${{ secrets.RSCONNECT_TOKEN }}\", \"${{ secrets.RSCONNECT_SECRET }}\")\n      rsconnect::deployApp(appName = \"${{ env.APPNAME }}\", account = \"${{ env.ACCOUNT }}\", server = \"${{ env.SERVER }}\", forceUpdate = TRUE)\n    shell: Rscript {0}\n\ngit add .\ngit commit -m \"shiny deploy workflow\"\n\n\n[16.2_cicd-shiny 7953a5c] shiny deploy workflow\n 10 files changed, 2130 insertions(+)\n create mode 100644 .Rprofile\n create mode 100644 .github/.gitignore\n create mode 100644 .github/workflows/shiny-deploy.yaml\n create mode 100644 renv.lock\n create mode 100644 renv/.gitignore\n create mode 100644 renv/activate.R\n create mode 100644 renv/settings.json\n create mode 100644 rsconnect/shinyapps.io/mjfrigaard/moviesAppCICD.dcf\n\nWe can see the workflow running on the Actions tab of the moviesApp repository:\n\n\n\nshiny deploy workflow running\n\n\nWhen it’s finished, we can see the deployment log from the workflow looks similar to the log we saw locally:\n\n\n\ndeploy log from workflow"
  },
  {
    "objectID": "cicd.html#a-shinydocker-workflow",
    "href": "cicd.html#a-shinydocker-workflow",
    "title": "16  CI/CD",
    "section": "16.3 A Shiny/Docker workflow",
    "text": "16.3 A Shiny/Docker workflow\nIn the previous chapter we covered Docker, which builds and application in an image and containerizes the deployment. We can combine Docker and GitHub Actions to automate the deployment of an app, which minimizes any risks of environmental discrepancies (avoiding the “it works on my machine” problem) and manual deployment processes (if something goes wrong after a workflow run, rolling back to a previous version in Git is straightforward).\n\n\nLaunch app with the shinypak package:\n\nlaunch('16.3_cicd-docker')\n\n\n16.3.1 Secrets and tokens\nMost of the steps below are covered in the excellent blog post by Nicola Rennie8 I’ve updated the contents to work with a Shiny app-package.\nTo make sure our RSCONNECT_USER, RSCONNECT_TOKEN, and RSCONNECT_SECRET travels with our Dockerfile, we can store these as environmental variables with Sys.setenv():\n\nSys.setenv(RSCONNECT_USER = '&lt;username&gt;', \n  RSCONNECT_TOKEN = '&lt;token&gt;', \n  RSCONNECT_SECRET = '&lt;secret&gt;')\n\nThese will be passed to rsconnect::setAccountInfo() in our deploy.R file.\n\n\n16.3.2 deploy.R\ndeploy.R contains the calls to rsconnect::setAccountInfo() and rsconnect::deployApp() we had in our previous workflow file. Sys.getenv() will retrieve the username, token, and secret stored with Sys.setenv():\n\nsetAccountInfo(name = Sys.getenv(\"RSCONNECT_USER\"),\n               token = Sys.getenv(\"RSCONNECT_TOKEN\"),\n               secret = Sys.getenv(\"RSCONNECT_SECRET\"))\ndeployApp(appDir = \".\", \n  appName = \"moviesAppDockerCiCd\", \n  account = \"mjfrigaard\", \n    server = \"shinyapps.io\", \n    forceUpdate = TRUE)\n\nThe deploy.R script should be placed in the root folder of moviesApp.\n\n\n16.3.3 Dockerfile\nThe Dockerfile will look similar to the example in the Docker chapter, but with a few important changes:\n\nThe /home/moviesAppDockerCiCd directory is not only the image location we’ll be launching the application from, it’s also the URL for the deployed app:\n\nhttps:// username .shinyapps.io/moviesAppDockerCiCd/\n\nWe’ll include rsconnect and bslib in the list of packages to install.\n\nThe final command runs the application from the deploy.R file\n\nFROM rocker/shiny\nRUN mkdir /home/moviesAppDockerCiCd\nADD . /home/moviesAppDockerCiCd\nWORKDIR /home/moviesAppDockerCiCd\nRUN R -e 'install.packages(c(\"rlang\", \"stringr\", \"shiny\", \"ggplot2\", \"remotes\", \"rsconnect\", \"bslib\"))'\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nEXPOSE 8180\nCMD Rscript deploy.R\n\n\n16.3.4 docker.yml\n\n\n\nname: docker-shiny, moviesapp\n\non:\n  push:\n    branches: [ 16.3_cicd-docker ]\n\njobs:\n  docker:\n    runs-on: ubuntu-latest\n    \n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build image\n        run: docker build -t moviesapp . \n\n\n\nAdd a name for the Docker/Shiny workflow\n\nSpecify the triggering event the workflow will run on\nThe job will run on ubuntu-latest (with docker id)\nCheckout the code\nBuild the docker image with docker build\n\n\n\n\nThe final execute step is runs docker run and passes our environment variables to the secrets we have stored in GitHub (i.e., with secrets.&lt;SECRET_NAME&gt;):\n      - name: execute\n        run: &gt;\n          docker run -e RSCONNECT_USER=${{ secrets.RSCONNECT_USER }} -e RSCONNECT_TOKEN=${{ secrets.RSCONNECT_TOKEN }}  -e RSCONNECT_SECRET=${{ secrets.RSCONNECT_SECRET }} moviesapp  \n       \n\n\n16.3.5 App dependencies\nrsconnect has a handy appDependencies() function that returns a data.frame of packages, versions, and repositories for your application:\n\nhead(rsconnect:::appDependencies(appDir = \".\"))\n\n\n#&gt;        Package  Version Source               Repository\n#&gt; 1  AsioHeaders 1.22.1-2   CRAN https://cran.rstudio.com\n#&gt; 2         MASS   7.3-60   CRAN https://cran.rstudio.com\n#&gt; 3       Matrix    1.6-4   CRAN https://cran.rstudio.com\n#&gt; 4           R6    2.5.1   CRAN https://cran.rstudio.com\n#&gt; 5 RColorBrewer    1.1-3   CRAN https://cran.rstudio.com\n#&gt; 6         Rcpp   1.0.12   CRAN https://cran.rstudio.com\n\nPassing appDependencies() function in your app-package directory will tell you if any packages have missing Source or Repository values (this can cause the deployment to fail).\nI also recommend running attachment::att_amend_desc() to capture all the dependencies in the DESCRIPTION. For example, att_amend_desc() added the following packages to the Suggests field in the DESCRIPTION:9\n[+] 4 package(s) added: fst, shinytest2, testthat, tidyr.\nIn the Shiny workflow example we captured our application dependencies using renv, but when we used Docker with Github Actions, we didn’t create a renv.lock file (or renv folder). When the workflow runs and renv is used to capture our dependencies (line 13 in the output below), we see a message about the packages listed in the Suggests field or our DESCRIPTION:\n\n\n\nDocker deploy log\n\n\nNot having these packages installed doesn’t interfere with the application deploying because the packages listed in Suggests are used in vignettes/, data-raw/, and tests/.\nView the deployed application here."
  },
  {
    "objectID": "cicd.html#recap",
    "href": "cicd.html#recap",
    "title": "16  CI/CD",
    "section": "16.4 Recap",
    "text": "16.4 Recap\nGitHub Actions can be used to set up the necessary R environment and dependencies required to deploy the application in your app-package, while allowing secure account credentials stored in GitHub secrets. The workflows in this chapter are only triggered by changes to the 16.1_cicd-style, 16.2_cicd-shiny, and 16.3_cicd-docker branches of the moviesApp repository, which is like having a personal assistant who streamlines a secure deployment process, which allows you to focus more on developing your app.\nRead about CI/CD in the rhino framework in this appendix section"
  },
  {
    "objectID": "cicd.html#footnotes",
    "href": "cicd.html#footnotes",
    "title": "16  CI/CD",
    "section": "",
    "text": "This chapter will only cover CI/CD with GitHub Actions. Travis-CI has been around longer than GitHub Actions, and if you’d like to compare the two, I recommend this article.↩︎\nWe’ll be covering code styling in the Code tools chapter.↩︎\nYou can find more examples of common GitHub Actions for R packages in r-lib/actions/examples.↩︎\nGitHub secrets should be specified by the user following the instructions in the Creating secrets for a repository article.↩︎\n“This action assumes you have an renv lockfile in your repository that describes the R packages and versions required for your Shiny application.” - Shiny App Deployment↩︎\nInstructions for the GitHub Action Shiny deployment can be found here↩︎\nrun-on is the latest Ubuntu runner and env is the GITHUB_PAT environment variable is your GitHub personal access token (access a secret with secrets.&lt;SECRET_NAME&gt;)↩︎\nAutomatically deploying a Shiny app for browsing #RStats tweets with GitHub Actions. Nicola Rennie. October 3, 2022. https://nrennie.rbind.io/blog/2022-10-05-automatically-deploying-a-shiny-app-for-browsing-rstats-tweets-with-github-actions/↩︎\natt_amend_desc() adds a dev folder with a YAML config file, but you can be remove this before building/deploying.↩︎"
  },
  {
    "objectID": "code_tools.html#code-style-and-formatting",
    "href": "code_tools.html#code-style-and-formatting",
    "title": "17  Code tools",
    "section": "17.1 Code style and formatting",
    "text": "17.1 Code style and formatting\nThe lintr and styler packages in R serve related but distinct purposes and have different focuses in their functionality. The primary difference between lintr and styler is that styler can automatically fix any stylistic issues it identifies in your code (rather than just reporting them).\n\n\nLaunch app with the shinypak package:\n\nlaunch('17_code-tools')\n\n\n17.1.1 lintr\nlintr is a static code analysis tool used to identify syntax errors, semantic issues, and violations of stylistic guidelines in your code. The package contains a list of ‘linters’ for various potential problems and can be customized according to your needs. lintr is designed to help improve your code’s quality and readability by generating reports in the ‘markers’ pane. Running lintr won’t automatically correct the identified issues (you’ll need to fix the linting issues it reports manually).\n\n\n17.1.2 styler\nOn the other hand, the purpose of styler is to ensure consistency in the code formatting, which is crucial if you’re working in a team or contributing to open-source projects (like tidyverse packages). The styler package will change your code’s format according to specified style guidelines. These changes include indentation, spaces, and line breaks that adhere to your style guidelines.\nWhile there is some overlap (both packages can help enforce coding style guidelines), lintr is a more general tool for code quality, spotting potential issues and bugs. At the same time, styler focuses on code formatting and can automatically apply fixes. Many developers find combining both can help catch potential issues and ensure a consistent, readable coding style."
  },
  {
    "objectID": "code_tools.html#sec-code-tools-dependencies",
    "href": "code_tools.html#sec-code-tools-dependencies",
    "title": "17  Code tools",
    "section": "17.2 Dependencies",
    "text": "17.2 Dependencies\nThe following packages will help keep your app-package dependencies managed in the DESCRIPTION file and the code below R/:\n\n17.2.1 attachment\nattachment was introduced in the golem chapter, but you don’t have to use the golem framework to take advantage of it’s functions. att_amend_desc() will update the package dependencies in the DESCRIPTION file.\nattachment::att_amend_desc()\nSaving attachment parameters to yaml config file\nUpdating moviesApp documentation\nℹ Loading moviesApp\nWriting NAMESPACE\nWriting NAMESPACE\nℹ Loading moviesApp\n[+] 6 package(s) added: cli, tools, fst, ggplot2movies, glue, waldo.\nattachment::att_amend_desc() will automatically create a dev/ folder with a YAML configuration file:\ndev\n└── config_attachment.yaml\n\n1 directory, 1 file\nconfig_attachment.yaml contents:\npath.n: NAMESPACE\npath.d: DESCRIPTION\ndir.r: R\ndir.v: vignettes\ndir.t: tests\nextra.suggests: ~\npkg_ignore: ~\ndocument: yes\nnormalize: yes\ninside_rmd: no\nmust.exist: yes\ncheck_if_suggests_is_installed: yes\nThis can be deleted, but if you’re going to continue using attachment it’s worth customizing some of the options for your app-package.\n\n\n17.2.2 sinew\nThe sinew package also warrants mentioning because it can help ensure you’re namespacing functions from add-on packages, although it’s not automated like attachment::att_amend_desc(). The primary function in sinew is pretty_namespace().\nsinew::pretty_namespace(con = \"app.R\")"
  },
  {
    "objectID": "code_tools.html#description-files",
    "href": "code_tools.html#description-files",
    "title": "17  Code tools",
    "section": "17.3 DESCRIPTION files",
    "text": "17.3 DESCRIPTION files\nThe desc package provides functions for creating, reading, writing, and manipulating DESCRIPTION files. You can include additional dependencies to your DESCRIPTION using the desc_set_dep() function.\nlibrary(desc)\ndesc_set_dep(\"glue\", \"Imports\")\ndesc_get(\"Imports\")\nImports:\n    bslib,\n    cli,\n    glue,\n    ggplot2,\n    logger,\n    rlang,\n    sass,\n    shiny,\n    shinythemes,\n    stringr,\n    tools"
  },
  {
    "objectID": "code_tools.html#checking-your-code",
    "href": "code_tools.html#checking-your-code",
    "title": "17  Code tools",
    "section": "17.4 Checking your code",
    "text": "17.4 Checking your code\nI’ve previously mentioned running devtools::check() can be overkill for your app-package (especially if it’s not destined for CRAN). A nice alternative to check() is the goodpractice package..\ngoodpractice::gp() inspects your package and prints any areas that might need ‘good practice’ advice:\n\nlibrary(goodpractice)\npkg_checks &lt;- gp(path = \".\")\npkg_checks\n\nPreparing: description\nPreparing: lintr\n  |====================================================================| 100%\nPreparing: namespace\nPreparing: rcmdcheck\n── GP moviesApp ───────────────────────────────────────────────────────\n\nIt is good practice to\n\n  ✖ add a \"URL\" field to DESCRIPTION. It helps users find information about your\n    package online. If your package does not have a homepage, add an URL to \n    GitHub, or the CRAN package package page.\n  ✖ add a \"BugReports\" field to DESCRIPTION, and point it to a bug tracker. \n    Many online code hosting services provide bug trackers for free, \n    https://github.com, https://gitlab.com, etc.\n  ✖ avoid long code lines, it is bad for readability. Also, many people prefer \n    editor windows that are about 80 characters wide. Try make your lines \n    shorter than 80 characters\n\n    data-raw/tidy_movies.R:49:81\n    R/data.R:4:81\n    R/data.R:7:81\n    R/data.R:17:81\n    R/data.R:21:81\n    ... and 13 more lines\n\n  ✖ not import packages as a whole, as this can cause name clashes between the \n    imported packages. Instead, import only the specific functions you need.\n  ✖ fix this R CMD check NOTE: display_type: no visible binding for global \n    variable\n    ‘.rs.invokeShinyPaneViewer’ display_type: no visible binding for global \n    variable\n    ‘.rs.invokeShinyWindowExternal’ display_type: no visible binding for global\n    variable\n    ‘.rs.invokeShinyWindowViewer’ mod_scatter_display_server : &lt;anonymous&gt;: no \n    visible binding for global\n    variable ‘movies’ Undefined global functions or variables: \n    .rs.invokeShinyPaneViewer \n    .rs.invokeShinyWindowExternal \n    .rs.invokeShinyWindowViewer \n    movies\nWe can also check specific components of our package by looking up the available checks in all_checks():\n\ngrep(\"import\", x = all_checks(), value = TRUE)\n\n\n[1] \"no_import_package_as_a_whole\"                 \n[2] \"rcmdcheck_undeclared_imports\"                 \n[3] \"rcmdcheck_imports_not_imported_from\"          \n[4] \"rcmdcheck_depends_not_imported_from\"          \n[5] \"rcmdcheck_triple_colon_imported_objects_exist\"\n[6] \"rcmdcheck_unexported_base_objects_imported\"   \n[7] \"rcmdcheck_unexported_objects_imported\"        \n[8] \"rcmdcheck_empty_importfrom_in_namespace\"  \n\nAll of the checks with the rcmdcheck_ prefix are part of the R CMD check diagnostic, but goodpractice comes with other checks that are good practices (even if you’re not submitting your package to CRAN).\nFor example, no_import_package_as_a_whole checks the practice we covered in managing imports. If we pass the no_import_package_as_a_whole check as a character vector to the checks argument:\n\ngp(path = \".\", checks = 'no_import_package_as_a_whole')\n\nOnly this check is performed:\n\n── GP moviesApp ───────────────────────────────────────────────────\n\nIt is good practice to\n\n  ✖ not import packages as a whole, as this can cause name clashes between\n    the imported packages. Instead, import only the specific functions you need.\n\n───────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "code_tools.html#recap",
    "href": "code_tools.html#recap",
    "title": "17  Code tools",
    "section": "17.5 Recap",
    "text": "17.5 Recap\nThis chapter covered an introduction to some tools and practices for improving and maintaining the quality of the code in your app-package. Maintaining code style and standards (lintr and styler), managing dependencies efficiently (attachment and desc), and performing thorough checks to adhere to best practices (goodpractice) will ensure efficient and reliable development and deployment for your app.\n\n\n\n\n\n\nCode tools recap\n\n\n\n\n\n\nThis chapter covered:\nCode Linting and Styling:\n\nlintr is used for checking the code for potential errors and style issues\n\nCan help in identifying syntactical and stylistic problems that might lead to code inefficiency or errors\nLinters are instrumental in enforcing coding standards and ensuring consistency across the codebase\n\nstyler is used to automatically style the R code in your app-package\n\nstyler will format R code according to specified style guidelines, ensuring that the code is not only consistent in its look but also adheres to best practices\nAutomating styling can save time and reduces manual effort in code formatting\n\n\nManaging Dependencies:\n\nThe attachment package helps in managing these dependencies by automatically listing and updating the packages used in your app-package\n\natt_amend_desc scans the code and identifies all package dependencies\nmanaging dependencies ensures reproducibility and ease of package installation\n\ndesc assists in handling the DESCRIPTION file in your app-package\n\nprovides tools for reading, writing, and modifying the DESCRIPTION files\n\n\nCode Checks:\n\ngoodpractice is designed to help ensure best practices in R coding and package development are adhered to in your app-package\n\ngoodpractice::gp() performs a comprehensive analysis of the code (beyond devtools::check()) and checks for various potential issues like code complexity, redundancy, adherence to coding standards, etc\nOffers suggestions for improvements, making it a helpful tool for quality assurance in package development"
  },
  {
    "objectID": "frameworks.html#footnotes",
    "href": "frameworks.html#footnotes",
    "title": "Frameworks",
    "section": "",
    "text": "rhino apps aren’t R packages–they’re dependencies are managed with a dependencies.R file and box modules.↩︎"
  },
  {
    "objectID": "golem.html#gap-a-golem-app-package",
    "href": "golem.html#gap-a-golem-app-package",
    "title": "18  golem",
    "section": "18.1 gap (a golem app-package)",
    "text": "18.1 gap (a golem app-package)\ngap exports the movies data and the standalone app function, run_app().\n\nlibrary(gap)\ngap::run_app()\n\n\n\n\n\n\n(a) gap movies app\n\n\nFigure 18.1: After loading, documenting, and installing gap, launch the movies with run_app()\n\n\nIn the sections below, I’ll note various features and workflows that differ from standard package (or app-package) development."
  },
  {
    "objectID": "golem.html#dev-scripts",
    "href": "golem.html#dev-scripts",
    "title": "18  golem",
    "section": "18.2 dev scripts",
    "text": "18.2 dev scripts\nNew golem apps have a dev/ folder with scripts for setting up your application, development, and launching/deploying.\n\ndev\n├── 01_start.R\n├── 02_dev.R\n└── 03_deploy.R\n\nThe package website has each script available in vignettes: 01_start, 02_dev, 03_deploy"
  },
  {
    "objectID": "golem.html#set-up",
    "href": "golem.html#set-up",
    "title": "18  golem",
    "section": "18.3 Set up",
    "text": "18.3 Set up\nThe dev/01_start.R file opens when the new golem app-package launches. Following the steps in 01_start.R sets up the following files, folders, and options in your golem app-package:\n\nDESCRIPTION: golem has a custom function for entering many of the fields we covered in the Packages chapter 1\ngolem has functions that automatically set multiple options in the golem-config.yml 2 and package dependencies 3\nusethis functions are called for a LICENSE4, creating (and building5) a README6 a CODE_OF_CONDUCT.md7, adding a Lifecycle badge8, and the NEWS.md file.9 Many of these functions and files are covered in the Whole App Game chapter.\nIf you aren’t using Git, there’s an option to initiate a Git repo 10\nThe testing infrastructure is set up using the custom golem::use_recommended_tests() function, which creates the necessary testthat folders we covered in the Test suite chapter 11, but also adds a collection of boilerplate tests.\ngolem apps also have custom functions for creating a series of UI 12 and server 13 utility functions (and their accompanying tests)."
  },
  {
    "objectID": "golem.html#development",
    "href": "golem.html#development",
    "title": "18  golem",
    "section": "18.4 Development",
    "text": "18.4 Development\nAfter setting up the golem app-package with dev/01_start.R, the dev/02_dev.R file opens and contains the following functions/options for developing your application.\n\nPackage dependencies: imports are managed with the attachment package14\n\n\nCode files: new code files in golem apps can be created with a variety of helper functions. \n\nModules: add_module() adds a .R file with a mod_ prefix (an optional test can be included with the with_test = TRUE argument) \nUtility functions: utility functions can be added with add_utils() or add_fct() (also include the with_test option for tests). golem_utils_* files contain commonly used UI and server functions. \nThe primary app UI and server functions are stored in R/app_ui.R and R/app_server.R. \nThe standalone app function is stored in R/run_app.R. \nR/_disable_autoload.R disables shiny::loadSupport() (an option we covered in the Launch chapter) \nR/app_config.R contains configuration functions:\n\n\napp_sys() is a wrapper for system.file() \nget_golem_config() reads environment variables (i.e., GOLEM_CONFIG_ACTIVE) and the contents of inst/golem-config.yml:\n\n\n\n\nR\n1├── _disable_autoload.R\n2├── app_config.R\n3├── app_server.R\n├── app_ui.R\n4├── data.R\n5├── golem_utils_server.R\n├── golem_utils_ui.R\n6├── mod_scatter_display.R\n7├── mod_var_input.R\n8├── utils_mod_scatter_display.R\n9├── utils_tests.R\n10└── run_app.R\n\n1 directory, 11 files\n\n\n1\n\nTurn off loadSupport()\n\n\n2\n\nConfigure app functions\n\n3\n\nApp UI and server functions\n\n\n4\n\nData documentation\n\n\n5\n\ngolem utility functions\n\n\n6\n\nScatter plot module\n\n\n7\n\nVariable input module\n\n8\n\nScatter plot utility function (scatter_plot())\n\n9\n\nTest utility function (test_logger())\n\n10\n\nStandalone app function\n\n\n\n\n\nExternal files: adding external files is handled with golem_add_external_resources(), which uses the same methods we covered in the External files chapter.15\n\n\nWORDLIST: includes the word ‘golem’ and is an artifact from spellcheck argument in use_recommended_tests(). 16 \napp/ contains the application files. 17 \nextdata/ contains the external data files. 18 \ngolem-config.yml is used to set various configuration options. 19\n\n\n\ninst\n├── WORDLIST\n├── app\n│   └── www\n│       ├── favicon.ico\n│       ├── golem-hex.png\n│       └── shiny.png\n├── extdata\n│   ├── movies.RData\n│   └── tidy_movies.fst\n└── golem-config.yml\n\n4 directories, 7 files\n\n\nData: the data in golem app-packages function like the data folder and files in a standard R package we covered in the Data chapter. \n\ndata/: contains the movies.rda file used in the application \ndata-raw/: movies.R reads in data-raw/movies.RData and creates data/movies.rda \n\ntidy_movies.R reads in the ggplot2movies::movies data and creates the inst/extdata/tidy_movies.fst data.\n\n\n\n\ndata\n└── movies.rda\n\n1 directory, 1 file\n\n\ndata-raw\n├── movies.R\n├── movies.RData\n└── tidy_movies.R\n\n1 directory, 2 files\n\n\nDocumentation: the roxygen2 documentation in golem app-package files comes with boilerplate tags and descriptions similar to those covered in the Documentation chapter. \n\nman/: By default, modules created with add_module() aren’t exported 20 \nvignettes/: Package vignettes in golem app-packages operate like vignettes in standard R packages.\n\n\n\nman\n1├── app_server.Rd\n├── app_ui.Rd\n2├── golem_add_external_resources.Rd\n3├── mod_scatter_display_server.Rd\n├── mod_scatter_display_ui.Rd\n├── mod_plot_ui.Rd\n├── mod_var_input_server.Rd\n├── mod_var_input_ui.Rd\n4├── movies.Rd\n5├── run_app.Rd\n6├── scatter_plot.Rd\n7└── test_logger.Rd\n\n1 directory, 12 files\n\n\n1\n\nPrimary UI and server functions (‘pre-packaged’ in golem apps)\n\n2\n\nExternal resources utility function (‘pre-packaged’ in golem apps)\n\n\n3\n\nModules\n\n4\n\nData documentation\n\n5\n\nThe ‘pre-packaged’ standalone app function (only export from golem apps)\n\n\n6\n\nPlot utility function (exported from gap)\n\n\n7\n\nTest utility function\n\n\n\n\n\nvignettes/\n└── tests_and_coverage.Rmd\n\n1 directory, 1 file"
  },
  {
    "objectID": "golem.html#tests",
    "href": "golem.html#tests",
    "title": "18  golem",
    "section": "18.5 Tests",
    "text": "18.5 Tests\ngolem applications provide a lot of boilerplate tests.\n\nTests: The testing framework for golem app-packages is set up with golem::use_recommended_tests() in the dev/01_start.R script.21 \n\nA tests/README.md file is created by the covrpage package 22 \ntests/spelling.R adds functionality from the spelling package 23 \ntestthat: The two golem utility function files (golem_utils_server.R, and golem_utils_ui.R) have accompanying tests files. \n\nThe with_test argument creates test files for modules and utility functions. 24\n\n\n\n\ntests\n1├── README.md\n2├── spelling.R\n├── testthat\n│   ├── _snaps\n3│   ├── fixtures\n│   │   ├── make-tidy_ggp2_movies.R\n│   │   └── tidy_ggp2_movies.rds\n4│   ├── helper.R\n5│   ├── setup-shinytest2.R\n6│   ├── test-app-feature-01.R\n7│   ├── test-golem-recommended.R\n8│   ├── test-golem_utils_server.R\n9│   ├── test-golem_utils_ui.R\n10│   ├── test-mod_scatter_display.R\n11│   ├── test-mod_var_input.R\n12│   ├── test-shinytest2.R\n13│   └── test-utils_mod_scatter_display.R\n└── testthat.R\n\n4 directories, 15 files\n\n\n1\n\nCreated from covrpage package\n\n\n2\n\nCreated from spelling package\n\n\n3\n\nTest fixtures\n\n\n4\n\nTest helpers\n\n\n5\n\nSetting up shinytest2\n\n\n6\n\nshinytest2 feature test\n\n\n7\n\nCreated with: golem::use_recommended_tests()\n\n8\n\nCreated with: golem::use_utils_ui(with_test = TRUE)\n\n9\n\nCreated with: golem::use_utils_server(with_test = TRUE)\n\n10\n\nCreated with: golem::add_module(name = 'scatter_display', with_test = TRUE)\n\n11\n\nCreated with: golem::add_module(name = 'var_input', with_test = TRUE)\n\n12\n\nTest recording from shinytest2::record_test()\n\n\n13\n\nUtility function test (scatter_plot())\n\n\n\n\nI’ve converted the tests from the previous chapters for the modules and utility functions in gap:\n\n18.5.1 Unit tests\n\ntest-golem-recommended.R contains tests for the functions included in your new golem app (app_ui(), app_sys(), etc.)\ntest-golem_utils_server.R contains utility functions that might be useful in the server\ntest-golem_utils_ui.R contains utility functions that might be useful in the ui\nThe tests for scatter_plot() is in the test-utils_mod_scatter_display.R file.\n\n\n\n18.5.2 Module tests\n\nThe communication between mod_var_input_server() and mod_scatter_display_server() are in test-mod_var_input.R and test-mod_scatter_display.R\n\n\n\n18.5.3 System tests\nThe two system tests are in test-shinytest2.R and test-app-feature-01.R:\n\ntest-shinytest2.R is the initial resulting test from shinytest2::record_test() covered in System tests\ntest-app-feature-01.R contains feature tests\n\n\n\n\n\n\n\nloadSupport() warning with shinytest2\n\n\n\n\n\n\nAfter setting up shinytest2, the tests/testthat/setup-shinytest2.R file contains a call to shinytest2::load_app_env(). This runs automatically with shinytest2 tests and produces a familiar warning:\nWarning message:\nIn shiny::loadSupport(app_dir, renv = renv, globalrenv = globalrenv) :\n  Loading R/ subdirectory for Shiny application, but this directory appears\n  to contain an R package. Sourcing files in R/ may cause unexpected behavior.\nWe covered this warning message in the Launch chapter, and it’s being addressed in a future release of shinytest2"
  },
  {
    "objectID": "golem.html#deployment",
    "href": "golem.html#deployment",
    "title": "18  golem",
    "section": "18.6 Deployment",
    "text": "18.6 Deployment\nWhen you’re ready to deploy your golem app dev/03_deploy.R file contains a ‘pre deployment checklist’ and multiple options for deploying your application.\n\n18.6.1 Posit platforms\n\ndevtools::check() and devtools::build() are called.25\ngolem has functions for RStudio Connect, shinyapps.io, and Shiny server,26 as well as options for deploying your application using rsconnect::deployApp(). 27\n\n\n\n18.6.2 Docker\ngolem has multiple options for creating Docker files:\n\ngolem::add_dockerfile() adds the following Dockerfile:\n\n\nshow/hide Dockerfile\nFROM rocker/verse:4.3.2\nRUN apt-get update && apt-get install -y  libcurl4-openssl-dev libicu-dev libssl-dev libxml2-dev make pandoc zlib1g-dev && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN Rscript -e 'remotes::install_version(\"glue\",upgrade=\"never\", version = \"1.6.2\")'\nRUN Rscript -e 'remotes::install_version(\"rlang\",upgrade=\"never\", version = \"1.1.2\")'\nRUN Rscript -e 'remotes::install_version(\"stringr\",upgrade=\"never\", version = \"1.5.1\")'\nRUN Rscript -e 'remotes::install_version(\"knitr\",upgrade=\"never\", version = \"1.45\")'\nRUN Rscript -e 'remotes::install_version(\"waldo\",upgrade=\"never\", version = \"0.5.2\")'\nRUN Rscript -e 'remotes::install_version(\"shiny\",upgrade=\"never\", version = \"1.8.0\")'\nRUN Rscript -e 'remotes::install_version(\"rmarkdown\",upgrade=\"never\", version = \"2.25\")'\nRUN Rscript -e 'remotes::install_version(\"config\",upgrade=\"never\", version = \"0.3.2\")'\nRUN Rscript -e 'remotes::install_version(\"spelling\",upgrade=\"never\", version = \"2.2.1\")'\nRUN Rscript -e 'remotes::install_version(\"shinytest2\",upgrade=\"never\", version = \"0.3.1\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2movies\",upgrade=\"never\", version = \"0.0.1\")'\nRUN Rscript -e 'remotes::install_version(\"logger\",upgrade=\"never\", version = \"0.2.2\")'\nRUN Rscript -e 'remotes::install_version(\"golem\",upgrade=\"never\", version = \"0.4.1\")'\nRUN Rscript -e 'remotes::install_version(\"ggplot2\",upgrade=\"never\", version = \"3.4.4\")'\nRUN Rscript -e 'remotes::install_github(\"rstudio/htmltools@a8a3559edbfd9dda78418251e69273fa9dfeb9bc\")'\nRUN Rscript -e 'remotes::install_github(\"r-lib/testthat@fe50a222c62cc8733b397690caf3b2a95856f902\")'\nRUN mkdir /build_zone\nADD . /build_zone\nWORKDIR /build_zone\nRUN R -e 'remotes::install_local(upgrade=\"never\")'\nRUN rm -rf /build_zone\nEXPOSE 80\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\"\n\n\ngolem::add_dockerfile_with_renv() creates a tmp/deploy folder and adds the following files:\n\n\ndeploy/\n  ├── Dockerfile\n  ├── Dockerfile_base\n  ├── README\n  ├── gap_0.0.0.9000.tar.gz\n  └── renv.lock.prod\n\n\nREADME\n\ndocker build -f Dockerfile_base --progress=plain -t gap_base .\ndocker build -f Dockerfile --progress=plain -t gap:latest .\ndocker run -p 80:80 gap:latest\n# then go to 127.0.0.1:80\n\nDockerfile\n\n\nshow/hide Dockerfile\nFROM gap_base\nCOPY renv.lock.prod renv.lock\nRUN R -e 'renv::restore()'\nCOPY gap_*.tar.gz /app.tar.gz\nRUN R -e 'remotes::install_local(\"/app.tar.gz\",upgrade=\"never\")'\nRUN rm /app.tar.gz\nEXPOSE 80\nCMD R -e \"options('shiny.port'=80,shiny.host='0.0.0.0');library(gap);gap::run_app()\"\n\n\nDockerfile_base\n\n\nshow/hide Dockerfile_base\nFROM rocker/verse:4.3.2\nRUN apt-get update -y && apt-get install -y  make zlib1g-dev git libicu-dev && rm -rf /var/lib/apt/lists/*\nRUN mkdir -p /usr/local/lib/R/etc/ /usr/lib/R/etc/\nRUN echo \"options(renv.config.pak.enabled = FALSE, repos = c(CRAN = 'https://cran.rstudio.com/'), download.file.method = 'libcurl', Ncpus = 4)\" | tee /usr/local/lib/R/etc/Rprofile.site | tee /usr/lib/R/etc/Rprofile.site\nRUN R -e 'install.packages(\"remotes\")'\nRUN R -e 'remotes::install_version(\"renv\", version = \"1.0.3\")'\nCOPY renv.lock.prod renv.lock\nRUN R -e 'renv::restore()'\n\n\ngap_0.0.0.9000.tar.gz is a compressed version of our app-package to deploy in the Docker container.\nrenv.lock.prod is a JSON file with a list of packages used in our app-package.\n\nYou can read more details about deploying with Docker on the Shiny Frameworks supplemental website."
  },
  {
    "objectID": "golem.html#summary-of-golem-features",
    "href": "golem.html#summary-of-golem-features",
    "title": "18  golem",
    "section": "18.7 Summary of golem features",
    "text": "18.7 Summary of golem features\ngolems helper functions and dev scripts make application development fast–I was able to create gap quickly, and all of the supporting packages (covrpage, attachment, spelling) make the development process faster/easier:\n\nI created the two modules (mod_plot and mod_var) with add_module(), the utility function with add_utils()\n\nI added the modules to the app_ui() and app_server()\n\nI moved images into inst/app/www/\n\nThe movies data was added to inst/extdata/, then read into data/ folder with the data-raw/movies.R file.\nI re-ran the attachment::att_amend_desc() to capture any dependencies\n\nFinally I loaded, documented, and installed the gap package.\n\nIf you’ve followed along with the preceding chapters, the golem framework should be familiar. In essence, golem takes many of the package development steps and bundles them into wrapper functions (i.e., add_module() is identical to running usethis::use_r() and usethis::use_test(), then adding an roxygen2 skeleton)."
  },
  {
    "objectID": "golem.html#dependencies",
    "href": "golem.html#dependencies",
    "title": "18  golem",
    "section": "18.8 Dependencies",
    "text": "18.8 Dependencies\nIt’s also worth noting that using the golem framework adds golem as a dependency:\n\n# in the 15_golem branch of moviesApp\npak::local_deps_explain(deps = 'golem', root = \".\")\n\ngap -&gt; golem \n\n18.8.1 moviesApp dependencies\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 09d_inst-prod branch of moviesApp.\n\nFor comparison, this is the moviesApp dependency tree (note that using devtools/usethis doesn’t make our app-package depend on these packages).\n\n# in the 09d_inst-prod branch of moviesApp\npak::local_deps_explain(deps = 'devtools', root = \".\")\n\nx devtools\n\n# in the 09d_inst-prod branch of moviesApp\npak::local_deps_explain(deps = 'usethis', root = \".\")\n\nx usethis"
  },
  {
    "objectID": "golem.html#recap",
    "href": "golem.html#recap",
    "title": "18  golem",
    "section": "18.9 Recap",
    "text": "18.9 Recap\nThe golem framework is a huge time saver if you’re familiar with R package development (and you’d prefer if many of these steps were bundled and optimized for ‘production grade’ Shiny apps). However, if you’re not familiar with package development, you might end up with app-packages that have bugs you can’t diagnose or fix."
  },
  {
    "objectID": "golem.html#footnotes",
    "href": "golem.html#footnotes",
    "title": "18  golem",
    "section": "",
    "text": "Fields are filled with golem::fill_desc()↩︎\nOptions are set with with golem::set_golem_options()↩︎\nDependencies are installed with golem::install_dev_deps()↩︎\nCreated using usethis::use_mit_license()↩︎\nBuilt using devtools::build_readme()↩︎\nCreated using usethis::use_readme_rmd()↩︎\nCreated using usethis::use_code_of_conduct()↩︎\nCreated using usethis::use_lifecycle_badge()↩︎\nCreated using usethis::use_news_md()↩︎\nInitialize Git using usethis::use_git()↩︎\nThe tests/ folder and testthat files are included with golem::use_recommended_tests()↩︎\nCreate UI utility functions using golem::use_utils_ui()↩︎\nCreate server utility functions using golem::use_utils_server()↩︎\nattachment::att_amend_desc() parses the code under R/ and make sure the DESCRIPTION file is up-to-date↩︎\ngolem_add_external_resources() is a wrapper for golem::add_resource_path(), which is a wrapper for shiny::addResourcePath() (and app_sys() is a wrapper for system.file()).↩︎\nThe use_recommended_tests() is run in the dev/01_start.R file and if spellcheck is TRUE, creates the tests/spelling.R file and the inst/WORDLIST file.↩︎\nthe app/ folder is used to add external resources to the application (similar to the previous versions of moviesApp).↩︎\nThis contains the RData file for the original movies data and the exported tidy_movies.fst file.↩︎\ngolem apps use a golem-config.yml file for setting various options. These are initially set with set_golem_options() (and based on the config package)↩︎\nThe noRd tag is added to module files created with add_module(), but you can export these functions by setting the export argument to TRUE. @importFrom is used to import NS() and tagList().↩︎\ntest-golem-recommended.R contains the recommended tests for app_ui(), app_server(), app_sys(), and golem-config.yml↩︎\nThe covrpage package is not on CRAN, but the development version always seems to work. Create the tests/README.md file with covrpage::covrpage().↩︎\nThe spelling package will spell check vignettes, packages, etc.↩︎\nwith_test = TRUE) adds tests in the dev/01_start.R script. Code files created with golem::add_module(), golem::add_utils(), and golem::add_fct() will also include a test file if with_test is set to TRUE.↩︎\nThis also includes a call to rhub::check_for_cran(), which may or may not be of concern for your application.↩︎\nThese functions will create and app.R file to launch and deploy your application.↩︎\nIncludes boilerplate for appName, appTitle, appFiles, etc.↩︎"
  },
  {
    "objectID": "leprechaun.html#lap-a-leprechaun-app-package",
    "href": "leprechaun.html#lap-a-leprechaun-app-package",
    "title": "19  leprechaun",
    "section": "19.1 lap (a leprechaun app-package)",
    "text": "19.1 lap (a leprechaun app-package)\nlap exports the movies data and the standalone app function, run().\n\nlibrary(lap)\nlap::run()\n\n\n\n\n\n\n(a) lap movies app\n\n\nFigure 19.1: After loading, documenting, and installing lap, launch the movies with run()"
  },
  {
    "objectID": "leprechaun.html#set-up",
    "href": "leprechaun.html#set-up",
    "title": "19  leprechaun",
    "section": "19.2 Set up",
    "text": "19.2 Set up\nCreating a new leprechaun app-package can be done with usethis::create_package()1 (which we covered in Packages). After your app-package is created, leprechaun::scaffold() builds the core app files:2\nCode files: the code files in new leprechaun apps include the following:\n\n_disable_autoload.R: Disables shiny::loadSupport() (covered in Launch)\nassets.R: includes serveAssets() for serving JavaScript files, remove_modules() and get_modules() for adding/removing modules, and the collapse_files() helper function for collapsing files.3\ninput-handlers.R: leprechaun_handler_df() and leprechaun_handler_list() are helper functions for including data and lists “from Websocket”.4\nleprechaun-utils.R: includes a make_send_message() function for “send custom messages to the front-end” with the “namespace carried along”. Read below for demonstration of how this is used.5\nrun.R: the standalone app function for your leprechaun app (covered in Launch). \nserver.R & ui.R are applications primary UI and server functions.\n\nui: contains the application UI and the assets() function (which calls serveAssets() covered above).6\nserver.R: creates send_message from make_send_message(session) (covered below).7\n\nzzz.R is a utility function file that holds the .onLoad() function for adding external resources (using methods covered in External files).8\n\n\nR\n1├── _disable_autoload.R\n2├── assets.R\n3├── input-handlers.R\n4├── leprechaun-utils.R\n5├── run.R\n6├── server.R\n7├── ui.R\n8└── zzz.R\n\n1 directory, 8 files\n\n\n1\n\nDisables shiny::loadSupport()\n\n\n2\n\nIncludes functions for serving JavaScript files, adding/removing modules, and collapsing files.\n\n3\n\nUtility functions for handling lists and data.frames\n\n\n4\n\nContains the make_send_message() function for ‘send[ing] custom messages to the front-end’\n\n5\n\nStandalone app function\n\n\n6\n\nApp primary server function\n\n\n7\n\nApp primary ui function\n\n\n8\n\nIncludes wrapper for adding external files\n\n\n\n\n\nAdding dependencies: shiny, bslib, htmltools and pkgload should be added to the DESCRIPTION with usethis::use_package() (covered in the Dependencies chapter).\n\n\nImports: \n    bslib,\n    htmltools,\n    shiny\nSuggests: \n    pkgload\n\nThe lap folder structure should look familiar if you’ve been following along with the previous chapters. The standard R package files (DESCRIPTION, NAMESPACE, and .Rproj) are accompanied by a .leprechaun lock file.\n\nlap/\n├── .leprechaun\n├── DESCRIPTION\n├── NAMESPACE\n└── moviesApp.Rproj\n\nThe initial call to leprechaun::scaffold() creates the following folders in the inst/ folder (recall that inst/ contents are available when the package is installed).\n\ninst/\n├── assets\n├── dev\n├── img\n└── run\n    └── app.R\n\n5 directories, 1 file\n\ninst/run/app.R contains a call to leprechaun::build(), pkgload::load_all(), then a call to the standalone app function, run().9"
  },
  {
    "objectID": "leprechaun.html#development",
    "href": "leprechaun.html#development",
    "title": "19  leprechaun",
    "section": "19.3 Development",
    "text": "19.3 Development\nCode files: new code files in leprechaun apps can be created with usethis::use_r() or with a helper function:\n\nCreate modules with add_module(). Modules created with add_module(\"name\") will have:10\n\nA module file with a module_name prefix (R/module_name.R)\nA module UI function: nameUI()\nA module server function: name_server()\n\n\nCreate an app.R file with add_app_file(). This includes a call to pkgload::load_all() and run().11 \nApp files: R/run.R contains functions for running the app.12 \nAdd the modules to R/ui.R and R/server.R.  - R/server.R includes a call to send_message by default.13  - R/ui.R holds the ui() and assets() functions.14 \nUtility function: R/utils_scatter_plot.R holds the scatter_plot() utility function.15 \nAdding files: The R/zzz.R file contains the .onLoad() function, which wraps system.file('img', package = 'lap') and addResourcePath() for including external resources. \n\n\nR\n├── module_plot_display.R\n├── module_var_input.R\n├── run.R\n├── server.R\n├── ui.R\n└── utils_scatter_plot.R\n\n1 directory, 6 files\n\n\n19.3.1 Data files\n\nIncluding data files: the movies.RData data was moved into inst/extdata, then loaded into data/ with the script created with usethis::use_data_raw('movies') (similar to methods covered in the Data chapter):\n\n\ndata-raw/\n└── movies.R\n\n1 directory, 1 file\n\n\n└── extdata\n      └── movies.RData\n1 directory, 1 file\n\n\ndata\n└── movies.rda\n\n1 directory, 1 file\n\n\n\n19.3.2 Adding features\nThe leprechaun workflow involves a combination of use_ functions that are combined with leprechaun::build() to add various functionality to your application. I’ll demonstrate three options in the sections below:\n\n19.3.2.1 Use packer\nI’ll demo using the make_send_message() from the JavaScript example on the package website:\n\nRun packer::scaffold_leprechaun() \n\nDon’t be alarmed when calling packer::scaffold_leprechaun() downloads multiple folders into the root directory of your leprechaun app-package. 16 \n\nRun leprechaun::use_packer() \nRun leprechaun::build()\n\nThis creates inst/dev/packer.R and inst/assets/index.js.\n\ninst\n├── assets\n│   └── index.js\n├── dev\n│   └── packer.R\n├── extdata\n│   └── movies.RData\n├── img\n└── run\n    └── app.R\n\nAssign the output from make_send_message() to send_message() in R/server.R, then pass the msgId and text of the message:\n\nserver &lt;- function(input, output, session){\n    ## New code --&gt;\n1  send_message &lt;- make_send_message(session)\n  \n2    send_message(\"show-packer\",\n                  text = \"this message is from your R/server.R file\")\n    \n   selected_vars &lt;- var_input_server(\"vars\")\n\n   plot_display_server(\"plot\", var_inputs = selected_vars)\n   ## New code &lt;--\n\n}\n\n\n1\n\nCreate send_message()\n\n\n2\n\nUse send_message() to send message the UI.\n\n\n\n\nAfter loading, documenting, and installing your app-package:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nRun the application:\n\nlap::run()\n\n\n\n\n\n\n(a) send_message() in lap::run()\n\n\nFigure 19.2: Adding the make_send_message() functionality to R/server.R\n\n\n\n\n19.3.2.2 Add images\nAdding images is simplified with the .onLoad() function, which I’ll demonstrate by adding the leprechaun.jpg image file to the UI function.\n\nPlace the leprechaun.jpg file in inst/img/ \nAdd the img/ path to the code to UI:\n\n\ntags$img(\n  src = \"img/leprechaun.jpg\", \n  height = \"25%\", \n  width = \"25%\")\n\n\nrun devtools::load_all(), devtools::document(), and devtools::install(), then run the application with run():\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n\n\n\n(a) leprechaun.jpg in R/ui.R\n\n\nFigure 19.3: Adding images to inst/img/\n\n\n\n\n19.3.2.3 Use Sass\nTo add Sass styling, I can use leprechaun’s use_sass() function\n\nRun leprechaun::use_sass() \na scss/ folder will be created that contains _core.scss and main.scss\n\n\nscss\n├── _core.scss\n└── main.scss\n\n1 directory, 2 files\n\n\nThe original _core.scss file is below\n\nhtml{\n    .error {\n        color: red\n    }\n}\n\nChange the color: from red to green (#38B44A) using $accent: #38B44A;\n\n$accent: #38B44A;\n\nhtml{\n    h1 {\n        color: $accent;\n    }\n}\n\nSave this file and run leprechaun::build():17\n\n\nleprechaun::build()\n\n\n✔ Running packer.R\n✔ Bundled       \n✔ Running sass.R\n\n\nOnce again, run devtools::load_all(), devtools::document(), and devtools::install(), then run the application with run():\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nlap::run()\n\n\n\n\n\n\n(a)\n\n\nFigure 19.4: Running lap with new Sass\n\n\n\n\n19.3.2.4 New root folders\nIt’s important to note that adding features to your leprechaun app-package will add non-standard directories to the root folder:\n\n├── node_modules/ &lt;- too many sub-folders to list here!\n├── package-lock.json\n├── package.json\n├── scss/\n│   ├── _core.scss\n│   └── main.scss\n├── srcjs/\n│   ├── config\n│   ├── index.js\n│   └── modules\n├── webpack.common.js\n├── webpack.dev.js\n└── webpack.prod.js\n\nThese folders are necessary for adding JavaScript/SCSS functionality, so don’t remove them (just make sure they’re added to the .Rbuildignore/.gitignore)"
  },
  {
    "objectID": "leprechaun.html#tests",
    "href": "leprechaun.html#tests",
    "title": "19  leprechaun",
    "section": "19.4 Tests",
    "text": "19.4 Tests\nleprechaun doesn’t any specific support for testing (like the golem framework), but we can create tests using any combination of testthat, testServer(), and shinytest2."
  },
  {
    "objectID": "leprechaun.html#lap-dependencies",
    "href": "leprechaun.html#lap-dependencies",
    "title": "19  leprechaun",
    "section": "19.5 lap dependencies",
    "text": "19.5 lap dependencies\nIt’s also worth noting that using the leprechaun framework doesn’t add itself as a dependency:\n\n# in the 16_leprechaun branch of moviesApp\npak::local_deps_explain(deps = 'leprechaun', root = \".\")\n\nx leprechaun"
  },
  {
    "objectID": "leprechaun.html#recap",
    "href": "leprechaun.html#recap",
    "title": "19  leprechaun",
    "section": "19.6 Recap",
    "text": "19.6 Recap\nleprechaun apps are built using the same methods as app-packages (devtools and usethis), and are intended to be a ‘leaner and smaller’ version of golem.\n\n“it generates code and does not make itself a dependency of the application you build; this means applications are leaner, and smaller”\n\nleprechaun is similar to golem in that it ‘bundles’ various app-package development functions into helper/utility functions. For example, the .onLoad() function saves some time (at the cost of making your app code less clear and explicit).\nleprechaun also relies on external packages like packer to integrate and bundle external code files, so becoming more familiar with these packages will extend what you can build with leprechaun."
  },
  {
    "objectID": "leprechaun.html#footnotes",
    "href": "leprechaun.html#footnotes",
    "title": "19  leprechaun",
    "section": "",
    "text": "Remember to provide a list of fields to usethis::create_package() for the DESCRIPTION file (or edit this manually).↩︎\nleprechaun::scaffold() has arguments for ui (fluidPage or navbarPage) bs_version (bootstrap version) and overwrite (if you need to start over).↩︎\nLink to R/assets.R file.↩︎\nLink to R/input-handlers.R file.↩︎\nLink to R/leprechaun-utils.R file.↩︎\nLink to R/ui.R file.↩︎\nLink to R/server.R file.↩︎\nLink to R/zzz.R file.↩︎\nLink to inst/run/app.R file.↩︎\nleprechaun modules do not have the same naming conventions as golem (or that I’ve recommended throughout this book).↩︎\npkgload::load_all() has reset set to TRUE and helpers set to FALSE.↩︎\nR/run.R includes functions for running the production (run()) and development (run_dev()) version of the application.↩︎\nmake_send_message() is in R/leprechaun-utils.R.↩︎\nassets() loads the resources called in the R/assets.R file with the serveAssets() function.↩︎\nThe same scatter_plot() function from moviesApp (i.e, imports .data from rlang)↩︎\nsrcjs/, package-lock.json, package.json, webpack.common.js, webpack.dev.js and webpack.prod.js are added to the .Rbuildignore (and node_modules/ is added to the .gitignore).↩︎\nThe scss folder in the root directory is used by leprechaun::build() to create inst/dev/sass.R.↩︎"
  },
  {
    "objectID": "rhino.html#rap-a-rhino-app",
    "href": "rhino.html#rap-a-rhino-app",
    "title": "20  rhino",
    "section": "20.1 rap (a rhino app)",
    "text": "20.1 rap (a rhino app)\nThe files in rap are below:\n\n1├── .Rprofile\n2├── .github/\n│   └── workflows\n├── .gitignore\n3├── .lintr\n4├── .renvignore\n├── .rscignore        \n├── README.md\n├── app\n│   ├── js\n│   ├── logic\n│   ├── main.R\n│   ├── static\n│   ├── styles\n│   └── view\n├── app.R\n├── config.yml\n5├── dependencies.R.\n├── moviesApp.Rproj\n6├── renv\n│   ├── .gitignore.   \n│   ├── activate.R\n│   ├── library\n│   ├── settings.json\n│   └── staging\n├── renv.lock\n├── rhino.yml\n└── tests\n    ├── cypress\n    ├── cypress.json\n    └── testthat\n\n24 directories, 31 files\n\n\n1\n\nActivates the renv package\n\n2\n\nCI/CD via GitHub actions\n\n\n3\n\nLintr (from lintr package)\n\n\n4\n\nrenv ignore (works like .gitignore)\n\n\n5\n\nrhino app dependencies\n\n6\n\nrenv library of packages in app project\n\n\n\n\nAs we can see, most of the standard R package folders and files are missing from rap, because rhino applications use the box package for importing dependencies and organizing code.2"
  },
  {
    "objectID": "rhino.html#rhino-features",
    "href": "rhino.html#rhino-features",
    "title": "20  rhino",
    "section": "20.2 rhino features",
    "text": "20.2 rhino features\nThe rhino website explains the philosophy behind the application structure above, so I won’t repeat that information here. However, I highly recommend reading the available documentation on rhino and box before deciding to adopt this framework.3"
  },
  {
    "objectID": "rhino.html#box-modules",
    "href": "rhino.html#box-modules",
    "title": "20  rhino",
    "section": "20.3 box modules",
    "text": "20.3 box modules\nA box module (not to be confused with a Shiny module) is a collection of .R scripts in a specified folder. The modules in a new rhino app are stored in the app/logic/ and app/view/ folders:4\n\napp\n1├── js/\n2├── logic/\n3├── main.R\n4├── static/\n5├── styles/\n6└── view/\n\n6 directories, 1 file\n\n\n1\n\nJavaScript code\n\n2\n\nNon-shiny code\n\n\n3\n\nPrimary app file\n\n\n4\n\nStatic .js or .css\n\n\n5\n\nApp CSS files\n\n6\n\nShiny modules and app code\n\n\n\n\n\n20.3.1 Utility functions\nIn rap, I’ve placed the non-Shiny utility functions (i.e., the business logic) in app/logic:\n\napp/logic\n├── __init__.R\n1├── data.R\n2└── plot.R\n\n1 directory, 4 files\n\n\n1\n\nLoad movies data\n\n\n2\n\nscatter_plot() utility function\n\n\n\n\n\n\n20.3.2 Shiny modules\nOur Shiny box modules are placed in app/view, and separated into inputs and display:\n\napp/view\n├── __init__.R\n1├── display.R\n2└── inputs.R\n\n1 directory, 3 files\n\n\n1\n\nsimilar to the code from R/mod_var_input.R\n\n2\n\nsimilar to the code from R/mod_scatter_display.R\n\n\n\n\napp/view/inputs collects and returns the reactive values from the UI. The app/view/display module includes the app/logic/data and app/logic/plot modules.\n\n# app/view/display.R\n\n# import data and plot modules\nbox::use(\n  app / logic / data,\n  app / logic / plot\n)"
  },
  {
    "objectID": "rhino.html#appmain.r",
    "href": "rhino.html#appmain.r",
    "title": "20  rhino",
    "section": "20.4 app/main.R",
    "text": "20.4 app/main.R\nThe app/main.R file contains the primary UI and Server functions for the application. This file adds the shiny functions and the inputs and display modules from app/view:\n\n# app/main.R\n\n# shiny functions\nbox::use(\n  shiny[\n    NS, fluidPage, sidebarLayout, sidebarPanel,\n    mainPanel, fluidRow, column, tags, icon,\n    textOutput, moduleServer, renderText\n  ]\n)\n\n# import modules\nbox::use(\n  # load inputs module ----\n  app / view / inputs,\n  # load display module ----\n  app / view / display\n)\n\nNote that we don’t need to import app/logic modules in app/main.R, because they’re imported in their respective app/view modules."
  },
  {
    "objectID": "rhino.html#tests",
    "href": "rhino.html#tests",
    "title": "20  rhino",
    "section": "20.5 Tests",
    "text": "20.5 Tests\nrhino apps have support for testing with testthat, shiny::testServer(), shinytest2, and Cypress.\n\ntests/\n1├── cypress\n│   └── integration\n│       └── app.spec.js\n├── cypress.json\n2└── testthat\n    └── test-main.R\n\n4 directories, 3 files\n\n\n1\n\nCypress test infrastructure\n\n\n2\n\ntestthat test infrastructure\n\n\n\n\nBelow is the boilerplate test code in the tests/testthat/test-main.R file:\n\n1box::use(\n  shiny[testServer], \n  testthat[...],\n)\n\nbox::use(\n  app/main[...],\n)\n\n2test_that(\"main server works\", {\n  testServer(server, {\n    expect_equal(output$message, \"Hello!\")\n  })\n})\n\n\n1\n\nbox module importing test package functions\n\n2\n\nUsing shiny::testServer() and testthat::test_that() functions in test.\n\n\n\n\nI’ve included tests for the utility functions and modules in the 17_rhino branch, but I’ll cover testing with rhino elsewhere.5"
  },
  {
    "objectID": "rhino.html#rhino-dependencies",
    "href": "rhino.html#rhino-dependencies",
    "title": "20  rhino",
    "section": "20.6 rhino dependencies",
    "text": "20.6 rhino dependencies\nIn rhino apps, dependencies are managed by renv and the dependencies.R file. The renv package is designed to,\n\n“create[s] and manage[s] project-local R libraries, save[s] the state of these libraries to a ‘lockfile’, and later restore[s] the library as required.” 6\n\nThe rhino::pkg_install() helper function updates both the dependencies.R file and renv library. Using dependencies.R, renv, and box modules removes the need to manage dependencies in a DESCRIPTION or NAMESPACE file.7"
  },
  {
    "objectID": "rhino.html#recap",
    "href": "rhino.html#recap",
    "title": "20  rhino",
    "section": "20.7 Recap",
    "text": "20.7 Recap\nrhino takes a novel and innovative approach to developing Shiny applications (and covering all the ways they differ from app-packages is beyond the scope of this book). Feel free to review the code in the 17_rhino branch for a better understanding of how the box modules are structured and used within the ui and server.\nThe rhino framework isn’t used as widey golem,8 but it’s been gaining popularity (and has been used in a recent pilot FDA submission).\n\n\n\n\n\n(a) rhino CRAN downloads\n\n\nFigure 20.4: CRAN downloads for rhino, leprechaun, and goelm between 2020-10-31 and 2023-10-31."
  },
  {
    "objectID": "rhino.html#footnotes",
    "href": "rhino.html#footnotes",
    "title": "20  rhino",
    "section": "",
    "text": "I re-initialize the session on the 17_rhino branch so I’m not tempted to load, document, install, or test the code using the IDE.↩︎\nImported dependencies in rhino apps use box modules instead of the DESCRIPTION and NAMESPACE.↩︎\nBe sure to read up on testing box modules and rhino applications with cypress and shinytest2.↩︎\nrhino recommends placing non-Shiny code in the app/logic folder and keeping all Shiny modules and reactive code in app/view.↩︎\nSee the Shiny frameworks supplemental website for more information on testing your rhino app.↩︎\nAs described in renv’s DESCRIPTION file↩︎\nBe sure to read the renv configuration article for a better understanding on how it works with rhino apps.↩︎\nCheck for yourself on cran-downloads↩︎"
  },
  {
    "objectID": "special_topics.html#debugging",
    "href": "special_topics.html#debugging",
    "title": "Special topics",
    "section": "Debugging",
    "text": "Debugging\nThe Debugging chapter covers how to use browser() (see Section 21.1.1) and the IDE’s debugger console to ‘step through’ a function line-by-line. This chapter also covers how to send and view print() statements in the UI (see Section 21.5)"
  },
  {
    "objectID": "special_topics.html#values-vs.-data",
    "href": "special_topics.html#values-vs.-data",
    "title": "Special topics",
    "section": "Values vs. Data",
    "text": "Values vs. Data\nValues vs. Data gives an example of how to use session$userData to store persistent, non-reactive objects in your application (see also Section 9.3). Section 22.1 demonstrates how we can use reactiveValues() to store and retrieve reactive values from a ‘persistent’ object in our app. Section 22.3.1 also has examples of testing modules with values from a reactiveValues() object."
  },
  {
    "objectID": "special_topics.html#graph-snapshots",
    "href": "special_topics.html#graph-snapshots",
    "title": "Special topics",
    "section": "Graph snapshots",
    "text": "Graph snapshots\nSnapshots for graphs are covered in Chapter 23 using the vdiffr package"
  },
  {
    "objectID": "special_topics.html#test-mocks",
    "href": "special_topics.html#test-mocks",
    "title": "Special topics",
    "section": "Test mocks",
    "text": "Test mocks\nTest mocks gives a general overview of how to use test mocks. Note: this example does not use code from the moviesApp app-package (see Section 12.1 and Section 12.2)"
  },
  {
    "objectID": "special_topics.html#code-tools",
    "href": "special_topics.html#code-tools",
    "title": "Special topics",
    "section": "Code tools",
    "text": "Code tools\nProperly styled and formatted code is easier to read, but not always easy to write. Code tools introduces two packages (lintr and styler) to help keep your code clean and stylish."
  },
  {
    "objectID": "special_topics.html#cicd",
    "href": "special_topics.html#cicd",
    "title": "Special topics",
    "section": "CI/CD",
    "text": "CI/CD\nThe CI/CD chapter…"
  },
  {
    "objectID": "special_topics.html#javascript",
    "href": "special_topics.html#javascript",
    "title": "Special topics",
    "section": "JavaScript",
    "text": "JavaScript\nThe JavaScript chapter…"
  },
  {
    "objectID": "debugging.html#debugging-shiny-apps",
    "href": "debugging.html#debugging-shiny-apps",
    "title": "21  Debugging",
    "section": "21.1 Debugging Shiny Apps",
    "text": "21.1 Debugging Shiny Apps\nDuring regular development, Posit Workbench’s interactive debugger lets us inspect variables and expressions and execute the code line-by-line. In Shiny functions, the debugger lets us track the execution of reactive expressions and observers, which allows us to unravel reactivity-related issues that are often difficult to diagnose.\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.1_debug-error')\n\nLet’s start by debugging the scatter plot in movies_app(). After loading, documenting and installing moviesApp, launch the application:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\n\nmovies_app(test = FALSE)\n\n\n\n\n\n\n(a) Error in movies_app()\n\n\nFigure 21.1: The Error messages in the UI is not always informative\n\n\nThe error printed in the UI is not very descriptive, but fortunately the following output is also printed to the Console:\nWarning: Error in ggplot2::geom_point: Problem while computing aesthetics.\nℹ Error occurred in the 1st layer.\nCaused by error in `.data[[NULL]]`:\n! Must subset the data pronoun with a string, not `NULL`.\nggplot2 has excellent error messages: we can see the error is coming from ggplot2::geom_point(), specifically from one of the calls to .data. We can safely assume the source of this bug is the scatter_plot() utility function. However, we’ll proceed as if the message wasn’t very helpful or informative.\n\n21.1.1 Strategies\nThe two most common tools I use for debugging are:\n\nWrapping browser() in a call to observe()\n\nCapturing reactive values with reactiveValuesToList() and sending output to the UI\n\nThese two methods cover 90% of my Shiny app debugging needs. In the following sections, I’ll provide examples of how–and when–I use each method.\nbrowser()\nbrowser() pauses code execution and activates the interactive debugger mode in the IDE, allowing us to view objects, execute code, and ‘step through’ each function line.\nobserve()\nShiny’s reactive model can make debugging challenging because the issues aren’t limited to logic or calculations but include the timing, sequence, or creation of reactive values. observe() creates a reactive observer that ‘listens’ for changes to reactive expressions (and executes code in response).\nWrapping browser() with observe() will trigger the debugger when the observer is invalidated, allowing us to interactively examine variables and reactive expressions (within the scope of the observe() function):\n\n\n\n\n\nPosit Workbench’s interactive debugger\n\n\n\n1server &lt;- function(input, output, session) {\n\n2    observe({\n3        browser()\n    \n\n    returned_values &lt;- mod_something(\"bla\")\n\n    mod_something_else(\"blabla\", input_values = returned_values)\n    \n    })\n}\n\n\n1\n\nShiny server function\n\n2\n\nobserve() function scope\n\n\n3\n\nCall to browser() (called at the top of the observe() scope)\n\n\n\n\n\n\n\n\n\n\nDebugging Reactivity in Shiny App-Packages\n\n\n\n\n\n\nDon’t forget to load any debugging calls with devtools::load_all() before re-launching the app\ndevtools::load_all('.')\nOr\nCtrl/Cmd + Shift + L"
  },
  {
    "objectID": "debugging.html#debugging-modules",
    "href": "debugging.html#debugging-modules",
    "title": "21  Debugging",
    "section": "21.2 Debugging modules",
    "text": "21.2 Debugging modules\nThe contents of your Shiny app-package can quickly become a complicated and intertwined combination of functions: utility, modules, UI, server, etc. I like to display the relationship between the functions with an abstract folder tree using the lobstr package:2\n\n\n\nFor example, we know scatter_plot() is called from within the scatter plot display module function:\n\n\n█─mod_scatter_display_server \n└─█─scatter_plot\n\n\n\n\n\nshow/hide abstract folder tree code\nlobstr::ast(\n  mod_scatter_display_server(\n    scatter_plot()\n    )\n  )\n\n\n\n\n\n\n\nAnd mod_scatter_display_server() is called within movies_server():\n\n\n█─movies_server \n├─█─mod_scatter_display_server \n│ └─█─scatter_plot \n└─█─mod_var_input_server \n\n\n\n\n\nshow/hide abstract folder tree code\nlobstr::ast(\n    movies_server(\n      mod_scatter_display_server(\n        scatter_plot()\n        ),\n      mod_var_input_server()\n      )\n)\n\n\n\n\n\n\n\nWhich is called from inside moviesApp():\n\n\n█─movies_app \n├─█─movies_ui \n│ ├─█─mod_var_input_ui \n│ └─█─mod_scatter_display_ui \n└─█─movies_server \n  ├─█─mod_scatter_display_server \n  │ └─█─scatter_plot \n  └─█─mod_var_input_server\n\n\n\n\n\nshow/hide abstract folder tree code\nlobstr::ast(\n  movies_app( \n    movies_ui(\n      mod_var_input_ui(),\n      mod_scatter_display_ui()\n    ),\n    movies_server(\n      mod_scatter_display_server(\n        scatter_plot()\n        ),\n      mod_var_input_server()\n      )\n    )\n  )\n\n\n\n\nI find these abstract folder trees helpful when I’m debugging or testing Shiny functions. I can use them to try and anticipate the application call stack (especially when I end up with multiple utility functions or nested modules).\nWe’ll add browser() and observe() in the movies_server() function to capture the behaviors of both modules:\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.2_debug-selected_vars')\n\n\nmovies_server &lt;- function(input, output, session) {\n\n1    observe({\n2      browser()\n    \n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n    })\n\n}\n\n\n1\n\nObserver scope\n\n\n2\n\nActivate debugger\n\n\n\n\nThen we’ll load the package and display the app in the Viewer pane (below the Console):\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\nℹ shinyViewerType set to pane\nThe application launches, but browser() pauses the execution of the modules and activates the IDE’s debugger. This allows us to view the objects that are available in movies_server() before the variables are passed to the graph rendering functions:\n\n\n\n\n\n(a) Debugger with call to browser() inside observe()\n\n\nFigure 21.2: Note that the plot hasn’t rendered in the application yet because the call to observe(browser()) suspends the execution of any subsequent code\n\n\nIn the Source pane, we can see the call to browser() highlighted (Browse[1]&gt; tells us the location in the browser() function).\n\n\n\n\n\n(a) R/movies_server.R with observe(browser())\n\n\nFigure 21.3: Because browser() was called inside observe(), the execution will pause, and we can interactively examine values\n\n\nIn the debugger, we want to confirm the returned values from the variable input module, selected_vars, which requires us to execute the next two lines of code:\n\nBrowse[1]&gt; n\nBrowse[2]&gt; n\n\n\n\n\n\n\n(a) Execute the function line-by-line with n to create selected_vars\n\n\nFigure 21.4: Click the Next icon twice to create selected_vars\n\n\nInside movies_server():\n\n\n\nmod_var_input_server() collects the following values and returns a reactive list (selected_vars):\n\n\n\nThree variable names\n\nx, y, z\n\n\nGraph aesthetics\n\nalpha and size\n\n\nAn optional plot title\n\nplot_title\n\n\n\n\n\nWhen we inspect selected_vars in the debugger console (without parentheses) we see the method (i.e., the reactive list of inputs), and not the actual values:\n\n\n\nBrowse[2]&gt; selected_vars\n\n\nreactive({\n    list(y = input$y, x = input$x, z = input$z, alpha = input$alpha, \n        size = input$size, plot_title = input$plot_title)\n}) \n\n\n\nIf we check selected_vars() (with parentheses) in the debugger, we see this contains the values from the variable input module:\n\n\n\nBrowse[2]&gt; selected_vars()\n\n\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nThese two steps confirm that the UI values are being collected by the variable input module and stored in selected_vars, so the error must be coming from inside the scatter plot display module."
  },
  {
    "objectID": "debugging.html#module-communication",
    "href": "debugging.html#module-communication",
    "title": "21  Debugging",
    "section": "21.3 Module communication",
    "text": "21.3 Module communication\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.3_debug-var_inputs')\n\nWe’ll repeat a similar process in mod_scatter_display_server(), but include the call to observe(browser()) after moduleServer(). Then we’ll load the package and run the application again:\n\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n    \n1    observe({\n      browser()\n    \n      # module code\n      \n      })\n\n  })\n}\n\n\n1\n\nWrap browser() in observe() and place after the call to moduleServer()\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\nInside the module, we want to confirm var_inputs() is being created correctly from the var_inputs object in movies_server().\n\n\n\nselected_vars is the input for mod_scatter_display_server() (as var_inputs)\n\n\n\nvar_inputs is converted to the reactive inputs\n\ninputs is passed to scatter_plot() inside renderPlot()\n\n\n\n\n\n\n\n\nBrowse[2]&gt; var_inputs()\n\n\n$y\n[1] \"audience_score\"\n\n$x\n[1] \"imdb_rating\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\n\n21.3.1 Verify variable inputs\nInside the scatter plot display module, the var_inputs argument is used to create a reactive input() object for the graph created by scatter_plot():\n\n2    inputs &lt;- reactive({\n1      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n    })\n\n\n1\n\nVariable inputs (from selected_vars)\n\n\n2\n\ninputs() for scatter_plot()\n\n\n\n\nNow that we’ve confirmed var_inputs() has been created, we’ll verify the values are passed correctly from var_inputs() to inputs() (which is used to create the scatter plot).\nTo do this, we’ll progress through the module function (using n in the debugger console or by clicking Next) until the inputs() reactive has been created,\n\n\n\n\n\n(a) Progressing past inputs() tells us it’s been created\n\n\nFigure 21.5: Use n in the debugger or click Next to progress through the function\n\n\n\n\n\nBrowse[2]&gt; inputs()\n\n\n$x\n[1] \"imdb_rating\"\n\n$y\n[1] \"audience_score\"\n\n$z\n[1] \"mpaa_rating\"\n\n$alpha\n[1] 0.5\n\n$size\n[1] 2\n\n$plot_title\n[1] \"\"\n\n\n\nThese two steps have shown us 1) the modules are communicating properly, and 2) the scatter plot display module contains the list of reactive values needed to render the graph.\n\n\n\n\n\n\nDebugging shiny functions\n\n\n\n\n\n\nIf a module or standalone app function is producing a bug (i.e., failing to render an output, producing an error in the Console, etc.), I start by placing a call to browser() (wrapped in shiny::observe()) at the top-level UI/server functions, then procced ‘down’ into the modules."
  },
  {
    "objectID": "debugging.html#debugging-utility-functions",
    "href": "debugging.html#debugging-utility-functions",
    "title": "21  Debugging",
    "section": "21.4 Debugging utility functions",
    "text": "21.4 Debugging utility functions\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.4_debug-scatter_plot')\n\nIf we want to debug the scatter plot output, we need to move our observe(browser()) functions inside the call to renderPlot():\n\noutput$scatterplot &lt;- renderPlot({\n1  observe({\n2    browser()\n\n    \n  })\n})\n\n\n1\n\nObserve scope\n\n\n2\n\nCall to browser()\n\n\n\n\nLoad the package and run the application again:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\nInside renderPlot(), we can progress to the creation of the plot object:\n\n\n\nBrowse[1]&gt; n\n\n\ndebug at moviesApp/R/mod_scatter_display.R#68: \n  plot &lt;- scatter_plot(\n    df = movies, \n    x_var = inputs()$x, \n    y_var = inputs()$y, \n    col_var = inputs()$col, \n    alpha_var = inputs()$alpha, \n    size_var = inputs()$size)\n\n\n\nFrom here we can step inside the scatter_plot() utility function to identify the source of the error:\n\nBrowse[2]&gt; s\n\n\n\n\n\n\n(a) Step into scatter_plot()\n\n\nFigure 21.6: Use s in the debugger console to ‘step into’ scatter_plot()\n\n\nNote the changes in the debugger console when we ‘step into’ scatter_plot():\n\ndebugging in: \n  scatter_plot(df = movies, \n    x_var = inputs()$x, \n    y_var = inputs()$y, \n    col_var = inputs()$col, \n    alpha_var = inputs()$alpha, \n    size_var = inputs()$size)\n1debug at /moviesApp/R/scatter_plot.R#30:\n{   \n    ggplot2::ggplot(data = df, \n      ggplot2::aes(x = .data[[x_var]], \n                   y = .data[[y_var]], \n                   color = .data[[col_var]])) + \n      ggplot2::geom_point(alpha = alpha_var, \n                          size = size_var)\n}\n\n\n1\n\nLocation of debugger in utility function\n\n\n\n\nAfter some examination, we can identify the source of the error.\n\n\nshow/hide source of scatter_plot() bug\ninputs &lt;- reactive({\n  plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n  list(\n    x = var_inputs()$x,\n    y = var_inputs()$y,\n1    col = var_inputs()$z,\n    alpha = var_inputs()$alpha,\n    size = var_inputs()$size,\n    plot_title = plot_title\n  )\n})\nplot &lt;- scatter_plot(\n  df = movies,\n  x_var = inputs()$x,\n  y_var = inputs()$y,\n2  col_var = inputs()$z,\n  alpha_var = inputs()$alpha,\n  size_var = inputs()$size\n)\n\n\n\n1\n\nColor is assigned as col in inputs\n\n\n2\n\nColor is passed to scatter_plot() as col_var"
  },
  {
    "objectID": "debugging.html#sec-verbatim-reactives",
    "href": "debugging.html#sec-verbatim-reactives",
    "title": "21  Debugging",
    "section": "21.5 Print debugging",
    "text": "21.5 Print debugging\n\n\nLaunch app with the shinypak package:\n\nlaunch('21.5_debug-print')\n\nOne of the best tried and tested methods of debugging is simply adding a cat() or print() call somewhere in your code to print variables or objects to the R console. This is a basic but effective way to track variable changes.\nWe can do something similar in Shiny applications by combining verbatimTextOutput(), renderPrint(), and reactiveValuesToList():\nIn mod_var_input:\n\nPlace a verbatimTextOutput() in the ui function.\n\n\n1    code(\"module reactive values\"),\n2    verbatimTextOutput(outputId = ns(\"mod_vals\"))\n  )\n\n\n1\n\nOptional label\n\n\n2\n\nInclude the ns() for the inputId\n\n\n\n\n\nIn a renderPrint(), use reactiveValuesToList() to gather the inputIds and pass them to print() (I’m actually using lobstr::tree() to give a clearer display).\n\n\n  output$mod_vals &lt;- renderPrint({\n2    lobstr::tree(\n1      reactiveValuesToList(\n        x = input,\n3        all.names = TRUE\n      )\n    )\n  })\n\n\n1\n\nCollect reactive values in module\n\n\n2\n\nPrint these values to the UI\n\n\n3\n\nInclude all reactive objects\n\n\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), run = 'p')\n\n\n\n\n\n\n(a) ‘Print’ in movies_app()\n\n\nFigure 21.7: reactiveValuesToList() printed from mod_var_inputs\n\n\nNow we can see the reactive values from our module in the application sidebar!\nWe can also use this ‘print’ method to explore reactive values at various locations in our application. For example, if we wanted to print the reactive values for multiple modules in an app, we can use these methods in the top level movies_ui() and movies_server() functions.\nIn the bslib portion of movies_ui():\n\nAdd verbatimTextOutput() with an optional label\n\ncode(\"reactive values\"),\nverbatimTextOutput(outputId = 'vals')\n)\n\n\nIn movies_server():\n\nCollect all the inputIds with reactiveValuesToList() and print with print() or lobstr::ast()\n\nall_vals &lt;- reactive({\n  reactiveValuesToList(x = input, all.names = TRUE)\n})\n\noutput$vals &lt;- renderPrint({\n  lobstr::tree(all_vals())\n})\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nmovies_app(options = list(test.mode = FALSE), \n  run = 'p', bslib = TRUE)\n\n\n\n\n\n\n(a) ‘Print’ in movies_app(bslib = TRUE)\n\n\nFigure 21.8: reactiveValuesToList() printed from movies_ui() and movies_server()\n\n\nHere we can see both levels of reactive values (from the module and the UI/server functions). The handy thing about this method is that the values change when we interact with the application:\n\n\n\n\n\n(a) Changing values in movies_app(bslib = TRUE)\n\n\nFigure 21.9: y and vars-y both update when the UI inputs change"
  },
  {
    "objectID": "debugging.html#exploring-code",
    "href": "debugging.html#exploring-code",
    "title": "21  Debugging",
    "section": "21.6 Exploring code",
    "text": "21.6 Exploring code\nobserve() and browser() aren’t only useful for addressing bugs–we can also use the debugger to understand how an application works.\nSuppose it’s been awhile since we’ve looked at the ggplot2movies::movies application (run with ggp2_movies_app()). We can place calls to observe(browser()) in the inst/dev/app.R file, load the package, and run the application to see how it executes.\nWe’ll wrap the code in dev_mod_scatter_server() in observe(), and place a call to browser() before the alternate dataset is loaded:\n\ndev_mod_scatter_server &lt;- function(id, var_inputs) {\n  moduleServer(id, function(input, output, session) {\n\n1    observe({\n2      browser()\n\n    # load alternate data\n    all_data &lt;- fst::read_fst(\"tidy_movies.fst\")\n3\n\n\n\n    })\n  })\n}\n\n\n1\n\nObserver scope\n\n\n2\n\nCall to browser()\n\n\n3\n\nAdditional module code omitted\n\n\n\n\nLoad the package and run the app:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading moviesApp\n\nggp2_movies_app(options = list(test.mode = FALSE), run = 'p')\n\nThis will suspend the execution of application before the tidy ggplot2movies::movies data are loaded (tidy_movies.fst), and before the graph is rendered:\n\n\n\n\n\n\n\nDebugging dev_mod_scatter_server()\n\n\n\n\n\n\n\nggp2_movies_app() in interactive debugger\n\n\n\n\n\n\nWe can step through the module function to explore how the alternate data are loaded (and missing values are removed).\n\n21.6.1 Verify app data\nFirst we’ll proceed through the code until tidy_movies.fst is loaded, then confirm it’s structure:\n\n\n\nBrowse[2]&gt; n\nBrowse[2]&gt; n\nBrowse[2]&gt; str(all_data)\n\n\n'data.frame':   46002 obs. of  8 variables: \n $ title     : chr  \"'Til There Was You\" ...\n $ length    : int  113 97 98 98 102 120 ...\n $ year      : int  1997 1999 2002 2004 ...\n $ budget    : int  23000000 16000000 ...\n $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...\n $ votes     : int  799 19095 181 7859 ...\n $ mpaa      : Factor w/ 5 levels \"G\",\"PG\" ...\n $ genre     : Factor w/ 8 levels \"Action\"...\n\n\n\nThis gives us an idea of the total rows before missing are removed.\n\n\n21.6.2 Verfiy missing\nAfter loading all_data, the module creates a reactive graph_data(). We can see graph_data() is ‘bound’ to input$missing, so we’ll confirm the input$missing value:\n\n\n\n\n\n\n\n\nBrowse[2]&gt; input$missing\n\n\n[1] TRUE\n\n\n\nThis tells us ‘Remove missing’ has been selected, and we can verify the missing values have been removed from graph_data():\n\n\n\nBrowse[2]&gt; n\nBrowse[2]&gt; str(graph_data())\n\n\n'data.frame':   1608 obs. of  8 variables: \n $ title     : chr  \"'Til There Was You\" ...\n $ length    : int  113 97 98 98 102 120 ...\n $ year      : int  1997 1999 2002 2004 ...\n $ budget    : int  23000000 16000000 ...\n $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...\n $ votes     : int  799 19095 181 7859 ...\n $ mpaa      : Factor w/ 5 levels \"G\",\"PG\" ...\n $ genre     : Factor w/ 8 levels \"Action\"...\n\n\n\n\n\n21.6.3 Verfiy variable inputs\nNext we’ll confirm the var_inputs() list of graph values from our dev variable input module:\n\n\n\nBrowse[2]&gt; str(var_inputs())\n\n\nList of 6\n $ x         : chr \"year\"\n $ y         : chr \"budget\"\n $ z         : chr \"mpaa\"\n $ alpha     : num 0.4\n $ size      : num 2.5\n $ plot_title: chr \"\"\n\n\n\nvar_inputs() is creates the inputs() reactive for the graph, so we’ll confirm those values, too.\n\n\n\n\n\n\n\n\nBrowse[2]&gt; n\nBrowse[2]&gt; str(inputs())\n\n\nList of 6\n $ x         : chr \"year\"\n $ y         : chr \"budget\"\n $ z         : chr \"mpaa\"\n $ alpha     : num 0.4\n $ size      : num 2.5\n $ plot_title: chr \"\"\n\n\n\n\n\n21.6.4 Verfiy graph\nNow that we have an understanding of the reactive flow inside the app, we’ll render the plot:\n\n\n\nBrowse[2]&gt; n\n\n\n\n\n\n\nUsing browser() to ‘step through’ an application gives us a better understanding of the ‘order of execution’ in our dev scatter plot display module, (and it lets us see how input$missing and bindEvent() are working)."
  },
  {
    "objectID": "debugging.html#recap",
    "href": "debugging.html#recap",
    "title": "21  Debugging",
    "section": "21.7 Recap",
    "text": "21.7 Recap\nbrowser() and observe() are powerful tools for debugging your application. Navigating a function using the debugger console gives you control over the execution of each line. If we want to see what’s happening ‘behind the scenes’, we can collect the reactive values and print them in the UI while the app is running.\nThe Shiny documentation also has a list of methods for debugging apps, and learning how to read call stacks (or a stacktrace) will help you debug your shiny app.3, 4"
  },
  {
    "objectID": "debugging.html#footnotes",
    "href": "debugging.html#footnotes",
    "title": "21  Debugging",
    "section": "",
    "text": "For an introduction to the IDE’s debugging tools, see this Posit article. Debugging is also covered in Advanced R, 2ed and Mastering Shiny.↩︎\nCreate abstract folder trees with the ast() function from the lobstr package.↩︎\nWatch this video to learn about call stacks and abstract folder trees with lobstr.↩︎\nStack traces are also covered in Advanced R, 2ed, Mastering Shiny, and in the Shiny documentation. I’ve summarized some tips on reading Shiny call stacks in the stack traces section on the Appendix.↩︎"
  },
  {
    "objectID": "values_vs_data.html#sec-reactiveValues",
    "href": "values_vs_data.html#sec-reactiveValues",
    "title": "22  Values vs. data",
    "section": "22.1 reactiveValues()",
    "text": "22.1 reactiveValues()\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 22.1_reactive-values branch of moviesApp.\n\nCalling reactiveValues() creates “an object for storing reactive values.” We’ve been storing the reactive values returned from the var_input module in the selected_vars object, then passing these values into the scatter_display module. 1\n\nmovies_server &lt;- function(input, output, session) {\n\n1      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n2      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\n1\n\nreactive values returned from var_input module\n\n\n2\n\nreactive values passed to scatter_display module\n\n\n\n\nIn the steps below we’ll walk through an example of using reactiveValues() to capture the selected_vars values returned from the var_input module and passed to the scatter_display module.\nYou should note a series of changes made to movies_server() in this branch:\n\nreactiveValues() is used to create rVals\nInstead of creating the selected_vars, the output from mod_var_input_server() is assigned to rVals as inputs\nrVals is then passed as an input argument to mod_scatter_display_server()\n.dev arguments have been added to both module server functions (and have been set to FALSE)\n\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n1    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n2    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = FALSE)\n    \n    # view output in the UI\n3    # output$vals &lt;- renderPrint({\n    #   str(rVals)\n    #   # str(rVals$inputs())\n    # })\n\n    # pass reactive values to display\n4    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nNew reactiveValues() object\n\n\n2\n\nReturned values from mod_var_input_server() assigned to rVals$inputs\n\n\n3\n\nrenderPrint() for str(rVals) and str(rVals$inputs()) (commented)\n\n\n4\n\nrVals object passed to mod_scatter_display_server()\n\n\n\n\nIn the steps below, we’ll view the structure and function of rVals and the reactive values in the application using methods covered in the Debugging chapter.\n\n22.1.1 Step 1\nChange .dev in mod_var_input_server() to TRUE in movies_server(), then load and run the application. The updated movies_server() function should look like this:\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n    # output$vals &lt;- renderPrint({\n    #   str(rVals)\n    #   # str(rVals$inputs())\n    # })\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n\n\n\nWhen the application launches, you should see the following:2\n\n\n\n\n\n\n(a) .dev = TRUE in mod_var_input_server()\n\n\nFigure 22.1: reactive values from mod_var_input_server()\n\n\n\nThe output in the sidebar are the reactive values from the variable input module:\nmod_var_input_server() has been simplified to return the output from reactiveValuesToList().\n\nThe same output is also being rendered in the sidebar when .dev is set to TRUE:\n\nmod_var_input_server &lt;- function(id, .dev = TRUE) {\n\n  moduleServer(id, function(input, output, session) {\n\n    if (.dev) {\n      # view output in the UI\n      output$vals &lt;- renderPrint({\n        x &lt;- reactiveValuesToList(input, all.names = TRUE)\n        str(x)\n      })\n    }\n\n    # return reactives\n    return(\n      reactive({\n        reactiveValuesToList(input, all.names = TRUE)\n      })\n    )\n\n  })\n}\n\n\n\n\n22.1.2 Step 2\nRemove the comments from the renderPrint() lines in movies_server() to view the structure of rVals, then load and run the application. The new movies_server() function should now look like this:\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      str(rVals)\n      # str(rVals$inputs())\n    })\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n2\n\nRemove comments from str(rVals)\n\n\n\n\n\n\n\n\n\n\n(a) str(rVals)from movies_server()\n\n\nFigure 22.2: rVals$inputs() from movies_server()\n\n\n\n\n22.1.2.1 What is reactiveValues()?\n\n“When you read a value from it, the calling reactive expression takes a reactive dependency on that value, and when you write to it, it notifies any reactive functions that depend on that value. Note that values taken from the reactiveValues() object are reactive, but the reactiveValues() object itself is not.” Shiny Documentation\n\nI’ve added emphasis to the quote above because it’s important to remember that any object assign to reactiveValue() should be treated like any reactive object (i.e., and inputId or object returned from reactive() or observe()).3\nFor example, if we try to access the input values as a list outside the a movies_server() or module function, we see the following error:4\n\nx &lt;- reactiveValues(\n  inputs = list(x = \"imdb_rating\",\n                y = \"audience_score\",\n                z = \"mpaa_rating\",\n                alpha = 0.5,\n                size = 2,\n                plot_title = \"Enter Plot Title\")\n  )\nx$inputs()\n\n\n## Error in `x$inputs`:\n## ! Can't access reactive value 'inputs' outside of reactive consumer.\n## ℹ Do you need to wrap inside reactive() or observe()?\n\n\n\n\n22.1.3 Step 3\nNow let’s remove the commented lines from renderPrint() to view the structure of rVals$inputs(), then load and run the application. The new movies_server() function should now look like this:\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      # str(rVals)\n      str(rVals$inputs())\n    })\n\n    # pass reactive values to display\n    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = FALSE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n2\n\nRemove comments from str(rVals$inputs())\n\n\n\n\n\n\n\n\n\n\n(a) str(rVals)from movies_server()\n\n\nFigure 22.3: rVals$inputs() from movies_server()\n\n\n\nThe rVals$inputs() being rendered in movies_server() are the returned values from the variable input module (and they’re identical to the value in the sidebar).\nWhen rVals is passed to mod_scatter_display_server(), the reactive inputs() object inside the function can be built using rVals$inputs():\n\ninputs &lt;- reactive({\n  plot_title &lt;- tools::toTitleCase(rVals$inputs()[['plot_title']])\n    list(\n      x = rVals$inputs()[['x']],\n      y = rVals$inputs()[['y']],\n      z = rVals$inputs()[['z']],\n      alpha = rVals$inputs()[['alpha']],\n      size = rVals$inputs()[['size']],\n      plot_title = plot_title\n    )\n})\n\nThe .dev argument displays the structure of rVals$inputs() inside mod_scatter_display_server() if it’s set to TRUE:\n\n    if (.dev) {\n      # view output in the UI\n      output$display_vals &lt;- renderPrint({\n        str(\n          rVals$inputs()\n          )\n      })\n    }\n\n\n\n22.1.4 Step 4\nSet .dev to TRUE in mod_scatter_display_server(), then load and run the application. The final movies_server() function should now look like this:\n\n# assign inputs to rVals\nmovies_server &lt;- function(input, output, session) {\n  \n    # create reactive values\n    rVals &lt;- reactiveValues()\n\n    # assign inputs to rVals\n1    rVals$inputs &lt;- mod_var_input_server(\"vars\", .dev = TRUE)\n    \n    # view output in the UI\n2    output$vals &lt;- renderPrint({\n      # str(rVals)\n      str(rVals$inputs())\n    })\n\n    # pass reactive values to display\n3    mod_scatter_display_server(\"plot\", rVals = rVals, .dev = TRUE)\n      \n}\n\n\n1\n\nSet .dev to TRUE\n\n2\n\nRemove comments\n\n\n3\n\nSet .dev to TRUE\n\n\n\n\n\n\n\n\n\n\n(a) .dev set to TRUE and reactive values from movies_server()\n\n\nFigure 22.4: Both module .dev arguments set to TRUE and rVals$inputs() from movies_server()\n\n\n\nAn important thing to note is that we can only reference rVals$inputs() in a reactive consumer (i.e., using reactive(), observe(), etc.). That’s why when we change any of the UI inputs, the values change in rVals$inputs() and in the inputs() object inside the display module.\nYou can also view these outputs using movies_app(run = 'b', bslib = TRUE).\n\n\n\n\n\n\n\n\n\n\nThis section’s code is in the 22.2_user-data branch of moviesApp."
  },
  {
    "objectID": "values_vs_data.html#sessionuserdata",
    "href": "values_vs_data.html#sessionuserdata",
    "title": "22  Values vs. data",
    "section": "22.2 session$userData",
    "text": "22.2 session$userData\nObjects stored in session$userData are not inherently reactive, which makes it ideal for storing persistent values or data that don’t require (or trigger) reactivity. Below is a demonstration of using session$userData to store a non-reactive function to be used in the inst/dev/ application.\n\n22.2.1 Non-reactive objects\nAssume I have an object that I want to pass inside the server (and modules), but I don’t need it to update or change. The example I’ll use below is a function (make_dev_ggp2_movies()) that prepares the ggplot2movies::movies for the application:\n\n\nView make_dev_ggp2_movies() function\nmake_dev_ggp2_movies &lt;- function(con) {\n  movies_data &lt;- read.csv(file = con)\n  # specify genre columns\n  genre_cols &lt;- c(\n    \"Action\", \"Animation\",\n    \"Comedy\", \"Drama\",\n    \"Documentary\", \"Romance\",\n    \"Short\"\n  )\n  # calculate row sum for genres\n  movies_data$genre_count &lt;- rowSums(movies_data[, genre_cols])\n  # create aggregate 'genres' for multiple categories\n  movies_data$genres &lt;- apply(\n    X = movies_data[, genre_cols],\n    MARGIN = 1,\n    FUN = function(row) {\n      genres &lt;- names(row[row == 1])\n      if (length(genres) &gt; 0) {\n        return(paste(genres, collapse = \", \"))\n      } else {\n        return(NA)\n      }\n    }\n  )\n  # format variables\n  movies_data$genre_count &lt;- as.integer(movies_data$genre_count)\n  movies_data$genre &lt;- ifelse(test = movies_data$genre_count &gt; 1,\n    yes = \"Multiple genres\",\n    no = movies_data$genres\n  )\n  movies_data$genre &lt;- as.factor(movies_data$genre)\n  movies_data$mpaa &lt;- factor(movies_data$mpaa,\n    levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n    labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\")\n  )\n\n  # reduce columns to only those in graph\n  movies_data[, c(\n    \"title\", \"year\", \"length\", \"budget\",\n    \"rating\", \"votes\", \"mpaa\", \"genre_count\",\n    \"genres\", \"genre\"\n  )]\n}\n\n\nThis function is designed to take a path or URL (i.e., a connection) as an input and returns a dataset that can be used in the inst/dev/ application.\nIn the inst/dev/app.R file, the following changes have been made to devServer():\n\nsession$userData stores the contents of make_dev_ggp2_movies()\nreactiveValues() is used to create rVals 5\nThe values returned from mod_var_input_server() is assigned to rVals as inputs\ndev_mod_scatter_server() as been updated to include arguments for rVals, userData, con, and .dev\n\n\ndevServer &lt;- function(input, output, session) {\n  \n1  session$userData$make_dev_ggp2_movies &lt;- make_dev_ggp2_movies\n  \n2  rVals &lt;- reactiveValues()\n  \n3  rVals$inputs &lt;- moviesApp::mod_var_input_server(\"vars\", .dev = TRUE)\n  \n  # # view output in the UI\n  # output$vals &lt;- renderPrint({\n  #   # str(session)\n  # })\n\n4  dev_mod_scatter_server(\"plot\",\n    rVals = rVals,\n    data_fun = session$userData$make_dev_ggp2_movies, \n    con = \"https://bit.ly/3FQYR8j\",\n    .dev = FALSE\n  )\n\n}\n\n\n1\n\nCreate userData$make_dev_ggp2_movies that holds make_dev_ggp2_movies()\n\n2\n\nCreate rVals\n\n3\n\nAssign output from mod_var_input_server() to rVals$inputs\n\n4\n\nUpdated dev_mod_scatter_server() function\n\n\n\n\n\n\n22.2.2 Step 1\nTo view what’s happening with session$userData, we’ll run the application using the Run App button at the top of app.R\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Initial app in dev/inst/app.R\n\n\nFigure 22.5: The reactive values from mod_var_input_server() in the sidebar\n\n\n\nWe’re using a previous version of mod_var_input_server() that includes a .dev argument, so we know it’s displaying the contents from reactiveValuesToList() in the sidebar.\n\n\n22.2.3 Step 2\nIn devServer(), un-comment the renderPrint() call so it renders str(session) and run the app:\n\n  # view output in the UI\n1  output$vals &lt;- renderPrint({\n    str(session)\n  })\n\n\n1\n\nRemove comments from renderPrint()\n\n\n\n\n\n\n\n\n\n\n(a) str(session) dev/inst/app.R\n\n\nFigure 22.6: The str(session) from devServer()\n\n\n\nNotice session has :Classes 'ShinySession', 'R6'\n\n22.2.3.1 What is session?\nEach time the app launches, the session list is created and tied to that particular ‘session.’\n\n“An environment for app authors and module/package authors to store whatever session-specific data they want.” Shiny Documentation\n\nsession$userData can store objects that should persist across different reactive contexts, but don’t need reactive updating (and won’t trigger reactivity). On the other hand, reactiveValues() creates objects stored in a reactive ‘state’, which will trigger reactive updates in the UI.\nWe’ll use both reactiveValues() and session$userData in the module below:\ndev_mod_scatter_server() includes arguments for rVals, data_fun, con, and .dev.\n\nrVals is the reactiveValues() object with our input values\ndata_fun is session$userData$make_dev_ggp2_movies\ncon is the path or URL to the data_fun in session$userData 6\n\n\ndev_mod_scatter_server(\"plot\",\n  \n1  rVals = rVals,\n  \n2  data_fun = session$userData$make_dev_ggp2_movies,\n  \n3  con = \"https://bit.ly/3FQYR8j\",\n  \n4  .dev = FALSE)\n\n\n1\n\npass reactive values\n\n2\n\npass session$userData with make_dev_ggp2_movies()\n\n3\n\npass value for non-reactive object\n\n4\n\nview userData value in module\n\n\n\n\n\nInside dev_mod_scatter_server(), all_data is created from data_fun():\n\n# use data_fun() function on con\nall_data &lt;- data_fun(con)\n\n\nThe inputs() list and plot output are very similar to mod_scatter_display_server():\n\n\ninputs &lt;- reactive({\n  plot_title &lt;- tools::toTitleCase(rVals$inputs()[[\"plot_title\"]])\n  list(\n    x = rVals$inputs()[[\"x\"]],\n    y = rVals$inputs()[[\"y\"]],\n    z = rVals$inputs()[[\"z\"]],\n    alpha = rVals$inputs()[[\"alpha\"]],\n    size = rVals$inputs()[[\"size\"]],\n    plot_title = plot_title\n  )\n})\n\n\nThe structure of data_fun will be printed to the UI if the .dev argument is set to TRUE\n\n\n# view output in the UI\noutput$data &lt;- renderPrint({\n    data_fun\n})\n\n\n\n\n\n22.2.4 Step 4\nChange .dev in dev_mod_scatter_server() to TRUE and run the app:\n\n\n\n\n\n\n(a) data_fun dev_mod_scatter_server()\n\n\nFigure 22.7: The data_fun argument from dev_mod_scatter_server() is not reactive\n\n\n\nHere we can see data_fun() is not a reactive (it’s a standard function)."
  },
  {
    "objectID": "values_vs_data.html#tests",
    "href": "values_vs_data.html#tests",
    "title": "22  Values vs. data",
    "section": "22.3 Tests",
    "text": "22.3 Tests\nIf you decide to use reactiveValues() or session$userData, you’ll need to confirm these objects in your tests.\n\n22.3.1 Example: testing reactiveValues()\nThe module tests for test-mod_scatter_display.R had to be redesigned to handle the reactiveValues() input. You can view the full test file in this branch, but to briefly summarize:\n\nargs = list() in testServer() now takes the output from helper functions (stored in tests/testthat/helper.R and R/testthat.R). 7\n\nmake_initial_rVals_inputs &lt;- function() {\n  rVals &lt;- reactiveValues(\n    inputs =\n      reactive(list(\n        x = \"imdb_rating\",\n        y = \"audience_score\",\n        z = \"mpaa_rating\",\n        alpha = 0.5,\n        size = 2,\n        plot_title = \"Enter Plot Title\"\n      ))\n  )\n  return(rVals)\n}\n\n\nThis creates a reaciveValues() list that can be used in the test:\n\n\nrVals &lt;- make_initial_rVals_inputs()\nrVals\n## &lt;ReactiveValues&gt; \n##   Values:    inputs \n##   Readonly:  FALSE\n\n\nWe can view it’s contents by wrapping it in isolate().\n\n\nisolate(rVals$inputs())\n## $x\n## [1] \"imdb_rating\"\n## \n## $y\n## [1] \"audience_score\"\n## \n## $z\n## [1] \"mpaa_rating\"\n## \n## $alpha\n## [1] 0.5\n## \n## $size\n## [1] 2\n## \n## $plot_title\n## [1] \"Enter Plot Title\"\n\n\nWhen make_initial_rVals_inputs() is passed to the args in testServer(), it looks like this:\n\n\n    shiny::testServer(app = mod_scatter_display_server,\n      args = list(rVals = make_initial_rVals_inputs()), expr = {\n        testthat::expect_equal(\n          object = rVals$inputs(),\n          expected = list(\n                x = \"imdb_rating\",\n                y = \"audience_score\",\n                z = \"mpaa_rating\",\n                alpha = 0.5,\n                size = 2,\n                plot_title = \"Enter Plot Title\"\n            )\n        )\n      })\n\n\nTests are more difficult for modules using session$userData, because these values are created when a Shiny app object is created (and exist inside the reactive context). This point is covered in more detail in this blog post.\n\n“reusing objects passed through session violates module independence – there is code inside the module that uses external objects without stating them explicitly as server arguments.”"
  },
  {
    "objectID": "values_vs_data.html#recap",
    "href": "values_vs_data.html#recap",
    "title": "22  Values vs. data",
    "section": "22.4 Recap",
    "text": "22.4 Recap\n\n\n\n\n\n\nRecap: reactiveValues() & session$userData\n\n\n\n\n\n\nsession$userData\n\nsession$userData is best used with values or objects that persist across actions or navigation inside the app (i.e., maintaining values or data across pages of a multi-page app). session$userData can react to changes, but we’d need to explicitly create these reactive expressions or observers.\n\nreactiveValues()\n\nAn object created with reactiveValues() is designed to be reactive, so changing values will trigger reactivity in any observers and/or reactives that depend on those values. Remember that ‘values taken from the reactiveValues() object are reactive, but the reactiveValues() object itself is not.’"
  },
  {
    "objectID": "values_vs_data.html#footnotes",
    "href": "values_vs_data.html#footnotes",
    "title": "22  Values vs. data",
    "section": "",
    "text": "Mastering Shiny also has a great section on reactiveVal() and reactiveValues()↩︎\nThe methods used in this chapter can be found in the chapter on Debugging↩︎\nRead more in the Shiny documentation.↩︎\nWe can access the values by wrapping the assigned object in isolate(). Read more in the documentation on reactiveValues().↩︎\nWe’ll cover how reactiveValues() works in Section 22.1 below.↩︎\nIn this case, con is a URL for a .csv version of ggplot2movies::movies)↩︎\nI resorted to both locations because the tests/testthat/helper.R file wasn’t loading with devtools::load_all()↩︎"
  },
  {
    "objectID": "test_snapshots.html#vdiffr",
    "href": "test_snapshots.html#vdiffr",
    "title": "23  Snapshot tests",
    "section": "23.1 vdiffr",
    "text": "23.1 vdiffr\nThe expect_doppelganger() function from vdiffr is designed specifically to work with ‘graphical plots’.\n\nvdiffr::expect_doppelganger(\n      title = \"name of graph\", \n      fig = # ...code to create graph...\n  )\n\nAnother option for using snapshots for testing is the expect_snapshot_file() function 1 but expect_doppelganger() is probably the better option for comparing graph outputs."
  },
  {
    "objectID": "test_snapshots.html#testing-graph-outputs",
    "href": "test_snapshots.html#testing-graph-outputs",
    "title": "23  Snapshot tests",
    "section": "23.2 Testing graph outputs",
    "text": "23.2 Testing graph outputs\nThe Feature for the initial graph output from scatter_plot() might look like:\n\ntestthat::describe(\n  \"Feature: Scatter Plot Configuration in Movie Review Application\n    As a user who accesses the movie review application,\n    I want the initial scatter plot pre-configured with variables and aesthetics,\n    So that I can immediately see a meaningful visualization.\", code = {\n    \n})\n\nCombining scenarios in the same test file is helpful if we’re trying to keep a 1:1 between the test/testthat/ file names and file names in R/.2\n\n1testthat::it(\n  \"Scenario: Create scatter plot\n      Given I have launched the movie review exploration app,\n      When the scatter plot renders,\n      Then the points on the x axis should represent 'Ratings'\n      And the points on the y axis should represent 'Length'\n      And the points should be colored by 'MPAA' rating\n      And the opacity of the points should be set to '0.5'\n      And the size of the points should be set to '2'\n      And the plot title should be set to 'Enter plot title'\",\n  code = {\n    \n2    test_logger(\n      start = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n\n3    scatter_inputs &lt;- list(\n      x = \"imdb_rating\",\n      y = \"audience_score\",\n      z = \"mpaa_rating\",\n      alpha = 0.5,\n      size = 2,\n      plot_title = \"Enter plot title\"\n    )\n\n4    vdiffr::expect_doppelganger(\n      title = \"Initial x y z axes\",\n      fig = scatter_plot(movies,\n        x_var = scatter_inputs$x,\n        y_var = scatter_inputs$y,\n        col_var = scatter_inputs$z,\n        alpha_var = scatter_inputs$alpha,\n        size_var = scatter_inputs$size\n      ) +\n        ggplot2::labs(\n          title = scatter_inputs$plot_title,\n          x = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$x\n            ), \"_\", \" \"\n          ),\n          y = stringr::str_replace_all(\n            tools::toTitleCase(\n              scatter_inputs$y\n            ), \"_\", \" \"\n          )\n        ) +\n        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    )\n\n5    test_logger(\n      end = \"snap scatter_plot()\", \n      msg = \"initial x,y,z,size,alpha\")\n    \n  }\n)\n\n\n1\n\nTest scope\n\n\n2\n\nLog start\n\n\n3\n\nInitial movies variable inputs for x, y, and z from UI\n\n\n4\n\nSnapshot with initial values\n\n\n5\n\nLog end\n\n\n\n\nTest results also return the output from test_logger() with the context I’ve added on what’s being tested.\n\n23.2.1 Snapshots\nWe also see a warning when the snapshot has been saved in the tests/testthat/_snaps/ folder the first time the test is run:\n── Warning (test-scatter_plot.R:124:9): \n      Scenario: Create scatter plot\n          Given I have launched the movie review exploration app,\n          When the scatter plot renders,\n          Then the points on the x axis should represent 'Ratings'\n          And the points on the y axis should represent 'Length'\n          And the points should be colored by 'MPAA' rating\n          And the size of the points should be set to '2'\n          And the opacity of the points should be set to '0.5' ──\nAdding new file snapshot: 'tests/testthat/_snaps/initial-x-y-z-axes.svg'\n\n── Warning (test-scatter_plot.R:186:7): \n      Scenario: Change x, y, color values for plotting\n        When I launch the Scatter Plot Data Visualization\n        And I select the variable 'Audience Score' for the x-axis\n        And I select the variable 'IMDB Rating' for the y-axis\n        And I select the variable 'Critics Rating' for the color\n        Then the scatter plot should show 'Audience Score' on the x-axis\n        And the scatter plot should show 'IMDB Rating' on the y-axis\n        And the points on the scatter plot should be colored by 'Critics Rating' ──\nAdding new file snapshot: 'tests/testthat/_snaps/updated-x-y-color.svg'\n[ FAIL 0 | WARN 2 | SKIP 0 | PASS 2 ]\nOn subsequent runs, this warning will disappear (as long as there are no changes to the .svg files).\nINFO [2023-10-27 10:58:25] [ START snap scatter_plot() = initial x,y,z,size,alpha]\n[ FAIL 0 | WARN 1 | SKIP 0 | PASS 3 ]\nINFO [2023-10-27 10:58:25] [ END snap scatter_plot() = initial x,y,z,size,alpha]\n\n\n\n\n\n\nReviewing snapshots\n\n\n\n\n\n\nPlacing the functional requirement in the title argument of expect_doppelganger() gives us a clear idea of what the snapshot file should contain.\n\n\n\n\n\n\n23.2.2 Comparing graph objects\nBelow is the output from diffobj::diffObj() comparing our custom plotting function (scatter_plot()) against a graph built with analogous ggplot2 code:\n\nggp_graph &lt;- ggplot2::ggplot(mtcars, \n              ggplot2::aes(x = mpg, y = disp)) + \n              ggplot2::geom_point(\n                ggplot2::aes(color = cyl), \n                             alpha = 0.5, \n                             size = 3)\n  \napp_graph &lt;- scatter_plot(mtcars, \n                  x_var = \"mpg\", \n                  y_var = \"disp\", \n                  col_var = \"cyl\", \n                  alpha_var = 0.5, \n                  size_var = 3)\n\ndiffobj::diffObj(ggp_graph, app_graph)\n\n\n\n\n\n\n\ndiffobj::diffObj() on graph outputs\n\n\nFigure 23.1: Graph objects are difficult to use as test objects\n\n\n\nThe output shows us all the potential points of failure when comparing complex objects like graphs (despite the actual outputs appearing identical), so it’s best to limit the number of ‘visual unit tests’ unless they’re absolutely necessary."
  },
  {
    "objectID": "test_snapshots.html#recap",
    "href": "test_snapshots.html#recap",
    "title": "23  Snapshot tests",
    "section": "23.3 Recap",
    "text": "23.3 Recap\nI’ve included additional snapshot tests (test-text_logo.R) in the 23_tests-snapshots branch of moviesApp:\ntests/testthat/\n    ├── test-scatter_plot.R\n    └── test-text_logo.R\n\n\n\n\n\n\nRecap: graph snapshots\n\n\n\n\n\n\nvdiffr\nCreate graph snapshots with the expect_doppelganger() function from vdiffr\nSnapshots are brittle\nAs stated before, snapshots are brittle and can produce false negatives test failures (i.e., due to inconsequential changes in the graph) when comparing a new graph to the baseline image."
  },
  {
    "objectID": "test_snapshots.html#footnotes",
    "href": "test_snapshots.html#footnotes",
    "title": "23  Snapshot tests",
    "section": "",
    "text": "Follow the expect_snapshot_file() example from the testthat documentation↩︎\nmatching files names between R/ and tests/testthat/ keeps our code organized and ensures the devtools::test_coverage_active_file() function works.↩︎"
  },
  {
    "objectID": "test_mocks.html#example-mocking-add-on-functions",
    "href": "test_mocks.html#example-mocking-add-on-functions",
    "title": "24  Test mocks",
    "section": "24.1 Example: mocking add-on functions",
    "text": "24.1 Example: mocking add-on functions\nWe’ll use local_mocked_bindings() from testthat to mock the behavior of rlang::is_installed().2 Instead of real-time computations, mocks return predefined responses to given inputs. Consider the check_installed() function below:\n\ncheck_installed &lt;- function(package) {\n  if (is_installed(package)) {\n    return(invisible())\n  } else {\n    stop(\"Please install '{package}' before continuing\")\n  }\n}\n\nBelow is a feature description for check_installed() and two scenarios for each expected behavior:\nFeature: Checking if an R package is installed\n\n  Scenario: Checking an installed package\n    Given the R package 'base' is installed\n    When I call the `check_installed()` function with 'base'\n    Then the function should return without any error\n\n  Scenario: Checking an uninstalled package\n    Given the R package 'foo' is not installed\n    When I call the `check_installed()` function with 'foo'\n    Then the function should raise an error with the message\n      `Please install 'nonexistent_package' before continuing`\nThe check_installed() shouldn’t be confused with rlang::check_installed(), which checks if a package is installed, and if it isn’t, prompts the user install the package using pak::pkg_install().\nLets review how is_installed() behaves with installed and missing packages:\n\nrlang::is_installed('foo')\n## [1] FALSE\nrlang::is_installed('base')\n## [1] TRUE\n\nThe version of check_installed() in moviesApp will check if a package is installed and return invisible() if it is (which, when assigned to an object, evaluates to NULL):\n\ncheck_installed('base')\n\n\nx &lt;- check_installed('base')\nx\n## NULL\n\nIf the package is not installed, check_installed() prints an error message:\n\ncheck_installed('foo')\n## Error in check_installed(\"foo\"): Please install '{package}' before continuing\n\nTo use mocking with is_installed(), we’ll use the following syntax:\nlocal_mocked_bindings(\n  {local function} = function(...) {value}\n)\nIn this case, {local function} is is_installed() from rlang, and we want to test the two possible {value}s (TRUE/FALSE).\nIn the first test, we’ll use expect_error() to confirm that the error message is returned for an uninstalled package by using local_mocked_bindings() and setting the is_installed() value to FALSE:\n\ndescribe(\"Feature: Checking if an R package is installed\", {\n  \n  test_that(\n    \"Scenario: Checking an uninstalled package\n        Given the R package 'foo' is not installed\n        When I call the `check_installed()` function with 'foo'\n        Then the function should raise an error with the message\n        `Please install 'nonexistent_package' before continuing`\", {\n          \n1    test_logger(start = \"mock is_installed\", msg = \"FALSE\")\n2    local_mocked_bindings(is_installed = function(package) FALSE)\n3    expect_error(object = check_installed(\"foo\"))\n    test_logger(end = \"mock is_installed\", msg = \"FALSE\")\n    \n  })\n  \n})\n\n\n1\n\nLog test start and end\n\n2\n\nSet {value} to FALSE\n\n\n3\n\nPass a package we know is not installed\n\n\n\n\nTo test installed packages, we’ll confirm check_installed('foo') with expect_invisible():\n\ndescribe(\"Feature: Checking if an R package is installed\", {\n  \n  test_that(\n    \"Scenario: Checking an installed package\n        Given the R package 'base' is installed\n        When I call the `check_installed()` function with 'base'\n        Then the function should return without any error\", {\n          \n1    test_logger(start = \"mock is_installed\", msg = \"TRUE\")\n2    local_mocked_bindings(is_installed = function(package) TRUE)\n3    expect_invisible(check_installed(\"base\"))\n    test_logger(end = \"mock is_installed\", msg = \"TRUE\")\n    \n  })\n})\n\n\n1\n\nLog test start and end\n\n2\n\nSet {value} to TRUE\n\n\n3\n\nPass a package we know is installed\n\n\n\n\nThe output from the tests above is provided below:\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 0 ]\nINFO [2023-10-08 22:59:43] [ START mock is_installed = FALSE]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]\nINFO [2023-10-08 22:59:43] [ END mock is_installed = FALSE]\n\nINFO [2023-10-08 22:59:43] [ START mock is_installed = TRUE]\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 2 ]\nINFO [2023-10-08 22:59:43] [ END mock is_installed = TRUE]\n\n24.1.0.1 Notes on mocking\nThe roxygen2 documentation for check_installed() uses the @importFrom tag to import is_installed and add it to the moviesApp namespace (using explicit namespacing alone won’t work):\n\n#' Check if package is installed\n#' \n#' @description\n#' An example function for demonstrating how to use `testthat`'s\n#' mocking functions.\n#' \n#' @param package string, name of package\n#'\n#' @return invisible \n#'\n1#' @importFrom rlang is_installed\n#'\n#' @export\n#'\n#' @examples\n#' check_installed(\"foo\")\n#' check_installed(\"base\")\n\n\n1\n\nFortunately we already included rlang in our DESCRIPTION file for .data in scatter_plot()\n\n\n\n\nUsing testthat’s mocking functions allow us to craft unit tests that evaluate a single, specific behavior. Read more about mocking functions on the testthat webite."
  },
  {
    "objectID": "test_mocks.html#footnotes",
    "href": "test_mocks.html#footnotes",
    "title": "24  Test mocks",
    "section": "",
    "text": "Test mocking functions are a relatively new addition to testthat. Read more in the recent updates to testthat↩︎\nThis example comes from the package development masterclass workshop at posit::conf(2023).↩︎"
  },
  {
    "objectID": "css.html",
    "href": "css.html",
    "title": "25  CSS",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience.\n\n\n\n\nend css.qmd"
  },
  {
    "objectID": "js.html",
    "href": "js.html",
    "title": "26  JavaScript",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience.\n\n\n\n\nend js.qmd"
  },
  {
    "objectID": "glossary.html#footnotes",
    "href": "glossary.html#footnotes",
    "title": "Appendix A — Glossary of terms",
    "section": "",
    "text": "App-packages are covered in Mastering Shiny and Engineering Production-Grade Shiny Apps↩︎\nExternal resources/files are covered in the Shiny documentation and in Engineering Production-Grade Shiny Apps↩︎\nModules are also part of the box package from the rhino framework, but these are different from Shiny modules.↩︎\nShiny modules are covered in the Shiny documentation, Mastering Shiny, and in Engineering Production-Grade Shiny Apps↩︎\nPackages are covered in Writing R Extensions and R Packages, 2ed↩︎\nRead more about R projects on the Posit website↩︎\nStandalone app functions are also covered in Mastering Shiny.↩︎\nUtility/helper function are covered in Mastering Shiny and Engineering Production-Grade Shiny Apps↩︎"
  },
  {
    "objectID": "github.html#projapp",
    "href": "github.html#projapp",
    "title": "Appendix B — GitHub",
    "section": "B.1 projApp",
    "text": "B.1 projApp\nThe projApp repo is a shiny application built outside of a package structure. It was initially created using the New Project Wizard (with a Git repo initialized).\nIf you’re new to GitHub, the steps below will walk you through setting up Git and GitHub from RStudio using the Git pane. The initial files in the project are below:\nprojApp/\n  ├── app.R\n  └── projApp.Rproj\n\n1 directory, 2 files\nAfter creating the project, head over to GitHub and create am empty repo. You’ll see the following options:\n\n\n\n\n\n\n(a) New repository on GitHub\n\n\nFigure B.1: Empty GitHub repository options\n\n\n\nWe’re interested in the second option, “…push an existing repository from the command line”, but we’re going to use Posit Workbench’s Git pane.\n\nB.1.1 Commit\nCommit these initial changes to the repo using the Commit icon in the Git pane\n\n\n\n\n\n(a) Commit changes\n\n\n\n\n\n(b) First commit\n\n\nFigure B.2: Click on Commit to open the Git window. Stage all the files, add a commit message, and click Commit\n\n\nAdd a commit message and click Commit. This is the equivalent of entering the following commands in the Terminal:\ngit commit -m 'first commit'\n\n\n\n\n\n\nCommit changes in your repository with a specific message\n\n\n\n\n\n\ngit commit -m 'first commit'\n\ngit commit: This command captures a snapshot of the changes in your project’s tracked files and directories. By committing, you’re saving the current state of those files in the Git repository.\n-m: This flag indicates that a commit message will be provided directly from the command line.\n'first commit': This is the commit message associated with this commit. Commit messages are useful for documenting the changes you’ve made, making it easier for others (and your future self) to understand the evolution and purpose of changes in the project.\n\nWhen you run git commit -m 'first commit', you are committing your staged changes (i.e., changes you’ve previously added to the staging area using git add) with the message ‘first commit’.\nThis message is then stored in the Git history, allowing anyone who looks at the commit logs to see a brief description of what was done in that particular commit.\n\n\n\n\nReview the output from the commit.\n\n\n\n\n\n(a) First commit output\n\n\nFigure B.3: The .gitignore, app.R, and moviesApp.Rproj files have been committed to main\n\n\nThis shows the contents of projApp are part of the main branch. Now we need to make sure the local branch has a remote (on GitHub at https://github.com/&lt;username&gt;/moviesApp.git).\n\n\n\n\n\n\nRename the currently checked-out branch to main\n\n\n\n\n\n\nThe command git branch -M main is used to rename the currently checked-out branch to main.\nHere’s a breakdown of the command:\n\ngit branch: This command without any arguments would list all the local branches in the current repository. But, with certain options (like -M), you can perform other branch-related operations.\n-M: This option stands for ‘move/rename’ and forcibly renames the branch. If a branch named main already exists, it will be overwritten because of the forceful nature of the -M option. If you want to avoid accidentally overwriting an existing branch, you could use -m (lowercase) instead. The lowercase -m will rename only if the target name doesn’t already exist.\nmain: This is the new name for the currently checked-out branch.\n\nThe command became more common after the industry started transitioning from using master to main as the default branch name for new repositories. Running git branch -M main is a way to rename the master branch to main in existing repositories.\n\n\n\n\n\n\nB.1.2 Adding remotes\nClick the New Branch icon in the Git pane and create a new main branch. Then click on Add Remote… and name the remote origin.\n\n\n\n\n\n(a) Add branch and remote name\n\n\n\n\n\n(b) Add remote URL\n\n\nFigure B.4: Create new main branch to track origin\n\n\nThe Remote URL is the link from the Quick Setup above. After clicking Add and Create, you’ll be asked to checkout or overwrite the existing main branch. In this case, we can select Overwrite (because we’re already on the main branch).\n\n\n\n\n\n\nAdd a new remote to your Git repository\n\n\n\n\n\n\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n\ngit remote: used to manage and set remotes (‘remote repositories’) for your project\nadd: specifies that you want to add a new remote.\norigin: a convention widely used in the Git community is to name the primary remote repository origin.\nhttps://github.com/&lt;username&gt;/&lt;repo&gt;.git: This is the URL to the Git repository (hosted on GitHub). Replace &lt;username&gt; with the GitHub username of the repository owner and &lt;repo&gt; with the name of the repository.\n\nSo, when you run this command, you’re telling Git: ‘I want to add a new remote called origin, and the URL for this remote is https://github.com/&lt;username&gt;/&lt;repo&gt;.git'.’\nAfter executing this command, you can then push to and pull from the repository using this remote by referring to its name (origin). For instance, git push origin master would push your local master branch to the master branch on the origin remote.\n\n\n\n\n\n\n\n\n\n(a) Overwrite main\n\n\n\n\n\n(b) branch main set up to track origin/main\n\n\nFigure B.5: main will now track the remote (origin)\n\n\n\n\n\n\n\n\nPush a local branch (main) to a remote (origin), and set local branch to track remote branch\n\n\n\n\n\n\ngit push -u origin main\n\ngit push: used to push commits from your local repository to a remote repository.\norigin: name of the remote repository you want to push to. When you clone a repo or add a remote using git remote add, it’s common to name the main remote origin (though it could technically be any name).\nmain: name of the branch you’re pushing to the remote repository.\n-u or --set-upstream: When this option is used, it sets a tracking relationship between the local and upstream remote branches. This means that in the future, using git pull or git push doesn’t require specifying the remote or branch (Git will know you’re referring to the origin/main branch).\n\nIn essence, git push -u origin main is saying: ‘Push my ’main’ branch to the ‘origin’ remote, and also set my local ‘main’ branch to track the ‘main’ branch on ‘origin’.\nThe common workflow for setting up Git from the command line is below:\n# make changes \ngit add .\ngit commit 'first commit'\n# set remote on GitHub\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n# rename the current branch to main\ngit branch -M main\n# push and set upstream to origin (remote)\ngit push -u origin main"
  },
  {
    "objectID": "create.html#can-an-.rproj-file-convert-an-r-project-into-an-r-package",
    "href": "create.html#can-an-.rproj-file-convert-an-r-project-into-an-r-package",
    "title": "Appendix C — Packages FAQ",
    "section": "C.1 Can an .Rproj file convert an R project into an R package?",
    "text": "C.1 Can an .Rproj file convert an R project into an R package?\nThe technical answer is no, because the .Rproj only activates the Build pane in the IDE. The tools in the Build pane are directly connected to the devtools package (hence the PackageUseDevtools: Yes in the .Rproj file).\nThe seven mandatory fields are required in the DESCRIPTION to have a functioning R package."
  },
  {
    "objectID": "create.html#i-have-a-description-file-with-the-required-fields-but-where-is-the-build-pane",
    "href": "create.html#i-have-a-description-file-with-the-required-fields-but-where-is-the-build-pane",
    "title": "Appendix C — Packages FAQ",
    "section": "C.2 I have a DESCRIPTION file with the required fields, but where is the Build pane?",
    "text": "C.2 I have a DESCRIPTION file with the required fields, but where is the Build pane?\nIf the mandatory fields are added to the DESCRIPTION, but the .Rproj file doesn’t have any of the package configuration fields, then the Build pane will not be displayed (see example below):\n\n\n\n\n\n(a) Build pane tools\n\n\nFigure C.1: Mandatory DESCRIPTION fields with package configuration in .Rproj file"
  },
  {
    "objectID": "create.html#what-if-my-.rproj-file-is-configured-to-work-with-a-package-but-my-description-file-is-missing-one-or-more-of-the-required-fields",
    "href": "create.html#what-if-my-.rproj-file-is-configured-to-work-with-a-package-but-my-description-file-is-missing-one-or-more-of-the-required-fields",
    "title": "Appendix C — Packages FAQ",
    "section": "C.3 What if my .Rproj file is configured to work with a package, but my DESCRIPTION file is missing one (or more) of the required fields?",
    "text": "C.3 What if my .Rproj file is configured to work with a package, but my DESCRIPTION file is missing one (or more) of the required fields?\nSetting the Project build tools in your Project Options is insufficient to convert a project into a package. If the .Rproj file has the package development fields (i.e., Project build tools to Package) but the mandatory fields are missing from the DESCRIPTION file, the Build pane will be triggered:\n\n\n\n\n\n(a) DESCRIPTION\n\n\nFigure C.2: Unchanged DESCRIPTION file after changing .Rproj\n\n\nBut trying to load the code in the R/ folder with Build &gt; Load All (or devtools::load_all()) we return the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n(a) Build pane tools\n\n\nFigure C.3: Attempt to load_all() code in R/ folder\n\n\nThe directory must include a DESCRIPTION file containing the mandatory fields and an .Rproj file with the package configuration fields listed above to be a functional R package.\nRead more about DESCRIPTION file fields in R Packages, 2ed\n\n\n\n\n\n\nRStudio project files\n\n\n\n\n\n\nYou can read more about the benefits of using RStudio projects to configuring project-level options here."
  },
  {
    "objectID": "create.html#i-have-the-mandatory-fields-in-my-.rproj-file-and-description-but-still-no-build-pane",
    "href": "create.html#i-have-the-mandatory-fields-in-my-.rproj-file-and-description-but-still-no-build-pane",
    "title": "Appendix C — Packages FAQ",
    "section": "C.4 I have the mandatory fields in my .Rproj file and DESCRIPTION, but still no Build pane?",
    "text": "C.4 I have the mandatory fields in my .Rproj file and DESCRIPTION, but still no Build pane?\nTo get the IDE to re-read the .Rproj file, you might have to terminate the session (Session &gt; Terminate R… &gt; Yes)\n\n\n\n\n\n\n\n(a) Session &gt; Terminate\n\n\n\n\n\n\n\n(b) Click Yes\n\n\n\n\nFigure C.4: Terminate your R session\n\n\nThis prompts the IDE to re-read the .Rproj file and trigger the Build pane."
  },
  {
    "objectID": "dependency_trees.html#trees",
    "href": "dependency_trees.html#trees",
    "title": "Appendix D — Dependency lookup",
    "section": "D.1 Trees",
    "text": "D.1 Trees\npak::pkg_deps_tree() shows us the dependencies for a particular package. To demonstrate how this function works, we’ll explore the dependencies in three packages:\n\nrlang: “Functions for Base Types and Core R and ‘Tidyverse’ Features”\nlifecycle: “Manage the Life Cycle of your Package Functions”, and\nvctrs: “Vector Helpers”\n\nLet’s start with the rlang package:\n\npak::pkg_deps_tree(\"rlang\")\n\nrlang 1.1.1 ✨\n\nKey:  ✨ new\nrlang is “a collection of frameworks and APIs for programming with R” and it’s built with only base R packages (that’s why it’s DESCRIPTION file only Imports the utils package):\nImports:\n    utils\nNow lets look at lifecycle:\n\npak::pkg_deps_tree(pkg = \"lifecycle\")\n\nlifecycle 1.0.3 ✨ ⬇ (123.60 kB)               \n├─cli 3.6.1 ✨\n├─glue 1.6.2 ✨\n└─rlang 1.1.1 ✨\nlifecycle depends on cli, glue, and rlang.\n\ncli: “Helpers for Developing Command Line Interfaces”\nglue: “Interpreted String Literals”\n\nIf we look at the DESCRIPTION file for lifecycle, it also imports cli, glue, and rlang (and specifies versions for cli and rlang)\nImports:\n    cli (&gt;= 3.4.0),\n    glue,\n    rlang (&gt;= 1.1.0)\nFinally, lets look at the dependencies in the vctrs package. The DESCRIPTION file for vctrs imports cli, glue, lifecycle, and rlang\nImports:\n    cli (&gt;= 3.4.0),\n    glue,\n    lifecycle (&gt;= 1.0.3),\n    rlang (&gt;= 1.1.0)\nIf we check the dependency tree, we see the cli, glue, and rlang are listed twice (once for vctrs, and again for lifecycle):\n\npak::pkg_deps_tree(pkg = \"vctrs\")\n\nvctrs 0.6.4 ✨                               \n├─cli 3.6.1 ✨\n├─glue 1.6.2 ✨\n├─lifecycle 1.0.3 ✨ ⬇ (123.60 kB)\n│ ├─cli\n│ ├─glue\n│ └─rlang 1.1.1 ✨\n└─rlang\n\nKey:  ✨ new |  ⬇ download\nvctrs depends on cli, glue, rlang, and lifecycle (which also depends on cli, glue, and rlang)"
  },
  {
    "objectID": "dependency_trees.html#explaining-dependencies",
    "href": "dependency_trees.html#explaining-dependencies",
    "title": "Appendix D — Dependency lookup",
    "section": "D.2 Explaining dependencies",
    "text": "D.2 Explaining dependencies\nWe can show dependency relationships with pak::pkg_deps_explain():\nHow does lifecycle depend on rlang?\n\npak::pkg_deps_explain(\"lifecycle\", \"rlang\")\n\nlifecycle -&gt; rlang \nHow does vctrs depend on rlang?\n\npak::pkg_deps_explain(\"vctrs\", \"rlang\")\n\nvctrs -&gt; lifecycle -&gt; rlang                                    \nvctrs -&gt; rlang\nvctrs directly depends on rlang and lifecycle (which also depends on rlang)."
  },
  {
    "objectID": "dependency_trees.html#case-study-devtools",
    "href": "dependency_trees.html#case-study-devtools",
    "title": "Appendix D — Dependency lookup",
    "section": "D.3 Case study: devtools",
    "text": "D.3 Case study: devtools\nThe conscious uncoupling of devtools split package development across multiple packages. Let’s see how this works, starting with the commonly used devtools function load_all()\n\nD.3.1 pkgload\nload_all() is handled by the pkgload package, which “Simulate[s] Package Installation and Attach”.\nHow does devtools depend on pkgload?\n\npak::pkg_deps_explain(\"devtools\", \"pkgload\")\n\ndevtools -&gt; pkgload                                            \ndevtools -&gt; roxygen2 -&gt; pkgload\ndevtools -&gt; testthat -&gt; pkgload\nThis relationship shows the three actions that call load_all() during package development:\n\ndevtools::load_all() actually calls pkgload::load_all()\ndevtools::document() and devtools::test() also call pkgload::load_all()\n\n\npak::pkg_deps_explain(\"devtools\", \"roxygen2\")\n\ndevtools -&gt; roxygen2\n\npak::pkg_deps_explain(\"devtools\", \"testthat\")\n\ndevtools -&gt; testthat \n\n\nD.3.2 Depends\nHow does devtools depend on usethis?\n\npak::pkg_deps_explain(\"devtools\", \"usethis\")\n\ndevtools -&gt; usethis\nIn the DECRIPTION file for devtools, usethis is listed under Depends:\nDepends: \n    usethis (&gt;= 2.1.6)"
  },
  {
    "objectID": "stack_traces.html",
    "href": "stack_traces.html",
    "title": "Appendix E — Stack traces",
    "section": "",
    "text": "Alert\n\n\n\n\n\n\nThe contents for section are being revised. Thank you for your patience."
  },
  {
    "objectID": "bdd.html#specifying-behaviors",
    "href": "bdd.html#specifying-behaviors",
    "title": "Appendix F — Behavior-driven development",
    "section": "F.1 Specifying behaviors",
    "text": "F.1 Specifying behaviors\nBDD uses a specific format for translating application behavior into into features. These ‘user stories’ are typically written in the Gherkin language and include the following sections:\nFeature: title of feature\n  \n  As a ...\n  I want ...\n  So that ...\n  \n  Scenario 1:\n    When ... \n    And ... \n    Then ...\n    \n  Scenario 2:\n    When ... \n    And ... \n    Then ...\nThe testthat BDD functions can be adapted to use this format, because the description argument a text string and these functions can be nested.\n\ntestthat::describe(description = \"\n  Feature: Scatter Plot Data Visualization\n\n  As a film analyst\n  I want to visualize data on a scatter plot with various inputs\n  So that I can analyze relationships between variables and groups in a customizable way.\n\n  Background:\n    Given the Shiny app is launched\n    And I have a dataset available with continuous and categorical variables\n  \", code = {\n    \n\n  testthat::describe(description = \"\n  Scenario: Select x and y continuous variables for plotting\n    When I select the variable 'input$x' for the x-axis\n    And I select the variable 'input$y' for the y-axis\n    Then the scatter plot should show 'input$x' on the x-axis\n    And 'input$y' on the y-axis\n    \", code = {\n      \n    })\n    \n  })"
  },
  {
    "objectID": "comparisons.html#footnotes",
    "href": "comparisons.html#footnotes",
    "title": "Appendix G — Comparisons",
    "section": "",
    "text": "Be mindful of the difference in arguments between expectation functions (i.e., expect_equal()) and waldo::compare()↩︎\nThe results from testthat don’t include the differences between old$num and new$num. This is due to the tolerance argument, which can be adjusted in both functions.↩︎"
  },
  {
    "objectID": "rhino_cicd.html#trigger",
    "href": "rhino_cicd.html#trigger",
    "title": "Appendix H — Rhino CI/CD",
    "section": "H.1 Trigger",
    "text": "H.1 Trigger\nThe .github/workflows/rhino-test.yml file runs on pushes to the repo containing a rhino app.\nname: Rhino Test\non: push"
  },
  {
    "objectID": "rhino_cicd.html#permissions",
    "href": "rhino_cicd.html#permissions",
    "title": "Appendix H — Rhino CI/CD",
    "section": "H.2 Permissions",
    "text": "H.2 Permissions\nThe workflow only has read permission for the repository. Read more about setting permissions here.\npermissions:\n  contents: read"
  },
  {
    "objectID": "rhino_cicd.html#jobs",
    "href": "rhino_cicd.html#jobs",
    "title": "Appendix H — Rhino CI/CD",
    "section": "H.3 Jobs",
    "text": "H.3 Jobs\nrhino-test.yml contains a single job named main with the following steps:\njobs:\n  main:\n    name: Run linters and tests\n    runs-on: ubuntu-20.04\n    env:\n      R_VERSION: '4.1.0'\n      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}\n\nH.3.1 Step: Checkout Code, R version, Dependencies\nChecks out the code using actions/checkout@v2, extracts the R version from a lockfile (renv.lock) and sets it as an environment variable (env.R_VERSION), and uses apt-get to install system dependencie (libcurl4-openssl-dev)\n    steps:\n      - name: Checkout repo\n        uses: actions/checkout@v2\n\n      - name: Setup R\n        uses: r-lib/actions/setup-r@v1\n        with:\n          r-version: ${{ env.R_VERSION }}\n\n      - name: Setup system dependencies\n        run: &gt;\n          sudo apt-get update && sudo apt-get install --yes\n          libcurl4-openssl-dev\n\n\nH.3.2 Step: Restore and sync renv\nThe R dependencies in renv.lock are restored from cache with actions/cache@v2, then the R environment is synchronized with the lockfile (ensuring all necessary R packages are installed).\n\n      - name: Restore renv from cache\n        uses: actions/cache@v2\n        env:\n          CACHE_KEY: renv-${{ runner.arch }}-${{ runner.os }}-${{ env.R_VERSION }}\n        with:\n          path: renv/library\n          key: ${{ env.CACHE_KEY }}-${{ hashFiles('renv.lock') }}\n          restore-keys: ${{ env.CACHE_KEY }}-\n          \n      - name: Sync renv with lockfile\n        shell: Rscript {0}\n        run: |\n          options(renv.config.cache.symlinks = FALSE)\n          renv::restore(clean = TRUE)\n\n\nH.3.3 Step: Node.js\nThe Node.js environment is set up with version 16.\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: 16\n\n\nH.3.4 Step: Linters\nLints R (rhino::lint_r()), JavaScript (rhino::lint_js()), and Sass (rhino::lint_sass()) code for quality and style consistency.\n      - name: Lint R\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_r()\n\n      - name: Lint JavaScript\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_js()\n\n      - name: Lint Sass\n        if: always()\n        shell: Rscript {0}\n        run: rhino::lint_sass()\n\n\nH.3.5 Step: Unit Tests\nExecutes testthat unit tests written in R (rhino::test_r())\n      - name: Run R unit tests\n        if: always()\n        shell: Rscript {0}\n        run: rhino::test_r()\n\n\nH.3.6 Step: Cypress End-to-End Tests\nSpecifies the working directory .rhino/, starting command for the application (npm run run-app), project directory for tests (../tests), URL to wait for ('http://localhost:3333/'), and a timeout for waiting (60) for Cypress to run end-to-end tests.\n      - name: Run Cypress end-to-end tests\n        if: always()\n        uses: cypress-io/github-action@v5\n        with:\n          working-directory: .rhino # Created by earlier commands which use Node.js\n          start: npm run run-app\n          project: ../tests\n          wait-on: 'http://localhost:3333/'\n          wait-on-timeout: 60"
  }
]