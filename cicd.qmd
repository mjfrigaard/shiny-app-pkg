# CI/CD {#sec-cicd}


```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(testthat)
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", 
  look = "minimal",
  header = "Alert",
  contents = "The contents for section are being developed. Thank you for your patience."
)
```

Continuous Integration (CI) and Continuous Deployment (CD) help automate software development aspects, especially testing and deployment. In the context of a Shiny app-package, CI/CD usually refers to GitHub Actions or Travis CI.[^no-travis-ci]

[^no-travis-ci]: This chapter will only cover CI/CD with GitHub Actions. Travis-CI has been around longer than GitHub Actions, and if you'd like to compare the two, I recommend [this article.](https://talent500.co/blog/github-actions-vs-travis-ci-weighing-pros-cons-and-selecting-the-ideal-platform/)

[**Continuous integration**]{style="font-size: 1.30em;"}

1. **Automated Testing**: CI will automatically test changes to the code in your app-package, such as a new feature or bug fix. It's a little bit like having a hyper-vigilant bot checking if everything in your app still works as expected after each change.

2. **Quality Assurance**: CI helps maintain the quality of the code-base by running a series of 'checks and balances' to confirm updates and changes don't break anything. Should something go wrong, CI will alert developers so they can fix it promptly.

3. **Change Management**: CI systems work hand-in-hand with version control systems (like Git). Imagine having a meticulous bookkeeper tracking all of the project changes, making sure every modification gets tested and is safe to be included to the `main` app-package.

[**Continuous deployment**]{style="font-size: 1.30em;"}

1. **Automated Deployment**: Once CI confirms the changes are safe, CD can automatically deploy the updated Shiny app-package to the package management system and Shiny server where it's hosted, which means that the updated version becomes available to its users without any manual intervention.

2. **Consistent Updating**: CD ensures that users experience new features and fixes much faster. As soon as improvements are made and tested, they are deployed, which leads to a more dynamic and responsive development process.

3. **Streamlined Development**: CI and CD streamline the entire software development process. Developers can focus more on developing and less on testing and deploying. Properly implemented CI/CD is like a well-oiled machine, where each part works seamlessly with the others, making the process efficient and reliable.

Implementing CI/CD in your app-package can automate your tests, code quality tasks, and application deployment, which saves time, reduces errors, and ensures that your app-package is always up-to-date and functioning optimally for its users. 

## GitHub Actions

[GitHub Actions](https://github.com/features/actions) (or Actions, for short) is a feature provided by GitHub that enables automation of various development workflows. These workflows are defined in YAML files and can automate some of the repetitive tasks in the development lifecycle, right within a GitHub repository. 

Actions allow us to create custom workflows to automatically build, test, and deploy our code. Workflows can be triggered by a push to a branch, a pull request, a specific time schedule, or another GitHub event. 

```{r}
#| label: git_box_16.1_cicd-style
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '50%', 
  branch = "16.1_cicd-style", 
  repo = 'moviesApp')
```

### Workflow fields

The YAML workflow file configures and defines the automated tasks run in a GitHub repository. Workflow files typically include fields for building, testing, and deploying code and are structured into several key sections:

#### [`on`]{style="font-size: 1.05em; font-weight: bold; font-style: italic;"}

> *"An event is a specific activity in a repository that triggers a workflow run."*

**`on`** defines the [event(s) that trigger](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#events) the workflow. Common triggers include Git `push` and `pull` events to specific branches. The trigger can also be configured to run at scheduled times or other GitHub events (like creating a release or commenting on an issue).

```yaml
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
```


#### [`name`]{style="font-size: 1.05em; font-weight: bold; font-style: italic;"}

`name` is an optional field to specify a name for the workflow. The `name` is used to identify the workflow in the Actions tab of the GitHub repository. If `name` is not provided, GitHub will use the file path. Below are some example workflow names:

```yaml
name: R CI
```

```yaml
name: style
```

```yaml
name: shiny
```

#### [`jobs`]{style="font-size: 1.05em; font-weight: bold; font-style: italic;"}

> *"A job is a set of steps in a workflow that is executed on the same runner."*

The [**`job`**](https://docs.github.com/en/actions/using-jobs) and it's [identifier](https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow#setting-an-id-for-a-job) (`check`) are used to reference the runner, in this example it's `ubuntu-latest`. 

```yaml
jobs:
  check:
    runs-on: ubuntu-latest
```

Occasionally the [`matrix` directive](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs#using-a-matrix-strategy) will be used to run jobs across different operating systems, programming language versions, etc.

#### [`steps`]{style="font-size: 1.05em; font-weight: bold; font-style: italic;"}

> *"Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step."*

`steps` define a series of [tasks or actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps) that the `job` will execute. In this example, the code is checked out (`actions/checkout@v2`), an R environment is set up (`r-lib/actions/setup-r@v2`), and R package dependencies are installed with **`run`**:

```yaml
steps:
    - uses: actions/checkout@v2

    - name: Set up R
      uses: r-lib/actions/setup-r@v2

    - name: Install R dependencies
      run: |
        install.packages('remotes')
        remotes::install_deps(dependencies = TRUE)
      shell: Rscript {0}
      
```

```{r}
#| label: co_box_run_e_rscript_comparison
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "g", 
  fold = TRUE,
  look = "default", 
  hsize = '1.15', 
  size = '1.02',
  header = "What is **`shell: Rscript {0}`**?",
  contents = "
  
\`\`\`yaml
  name: Install packages
  run: |
    pkgs <- c('glue', 'cli')
    install.packages(pkgs)
  shell: Rscript {0}
\`\`\`
  
The command `install.packages(pkgs)` is run as an R script:
  
- `shell` specifies which command-line interpreter (`bash`, `pwsh`, `python`, or `Rscript`) to use for the `run` commands
  
- `Rscript` is the command-line tool provided by R to execute R scripts and commands in a non-interactive environment. 

- `{0}` is a placeholder for the R commands written in the `run` section. 

"
)
```

The final step might include something like `R CMD check` (similar to `devtools::check()`) which would also have `name` and `run` fields: 

```yaml
    - name: Check package
      run: R CMD check . --no-manual
```

#### Comments 

Lines beginning with `#` will not be executed. It's common to provide 1) a reference to the workflow source ([`r-lib/actions`](https://github.com/r-lib/actions/) in this case) and 2) a link for help with debugging build failures.


The first workflow we'll be demonstrating can be used to automate the [code style in an app-package](https://github.com/r-lib/actions/tree/v2/examples#style-package).[^style-coverage]

[^style-coverage]: We'll be covering code styling in the [Code tools](code_tools.qmd) chapter.

### Workflow permissions

In order for workflows to run, we'll need to make sure Actions have read and write permissions. We can do this by clicking on the repository's **Settings** tab, then expand the **Actions** menu and select **General**:

![Repository Action settings](images/gh_action_settings.png){width='100%'}

In the **General** settings, we want to confirm the workflow has **Read and write permissions** permissions (if this needs to be been changed, be sure to click **Save**). 

![Workflow permissions](images/gh_action_permissions.png){width='100%'}

Now our workflows can commit and push changes to the repository.

### [`use_github_action()`]{style="font-size: 0.95em;"}

In R packages, we can set up the GitHub Action infrastructure with `usethis::use_github_action()`. The `name` can be any of the workflow files available at [r-lib/actions](https://github.com/r-lib/actions/?tab=readme-ov-file#list-of-actions).

```{r}
#| code-fold: false
#| eval: false
usethis::use_github_action("style")
```

```{bash}
#| code-fold: false
#| eval: false
#| code-overflow: scroll
✔ Setting active project to '/projects/apps/moviesApp'
✔ Creating '.github/'
✔ Adding '*.html' to '.github/.gitignore'
✔ Creating '.github/workflows/'
✔ Saving 'r-lib/actions/examples/style.yaml@v2' to '.github/workflows/style.yaml'
```

The output tells us a local `.github/workflows/style.yaml` file has been copied from the [`r-lib/actions/examples/style.yaml@v2`](https://github.com/r-lib/actions/blob/v2/examples/style.yml) into the `.github/workflows` folder: 

```{bash}
#| code-fold: false
#| eval: false
.github/
  └── workflows
    └── style.yaml

2 directories, 1 file
```

The documentation for the `.github/workflows/style.yml` file tells us it,

> "*styles the R code in a package, then commits and pushes the changes to the same branch."* 

We'll make one small change to `style.yaml` before pushing it to GitHub. **Instead of having the workflow automatically commit and push the styled code changes to the same branch, we'll limit the code styling to the `16.1_cicd-style` branch:**


```yaml
on:
  push:
    branches: [16.1_cicd-style]
    paths: ["**.[rR]", "**.[qrR]md", "**.[rR]markdown", "**.[rR]nw", "**.[rR]profile"]
```

This change ensures our "Style" workflow will be triggered only for pushes to the specified `branches` (and only when changes are made to files with the specified extensions in `path`). 

After saving these changes to [`.github/workflows/style.yaml`](https://github.com/mjfrigaard/moviesApp/blob/16.1_cicd-style/.github/workflows/style.yaml), we'll add, commit, and push the changes to GitHub, 

```{bash}
#| eval: false 
#| code-fold: false 
git add .
git commit -m "updates to style workflow"
```

```{bash}
#| eval: false 
#| code-fold: false
[16.1_cicd-style 899bd38] updates to style workflow
 4 files changed, 43 insertions(+), 45 deletions(-)
```

```{bash}
#| eval: false 
#| code-fold: false 
git push
```

```{bash}
#| eval: false 
#| code-fold: false 
Enumerating objects: 17, done.
Counting objects: 100% (17/17), done.
Delta compression using up to 12 threads
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 950 bytes | 25.00 KiB/s, done.
Total 9 (delta 6), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (6/6), completed with 6 local objects.
To https://github.com/mjfrigaard/moviesApp.git
   d366e0f..899bd38  16.1_cicd-style -> 16.1_cicd-style
```

If we view the **Actions** tab, we'll see the workflow listed with the name of our commit message: 

![Currently running workflows](images/gh_action_tab.png){width='100%'}

Clicking on the workflow reveals the following: 

![name of running workflow](images/gh_action_details.png){width='100%'}

The **style** widget contains each step in the workflow file. If we click on it we can see each step executed in real-time. Below we can see the dependency lockfile from `pak`:

![**Install dependencies** workflow step running](images/gh_action_dependencies_output.gif){width='100%'}

The actual styling comes is in the **Style** step: 

![**Style**, **Commit and push changes**, **Post install dependencies**, **Post checkout repo**, and **Post Cache Styler** workflow steps running](images/gh_action_style_output.gif){width='100%'}

When the workflow has finished, we can pull the style changes to our local branch and view the styled files:[^rlib-actions-examples] 

[^rlib-actions-examples]: You can find more examples of common GitHub Actions for R packages in [r-lib/actions/examples](https://github.com/r-lib/actions/tree/v2/examples#readme).

```{bash}
#| eval: false 
#| code-fold: false 
git pull
```

```{bash}
#| eval: false 
#| code-fold: false 
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Total 4 (delta 3), reused 4 (delta 3), pack-reused 0
Unpacking objects: 100% (4/4), 450 bytes | 56.00 KiB/s, done.
From https://github.com/mjfrigaard/moviesApp
   899bd38..0ad97cf  16.1_cicd-style -> origin/16.1_cicd-style
Updating 899bd38..0ad97cf
Fast-forward
 R/display_type.R  | 13 +++----------
 R/mod_var_input.R | 30 ++++++++++++++++++++----------
 R/test_logger.R   | 30 ++++++++++--------------------
 3 files changed, 33 insertions(+), 40 deletions(-)
```


## A Shiny workflow

We'll be adapting the example GitHub Action workflow file for [deploying a Shiny application](https://github.com/r-lib/actions/blob/v2/examples/shiny-deploy.yaml). Before we get to the workflow file, we need to address a few settings and configurations that need to take place *outside* of the workflow file. 

```{r}
#| label: git_box_16.2_cicd-shiny
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '50%', 
  branch = "16.2_cicd-shiny", 
  repo = 'moviesApp')
```

### Creating repository secrets

We need to make sure our `rsconnect` secrets are stored with the GitHub repository (so we can access them from within the workflow file). To do this, we're going to return to the **Settings** tab on the `moviesApp` repository, expand **Secrets and variables** under **Security**, and select **Actions**:[^repo-secrets]

[^repo-secrets]: GitHub secrets should be specified by the user following the instructions in the [Creating secrets for a repository](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-a-repository) article.

![**Secrets and variables** for `moviesApp` repository](images/gh_action_secrets_repo.png){width='80%' fig-align='center'}

Use **New repository secret** to create three new secrets: **RSCONNECT_USER**, **RSCONNECT_TOKEN**, and **RSCONNECT_SECRET**. You can access these in your shinyapps.io account:

![**Token** and **Secret** from shinyapps.io](images/gh_action_shinyapps_secrets_token.png){width='100%' fig-align='center'}

When you're finished, should see the following three **Repository secrets**:

![**Repository secrets** in `moviesApp`](images/gh_action_all_repo_secrets.png){width='95%' fig-align='center'}

### Enable private repositories 

We also need to make sure our shinyapps.io account allows us to install from private GitHub repositories during a workflow deployment. We can do this in the **Profile** menu item in our dashboard:

![**Update Authentication** in shinyapps.io profile](images/gh_action_shinyapps_auth.png){width='85%' fig-align='center'}

Clicking **Update Authentication** will open your Posit profile settings, where you can enable private repositories. 

![**Private repo access also enabled**](images/gh_action_shinyapps_private_repos.png){width='95%' fig-align='center'}

### Generate [`renv.lock`]{style="font-size: 0.95em; font-weight: bold;"}

The documentation for 'Shiny App Deployment' indicates we need to create a `renv` lockfile in the `16.2_cicd-shiny` branch.[^renv-lockfile] 

[^renv-lockfile]: "*This action assumes you have an `renv` lockfile in your repository that describes the R packages and versions required for your Shiny application.*" - [Shiny App Deployment](https://github.com/r-lib/actions/tree/v2/examples#shiny-app-deployment)

We can create the lockfile with the code below:

```{r}
#| eval: false
#| code-fold: false
install.packages('renv')
renv::init(force = TRUE)
```

```{bash}
#| eval: false
#| code-fold: false
This project contains a DESCRIPTION file.
Which files should renv use for dependency discovery in this project? 

1: Use only the DESCRIPTION file. (explicit mode)
2: Use all files in this project. (implicit mode)
```

We're going to use the `explicit mode`, because the dependencies in the `DESCRIPTION` should be all that's needed to run and deploy the application.

```{bash}
#| eval: false
#| code-fold: false
Selection: 1
```

```{bash}
#| eval: false
#| code-fold: false
- Using 'explicit' snapshot type. Please see `?renv::snapshot` for more details.

This project already has a private library. What would you like to do? 

1: Activate the project and use the existing library.
2: Re-initialize the project with a new library.
3: Abort project initialization.
```

We will start fresh and create a new project library:

```{bash}
#| eval: false
#| code-fold: false
Selection: 2
- Resolving missing dependencies ...
```

After `renv` has discovered and installed the dependencies, the R session will restart and we'll see the following new folder/files: 

```{bash}
#| eval: false
#| code-fold: false
├── .Rprofile # <1>
├── renv/
│   ├── activate.R
│   └── settings.json # <2>
└── renv.lock # <3>
```
1. `.Rprofile` contains a call to `source("renv/activate.R")`, which manages the project-level dependencies   
2. `renv` settings   
3. `renv` lockfile

When using `renv` in package development, we want to be sure to run `renv::install()` and `renv::update()`: 

```{r}
#| eval: false
#| code-fold: false
renv::install()
```

```{bash}
#| eval: false
#| code-fold: false
- There are no packages to install.
```

```{r}
#| eval: false
#| code-fold: false
renv::update()
```

```{bash}
#| eval: false
#| code-fold: false
- Checking for updated packages ... Done!
- All packages appear to be up-to-date.
```

### [`shiny-deploy.yaml`]{style="font-size: 0.90em; font-weight: bold;"}

We can include the 'Shiny App Deployment' workflow file in `moviesApp` with `usethis::use_github_action("shiny-deploy")`:[^shiny-depoy]

[^shiny-depoy]: Instructions for the GitHub Action Shiny deployment can be found [here](https://github.com/r-lib/actions/tree/v2/examples#shiny-app-deployment)

```{r}
#| eval: false 
#| code-fold: false
usethis::use_github_action("shiny-deploy")
```

```{bash}
#| eval: false 
#| code-fold: false
✔ Creating '.github/'
✔ Adding '^\\.github$' to '.Rbuildignore'
✔ Adding '*.html' to '.github/.gitignore'
✔ Creating '.github/workflows/'
✔ Saving 'r-lib/actions/examples/shiny-deploy.yaml@v2' to '.github/workflows/shiny-deploy.yaml'
```

This example workflow file is designed to deploy a Shiny application to a server. We're going to make a few changes to `shiny-deploy.yaml` so it will deploy the application stored in the [`16.2_cicd-shiny` branch](https://github.com/mjfrigaard/moviesApp/tree/16.2_cicd-shiny).

The example shiny workflow includes calls to `rsconnect::setAccountInfo()` and `rsconnect::deployApp()`. We'll perform a sanity check and confirm we can deploy the application using the information we've collected:

-   Start by entering your rsconnect info: 

    ```{r}
    #| eval: false 
    #| code-fold: false
    install.packages('rsconnect')
    rsconnect::setAccountInfo(
      name = "mjfrigaard",
      token = "YOUR TOKEN", 
      secret = "YOUR SECRET")
    ```
    
    -   Then try to deploy the application using `rsconnect::deployApp()`:

    ```{r}
    #| eval: false 
    #| code-fold: false
    library(moviesApp)
    rsconnect::deployApp(
      appName = "moviesAppCICD",
      account = "mjfrigaard",
      server = "shinyapps.io",
      forceUpdate = TRUE)
    ```

    -   Reading the deployment log will tells us if the secret, token, configuration, and lockfile are all working:

```{bash}
#| eval: false 
#| code-fold: false
── Preparing for deployment ──────────────────────────────────────────────────
✔ Deploying "moviesAppCICD" using "server: shinyapps.io / username: mjfrigaard"
ℹ Bundling 50 files: .github/workflows/shiny-deploy.yaml, .Rbuildignore, ..., 
tests/testthat.R, and vignettes/test-specs.Rmd
ℹ Capturing R dependencies with renv
✔ Found 99 dependencies
✔ Created 2,431,325b bundle
ℹ Uploading bundle...
✔ Uploaded bundle with id 8130675
── Deploying to server ─────────────────────────────────────────────────────────
Waiting for task: 1372980209
  building: Processing bundle: 8130675
  building: Building image: 9770352
  building: Fetching packages
  building: Installing packages
  building: Installing files
  building: Pushing image: 9770352
  deploying: Starting instances
  unstaging: Stopping old instances
── Deployment complete ─────────────────────────────────────────────────────────
✔ Successfully deployed to <https://mjfrigaard.shinyapps.io/moviesAppCICD/>
```

Making sure my application will deploy locally with the code I plan on putting in a workflow file makes me confident it run when it's triggered. Below we'll adapt the `.github/workflows/shiny-deploy.yaml` file to deploy `moviesApp`. 

#### Trigger

::: {layout="[50,50]" layout-valign="top"}

```YAML
on:
  push:
    branches: [16.2_cicd-shiny]
    
name: shiny
```

-   The event we want the workflow triggered **`on`** is a `push` to the `16.2_cicd-shiny` branch    
-   we'll change the **`name`** to `shiny`   

:::



#### Jobs 

::: {layout="[50,50]" layout-valign="top"}

```yaml
jobs:
  shiny-deploy:
    runs-on: ubuntu-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
```


-   **`jobs`** remains unchanged, but the identifier should match the **`name`**.[^jobs-shiny]

[^jobs-shiny]: `run-on` is the latest Ubuntu runner and `env` is the `GITHUB_PAT` environment variable is your GitHub personal access token (access a secret with `secrets.<SECRET_NAME>`) 

:::

#### Steps 

::: {layout="[50,50]" layout-valign="top"}

```yaml
    steps:
      - uses: actions/checkout@v3

      - uses: r-lib/actions/setup-pandoc@v2

      - uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true

      - uses: r-lib/actions/setup-renv@v2

      - name: Install rsconnect
        run: install.packages("rsconnect")
        shell: Rscript {0}
```


-   Check out the repository code   
-   Set up Pandoc for document conversions   
-   Set up R environment   
    -   `use-public-rspm` is the public RStudio package manager      
-   Set up `renv` to manage the project-specific dependencies captured in `renv.lock`   
-   `Install rsconnect` the step to deploy our app to the Shiny server    
    -   `run` installs the `rsconnect` package   

:::

Now we're ready to update the information in our `.github/workflows/shiny-deploy.yaml` file.
        
::: {layout="[50,50]" layout-valign="top"}

    
```yaml
  - name: Authorize and deploy app
    env: 
      APPNAME: moviesAppCICD
      ACCOUNT: mjfrigaard
      SERVER: shinyapps.io 
```

-   `Authorize and deploy app` defines the step to deploy our Shiny app    
-   `env` sets up the environment variables `APPNAME`, `ACCOUNT`, and `SERVER`
        
:::


The final `run` step sets the account information using `rsconnect::setAccountInfo()` and deploys the app to the specified server using `rsconnect::deployApp()`:

    
```yaml
    run: |
      rsconnect::setAccountInfo("${{ secrets.RSCONNECT_USER }}", "${{ secrets.RSCONNECT_TOKEN }}", "${{ secrets.RSCONNECT_SECRET }}")
      rsconnect::deployApp(appName = "${{ env.APPNAME }}", account = "${{ env.ACCOUNT }}", server = "${{ env.SERVER }}", forceUpdate = TRUE)
    shell: Rscript {0}
```

```{bash}
#| eval: false
#| code-fold: false
git add .
git commit -m "shiny deploy workflow"
```

```{bash}
#| eval: false
#| code-fold: false
[16.2_cicd-shiny 7953a5c] shiny deploy workflow
 10 files changed, 2130 insertions(+)
 create mode 100644 .Rprofile
 create mode 100644 .github/.gitignore
 create mode 100644 .github/workflows/shiny-deploy.yaml
 create mode 100644 renv.lock
 create mode 100644 renv/.gitignore
 create mode 100644 renv/activate.R
 create mode 100644 renv/settings.json
 create mode 100644 rsconnect/shinyapps.io/mjfrigaard/moviesAppCICD.dcf
```

We can see the workflow running on the **Actions** tab of the `moviesApp` repository: 

![shiny deploy workflow running](images/gh_action_shiny_tab.png){width='100%' fig-align='center'}

When it's finished, we can see the deployment log from the workflow looks similar to the log we saw locally:

![deploy log from workflow](images/gh_action_shiny_deploy.png){width='100%' fig-align='center'}


## Recap

The workflow above automates the deployment of a Shiny application to a specified server. The workflow Actions in this chapter are triggered by changes to the `16.1_cicd-style` and `16.2_cicd-shiny` branches of the `moviesApp` repository. 
GitHub Action workflows can be used to set up the necessary R environment and dependencies required to deploy the application in your app-package, while allowing secure account credentials stored in GitHub secrets. 

GitHub Actions is like having a personal assistant who streamlines a secure deployment process for your Shiny app-package, allowing you to focus more on developing code. 

<!-- https://github.com/pharmaverse/admiralci/blob/main/.github/workflows/code-coverage.yml --> 

