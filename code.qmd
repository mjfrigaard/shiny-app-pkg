# Code {.unnumbered}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(shinypak)
```

Expand the boxes below to review what was covered in previous three chapters:

::: {.callout-note collapse='true'}

## [Docker (Chapter 15)]{style='font-size: 1.35em;'}

The [Docker chapter](docker.qmd) covered the following topics:

-   @sec-what-is-docker covers an introduction to Docker 'containerization' and images.

-   @sec-dockerfile describes the contents of a `Dockerfile` and few common commands for running R and launching Shiny apps.

-   @sec-docker-image demonstrates how to build a docker image from the command line.

    -   @sec-docker-golem takes a slight detour into using Docker with the `golem` framework.

-   @sec-docker-app-packages gives advice for using Docker in your app-package.

:::: {.callout-tip collapse='true' appearance='default'}

### [Chapter 15 Applications]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 0.95em; color: #282b2d;'}

The applications in Chapter 15 (Docker) can be accessed with the `launch()` or `get()` functions from the [`shinypak` R package](https://mjfrigaard.github.io/shinypak/):

```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| eval: false
# install.packages('pak')
pak::pak('mjfrigaard/shinypak')
library(shinypak)
```

Chapter 15 applications:
  
```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| collapse: true
list_apps(regex = '^15')
```

::: 

::::

:::


::: {.callout-note collapse='true'}

## [CI/CD (Chapter 16)]{style='font-size: 1.35em;'}

Continuous integration and continuous deployment is demonstrated using GitHub Actions to automate three common workflows:

-   GitHub Actions are introduced with @sec-gha-style that styles and lints the code in your app-package when it's pushed to Github.

-   The next section demonstrates using the @sec-gha-shiny, creating a `renv` lockfile for your app-package, and storing/setting your `rsconnect` account info.

-   The final section combines the previous chapter into a @sec-gha-shiny-docker, which includes how to use a `Dockerfile` and a workflow file to launch you application. 

:::: {.callout-tip collapse='true' appearance='default'}

### [Chapter 16 Applications]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 0.95em; color: #282b2d;'}

The applications in Chapter 16 (CI/CD) can be accessed with the `launch()` or `get()` functions from the [`shinypak` R package](https://mjfrigaard.github.io/shinypak/):

```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| eval: false
# install.packages('pak')
pak::pak('mjfrigaard/shinypak')
library(shinypak)
```

Chapter 16 applications:
  
```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| collapse: true
list_apps(regex = '^16')
```

::: 

::::

:::

::: {.callout-note collapse='true'}

## [pkgdown (Chapter 17)]{style='font-size: 1.35em;'}


-   @sec-pkgdown-setup: covers creating a `_pkgdown.yml` configuration file that `pkgdown` uses to build the site for your app-package. 

    -   The `_pkgdown.yml` file also lets you customize how your website looks and which parts of your package are highlighted.

-   @sec-pkgdown-site-contents demonstrates how `build_site_github_pages()` (or `build_site()`) tells `pkgdown` to go through your app-package, including the documentation, vignettes, and examples, and assemble them into a coherent, navigable website.

-   @sec-pkgdown-layouts briefly touches on the various ways you can customize your site (themes, fonts, and colors). 

-   After building your site, you'll need to deploy it with a @sec-pkgdown-workflow.

    -   This also involves creating an orphan Git branch and pushing the `pkgdown` contents to GitHub Pages.

:::: {.callout-tip collapse='true' appearance='default'}

### [Chapter 17 Applications]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 0.95em; color: #282b2d;'}

The applications in Chapter 17 (`pkgdown`) can be accessed with the `launch()` or `get()` functions from the [`shinypak` R package](https://mjfrigaard.github.io/shinypak/):

```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| eval: false
# install.packages('pak')
pak::pak('mjfrigaard/shinypak')
library(shinypak)
```

Chapter 17 applications:
  
```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| collapse: true
list_apps(regex = '^17')
```

::: 

::::

:::

---

Shiny simplifies the creation of interactive web applications by allowing you to write R code that is automatically translated into HTML, CSS and JavaScript. However, sometimes it's necessary to include non-R code files as supplemental resources to improve your application. This section will cover how to include HTML, CSS, and JavaScript files in your Shiny app-package.

This section introduces the following upgrades to our Shiny application in `shinyAppPkgs`: 

1) A new layout using `page_navbar()` from [`bslib`](https://rstudio.github.io/bslib/)
    a. The UI outputs now sit in two `nav_panel()`s, with collapsible sidebars and footers.[^card-footer]

2) Improved plots
    a. We're using `rlang`'s injection operator (`!!`) for the plot inputs (instead of the `.data` masking), so the plotting modules now contain the `ggplot2` functions used to create the graphs.  
    b. A new plot label formatting function (`label_titler()`) makes it easier to convert variable inputs into title case.

3) New graphs for viewing metrics by year and distributions  
    a. 


[^card-footer]: `bslib` uses cards to display contents inside each `nav_panel()`. The outputs use `card()` with `layout_sidebar()`, `card_body()`, and `card_footer()`. Learn more on the [`bslib` website](https://rstudio.github.io/bslib/).

<!--

The reactive programming model ensures that user inputs are instantly reflected in the outputs, creating a seamless interactive experience. 

-->

### HTML 

In [HTML chapter](html.qmd), we'll explore how to embed HTML within Shiny apps, use tags and functions to enhance UI layouts, and leverage HTML templates for more complex designs. 

Additionally, we'll cover how to seamlessly combine Shiny's reactive outputs with custom HTML elements to build interactive interfaces.

### CSS

The [CSS chapter](css.qmd) delves into the art of styling your Shiny applications, ensuring they are both visually appealing and user-friendly. We discuss how to apply custom styles to your app using CSS, enabling you to customize the appearance of your elements beyond Shiny's default themes. You'll learn how to include external CSS files, write inline styles, and utilize CSS frameworks like Bootstrap for responsive design. Through practical examples, we demonstrate how to manage CSS specificity, create reusable styles, and enhance the overall user experience by controlling layout, typography, colors, and animations.

### JavaScript

In the [JavaScript chapter](js.qmd), we cover how to extend the functionality of your Shiny applications with custom JavaScript. JavaScript can be used to handle client-side interactivity, manipulate the DOM, and integrate third-party libraries and APIs. We'll show you how to include JavaScript files in your Shiny app-package, write custom JavaScript code that interacts with Shiny's reactive model, and use Shiny's JavaScript functions to create more dynamic and responsive applications. This chapter equips you with the skills to bridge the gap between Shiny's R-based framework and the extensive capabilities of JavaScript, enhancing your app's performance and user interaction.
   
### Style 

[Style](style.qmd) covers formatting the code in your package so it's easier to debug (and read). 
