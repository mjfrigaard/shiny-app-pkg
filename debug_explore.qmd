# Exploring code {#sec-debug-explore}

<!--
https://shiny.posit.co/r/articles/improve/debugging/
https://debruine.github.io/shinyintro/debugging.html
-->

```{r}
#| label: _common
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(lobstr)
```

```{r}
#| label: co_box_tldr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b",
  look = "default", hsize = "1.10", size = "1.05",
  header = "TLDR &emsp; Exloring code with debugging",
  fold = TRUE,
  contents = "

<br>
  
Debugging plays a crucial role in ensuring that our app works as expected *and* integrates seamlessly into the R package structure. 

  "
)
```

Debugging Shiny code can be challenging because the reactive model involves a dynamic interactions and non-linear flow of execution between inputs, outputs, and reactive expressions. Shiny bugs can originate from reactive dependencies, execution order (Shiny is inherently asynchronous), hidden states, lazy evaluation, and reactive context/invalidation (i.e., with `isolate()`, `reactive()`, and `observe()`).

Understanding the interplay of reactivity, lazy evaluation, asynchronous execution, and hidden states will help us diagnose and resolve bugs in our Shiny app-packages. However, we'll have to employ specific strategies and tools to handle Shiny bugs effectively, and some of the traditional debugging approaches can fall short in reactive contexts. Below we'll cover the two most common methods for debugging R code, and how we can adapt them for a Shiny application. 

:::: {.callout-tip collapse='true' appearance='default'}

## [Accessing applications]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 0.95em; color: #282b2d;'}

I've created the [`shinypak` R package](https://mjfrigaard.github.io/shinypak/) In an effort to make each section accessible and easy to follow:
  
Install `shinypak` using `pak` (or `remotes`):

```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| eval: false
# install.packages('pak')
pak::pak('mjfrigaard/shinypak')
```

Review the chapters in each section:
  
```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| collapse: true
library(shinypak)
list_apps(regex = 'debug')
```

Launch the app: 

```{r}
#| code-fold: false 
#| eval: false
launch(app = "23.1_debug-error")
```

Download the app: 

```{r}
#| code-fold: false 
#| eval: false
get_app(app = "23.1_debug-error")
```

::: 

::::

## Debugging methods {#sec-debug-explore-methods}

When used as an exploratory tool, debugging can allow us peak ‘inside’ functions, see their intermediate values/variables, and break down their execution line-by-line. The two most common methods for debugging R code are:

1. Interactive debugging (i.e., using `browser()`) 

2. Print debugging (with `print()` or `cat()`)

However, `browser()` and `print()` are not as straightforward to use within reactive contexts. For example, `browser()` will disrupt the reactive flow, making it hard to maintain an interactive debugging session. `print()`/`cat()` only provides a snapshot of variable values *at the time of the print call*, so they can't help us explore the other parts of the environment or interact with the running application.



These two methods cover 90% of my Shiny app debugging needs. In the following sections, I'll provide examples of how--and when--I use `browser()` and `observe()`.

### [`browser()`]{style="font-size: 1.02em; font-weight: bold;"} and [`observe()`]{style="font-size: 1.02em; font-weight: bold;"}

`browser()` pauses code execution and activates the interactive debugger mode in the IDE, allowing us to view objects, execute code, and ‘step through’ each function line.

```{=html}

<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}

</style>
```

```{mermaid}
%%| label: function_exec_browser
%%| fig-width: 5
%%| fig-height: 6
%%| fig-align: center
%%| fig-cap: '`browser()` used for debugging functions'
%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'Inconsolata', 'primaryColor': '#8dd38d', 'edgeLabelBackground':'#ffd700'}}}%%
flowchart TD
    Start["Run <code>.R</code> File"] --> Running[Function Executes]
    Running --> Browser["<code>browser()</code>"]
    Browser --> Pause[Execution paused]
    Pause --> Debugger[View intermediate variables/values]
    Debugger --> Exit["Exit <code>browser()</code>"]
    Exit --> Resume[Resume Execution]
    Resume --> Running
    
```

`observe()` creates a reactive observer that 'listens' for changes to reactive expressions (and executes code in response). 

Wrapping `browser()` with `observe()` will trigger the debugger when the observer is invalidated, allowing us to interactively examine variables and reactive expressions (within the scope of the `observe()` function):

```{=html}

<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}

</style>
```

```{mermaid}
%%| label: function_observe_browser
%%| fig-width: 5.0
%%| fig-align: center
%%| fig-cap: '`observe()` and `browser()` functions'
%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'Inconsolata', 'primaryColor': '#8dd38d', 'edgeLabelBackground':'#ffd700'}}}%%
flowchart TD
    subgraph shinyServer["<code>server()</code> Function"]
        S1["<code>observe({})</code>"]
        S1 --> S2["<code>browser()</code> invalidates observer"]
        S2 --> S3["<code>observe()</code> scope execution paused"]
        S3 --> S4["View variables/reactive expressions"]
        S4 --> S5["Exit <code>browser()</code>"]
        S5 --> S1
    end
    
    style shinyServer fill:#fafafa,stroke:#333,stroke-width:1px
```


```{r}
#| eval: false 
#| code-fold: false
server <- function(input, output, session) { # <1> 

    observe({ # <2>
        browser() # <3> 
    

    returned_values <- module_values_server("id_x")

    module_render_server("id_y", input_values = returned_values)
    
    }) # <2>
} # <1>
```
1. Shiny server function
2. `observe()` function scope  
3. `browser()` called at the top of the `observe()` scope

`observe()` and `browser()` aren't only useful for addressing bugs--we can also use the debugger to understand how an application works.

## Example: [`ggplot2movies`]{style="font-size: 1.02em; font-weight: bold;"} app

```{r}
#| label: git_box_10_debug-explore
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '65%', 
  branch = "10_debug-explore", 
  repo = 'sap')
```

Suppose it's been awhile since we've looked at our development `ggplot2movies` application[^ggp2-callback] and we can't remember how the 'Remove missing' checkbox works. We can place the debugging functions in the module `.R` file, load the changes, and launch the application to refresh our memory on how this code is evaluated. RStudio's debugging tools are covered elsewhere,[^debug-other-resources] so this chapter will focus on Positron's debugging features for functions inside our app-package.

[^debug-other-resources]: For an introduction to the IDE's debugging tools, see this [Posit article](https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE). Debugging is also covered in [Advanced R, 2ed](https://adv-r.hadley.nz/debugging.html) and [Mastering Shiny.](https://mastering-shiny.org/action-workflow.html#debugging)

[^ggp2-callback]: We covered the `ggplot2movies` application in @sec-external-inst-dev.

```{r}
#| label: co_box_positron_version
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", 
  look = "simple", 
  hsize = "1.10", 
  size = "1.05",
  header = "![](images/positron.png){height=20} Positron Version", 
  fold = TRUE,
  contents = "At the time of this writing, the [2024.09.0-1](https://github.com/posit-dev/positron/releases/tag/2024.09.0-1) pre-release of Positron was available for testing."
)
```

We'll place the call to  `observe()` inside `dev_mod_scatter_server()` (right after the `moduleServer()` function), and then place `browser()` just before the alternate dataset is loaded:

```{r}
#| eval: false 
#| code-fold: false 
dev_mod_scatter_server <- function(id, var_inputs) {
  moduleServer(id, function(input, output, session) {
    # load alternate data
    all_data <- fst::read_fst("tidy_movies.fst") # <1>

    observe({ # <2>
    # load alternate data
    browser() # <3>
      # <4> 
      # <4> 
    })  # <2>
  })
}
```
1. Read `tidy_movies.fst` data    
2. Observer scope   
3. Call to `browser()` 
4. Additional module code omitted  

Load the package and run the app:

```{r}
#| label: hot_key_ggp2_movies_app
#| echo: false
#| results: asis
#| eval: true
hot_key(fun = "L")
```

```{verbatim}
#| eval: false 
#| code-fold: false
ℹ Loading sap
```

```{r}
#| label: co_box_dbug_modules
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "r", 
  size = '1.05', 
  header = "Loading code changes", 
  hsize = '1.15', 
  fold = TRUE, 
  look = 'simple',
  contents = "
  
***Don't forget to load any debugging calls with `devtools::load_all()` _before_ re-launching the app*** 
  
\`\`\`r
devtools::load_all('.')
`\`\`\

***Or***
  
<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>

  "
)
```

```{r}
#| eval: false 
#| code-fold: false
ggp2_launch_app(options = list(test.mode = TRUE))
```

## Interactive debugging

Below we'll cover what happens to each IDE when they enter 'interactive debugger' mode. As noted above, RStudio's ![](images/rstudio-icon.png){height=20} debugger is covered elsewhere,[^debug-other-resources] so we'll focus on debugging tools in Positron ![](images/positron.png){height=20}. 

:::: {.panel-tabset}

### Positron ![](images/positron.png){height=20}

When the app is launched, Positron ![](images/positron.png){height=20} alerts us that we're in debugging with the following changes to the IDE: 

1. The footer is [highlighted in red]{style="background-color: #F78F8F; font-weight: bold;"}

2. The **Run and Debug** sidebar menu item is displayed (which I've outlined in [orange]{style="color: #FF9300; font-weight: bold;"}):

3. The **Console** displays the interactive debugger prompt: [`Browse[1]>`]{style="font-weight: bold;"}

4. The `dev_mod_scatter.R` file [highlights the call to `browser()` in yellow]{style="background-color: #FAFFC1; font-weight: bold;"}

:::{.column-page-inset-right}

![Click to enlarge Positron IDE in debugger mode](images/debug_explore_positron_all.png){width='100%' fig-align='center'}

:::

:::{layout="[50, 50]" layout-valign="top"}

![Click to enlarge `.R` file in debugger mode](images/debug_explore_dev_mod_scatter.png){fig-align='center'}

![Click to enlarge **Console** in debugger mode](images/debug_explore_positron_console.png){fig-align='center'}

:::

### RStudio ![](images/rstudio-icon.png){height=20}

In RStudio ![](images/rstudio-icon.png){height=20}, launching the apps triggers the interactive debugger and we see the following changes in the IDE: 

1. The **Console** displays the interactive debugger prompt ([`Browse[1]>`]{style="font-weight: bold;"})

2. The `dev_mod_scatter.R` file [highlights the `browser()` call]{style="background-color: #FFF399; font-weight: bold;"}. 

3. In the **Environment** pane, we can see the *Traceback* section [highlights the execution of our call to `shiny::observe()`.]{style="background-color: #FFF399; font-weight: bold;"}

:::{.column-page-inset-right}

![Click to enlarge debugging `dev_mod_scatter_server()`in RStudio](images/debug_explore_rstudio_all.png){width='100%'}

:::

::::

In both IDEs, our `observe()` and `browser()` placement will suspend the execution of the application before the data are loaded (`tidy_movies.fst`) and the graph is rendered. 

![Click to enlarge suspended `ggplot2movies` data app](images/debug_explore_browser_suspend_app.png){width='100%' fig-align='center'}

In the next sections, we'll 'step through' the module function to explore how the `tidy_movies.fst` data are loaded (and missing values are removed). 

### Verify app data 

First we'll proceed through the code until `tidy_movies.fst` is loaded, then confirm it's structure.


:::: {.panel-tabset}

### Positron ![](images/positron.png){height=20}

We can execute the next line of code by entering **`n`** in the **Console**. This will display a `debug at` location (which is the full path the file containing our call to `browser()`). In the `inst/dev/R/dev_mod_scatter.R` file, the next line of code to be executed is [highlighted in yellow]{style="background-color: #FAFFC1; font-weight: bold;"} (the final line is [highlighted in gray]{style="background-color: #E6E6E6; font-weight: bold;"})

:::{layout="[50, 50]" layout-valign="top"}

![](images/debug_explore_positron_step.png){width='100%' fig-align='center'}

![](images/debug_explore_positron_highlight_b4_exec.png){width='100%' fig-align='center'}


:::

After entering **`n`** again in the interactive debugger prompt (`Browse[1]>`) we can see the `graph_data` is created in the **DEBUG VARIABLES** sidebar:

![](images/debug_explore_positron_variables.png){width='80%' fig-align='center'}

### RStudio ![](images/rstudio-icon.png){height=20}

::::

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> n
Browse[2]> n
Browse[2]> str(all_data)
```

``` sh
'data.frame':	46002 obs. of  8 variables: 
 $ title     : chr  "'Til There Was You" ...
 $ length    : int  113 97 98 98 102 120 ...
 $ year      : int  1997 1999 2002 2004 ...
 $ budget    : int  23000000 16000000 ...
 $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...
 $ votes     : int  799 19095 181 7859 ...
 $ mpaa      : Factor w/ 5 levels "G","PG" ...
 $ genre     : Factor w/ 8 levels "Action"...
```
    
:::

This gives us an idea of the total rows before missing are removed. 

### Verfiy missing 

After loading `all_data`, the module creates a reactive `graph_data()`. We can see `graph_data()` is 'bound' to `input$missing`, so we'll confirm the  `input$missing` value:

![](images/debug_dev_verify_missing_04.png){width='85%' fig-align='center'}

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> input$missing
```

``` sh
[1] TRUE
```

:::

This tells us '*Remove missing*' has been selected, and we can verify the missing values have been removed from `graph_data()`:

::: {layout="[35, 65]" layout-valign="top"}


``` r
Browse[2]> n
Browse[2]> str(graph_data())
```

``` sh
'data.frame':	1608 obs. of  8 variables: 
 $ title     : chr  "'Til There Was You" ...
 $ length    : int  113 97 98 98 102 120 ...
 $ year      : int  1997 1999 2002 2004 ...
 $ budget    : int  23000000 16000000 ...
 $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...
 $ votes     : int  799 19095 181 7859 ...
 $ mpaa      : Factor w/ 5 levels "G","PG" ...
 $ genre     : Factor w/ 8 levels "Action"...
```

:::

### Verfiy variable inputs 
    
Next we'll confirm the `var_inputs()` list of graph values from our `dev` variable input module:

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> str(var_inputs())
```

``` sh
List of 6
 $ x         : chr "year"
 $ y         : chr "budget"
 $ z         : chr "mpaa"
 $ alpha     : num 0.4
 $ size      : num 2.5
 $ plot_title: chr ""
```
    
:::


`var_inputs()` is creates the `inputs()` reactive for the graph, so we'll confirm those values, too.

![](images/debug_dev_verify_inputs_04.png){width='85%' fig-align='center'}

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> n
Browse[2]> str(inputs())
```

``` sh
List of 6
 $ x         : chr "year"
 $ y         : chr "budget"
 $ z         : chr "mpaa"
 $ alpha     : num 0.4
 $ size      : num 2.5
 $ plot_title: chr ""
```
    
:::

### Verfiy graph

Now that we have an understanding of the reactive flow inside the app, we'll render the plot: 

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> n
```

![](images/debug_dev_verify_app_04.png)

:::

Using `browser()` to 'step through' an application gives us a better understanding of the 'order of execution' in our `dev` scatter plot display module, (and it lets us see how `input$missing` and `bindEvent()` are working).

## Print debugging

Capturing reactive values with `reactiveValuesToList()` and sending output to the UI.

## Recap {.unnumbered}

```{r}
#| label: co_box_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "g", 
  fold = FALSE,
  look = "default", hsize = "1.10", size = "1.05", 
  header = "Recap: CI/CD!",
  contents = "

`browser()` and `observe()` are powerful tools for debugging your application. Navigating a function using the debugger console gives you control over the execution of each line. If we want to see what's happening 'behind the scenes', we can collect the reactive values and print them in the UI while the app is running. 

The Shiny documentation also has a [list of methods](https://shiny.posit.co/r/articles/improve/debugging/) for debugging apps, and learning how to read call stacks (or a stacktrace) will help you debug your shiny app.[^debug-call-stacks], [^call-stack-shiny]")
```

```{r}
#| label: git_contrib_box
#| echo: false
#| results: asis
#| eval: true
git_contrib_box()
```

[^call-stack-shiny]: Stack traces are also covered in [Advanced R, 2ed](https://adv-r.hadley.nz/debugging.html#traceback), [Mastering Shiny](https://mastering-shiny.org/action-workflow.html#tracebacks-in-shiny), and in the [Shiny documentation](https://github.com/rstudio/shiny/wiki/Stack-traces-in-R). I've summarized some tips on reading Shiny call stacks in the [stack traces](stack_traces.qmd) section on the Appendix.


[^debug-call-stacks]: Watch [this video](https://www.youtube.com/watch?v=g1h-YDWVRLc) to learn about call stacks and abstract folder trees with `lobstr`. 

