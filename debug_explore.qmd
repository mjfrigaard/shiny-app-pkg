# Exploring code {#sec-debug-explore}

<!--
https://shiny.posit.co/r/articles/improve/debugging/
https://debruine.github.io/shinyintro/debugging.html
-->

```{r}
#| label: _common
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(lobstr)
```

When building Shiny app-packages, debugging plays a crucial role in ensuring that our app works as expected *and* integrates seamlessly into the package structure. RStudio's debugging tools are covered elsewhere,[^debug-other-resources] so this chapter will focus on Positron's debugging features for functions inside our app-package.

[^debug-other-resources]: For an introduction to the IDE's debugging tools, see this [Posit article](https://support.posit.co/hc/en-us/articles/205612627-Debugging-with-the-RStudio-IDE). Debugging is also covered in [Advanced R, 2ed](https://adv-r.hadley.nz/debugging.html) and [Mastering Shiny.](https://mastering-shiny.org/action-workflow.html#debugging)

:::: {.callout-tip collapse='true' appearance='default'}

## [Accessing applications]{style='font-weight: bold; font-size: 1.15em;'}

::: {style='font-size: 0.95em; color: #282b2d;'}

I've created the [`shinypak` R package](https://mjfrigaard.github.io/shinypak/) In an effort to make each section accessible and easy to follow:
  
Install `shinypak` using `pak` (or `remotes`):

```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| eval: false
# install.packages('pak')
pak::pak('mjfrigaard/shinypak')
```

Review the chapters in each section:
  
```{r}
#| code-fold: false 
#| message: false
#| warning: false
#| collapse: true
library(shinypak)
list_apps(regex = 'debug')
```

Launch the app: 

```{r}
#| code-fold: false 
#| eval: false
launch(app = "23.1_debug-error")
```

Download the app: 

```{r}
#| code-fold: false 
#| eval: false
get_app(app = "23.1_debug-error")
```

::: 

::::

## Debugging methods {#sec-debug-explore-methods}

When used as an exploratory tool, the debugger allows us to ‘look inside’ functions and break down their execution line-by-line. The two most common tools I use for debugging are:

1. Wrapping `browser()` in a call to `observe()`  
2. Capturing reactive values with `reactiveValuesToList()` and sending output to the UI

These two methods cover 90% of my Shiny app debugging needs. In the following sections, I'll provide examples of how--and when--I use each method.

### [`browser()`]{style="font-size: 1.02em; font-weight: bold;"} and [`observe()`]{style="font-size: 1.02em; font-weight: bold;"}

`browser()` pauses code execution and activates the interactive debugger mode in the IDE, allowing us to view objects, execute code, and ‘step through’ each function line.

```{=html}

<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}

</style>
```

```{mermaid}
%%| fig-width: 6.5
%%| fig-align: center
%%| fig-cap: '`browser()` used for debugging functions'
%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'Inconsolata', 'primaryColor': '#8dd38d', 'edgeLabelBackground':'#ffd700'}}}%%
flowchart TD
    Start["Run (i.e., <code>source()</code>) .R File"] --> Running[Function Executes]
    Running --> Browser["<code>browser()</code>"]
    Browser --> Pause[Execution paused]
    Pause --> Debugger[View intermediate variables/values]
    Debugger --> Exit["Exit <code>browser()</code>"]
    Exit --> Resume[Resume Execution]
    Resume --> Running
    
```

Shiny’s reactive model can make debugging challenging because the issues aren’t limited to the internal logic or calculations. Bugs can also be caused by the timing, sequence, or creation of reactive values. `observe()` creates a reactive observer that 'listens' for changes to reactive expressions (and executes code in response).

```{r}
#| label: co_box_dbug_modules
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "r", 
  size = '1.05', 
  header = "Debugging in Shiny App-Packages", 
  hsize = '1.15', 
  fold = TRUE, 
  look = 'simple',
  contents = "
  
***Don't forget to load any debugging calls with `devtools::load_all()` _before_ re-launching the app*** 
  
\`\`\`r
devtools::load_all('.')
`\`\`\

***Or***
  
<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>

  "
)
```

Wrapping `browser()` with `observe()` will trigger the debugger when the observer is invalidated, allowing us to interactively examine variables and reactive expressions (within the scope of the `observe()` function):

```{r}
#| eval: false 
#| code-fold: false
server <- function(input, output, session) { # <1> 

    observe({ # <2>
        browser() # <3> 
    

    returned_values <- module_values_server("id_x")

    module_render_server("id_y", input_values = returned_values)
    
    }) # <2>
} # <1>
```
1. Shiny server function
2. `observe()` function scope  
3. `browser()` called at the top of the `observe()` scope

```{=html}

<style>

.codeStyle span:not(.nodeLabel) {
  font-family: monospace;
  font-size: 1.5em;
  font-weight: bold;
  color: #9753b8 !important;
  background-color: #f6f6f6;
  padding: 0.2em;
}

</style>
```

```{mermaid}
%%| fig-width: 6.5
%%| fig-align: center
%%| fig-cap: '`observe()` and `browser()` functions'
%%{init: {'theme': 'base', 'themeVariables': { 'fontFamily': 'Inconsolata', 'primaryColor': '#8dd38d', 'edgeLabelBackground':'#ffd700'}}}%%
flowchart TD
    subgraph shinyServer["<code>server()</code> Function"]
        S1["<code>observe({})</code>"]
        S1 --> S2["<code>browser()</code> invalidates observer"]
        S2 --> S3["<code>observe()</code> scope execution paused"]
        S3 --> S4["View variables/reactive expressions"]
        S4 --> S5["Exit <code>browser()</code>"]
        S5 --> S1
    end
    
    style shinyServer fill:#fafafa,stroke:#333,stroke-width:1px
```

`observe()` and `browser()` aren't only useful for addressing bugs--we can also use the debugger to understand how an application works.

## Example: [`ggplot2movies`]{style="font-size: 1.02em; font-weight: bold;"} app

```{r}
#| label: git_box_10_debug-explore
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "launch",
  fig_pw = '65%', 
  branch = "10_debug-explore", 
  repo = 'sap')
```

Suppose it's been awhile since we've looked at the `ggplot2movies::movies` application (run with `ggp2_movies_app()`). We can place calls to `observe(browser())` in the `inst/dev/app.R` file, load the package, and run the application to see how it executes.

We'll wrap the code in `dev_mod_scatter_server()` in `observe()`, and place a call to `browser()` before the alternate dataset is loaded:

```{r}
#| eval: false 
#| code-fold: false 
dev_mod_scatter_server <- function(id, var_inputs) {
  moduleServer(id, function(input, output, session) {

    observe({ # <1> 
      browser() # <2>

    # load alternate data
    all_data <- fst::read_fst("tidy_movies.fst")
    # <3>
    # <3> 
    # <3> 
    # <3>
    }) # <1> 
  })
}
```
1. Observer scope   
2. Call to `browser()`   
3. Additional module code omitted

Load the package and run the app:

```{r}
#| label: hot_key_ggp2_movies_app
#| echo: false
#| results: asis
#| eval: true
hot_key(fun = "L")
```

```{verbatim}
#| eval: false 
#| code-fold: false
ℹ Loading sap
```

```{r}
#| eval: false 
#| code-fold: false
ggp2_movies_app(options = list(test.mode = FALSE), run = 'p')
```


This will suspend the execution of application before the tidy `ggplot2movies::movies` data are loaded (`tidy_movies.fst`), and before the graph is rendered: 


:::: {.column-page-inset-right}

::: {layout="[60, 40]" layout-valign="top"}

![Debugging `dev_mod_scatter_server()`](images/debug_dev_app_04.png){width='100%'}

![`ggp2_movies_app()` in interactive debugger](images/debug_dev_ggp2_movies_app_04.png){width='100%'}

:::

::::

We can step through the module function to explore how the alternate data are loaded (and missing values are removed). 

### Verify app data 

First we'll proceed through the code until `tidy_movies.fst` is loaded, then confirm it's structure: 

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> n
Browse[2]> n
Browse[2]> str(all_data)
```

``` sh
'data.frame':	46002 obs. of  8 variables: 
 $ title     : chr  "'Til There Was You" ...
 $ length    : int  113 97 98 98 102 120 ...
 $ year      : int  1997 1999 2002 2004 ...
 $ budget    : int  23000000 16000000 ...
 $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...
 $ votes     : int  799 19095 181 7859 ...
 $ mpaa      : Factor w/ 5 levels "G","PG" ...
 $ genre     : Factor w/ 8 levels "Action"...
```
    
:::

This gives us an idea of the total rows before missing are removed. 

### Verfiy missing 

After loading `all_data`, the module creates a reactive `graph_data()`. We can see `graph_data()` is 'bound' to `input$missing`, so we'll confirm the  `input$missing` value:

![](images/debug_dev_verify_missing_04.png){width='85%' fig-align='center'}

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> input$missing
```

``` sh
[1] TRUE
```

:::

This tells us '*Remove missing*' has been selected, and we can verify the missing values have been removed from `graph_data()`:

::: {layout="[35, 65]" layout-valign="top"}


``` r
Browse[2]> n
Browse[2]> str(graph_data())
```

``` sh
'data.frame':	1608 obs. of  8 variables: 
 $ title     : chr  "'Til There Was You" ...
 $ length    : int  113 97 98 98 102 120 ...
 $ year      : int  1997 1999 2002 2004 ...
 $ budget    : int  23000000 16000000 ...
 $ avg_rating: num  4.8 6.7 5.6 6.4 6.1 ...
 $ votes     : int  799 19095 181 7859 ...
 $ mpaa      : Factor w/ 5 levels "G","PG" ...
 $ genre     : Factor w/ 8 levels "Action"...
```

:::

### Verfiy variable inputs 
    
Next we'll confirm the `var_inputs()` list of graph values from our `dev` variable input module:

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> str(var_inputs())
```

``` sh
List of 6
 $ x         : chr "year"
 $ y         : chr "budget"
 $ z         : chr "mpaa"
 $ alpha     : num 0.4
 $ size      : num 2.5
 $ plot_title: chr ""
```
    
:::


`var_inputs()` is creates the `inputs()` reactive for the graph, so we'll confirm those values, too.

![](images/debug_dev_verify_inputs_04.png){width='85%' fig-align='center'}

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> n
Browse[2]> str(inputs())
```

``` sh
List of 6
 $ x         : chr "year"
 $ y         : chr "budget"
 $ z         : chr "mpaa"
 $ alpha     : num 0.4
 $ size      : num 2.5
 $ plot_title: chr ""
```
    
:::

### Verfiy graph

Now that we have an understanding of the reactive flow inside the app, we'll render the plot: 

::: {layout="[35, 65]" layout-valign="top"}

``` r
Browse[2]> n
```

![](images/debug_dev_verify_app_04.png)

:::

Using `browser()` to 'step through' an application gives us a better understanding of the 'order of execution' in our `dev` scatter plot display module, (and it lets us see how `input$missing` and `bindEvent()` are working).

## Recap {.unnumbered}

```{r}
#| label: co_box_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "g", 
  fold = FALSE,
  look = "default", hsize = "1.10", size = "1.05", 
  header = "Recap: CI/CD!",
  contents = "

`browser()` and `observe()` are powerful tools for debugging your application. Navigating a function using the debugger console gives you control over the execution of each line. If we want to see what's happening 'behind the scenes', we can collect the reactive values and print them in the UI while the app is running. 

The Shiny documentation also has a [list of methods](https://shiny.posit.co/r/articles/improve/debugging/) for debugging apps, and learning how to read call stacks (or a stacktrace) will help you debug your shiny app.[^debug-call-stacks], [^call-stack-shiny]")
```

```{r}
#| label: git_contrib_box
#| echo: false
#| results: asis
#| eval: true
git_contrib_box()
```

[^call-stack-shiny]: Stack traces are also covered in [Advanced R, 2ed](https://adv-r.hadley.nz/debugging.html#traceback), [Mastering Shiny](https://mastering-shiny.org/action-workflow.html#tracebacks-in-shiny), and in the [Shiny documentation](https://github.com/rstudio/shiny/wiki/Stack-traces-in-R). I've summarized some tips on reading Shiny call stacks in the [stack traces](stack_traces.qmd) section on the Appendix.


[^debug-call-stacks]: Watch [this video](https://www.youtube.com/watch?v=g1h-YDWVRLc) to learn about call stacks and abstract folder trees with `lobstr`. 

