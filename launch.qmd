# Launch {#sec-launch}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = "minimal",
  header = "Caution",
  contents = "This section is still being developed--it's contents are subject to change.",
  fold = FALSE
)
```

In the previous chapter, we moved `movies` into `data/` folder to ensure it's part of the `shinyAppPkg` namespace. However, we will still want a way to lunch our app during development (and a process for deploying the application into a production environment).

```{r}
#| label: co_box_tldr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", look = "minimal",
  header = "TLDR", fold = TRUE,
  contents = "
**Launching Apps:** 
  
- **`shinyApp()`**: ...\n
  
- **`runApp()`**:...\n
    - Does ...`\n
    - And ...\n
  
- **`shinyAppDir()`**:...\n
    
**Workflow:**...\n
  
  "
)
```


This chapter will cover what belongs in the `app.R` file, the differences between shiny's `shinyApp()`, `runApp()`, and `shinyAppDir()` functions, and other options for launching an app (or apps) in your app-package.

## [`app.R`]{style="font-size: 0.95em"}

In the current branch of `shinyAppPkg`, the `app.R` file loads our package and runs the standalone app function:

```{r}
#| label: co_box_launch
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", 
  look = 'default',
  header = "Terminology",
  contents = "
I'll be using the term 'launch' to differentiate successfully running an application locally (either in the IDE window, viewer pane, or browser) from clicking on the **Run App** icon or calling `runApp()` and deploying an application to shinyapps.io.",
  fold = FALSE
)
```

```{r}
#| label: git_margin_box_shinyAppPkg_main
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "alt",
  fig_pw = '75%', 
  branch = "06b_pkg-imports", 
  repo = 'shinyAppPkg')
```

```{r}
#| eval: false 
#| code-fold: show
#| code-summary: 'show/hide app.R'
# pkgs <- c("shiny", "shinythemes", "stringr", "ggplot2", "rlang") # <1> 
# install.packages(pkgs, quiet = TRUE) # <1> 

# packages ------------------------------------ # <2> 
library(shinyAppPkg) # <2> 

# movies_app ------------------------------------ # <3> 
movies_app() # <3> 
```
1. Install packages (if needed)   
2. Load package   
3. Call standalone app function  

`movies_app()` is a wrapper function for `shinyApp()`, where it passes `movies_ui()` and `movies_server()` to the `ui` and `server` arguments.

### Clicking 'Run App'

As we can see in the image below, the **Run App** icon is available in the **Source** pane:

:::{#fig-05_app_main_runApp_icon}

![`app.R` in `main` branch](img/08_launch_pkg_imports_runApp_icon.png){#fig-05_app_main_runApp_icon width=100%}

**Run App** icon in `app.R` of `main` branch
:::

If we load the code in `R/` with `load_all()`, then click on **Run App**, we see this calls `runApp()` in the **Console**, but this also produces a warning: 

::: {#fig-06_app_pkg_imports_runApp_console}

![Calling `runApp()` in `main`](img/08_launch_pkg_imports_runApp_console.png){#fig-06_app_pkg_imports_runApp_console width=100%}

The application is launched (with the `loadSupport()` warning)
:::

## [`app.R`]{style="font-size: 0.95em"} ([`05_roxygen2`]{style="font-size: 0.95em"} branch)

Let's jump back to the `05_roxygen2` branch of `shinyAppPkg`. This is the first version of `shinyAppPkg` with `movies_app()` in the `R/` folder (i.e., in `R/movies_app.R`).

```{r}
#| label: git_margin_box_shinyAppPkg_05_roxygen2
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "alt",
  fig_pw = '75%', 
  branch = "05_roxygen2", 
  repo = 'shinyAppPkg')
```

```{bash}
#| eval: false
#| code-fold: false
R/
├── mod_scatter_display.R
├── mod_var_input.R
├── movies_app.R  # <1> 
├── movies_server.R
├── movies_ui.R
└── utils.R

1 directory, 6 files
```
1. The `movies_app()` standalone function 

By moving the call to `shinyApp()` into the `R/` folder, we no longer have the **Run App** icon in the `app.R` file:

:::{#fig-08_launch_roxygen_no_runApp_icon}

![`app.R` in `05_roxygen2` branch](img/08_launch_roxygen_no_runApp_icon.png){#fig-08_launch_roxygen_no_runApp_icon width=100%}

No **Run App** icon in `app.R` of `05_roxygen2` branch
:::

In the `05_roxygen2` branch, the `movies_app()` function hasn't been exported, so we should expect the following error when we run the contents of `app.R`:

```{verbatim}
#| eval: false
#| code-fold: false
Error in movies_app() : could not find function "movies_app"
```

However, calling `runApp()` from the **Console** will launch the app.

### Calling [`runApp()`]{style="font-size: 0.95em"}

This behavior might be surprising to you--`runApp()` can launch the application in `shinyAppPkg`, even without the standalone app function exported from the package namespace (but it still produces the `loadSupport()` warning).

:::{#fig-06_app_roxygen2_runApp_console}

![`runApp()` with `05_roxygen2` branch](img/08_app_roxygen2_runApp_console.png){#fig-06_app_roxygen2_runApp_console width=100%}

Calling `runApp()` in the **Console** of `05_roxygen2` branch
:::



### [`loadSupport()`]{style="font-size: 0.95em"}--feature or bug?

The warning in the **Console** is telling us `loadSupport()`[^load-support-shiny-chap] has detected that `shinyAppPkg` is a package, but it's still sourcing the `R/` subdirectory.

[^load-support-shiny-chap]: If you recall, we covered the  [`loadSupport()`](https://shiny.posit.co/r/reference/shiny/1.5.0/loadsupport) function in [Chapter 1](https://mjfrigaard.github.io/shinyap/shiny.html#r).

:::: {.callout-important collapse="true" title="Warning in loadSupport"}

::: {style='font-size: 1.05em; color: #696969;'}

```{r}
#| eval: false 
#| code-fold: false
shiny::runApp()
```

```{bash}
#| eval: false 
#| code-fold: false
#| code-overflow: wrap
Warning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL):
  Loading R/ subdirectory for Shiny application, but this directory 
  appears to contain an R package. 
  Sourcing files in R/ may cause unexpected behavior.
```

::: 

::::

The examples above demonstrate the differences between calling `shinyApp()` and `runApp()`, and the tensions between having a standalone app function in an R package vs. having an `app.R` file in a Shiny project.

In the following sections, we'll compare `shinyApp()`, `shinyAppDir()`, and `runApp()` to determine which one to use in `R/movies_app.R` and the `app.R` file.   

## Launching your shiny app

<!-- https://rtask.thinkr.fr/shinyapp-runapp-shinyappdir-difference/ -->

[`shinyApp()`]{style="font-style: italic; font-size: 1.25em"}, [`shinyAppDir()`]{style="font-style: italic; font-size: 1.25em"}, or [`runApp()`]{style="font-style: italic; font-size: 1.25em"}

During development, the Posit Workbench IDE provides the **Run App** icon for launching the application. 

![The **Run App** icon in the **Source** pane calls `runApp()`)](img/Run_App.png){width='40%'}

As we've seen, **Run App** calls `runApp()`, even when we have a call to `shinyApp()` in the `app.R` file. This might make you wonder, 

*"Why even include a call to `shinyApp()` if the app is being launched with `runApp()`?"* 

Let's review what happens when we call `shinyApp()`, `shinyAppDir()`, and `runApp()`:

### [`shinyApp()`]{style="font-size: 0.95em"}

:::: {.callout-note collapse="true" title="`shinyApp()`"}

::: {style='font-size: 1.05em; color: #696969;'}

:::{layout="[45,55]" layout-valign="center"}

[`shinyApp()`]{style="font-size: 0.95em"}: Creates and launches an app defined inline within the call itself (or with UI and server functions passed as arguments).

```{r}
#| eval: false 
#| code-fold: false
shinyApp(
  ui = fluidPage(
    # UI elements
  ),
  server = function(input, output) {
    # Server logic
  }
)
```

:::

:::

::::

One of the key features of `shinyApp()` is the creation of the `shiny.appobj` (a `shiny` app object):

```{r}
#| eval: false 
#| code-fold: false
app <- shinyApp(ui = movies_ui, 
                server = movies_server)
str(app)
```

If we look at the structure of the returned object from `shinyApp()`, we see the `shiny.appobj` includes the `appDir` under `appOptions`: 

```{bash}
#| eval: false 
#| code-fold: false
List of 5
 $ httpHandler     :function (req)  
 $ serverFuncSource:function ()  
 $ onStart         : NULL
 $ options         : list()
 $ appOptions      :List of 2
  ..$ appDir       : chr "/path/to/shinyAppPkg" # <1>
  ..$ bookmarkStore: NULL
 - attr(*, "class")= chr "shiny.appobj" # <2>
```
1. `appDir` is the first argument of `runApp()`   
2. A shiny app object  

This is why `runApp()` works with any `.R` file creating a shiny app object.

### [`shinyAppDir()`]{style="font-size: 0.95em"}

:::: {.callout-note collapse="true" title="`shinyAppDir()`"}

::: {style='font-size: 1.05em; color: #696969;'}

:::{layout="[45,55]" layout-valign="center"}

[`shinyAppDir()`]{style="font-size: 0.95em"}: Launches an app from a directory (with an `app.R` or `ui.R`/`server.R` files).

```{r}
#| eval: false 
#| code-fold: false
shinyAppDir(
  appDir = "path/to/app/", 
  options = list())
```

:::

:::

::::

`shinyAppDir()` is similar to `shinyApp()`, but is designed to use a "*path to directory that contains a Shiny app.*"

In practice, we can use `shinyAppDir()` with a returned object from `shinyApp()`:

```{r}
#| eval: false 
#| code-fold: false
app <- shinyApp(
        ui = movies_ui,
        server = movies_server
      )
app$appOptions$appDir
```

```{bash}
#| eval: false 
#| code-fold: false
[1] "path/to/shinyAppPkg"
```

This path can be passed to the `appDir` argument (along with any shiny `options`).

```{r}
#| eval: false 
#| code-fold: false
shinyAppDir(
  appDir = app$appOptions$appDir,
  options(test.mode = TRUE)
)
```

### [`runApp()`]{style="font-size: 0.95em"}

:::: {.callout-note collapse="true" title="`runApp()`"}

::: {style='font-size: 1.05em; color: #696969;'}

:::{layout="[45,55]" layout-valign="center"}

[`runApp()`]{style="font-size: 0.95em"}: A generalized way to launch your app--it can run apps defined inline, or from a directory.

```{r}
#| eval: false 
#| code-fold: false
runApp(
  appDir = "path/to/app/",
  test.mode = TRUE/FALSE)
```

:::

:::

::::

The reason we're able to call `runApp()` in the **Console** to launch both applications above is because it's versatile:

:::{layout="[45,55]" layout-valign="center"}

#### [`runApp()`]{style="font-size: 0.85em"}

Can launch an app from a directory (i.e., from `ui.R`/`server.R`, or a `app.R`):

#### [In `shinyAppPkg`]{style="font-size: 0.85em"}

```{r}
#| eval: false 
#| code-fold: false
# In console
runApp()
```

Works with a path to an `.R` file that creates a `shiny.appobj`:[^launch-run-app-shiny-examples]

[^launch-run-app-shiny-examples]: Shiny's examples are run [using `runApp()`](https://github.com/rstudio/shiny/blob/9ebcbf8a2dec7045f609624d5f339e9a3e29de5f/R/runapp.R#L436)

```{r}
#| eval: false 
#| code-fold: false
runApp(appDir = "path/to/shinyAppPkg")
```

Can also use a `shiny.appobj` directly:

```{r}
#| eval: false 
#| code-fold: false
app <- shinyApp(
        ui = movies_ui,
        server = movies_server)
runApp(appDir = app)
```

:::

This final method does not produce the `loadSupport()` warning because a Shiny object (`shiny.appobj`) has already been created, and `runApp()` is essentially calling `print(app)` in the **Console**.

#### Recap

`shinyApp()` is typically used to create apps within an interactive R session, while `shinyAppDir()` runs a Shiny app stored in a directory (containing an `app.R` file (or `ui.R` and `server.R` files). `runApp()` also launches apps in a directory, but it's versatility makes it suitable for running apps in various formats, either defined inline or in separate directories.[^shiny-app-launchers]

[^shiny-app-launchers]: It's worthwhile to read the documentation on  [`shinyApp()`, `shinyAppDir()`](https://shiny.posit.co/r/reference/shiny/0.14/shinyapp), and [`runApp()`](https://shiny.posit.co/r/reference/shiny/1.7.4/runapp).

## App launch options 

Below I'll cover two options to consider when writing a standalone app function (and what you'll include in `app.R`).

### [`if (interactive())`]{style="font-size: 0.95em"}

The first thing we should include is a check to see if there is a "*[human operator to interact with](https://stat.ethz.ch/R-manual/R-devel/library/base/help/interactive.html)*" with `base::interactive()`:

```{r}
#| eval: false 
#| code-fold: false
if (interactive()) {
  
} else {
   
}
```

You have probably seen control flow like this in `shiny` help file examples (like `flowLayout()` below):

:::{#fig-08_flowLayout_examples}

![`if (interactive())` in `flowLayout()` example](img/08_flowLayout_examples.png){#fig-08_flowLayout_examples width=100%}

Running examples 'interactively' let's us see the app demo beneath the code
:::

`if (interactive())` allows us to distinguish between launching the app from a Posit Workbench session (i.e., during development) and deploying the application (i.e., publishing the application on Posit Connect).

### [`test.mode`]{style="font-size: 0.95em"}

One of the shiny options to consider including is the ability to control the application's behavior with `test.mode`:

> '*Should the application be launched in test mode? This is only used for recording or running automated tests. Defaults to the `shiny.testmode` option, or `FALSE` if the option is not set.*'

The `test.mode` argument lets us [export values from our application]((https://shiny.posit.co/r/reference/shiny/1.0.2/exporttestvalues)) when we're running tests (which we'll cover in-depth in the testing chapter). 

We'll make `test` an logical argument (defaulting to `FALSE`) in our updated  `movies_app()` function.

```{r}
#| eval: false 
#| code-fold: false
if (test) {
  shinyApp(                           # <1>
    ui = movies_ui,                   # <2>
    server = movies_server,           # <2>
    options = list(test.mode = TRUE)  # <3>
  )
} else {
  shinyApp(                           # <1>
    ui = movies_ui,
    server = movies_server, 
    options = list(test.mode = FALSE)
  )
}
```
1. We don't need to explicitly namespace shiny functions (i.e., with `shiny::`) because we're using `#' @import shiny` in the `R/movies_app.R` file       
2. Build the shiny app object with `movies_ui` and `movies_server`   
3. Include option for `test.mode`    


### [`shinyViewerType`]{style="font-size: 0.95em"}

I've written `display_type()` helper function to control where the Shiny app is displayed. The `run` argument in `display_type()` takes the following options: 

-   `"p"` = **Viewer Pane**  
-   `"w"` = **IDE Window**   
-   `"b"` = **External browser**   

The option to access configuration is `shiny.launch.browser`:[^launch-shiny.launch.browser]

[^launch-shiny.launch.browser]: The `shiny.launch.browser` options are covered in [this blog post by Garrick Aden-Buie](https://www.garrickadenbuie.com/blog/shiny-tip-option-where-to-run/), and I've combined them into a `run` argument in `movies_app()`

```{r}
#| eval: false 
#| code-fold: false
display_type <- function(run = "w") {
  if (run == "p") {
    options(shiny.launch.browser = .rs.invokeShinyPaneViewer)
  } else if (run == "b") {
    options(shiny.launch.browser = .rs.invokeShinyWindowExternal) 
  } else if (run == "w") {
    options(shiny.launch.browser = .rs.invokeShinyWindowViewer) 
  } else {
    options(shiny.launch.browser = NULL)
  }
    shinyViewerType <- getOption('shiny.launch.browser') |> 
                        attributes() |> 
                        unlist() |> 
                        unname()
    cli::cli_alert_info("shinyViewerType set to {shinyViewerType}")
}
```
1. Set option   
2. Get option  
3. Print option to console  

The `roxygen2` documentation for `display_type()` is below: 

```{r}
#| label: co_box_cli
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = 'minimal',
  header = "Dependency watch!",
  contents = "
The `cli` package is imported as part the `devtools`/`usethis` workflow, otherwise we'd want to add it the `Imports` field of the `DESCRIPTION` with `usethis::use_package('cli')`.
  ",
  fold = TRUE
)
```



```{r}
#| eval: false 
#| code-fold: true 
#| code-summary: 'show/hide roxygen2 for R/display_type.R'
#' Shiny app display mode helper
#'
#' @param run where to launch app: 
#'  * `"p"` = launch in viewer pane 
#'  * `"b"` = launch in external browser  
#'  * `"w"` = launch in window (default)
#'
#' @return notification of `shinyViewerType` option
#' 
#' @export
#'
```



## Updated [`movies_app()`]{style="font-size: 0.95em"}

In `movies_app()`, I'll add the `interactive()` check, `display_type()`, and `test.mode` option:

```{r}
#| eval: false 
#| code-fold: false
movies_app <- function(test = FALSE, run = "w") {
  
  if (interactive()) { # <1> 
      
      # App launched from interactive session
      display_type(run = run) # <2> 
      
      if (isTRUE(test)) { 
        shinyApp(  # <3> 
          ui = movies_ui,  # <3> 
          server = movies_server,  # <3> 
          options = list(test.mode = TRUE)  # <3> 
        )  # <3> 
      } else {  
        shinyApp( # <4> 
          ui = movies_ui, # <4> 
          server = movies_server,  # <4> 
          options = list(test.mode = FALSE) # <4> 
        ) # <4> 
      }
    
  } else {
    
    # App deployed 
    shinyApp(ui = movies_ui(),
             server = movies_server)
    
  }
}
```
1. Check if interactive (Workbench) launch  
2. Set `shinyViewerType` option with `display_type()`     
3. Launch app in test mode    
4. Launch app   

After loading, documenting, and installing the package, I can test my new standalone app function: 

```{r}
#| label: dev_key_all_00
#| echo: false
#| results: asis
#| eval: true
hot_key("all")
```

:::{#fig-08_launch_movies_app_updated}

![updated `movies_app()` function](img/08_launch_movies_app_updated.png){#fig-08_launch_movies_app_updated width=100%}

`movies_app()` launches the application without the `loadSupport()` warning.
:::

Now we can see `movies_app()` is launching the application without the `loadSupport()` warning. We can also adjust the `test` and `run` arguments to see make sure these are implemented correctly:

:::{#fig-08_launch_movies_app_updated_options}

![`test` and `run` arguments in `movies_app()`](img/08_launch_movies_app_updated_options.png){#fig-08_launch_movies_app_updated_options width=100%}

Testing the options in `movies_app()`
:::



## Updated [`app.R`]{style="font-size: 0.95em"}

Below are a few options to consider including in your `app.R` file. There are multiple ways to launch an application from this file, so of these options are required (but you might find them helpful!).

### [`if (!interactive())`]{style="font-size: 0.95em"}

######

[What if the session isn't interactive (i.e., `!interactive() == TRUE`)?]{style="font-style: italic; color: #696969; "}

In this case, we'll divert all regular output to the standard error stream.

#### [`stderr()`]{style="font-size: 0.85em"}

The `sink()` function *"diverts R output to a connection"*, so the code below sends the output that would normally print to the console to the where error messages are written.

```{r}
#| eval: false 
#| code-fold: false
if (!interactive()) {
   sink(stderr(), type = "output")
} else {
   
}
```


This is useful in a non-interactive settings if we want to re-direct the error output for the console text-mode connection.

#### [`tryCatch()`]{style="font-size: 0.85em"}

`tryCatch()` is used for 'catching conditions' during the execution of an expression (`expr = `):

```{r}
#| eval: false 
#| code-fold: false
if (!interactive()) {
   sink(stderr(), type = "output")
   tryCatch(expr = {
      library(shinyAppPkg)
   }, error = function(e) {
      pkgload::load_all()
   })
} else {
   
}
```

In this case, if `library(shinyAppPkg)` throws an error, the function specified after `error =` is executed (i.e., `pkgload::load_all()`).[^launch-pkgload-load_all]

[^launch-pkgload-load_all]: `pkgload` is part of the [conscious uncoupling](https://www.tidyverse.org/blog/2018/10/devtools-2-0-0/) of the `devtools` package we learned about back in [Chapter 3](https://mjfrigaard.github.io/shinyap/dependencies.html).

Written this way, in a non-interactive R session, `app.R` will re-direct the error output and attempt to load and attach `shinyAppPkg`, and if this fails, `app.R` will attempt to load all the files in the `R/` folder. 

### [`pkgload`]{style="font-size: 0.95em"}

```{r}
#| label: co_box_pkgload
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = 'minimal',
  header = "Dependency watch!",
  contents = "
The `pkgload` package is imported as part the `devtools`/`usethis` workflow, otherwise we'd want to add it the `Imports` field of the `DESCRIPTION` with `usethis::use_package('pkgload')`.
  ",
  fold = TRUE
)
```

If the session ***is*** interactive (i.e., `!interactive() == FALSE`), we want `app.R` to load all the code in the `R/` folder with `pkgload::load_all()`.[^launch-calling-load_all]

```{r}
#| eval: false 
#| code-fold: false
if (!interactive()) {
   sink(stderr(), type = "output")
   tryCatch(expr = {
      library(shinyAppPkg)
   }, error = function(e) {
      pkgload::load_all()
   })
} else {
   pkgload::load_all()
}
```

[^launch-calling-load_all]: `pkgload::load_all()` is the function that's actually called when we run `devtools::load_all()` (or use [<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>]{style="font-weight: bold; font-size: 0.75em"}), and this is somewhat analogous to running `library(shinyAppPkg)`

### [`withr`]{style="font-size: 0.95em"}


```{r}
#| label: co_box_withr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = 'minimal',
  header = "Dependency watch!",
  contents = "
The `withr` package is imported as part the `devtools`/`usethis` workflow, otherwise we'd want to add it the `Imports` field of the `DESCRIPTION` with `usethis::use_package('withr')`.
  ",
  fold = TRUE
)
```





The [`withr` package](https://withr.r-lib.org/) is designed to '*run code with safely and temporarily modified global state*', and it comes in handy when launching shiny apps. For example, I want to turn off the `loadSupport()` behavior when launching the app from `app.R`.[^launch-r-folder]

[^launch-r-folder]: You can read more about the `shiny.autoload.r` option and `loadSupport()` in [this article](https://shiny.posit.co/r/articles/build/app-formats/index.html#the-r-directory)

I can use `withr::with_options()` to accomplish this using the following `new` and `code` arguments 

1. `new`: a named list of the *new options and their values*  
2. `code`: the '*Code to execute in the temporary environment*

I want to place the `withr::with_options()` at the top of `app.R` and pass contents of `app.R` into the `code` argument. Just to be sure no options for `shiny.autoload.r` previously exist, I'll also set this option to `NULL` *before* executing the rest of the code.

```{r}
#| eval: false 
#| code-fold: false
# reset loadSupport()
options(shiny.autoload.r = NULL)
# set option to turn off loadSupport() ----
withr::with_options(new = list(shiny.autoload.r = FALSE), code = {
  if (!interactive()) {
    sink(stderr(), type = "output")
    tryCatch(
      expr = {
        # load package ----
        library(shinyAppPkg)
      },
      error = function(e) {
        # load R/ folder ----
        pkgload::load_all()
      }
    )
    # create shiny object ----
    shiny::shinyApp(
      ui = movies_ui,
      server = movies_server
    )
  } else {
    # load R/ folder ----
    pkgload::load_all()
    # create shiny object ----
    shiny::shinyApp(
      ui = movies_ui,
      server = movies_server
    )
  }
})
```

Now that we've updated the `app.R` account for the app-package structure, we should load, document, and install `shinyAppPkg` and run it's contents: 

```{r}
#| label: dev_key_all_01
#| echo: false
#| results: asis
#| eval: true
hot_key("all")
```

## Running [`app.R`]{style="font-size: 1.10em"}

When we send the contents of `app.R` to the **Console**, the `loadSupport()` options are applied before running the app:

```{r}
#| label: git_box_08_launch-app
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "standard",
  fig_pw = '75%', 
  branch = "08_launch-app", 
  repo = 'shinyAppPkg')
```


:::{#fig-08_launch_run_app_dot_r}

![Sending `app.R` to **Console**](img/08_launch_run_app_dot_r.png){#fig-08_launch_run_app_dot_r width=100%}

The application is launched without the `loadSupport()` warning
:::


```{r}
#| label: co_box_disable_autoload
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "g",
  header = "`R/_disable_autoload.R`",
  contents = "
In the documentation for `loadSupport()`, you'll find a second option for removing the `R/` directory sourcing behavior: placing a `_disable_autoload.R` file in the `R/` directory (this is also one of the behaviors of the [`golem` framework](https://github.com/ThinkR-open/golem/blob/365a5cc303b189973abab0dd375c64be79bcf74a/R/disable_autoload.R), which we will cover in the following chapters).
  
Both methods work--this chapter demonstrates a way to remove the `loadSupport()` warning without having to add this file.
  
  ",
  fold = TRUE
)
```

## Deploying the app

To deploy the app, I can click on the **Publish** icon: 

:::{#fig-08_launch_deploy_app_dot_r}

![Click on the **Publish** icon](img/08_launch_deploy_app_dot_r.png){#fig-08_launch_deploy_app_dot_r width=100%}

Send app.R to **Console** and click **Publish**
:::

Make sure all the files in the package are selected, then click **Publish**

:::{#fig-08_launch_publish_app}

![Publishing apps to `shinyapps.io`](img/08_launch_publish_app.png){#fig-08_launch_publish_app width=100%}

Publish the entire package to `shinyapps.io`
:::

The **Deploy** pane will open and you'll see a deployment log as your application is sent to the server: 

```{bash}
#| eval: false 
#| code-fold: true 
#| code-summary: 'show/hide deployment log'
── Preparing for deployment ────────────────────────────────────────────────────
ℹ Creating application on server...
✔ Created application with id 10026672
ℹ Bundling 24 files: .Rbuildignore, app.R, DESCRIPTION, launch.R, movies.RData, NAMESPACE, README.md, www/shiny.png, man/display_type.Rd, man/mod_scatter_display_server.Rd, man/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, man/mod_var_input_ui.Rd, man/movies_app.Rd, man/movies_server.Rd, man/movies_ui.Rd, man/scatter_plot.Rd, R/display_mode.R, …, R/movies_ui.R, and R/scatter_plot.R
ℹ Capturing R dependencies with renv
✔ Found 63 dependencies
✔ Created 258,028b bundle
ℹ Uploading bundle...
✔ Uploaded bundle with id 7740376
── Deploying to server ─────────────────────────────────────────────────────────
Waiting for task: 1340526445
  building: Parsing manifest
  building: Building image: 9212796
  building: Fetching packages
  building: Installing packages
  building: Installing files
  building: Pushing image: 9212796
  deploying: Starting instances
  rollforward: Activating new instances
  unstaging: Stopping old instances
── Deployment complete ─────────────────────────────────────────────────────────
✔ Successfully deployed to <https://yourusername.shinyapps.io/shinyap-run-app/>
Deployment completed: https://yourusername.shinyapps.io/shinyap-run-app/
```

You can view a deployed version of this application [here.](https://mjfrigaard.shinyapps.io/shinyap-08_launch-app/)

## Recap

This chapter has covered some options for launching your app within your app-package. We went over what to include in the standalone app function and the `app.R` file, the differences between `shinyApp()`, `shinyAppDir()` and `runApp()`, but it's worth exploring these topics further (especially if you plan on having more than one apps in your package).

```{r}
#| label: co_box_app_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b",
  header = "Recap: launching your app",
  contents = "

**`shinyApp()`**: 

-   `shinyApp()` doesn't care about file structure, so it's useful for quick prototyping or if the app is in a single `.R` script. It's also more portable because you can share your app with a single `.R` script.

    -   It's possible to bundle `shinyApp()` in a wrapper function to integrate within an R package (like we've done with `movies_app()`).

    -    `shinyApp()` returns a shiny app object, which can be useful if you want to explore the app structure programmatically (i.e., testing).
  
**`shinyAppDir()`**: 
  
-   `shinyAppDir()` launches an app from a directory, and is useful if an app is spread across multiple files and folders.

**`runApp()`**

-   `runApp()` a more generalized way to launch an app. It works with:
  
    -   apps contained in a directory (i.e., `runApp('path/to/app')`
  
    -   apps in separate `ui.R` and `server.R` files (or a single `app.R` file)
  
    -   a shiny app object (passed to the `appDir` argument).
  
-   Clicking on **Run App** will run the application with `runApp()` if is detects a file (or files) that creates a shiny object.
  
  ", 
  fold = FALSE
)
```

In the following chapter, we're going to cover how to ensure `movies.Data` becomes part of the `shinyAppPkg` namespace.
