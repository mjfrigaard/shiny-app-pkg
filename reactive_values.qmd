# [reactiveValues()]{style="font-size: 0.95em;"} {#sec-reactiveValues}

<!--
https://shiny.posit.co/r/articles/improve/debugging/
https://debruine.github.io/shinyintro/debugging.html
-->

```{r}
#| label: _common
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(lobstr)
library(shiny)
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", 
  look = "minimal",
  header = "Caution",
  contents = "This chapter is under review.",
  fold = FALSE
)
```

This chapter covers using `reactiveValues()` to store reactive values. Determining whether or not to use `reactiveValues()` will depend on the purpose you want it to serve in your application. [^reactive-values-intro]


[^reactive-values-intro]: Mastering Shiny also has a [great section](https://mastering-shiny.org/reactivity-objects.html#reactive-values) on `reactiveVal()` and `reactiveValues()`


```{r}
#| label: git_box_spec_topic-reactiveValues
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  fig_pw = '65%', 
  branch = "spec_topic-reactiveValues", 
  repo = 'moviesApp')
```


## `reactiveValues()`

Calling `reactiveValues()` will create *"an object for storing reactive values."* [^reactives-shiny-doc-reactive-values] We've been storing the reactive values returned from the `var_input` module in the `selected_vars` object, then passing these values into the `scatter_display` module.

```{r}
#| eval: false 
#| code-fold: false
movies_server <- function(input, output, session) {

      selected_vars <- mod_var_input_server("vars") # <1> 

      mod_scatter_display_server("plot", var_inputs = selected_vars) # <2>
      
}
```
1. reactive values returned from `var_input` module  
2. reactive values passed to `scatter_display` module  


Below is a demonstration of using `reactiveValues()` to capture the `selected_vars` values returned from the `var_input` module and passed to the `scatter_display` module.


[^reactives-shiny-doc-reactive-values]: Read more in the [Shiny documentation.](https://shiny.posit.co/r/reference/shiny/0.11/reactivevalues)

### App server

The first changes in this branch you'll notice are a series of changes made to `movies_server()`: 

-   `reactiveValues()` is used to create `rVals`

-   Instead of creating the `selected_vars`, the output from `mod_var_input_server()` is assigned to `rVals` as `inputs`

-   `rVals` is then passed as an input argument to `mod_scatter_display_server()`

-   `.dev` arguments have been added to both module server functions (and have been set to `FALSE`)

```{r}
#| eval: false 
#| code-fold: false
# assign inputs to rVals
movies_server <- function(input, output, session) {
  
    # create reactive values
    rVals <- reactiveValues() # <1>

    # assign inputs to rVals
    rVals$inputs <- mod_var_input_server("vars", .dev = FALSE) # <2>
    
    # view output in the UI
    # output$vals <- renderPrint({ # <3>
    #   str(rVals)
    #   # str(rVals$inputs())
    # }) # <3>

    # pass reactive values to display
    mod_scatter_display_server("plot", rVals = rVals, .dev = FALSE) # <4>
      
}
```
1. New `reactiveValues()` object   
2. Returned values from `mod_var_input_server()` assigned to `rVals$inputs`   
3. `renderPrint()` for `str(rVals)` and `str(rVals$inputs())` (commented)   
4. `rVals` object passed to `mod_scatter_display_server()`   

In the steps below, we'll view the structure and function of `rVals` and the reactive values in the application using methods covered in the [Debugging chapter](debugging.qmd).

#### Step 1

Change `.dev` in `mod_var_input_server()` to `TRUE` in `movies_server()`, then load and run the application. The updated `movies_server()` function should look like this:


```{r}
#| eval: false 
#| code-fold: false
# assign inputs to rVals
movies_server <- function(input, output, session) {
  
    # create reactive values
    rVals <- reactiveValues()

    # assign inputs to rVals
    rVals$inputs <- mod_var_input_server("vars", .dev = TRUE) # <1>
    
    # view output in the UI
    # output$vals <- renderPrint({
    #   str(rVals)
    #   # str(rVals$inputs())
    # })

    # pass reactive values to display
    mod_scatter_display_server("plot", rVals = rVals, .dev = FALSE)
      
}
```
1. Set `.dev` to `TRUE`

When the application launches, you should see the following:[^reactives-debugging-ref]

[^reactives-debugging-ref]: The methods used in this chapter can be found in the chapter on [Debugging](debugging.qmd) 

::::{.column-body-outset-right}

:::{#fig-reactive_values_input_dev}

![`.dev = TRUE` in `mod_var_input_server()`](images/reactive_values_input_dev.png){#fig-reactive_values_input_dev width='100%' align='center'}

 reactive values from `mod_var_input_server()`
:::

::::

The output in the sidebar are the reactive values from the variable input module, which we'll cover below.

### Modules 

`mod_var_input_server()` has been simplified to return the output from `reactiveValuesToList()`. The same output is also being rendered in the sidebar when `.dev` is set to `TRUE`:

```{r}
#| eval: false 
#| code-fold: false
mod_var_input_server <- function(id, .dev = TRUE) {

  moduleServer(id, function(input, output, session) {
    
    if (.dev) {
      # view output in the UI
      output$vals <- renderPrint({
        x <- reactiveValuesToList(input, all.names = TRUE)
        str(x)
      })
    }
    
    # return reactives
    return(
      reactive({
        reactiveValuesToList(input, all.names = TRUE)
      })
    )

  })
}
```

#### Step 2

Remove the comments from the `renderPrint()` lines in `movies_server()` to view the structure of `rVals`, then load and run the application. The new `movies_server()` function should now look like this:

```{r}
#| eval: false 
#| code-fold: false
# assign inputs to rVals
movies_server <- function(input, output, session) {
  
    # create reactive values
    rVals <- reactiveValues()

    # assign inputs to rVals
    rVals$inputs <- mod_var_input_server("vars", .dev = TRUE) # <1> 
    
    # view output in the UI
    output$vals <- renderPrint({  # <2> 
      str(rVals)
      # str(rVals$inputs())
    }) # <2>

    # pass reactive values to display
    mod_scatter_display_server("plot", rVals = rVals, .dev = FALSE)
      
}
```
1. Set `.dev` to `TRUE`
2. Remove comments from `str(rVals)`

::::{.column-body-outset-right}

:::{#fig-reactive_values_input_server_dev_01}

![`str(rVals) `from `movies_server()`](images/reactive_values_input_server_dev_01.png){#fig-reactive_values_input_server_dev_01 width='100%' align='center'}


`rVals$inputs()` from `movies_server()`
:::

::::


### What is `reactiveValues()`?

> *"When you read a value from it, the calling reactive expression takes a reactive dependency on that value, and when you write to it, it notifies any reactive functions that depend on that value. **Note that values taken from the `reactiveValues()` object are reactive, but the `reactiveValues()` object itself is not**."* [Shiny Documentation](https://shiny.posit.co/r/reference/shiny/1.7.2/session.html)

I've added emphasis to the quote above because it's important to remember that any object assign to `reactiveValue()` should be treated like any reactive object (i.e., and `inputId` or object returned from `reactive()` or `observe()`). 

For example, if we try to access the input values as a list outside the a `movies_server()` or module function, we see the following error:[^reactives-isolate] 

[^reactives-isolate]: We *can* access the values by wrapping the assigned object in `isolate()`. Read more in the [documentation on `reactiveValues()`](https://shiny.posit.co/r/reference/shiny/1.7.2/session.html).

```{r}
#| eval: false 
#| error: true 
#| code-fold: false
#| collapse: true
x <- reactiveValues(
  inputs = list(x = "imdb_rating",
                y = "audience_score",
                z = "mpaa_rating",
                alpha = 0.5,
                size = 2,
                plot_title = "Enter Plot Title")
  )
x$inputs()
```

```{r}
#| eval: false 
#| code-fold: false
## Error in `x$inputs`:
## ! Can't access reactive value 'inputs' outside of reactive consumer.
## â„¹ Do you need to wrap inside reactive() or observe()?
```



#### Step 3

Now let's remove the commented lines from `renderPrint()` to view the structure of `rVals$inputs()`, then load and run the application. The new `movies_server()` function should now look like this:

```{r}
#| eval: false 
#| code-fold: false
# assign inputs to rVals
movies_server <- function(input, output, session) {
  
    # create reactive values
    rVals <- reactiveValues()

    # assign inputs to rVals
    rVals$inputs <- mod_var_input_server("vars", .dev = TRUE) # <1> 
    
    # view output in the UI
    output$vals <- renderPrint({  # <2> 
      # str(rVals)
      str(rVals$inputs())
    }) # <2>

    # pass reactive values to display
    mod_scatter_display_server("plot", rVals = rVals, .dev = FALSE)
      
}
```
1. Set `.dev` to `TRUE`
2. Remove comments from `str(rVals$inputs())`

::::{.column-body-outset-right}

:::{#fig-reactive_values_input_server_dev_02}

![`str(rVals) `from `movies_server()`](images/reactive_values_input_server_dev_02.png){#fig-reactive_values_input_server_dev_02 width='100%' align='center'}


`rVals$inputs()` from `movies_server()`
:::

::::

The `rVals$inputs()` being rendered in `movies_server()` are the returned values from the variable input module (and they're identical to the value in the sidebar).

When `rVals` is passed to `mod_scatter_display_server()`, the reactive `inputs()` object inside the function can be built using `rVals$inputs()`:

```{r}
#| eval: false 
#| code-fold: false
inputs <- reactive({
  plot_title <- tools::toTitleCase(rVals$inputs()[['plot_title']])
    list(
      x = rVals$inputs()[['x']],
      y = rVals$inputs()[['y']],
      z = rVals$inputs()[['z']],
      alpha = rVals$inputs()[['alpha']],
      size = rVals$inputs()[['size']],
      plot_title = plot_title
    )
})
```

The `.dev` argument displays the structure of `rVals$inputs()` inside `mod_scatter_display_server()` if it's set to `TRUE`:

```{r}
#| eval: false 
#| code-fold: false
    if (.dev) {
      # view output in the UI
      output$display_vals <- renderPrint({
        str(
          rVals$inputs()
          )
      })
    }

```

#### Step 4

Set `.dev` to `TRUE` in `mod_scatter_display_server()`, then load and run the application. The final `movies_server()` function should now look like this:

```{r}
#| eval: false 
#| code-fold: false
# assign inputs to rVals
movies_server <- function(input, output, session) {
  
    # create reactive values
    rVals <- reactiveValues()

    # assign inputs to rVals
    rVals$inputs <- mod_var_input_server("vars", .dev = TRUE) # <1> 
    
    # view output in the UI
    output$vals <- renderPrint({  # <2> 
      # str(rVals)
      str(rVals$inputs())
    }) # <2>

    # pass reactive values to display
    mod_scatter_display_server("plot", rVals = rVals, .dev = TRUE) # <3>
      
}
```
1. Set `.dev` to `TRUE`
2. Remove comments  
3. Set `.dev` to `TRUE`


::::{.column-body-outset-right}

:::{#fig-reactive_values_input_server_dev}

![`.dev` set to `TRUE` and reactive values from `movies_server()`](images/reactive_values_all_dev.png){#fig-reactive_values_input_server_dev width='100%' align='center'}


Both module `.dev` arguments set to `TRUE` and `rVals$inputs()` from `movies_server()` 
:::

::::

An important thing to note is that we can only reference `rVals$inputs()` in a **reactive consumer** (i.e., using `reactive()`, `observe()`, etc.). That's why when we change any of the UI inputs, the values change in `rVals$inputs()` and in the `inputs()` object inside the display module.

You can also view these outputs using `movies_app(run = 'b', bslib = TRUE)`.

## Testing `reactiveValues()` {#sec-testing-reactive-values}

The module tests for `test-mod_scatter_display.R` had to be redesigned to handle the `reactiveValues()` input. You can view the full test file in [this branch](https://github.com/mjfrigaard/moviesApp/blob/spec_topic-reactiveValues/tests/testthat/test-mod_scatter_display.R), but to briefly summarize: 

-   `args = list()` in `testServer()` now takes the output from helper functions (stored in `tests/testthat/helper.R` and `R/testthat.R`). [^reactives-test-helpers]

    ```{r}
    #| eval: true 
    #| code-fold: false
    make_initial_rVals_inputs <- function() {
      rVals <- reactiveValues(
        inputs =
          reactive(list(
            x = "imdb_rating",
            y = "audience_score",
            z = "mpaa_rating",
            alpha = 0.5,
            size = 2,
            plot_title = "Enter Plot Title"
          ))
      )
      return(rVals)
    }
    ```

    -   This creates a `reaciveValues()` list that can be used in the test:

    ```{r}
    #| eval: true 
    #| code-fold: false
    #| collapse: true
    rVals <- make_initial_rVals_inputs()
    rVals
    ```

    -   We can view it's contents by wrapping it in `isolate()`. 

    ```{r}
    #| eval: true 
    #| code-fold: false
    #| collapse: true
    isolate(rVals$inputs())
    ```
    
    -   When `make_initial_rVals_inputs()` is passed to the `args` in `testServer()`, it looks like this: 
    
    ```{r}
    #| eval: false 
    #| code-fold: false
        shiny::testServer(app = mod_scatter_display_server,
          args = list(rVals = make_initial_rVals_inputs()), expr = {
            testthat::expect_equal(
              object = rVals$inputs(),
              expected = list(
                    x = "imdb_rating",
                    y = "audience_score",
                    z = "mpaa_rating",
                    alpha = 0.5,
                    size = 2,
                    plot_title = "Enter Plot Title"
                )
            )
          })
    ```
    

[^reactives-test-helpers]: I resorted to both locations because the `tests/testthat/helper.R` file wasn't loading with `devtools::load_all()`

## Recap 

```{r}
#| label: co_box_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", size = '1.05', hsize = '1.10',
  look = "default",
  header = "Recap: reactives",
  contents = "
#### **`reactiveValues()`**

- An object created with `reactiveValues()` is designed to be reactive, so changing values will trigger reactivity in any observers and/or reactives that depend on those values. Remember that '*values taken from the `reactiveValues()` object are reactive, but the `reactiveValues()` object itself is not.*'
  
  ",
  fold = FALSE
)
```









