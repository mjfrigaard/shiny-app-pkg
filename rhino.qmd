# `rhino` {#sec-rhino}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "y", 
  look = "minimal",
  header = "Caution",
  contents = "The contents for section are being revised. Thank you for your patience."
)
```

```{r}
#| label: co_box_tldr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "r", look = "minimal", size = '1.10', hsize = '1.30',
  header = "![](images/rhino.png){width='10%'} &emsp; The `rhino` framework", 
  fold = FALSE,
  contents = "
<br>
**WARNING**: `rhino` isn't like the previous two frameworks we've covered in this section, because `rhino` doesn't create an app-package.
<br>

- `rhino` apps rely on [`renv`](https://rstudio.github.io/renv/articles/renv.html) and [`box`](https://klmr.me/box/) for managing imported dependencies (instead of the `DESCRIPTION` and `NAMESPACE` files in an R package).
  
- `rhino` requires [node.js](https://www.wikiwand.com/en/Node.js), an open-source JavaScript runtime environment.
  
"
)
```

This chapter briefly describes a version of `moviesApp` built using [`rhino`](https://appsilon.github.io/rhino/). The resulting app (`rap`) is in the [`17_rhino` branch](https://github.com/mjfrigaard/moviesApp/tree/17_rhino). 

```{r}
#| label: git_box_rap
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  contents = "standard",
  fig_pw = '75%', 
  branch = "17_rhino", 
  repo = 'moviesApp')
```

The branch in this chapter is slightly different than the previous `golem` and `leprechaun` branches, because instead of loading, documenting, and installing `rap`, we're going to re-initialize the IDE by selecting **Session** > **Terminate R...**

::: {#fig-rhino_session_terminate}

![Re-initialize the IDE](images/rhino_session_terminate.png){#fig-rhino_session_terminate width='30%' fig-align='center'}

On the `17_rhino` branch, re-initialize the IDE (instead of loading, documenting, and installing)
:::

When the IDE re-opens, we see the `rap` files and notice the **Build** pane has been removed: 

::: {#fig-rhino_app_ide}

![`rhino` app IDE](images/rhino_app_ide.png){#fig-rhino_session_terminate width='100%' fig-align='center'}

Notice the **Build** pane has been removed from the `17_rhino` branch
:::

The **Build** pane is deactivated because **`rhino` applications aren't R packages**.[^rhino-terminate] 

Launch the application in `rap` by opening the `app.R` file and clicking **Run App** (or by passing `rhino::app()` into the **Console**).

::: {#fig-rhino_run_app}

![Calling `rhino::app()`](images/rhino_run_app.png){#fig-rhino_run_app width='100%' fig-align='center'}

Running the application in `rap`
:::



[^rhino-terminate]: I re-initialize the session on the `17_rhino` branch so I'm not tempted to load, document, install, or test the code using the IDE.

## `rap` (a `rhino` app)

The files in `rap` are below: 

```{bash}
#| eval: false 
#| code-fold: false 
├── .Rprofile         # <1> 
├── .github/          # <2> 
│   └── workflows     # <2> 
├── .gitignore
├── .lintr            # <3> 
├── .renvignore       # <4> 
├── .rscignore        
├── README.md
├── app
│   ├── js
│   ├── logic
│   ├── main.R
│   ├── static
│   ├── styles
│   └── view
├── app.R
├── config.yml
├── dependencies.R.  # <5> 
├── moviesApp.Rproj
├── renv             # <6> 
│   ├── .gitignore.   
│   ├── activate.R
│   ├── library
│   ├── settings.json
│   └── staging
├── renv.lock       # <6> 
├── rhino.yml
└── tests
    ├── cypress
    ├── cypress.json
    └── testthat

24 directories, 31 files
```
1. Activates the [`renv` package](https://rstudio.github.io/renv/articles/renv.html)
2. CI/CD via [GitHub actions](https://github.com/r-lib/actions)  
3. Lintr (from [`lintr`](https://lintr.r-lib.org/) package)  
4. `renv` ignore (works like `.gitignore`)   
5. `rhino` app dependencies 
6. `renv` library of packages in app project   

As we can see, most of the standard R package folders and files are missing from `rap`, because `rhino` applications use the [`box` package](https://klmr.me/box/) for importing dependencies and organizing code.[^rhino-box-depends] 

## `rhino` features

The [`rhino` website](https://appsilon.github.io/rhino/articles/explanation/application-structure.html) explains the philosophy behind the application structure above, so I won't repeat that information here. However, I highly recommend reading the available documentation on [`rhino`](https://appsilon.github.io/rhino/articles/tutorial/create-your-first-rhino-app.html) and [`box`](https://klmr.me/box/articles/box.html) before deciding to adopt this framework.[^rhino-recommended-documentation] 


[^rhino-box-depends]: Imported dependencies in `rhino` apps use [`box` modules](https://klmr.me/box/articles/box.html) instead of the `DESCRIPTION` and `NAMESPACE`.

[^rhino-recommended-documentation]: Be sure to read up on [testing box modules](https://klmr.me/box/articles/testing.html) and `rhino` applications [with cypress](https://appsilon.github.io/rhino/articles/tutorial/write-end-to-end-tests-with-cypress.html) and [`shinytest2`](https://appsilon.github.io/rhino/articles/how-to/use-shinytest2.html). 

## `box` modules

A `box` module (not to be confused with a Shiny module) is a collection of `.R` scripts in a specified folder. The modules in a new `rhino` app are stored in the `app/logic/` and `app/view/` folders:[^rhino-code-structure]

[^rhino-code-structure]: `rhino` [recommends](https://appsilon.github.io/rhino/articles/explanation/application-structure.html#philosophy) placing non-Shiny code in the `app/logic` folder and keeping all Shiny modules and reactive code in `app/view`.

```{bash}
#| eval: false 
#| code-fold: false 
app
├── js/ # <1>
├── logic/ # <2>
├── main.R # <3>
├── static/ # <4>
├── styles/ # <5>
└── view/ # <6>

6 directories, 1 file
```
1. JavaScript code
2. Non-shiny code  
3. Primary app file  
4. Static `.js` or `.css`  
5. App CSS files 
6. Shiny modules and app code

### `box::use()`

Below I'll demonstrate how `box` modules work with the `tidyverse_logo()` function from the `tidyverse` meta-package:[^rhino-box-blog-post]

-   If I attempt to use the `tidyverse_logo()` function without installing or loading the `tidyverse` package, I see the following error:

    ```{r}
    #| label: tidyverse_logo_test
    #| echo: true
    #| eval: false
    #| error: true
    #| code-fold: false
    tidyverse_logo()
    ```
    
    ```
    Error in tidyverse_logo(): could not find function "tidyverse_logo"
    ```
    
    -   This is expected, because even if `tidyverse` has been installed, it hasn't been loaded with `libaray(tidyverse)`.

I'll create a new `box` module named `tidy` (which again, is just a folder named `tidy`), and I'll import the `tidyverse_logo()` from `tidyverse` by creating a `logo.R` file with the following code:
    
  - The code must include `#' @export` on the preceding line:

    ```{r}
    #| label: box_tidy
    #| eval: false
    #| code-fold: false
    # contents of tidy/logo.R
    #' @export
    box::use(
      tidyverse[tidyverse_logo] 
    )
    ```
    
    -   Note I **did not** have to use `tidyverse::tidyverse_logo()`

**`box::use()` is used for creating *and* using `box` modules.** The code above places the `tidyverse_logo()` function in the `tidy` module, and we'll also call `box::use(tidy/logo)` to access the `logo` object from the `tidy` module:

  - `box::use(tidy/logo)` loads `logo` into the environment:

    ```{r}
    #| label: box_use_tidy_logo
    #| eval: false
    #| code-fold: false
    box::use(tidy/logo)
    ```
    
    ```bash
     <module: tidy/logo>
    ```
    
    -   I can use `ls()` on `logo` to return the object(s) it imports:
    
    ```{r}
    #| label: ls_logo
    #| eval: false
    #| code-fold: false
    ls(logo)
    ```
    
    ```bash
    [1] "tidyverse_logo"
    ```
    
**To access the objects within a `box` module, use the `$` operator.**

  - `logo$tidyverse_logo()` accesses the `tidyverse_logo()` function:

    ```{r}
    #| label: logo_tidyverse_logo
    #| eval: false
    #| code-fold: false
    logo$tidyverse_logo()
    ```
    
    ```bash
    ⬢ __  _    __   .    ⬡           ⬢  . 
     / /_(_)__/ /_ ___  _____ _______ ___ 
    / __/ / _  / // / |/ / -_) __(_-</ -_)
    \__/_/\_,_/\_, /|___/\__/_/ /___/\__/ 
         ⬢  . /___/      ⬡      .       ⬢ 
    ```
    
`box` modules are totally self-contained, meaning the `tidyverse_logo()` function only exists *inside* the `logo` module.

  - Note what happens when I try to access the `tidyverse_logo()` function by itself:

    ```{r}
    #| label: tidyverse_logo_retest
    #| eval: false
    #| error: true
    #| code-fold: false
    tidyverse_logo()
    ```
    
    ```
    Error in tidyverse_logo(): could not find function "tidyverse_logo"
    ```

By explicitly naming the functions you intend to use with `box::use(package[function])`, `box` modules remove the need install and load packages with `install.packages()` and `library()`.[^rhino-explicit-namespaces]

### Utility functions 

In `rap`, I've placed the non-Shiny utility functions (i.e., the business logic) in `app/logic`:

```{bash}
#| eval: false 
#| code-fold: false 
app/logic
├── __init__.R
├── data.R
└── plot.R

1 directory, 4 files
```

In `app/logic/data.R`, `box::use()` adds the necessary `vroom` functions used to import the `movies.csv` data from the GitHub repository:

```{r}
#| eval: false 
#| code-fold: false 
# contents of app/logic/data.R

#' @export
box::use(
  vroom[vroom, cols, col_skip] # <1>
)

#' import movies data 
#' @export
movies_data <- function() {
  raw_csv_url <- "https://bit.ly/47FPO6t"
  # from 07_data branch!
  vroom(raw_csv_url, # <2>
    col_types = cols(...1 = col_skip())) # <2>
}
```
1. Add `vroom` functions 
2. Call `vroom` functions

In the `app/logic/plot.R` file, `box::use()` adds the necessary `ggplot2` and `rlang` functions for the `scatter_plot()` function:

```{r}
#| eval: false 
#| code-fold: false 
# contents of app/logic/plot.R

#' scatter plot function
#' @export
scatter_plot <- function(df, x_var, y_var, col_var, alpha_var, size_var) {

box::use(
  ggplot2[ggplot, aes, geom_point], # <1> 
  rlang[.data] # <2> 
)
  
  ggplot( # <3>
    data = df,
    aes( 
      x = .data[[x_var]], # <4>
      y = .data[[y_var]], # <4>
      color = .data[[col_var]] # <4>
    )
  ) +
    geom_point(alpha = alpha_var, size = size_var) # <3>
  
}
```
1. Add `ggplot2` functions
2. Add `rlang` functions
3. Use `ggplot2` functions
4. Use `rlang` functions

The `app/logic/__init__.R` file exports the two modules above: 

```{r}
#| eval: false 
#| code-fold: false 
# Logic: application code independent from Shiny.
# https://go.appsilon.com/rhino-project-structure
#' @export
box::use(
  app / logic / data,
  app / logic / plot
)
```

### Shiny modules

Our Shiny `box` modules are placed in `app/view`, and are separated into `inputs` and `display`: 

```{bash}
#| eval: false 
#| code-fold: false 
app/view
├── __init__.R
├── display.R
└── inputs.R

1 directory, 3 files
```

The `box` module stored in `app/view/inputs` is the code from `R/mod_var_input.R`. **`rhino` modules are still broken into `ui` and `server` functions, and `box::use()` is called *within* each function to add the necessary `package[function]`**:

```{r}
#| eval: false 
#| code-fold: true 
#| code-summary: 'view/hide ui from app/view/inputs'
# app/view/inputs.R

# define module functions

#' input values ui
#' @export
ui <- function(id) {
  box::use(
    shiny[
      NS, tagList, selectInput, h3,
      sliderInput, textInput
    ],
  )
  ns <- NS(id)
  tagList(
    selectInput(
      inputId = ns("y"),
      label = "Y-axis:",
      choices = c(
        "IMDB rating" = "imdb_rating",
        "IMDB number of votes" = "imdb_num_votes",
        "Critics Score" = "critics_score",
        "Audience Score" = "audience_score",
        "Runtime" = "runtime"
      ),
      selected = "audience_score"
    ),
    selectInput(
      inputId = ns("x"),
      label = "X-axis:",
      choices = c(
        "IMDB rating" = "imdb_rating",
        "IMDB number of votes" = "imdb_num_votes",
        "Critics Score" = "critics_score",
        "Audience Score" = "audience_score",
        "Runtime" = "runtime"
      ),
      selected = "imdb_rating"
    ),
    selectInput(
      inputId = ns("z"),
      label = "Color by:",
      choices = c(
        "Title Type" = "title_type",
        "Genre" = "genre",
        "MPAA Rating" = "mpaa_rating",
        "Critics Rating" = "critics_rating",
        "Audience Rating" = "audience_rating"
      ),
      selected = "mpaa_rating"
    ),
    sliderInput(
      inputId = ns("alpha"),
      label = "Alpha:",
      min = 0, 
      max = 1, 
      step = 0.1,
      value = 0.5
    ),
    sliderInput(
      inputId = ns("size"),
      label = "Size:",
      min = 0, 
      max = 5,
      value = 2
    ),
    textInput(
      inputId = ns("plot_title"),
      label = "Plot title",
      placeholder = "Enter plot title"
    )
  )
}
```

The `server` function in `app/view/inputs` returns the same reactive list of inputs from the UI: 

```{r}
#| eval: false 
#| code-fold: false
#' input values server
#' @export
server <- function(id) {
  box::use(
    shiny[moduleServer, reactive],
  )

  moduleServer(id, function(input, output, session) {
    return(
      reactive({
        list(
          "x" = input$x,
          "y" = input$y,
          "z" = input$z,
          "alpha" = input$alpha,
          "size" = input$size,
          "plot_title" = input$plot_title
        )
      })
    )
  })
} 
```

The `app/view/display` module contains the code from `R/mod_scatter_display.R`, but with a few changes.

-   The `app/logic/data` and `app/logic/plot` modules are added to `app/view/display` with `box::use()`:

    ```{r}
    #| eval: false 
    #| code-fold: false
    # app/view/display.R
    
    # import data and plot modules
    box::use(
      app / logic / data,
      app / logic / plot
    )
    ```

-   The `ui` in `app/view/display` includes the same UI code from `R/mod_scatter_display.R`, but after the necessary `shiny` functions are added with `box::use()`:

    ```{r}
    #| eval: false 
    #| code-fold: false
    #' display ui
    #' @export
    ui <- function(id) {
      box::use(
        shiny[NS, tagList, tags, plotOutput]
      )
      ns <- NS(id)
      tagList(
        tags$br(),
        tags$blockquote(
          tags$em(
            tags$h6(
              "The code for this application comes from the ",
              tags$a("Building web applications with Shiny",
                href = "https://rstudio-education.github.io/shiny-course/"
              ),
              "tutorial"
            )
          )
        ),
        plotOutput(outputId = ns("scatterplot"))
      )
    }
    ```
    
-   The `server` function adds the `ggplot2`, `shiny`, `tools`, and `stringr` functions with `box::use()` for creating the plot output, and imports the `movies` data with `data$movies_data()`:

    ```{r}
    #| eval: false 
    #| code-fold: false
    #' display server
    #' @export
    server <- function(id, var_inputs) {
      
      # load 
      box::use(
        ggplot2[labs, theme_minimal, theme],
        shiny[NS, moduleServer, plotOutput, reactive, renderPlot],
        tools[toTitleCase],
        stringr[str_replace_all]
      )
    
      moduleServer(id, function(input, output, session) {
        
        # use data$movies_data() ----
        movies <- data$movies_data()
    
        inputs <- reactive({
          plot_title <- toTitleCase(var_inputs()$plot_title)
          list(
            x = var_inputs()$x,
            y = var_inputs()$y,
            z = var_inputs()$z,
            alpha = var_inputs()$alpha,
            size = var_inputs()$size,
            plot_title = plot_title
          )
        })
    
        output$scatterplot <- renderPlot({
          # use plot$scatter_plot() ----
          plot <- plot$scatter_plot(
            df = movies,
            x_var = inputs()$x,
            y_var = inputs()$y,
            col_var = inputs()$z,
            alpha_var = inputs()$alpha,
            size_var = inputs()$size
          )
          plot +
            labs(
              title = inputs()$plot_title,
              x = str_replace_all(
                toTitleCase(inputs()$x ), "_", " " ),
              y = str_replace_all(
                toTitleCase(inputs()$y), "_", " " )
            ) +
            theme_minimal() +
            theme(legend.position = "bottom")
        })
      })
    }
    ```

## [`app/main.R`]{style="font-size: 1.05em;"}

The `app/main.R` file contains the primary UI and Server functions for the application. This file adds the `shiny` functions *and* the `inputs` and `display` modules from `app/view`: 

```{r}
#| eval: false 
#| code-fold: false
# app/main.R

# shiny functions
box::use(
  shiny[
    NS, fluidPage, sidebarLayout, sidebarPanel,
    mainPanel, fluidRow, column, tags, icon,
    textOutput, moduleServer, renderText
  ]
)

# import modules
box::use(
  # load inputs module ----
  app / view / inputs,
  # load display module ----
  app / view / display
)
```

Note that we don't need to import `app/logic` modules in `app/main.R`, because they're imported in their respective `app/view` modules. 

The `ui()` and `server()` functions in `app/main` look very similar to the `movies_ui()` and `movies_server()` functions, except we access the modules using the `$` operator (i.e., `input$ui()`, `display$ui()`, etc.):

```{r}
#| eval: false 
#| code-fold: false
#' rap ui
#' @export
ui <- function(id) {
  ns <- NS(id)
  fluidPage(
    sidebarLayout(
      sidebarPanel(
        # use inputs module UI ----
        inputs$ui(ns("vals"))
      ),
      mainPanel(
        fluidRow(
          column(
            width = 12,
              tags$h3("rap")
            )
        ),
        fluidRow(
          column(
            width = 1,
            offset = 11,
            # example info button ---
            tags$button(
              id = "help-button",
              icon("info"),
              # add 'onclick' after rhino::build_sass()
              # and rhino::build_js()
              onclick = "App.showHelp()"
            )
          )
        ),
        fluidRow(
          column(
            width = 12,
            # use display module UI ----
            display$ui(ns("disp"))
          )
        )
      )
    )
  )
}

#' rap server
#' @export
server <- function(id) {
  moduleServer(id, function(input, output, session) {
    # use inputs module server ----
    selected_vars <- inputs$server(id = "vals")
    # use display module server ----
    display$server(
      id = "disp",
      var_inputs = selected_vars
    )
  })
}
```


## Tests

`rhino` apps have support for testing with `testthat`, `shiny::testServer()`, `shinytest2`, and [Cypress](https://appsilon.github.io/rhino/articles/tutorial/write-end-to-end-tests-with-cypress.html). 

```{bash}
#| eval: false 
#| code-fold: false 
tests/
├── cypress                 # <1>
│   └── integration
│       └── app.spec.js
├── cypress.json            # <1>
└── testthat                # <2>
    └── test-main.R         # <2>

4 directories, 3 files
```
1. Cypress test infrastructure  
1. `testthat` test infrastructure  

Below is the boilerplate test code in the `tests/testthat/test-main.R` file:

```{r}
#| eval: false 
#| code-fold: false 
box::use(                # <1>
  shiny[testServer], 
  testthat[...],
)

box::use(
  app/main[...],
)                       # <1>

test_that("main server works", {     # <2>
  testServer(server, {
    expect_equal(output$message, "Hello!")
  })
}) # <2>
```
1. `box` module importing test package functions
2. Using `shiny::testServer()` and `testthat::test_that()` functions in test. 

I've included tests for the utility functions and modules in the `17_rhino` branch, but I'll cover testing with rhino elsewhere.[^testing-rhino-apps]

[^testing-rhino-apps]: See the [Shiny frameworks](https://mjfrigaard.github.io/sfw/) supplemental website for more information on testing your `rhino` app.

## `rhino` dependencies 

In `rhino` apps, dependencies are managed by [`renv`](https://rstudio.github.io/renv/articles/renv.html) and the `dependencies.R` file. The `renv` package is designed to, 

> *"create[s] and manage[s] project-local R libraries, save[s] the state of these libraries to a 'lockfile', and later restore[s] the library as required."* [^rhino-renv-description] 

The `rhino::pkg_install()` helper function updates *both* the `dependencies.R` file and `renv` library. Using `dependencies.R`, `renv`, and `box` modules removes the need to manage dependencies in a `DESCRIPTION` or `NAMESPACE` file.[^rhino-renv-config]

[^rhino-box-blog-post]: I've written a [blog post](https://mjfrigaard.github.io/posts/box/) on using box modules (outside of a Shiny application).

[^rhino-explicit-namespaces]: "*In fact, `box` completely replaces the base R `library` and `require` functions*" - [`box` documentation](https://klmr.me/box/index.html).

[^rhino-renv-description]: As described in `renv`'s [DESCRIPTION file](https://github.com/rstudio/renv/blob/main/DESCRIPTION)

[^rhino-renv-config]: Be sure to read the [`renv` configuration article](https://appsilon.github.io/rhino/articles/explanation/renv-configuration.html) for a better understanding on how it works with rhino apps.

## Recap 

`rhino` takes a novel and innovative approach to developing Shiny applications (and covering all the ways they differ from app-packages is beyond the scope of this book). Feel free to review the code in the [`17_rhino` branch](https://github.com/mjfrigaard/moviesApp/tree/17_rhino) for a better understanding of how the `box` modules are structured and used within the `ui` and `server`. 

The `rhino` framework isn't used as widey `golem`,[^rhino-cran-downloads] but it's been gaining popularity (and has been used in a recent [pilot FDA submission](https://github.com/appsilon/rhino-fda-pilot)). 

::: {#fig-rhino_cran_downloads}

![`rhino` CRAN downloads](images/rhino_cran_downloads.png){#fig-rhino_cran_downloads width='100%' fig-align='center'}

CRAN downloads for `rhino`, `leprechaun`, and `goelm` between 2020-10-31 and 2023-10-31.
:::

[^rhino-cran-downloads]: Check for yourself on  [cran-downloads](https://hadley.shinyapps.io/cran-downloads/)
