[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "Welcome!\nShiny App-Packages covers how to create a Shiny application as an R package."
  },
  {
    "objectID": "index.html#why-this-book",
    "href": "index.html#why-this-book",
    "title": "Shiny App-Packages",
    "section": "Why this book?",
    "text": "Why this book?\nIf you’re comfortable building Shiny applications but aren’t as familiar with writing R packages, this book is for you.\nI started putting this resource together after multiple encounters with Shiny developers who had created impressive, complex apps but struggled to convert them into R packages. This problem often resulted in delays when moving their applications into a production environment.\n\n\nDid you read Mastering Shiny and want to learn more about package development?\n\n\nMastering Shiny is an excellent introduction to the captivating world of Shiny and provides a foundation of best practices for building applications. R packages are introduced in Mastering Shiny, and this chapter is a great place to start. 1 However, to fully understand and appreciate the benefits of developing your Shiny app as an R package, I’ve found it’s helpful to have an example that includes the full suite of the package development tools (loading, documenting, testing, deploying, etc.). That’s what I’ve attempted to do with this book.\n\n\nDid you read Engineering Production-Grade Shiny Apps and decide the golem framework wasn’t a good fit for your application?\n\n\ngolem is an ‘opinionated framework for building production-grade Shiny applications’ introduced in Engineering Production-Grade Shiny Apps (or EPGSA) that offers a robust and standardized way to build, maintain, and deploy production-grade Shiny apps. Whether due to the learning curve, overhead, dependencies, legacy code, or your particular deployment constraints, golem might not be the right fit for your situation.2"
  },
  {
    "objectID": "index.html#connecting-the-dots",
    "href": "index.html#connecting-the-dots",
    "title": "Shiny App-Packages",
    "section": "Connecting the dots",
    "text": "Connecting the dots\n‘Production’ usually means passing the code from your personal development environment into your company’s cloud-based server environment, which typically involves bundling your app in a structure that can be shared, installed, tested, and launched.\n\n\n\n\n\n\nWhat does it mean to ‘put something into production?’\n\n\n\n\n\n\n\n‘I think the easiest way to think about it for me is that we develop a model in one computational environment–think of this as maybe your laptop or maybe you work in a server environment–still, it’s in one place, and it turns out the software that you need to have installed there is about tuning, training, etc. Putting something into production is getting it out of that computational environment and successfully carrying it over to a new computational environment. For many people, this might be like a cloud computing environment. It might be some kind of server your organization has, and we need to take it, lift it, and then successfully have it working.’ - Julia Silge, What is ‘production’ anyway? MLOps for the curious (SatRdays London 2023)\n\nI’ve added emphasis and edited this for clarity.\n\n\n\n\n\n\nR packages are designed for other users to install and load into their R environment. The package structure offers a standardized way of extending R’s capabilities by adding new functionality (like developing Shiny apps!).\nThis book is a resource to help ‘connect the dots’ between building scalable Shiny applications and writing R packages. Adopting R package development practices in the early stages of your Shiny app will improve the reusability, maintainability, and shareability of all your hard work."
  },
  {
    "objectID": "index.html#what-this-book-is",
    "href": "index.html#what-this-book-is",
    "title": "Shiny App-Packages",
    "section": "What this book is",
    "text": "What this book is\nThe chapters in this book as written as a toolchain walkthrough, 3 or “a Shiny developers’ guide to a collection of computational tools and commands for creating shiny app-packages.”\nFor continuity, I’ve used code and data from the excellent Building Web Applications with Shiny (BWAS) course. The learning modules in BWAS also serve as ‘prerequisites’ for many of the chapters covered here (if you haven’t completed that course, be sure you understand the topics it covers). You’ll find each section in this book also includes a dedicated GitHub repository and branch for you to follow along."
  },
  {
    "objectID": "index.html#what-this-book-isnt",
    "href": "index.html#what-this-book-isnt",
    "title": "Shiny App-Packages",
    "section": "What this book isn’t",
    "text": "What this book isn’t\nThis book isn’t a replacement for R Packages, 2ed or Writing R Extensions. I highly suggest bookmarking both resources to return and read when you’d like to learn more about package development.\nI also won’t be recommending a particular Shiny framework or package, but I’ll cover a few popular choices, show you what they are doing ‘under the hood,’ and let you decide if you’d like to adopt some of their practices."
  },
  {
    "objectID": "index.html#what-i-assume-about-you",
    "href": "index.html#what-i-assume-about-you",
    "title": "Shiny App-Packages",
    "section": "What I assume about you",
    "text": "What I assume about you\nIf you’re reading this, I assume you’re comfortable with R, Posit Workbench, Shiny, and the tidyverse. Maybe you haven’t built a ton of applications, but you understand reactivity, and you’re comfortable with the core Shiny concepts (i.e., the UI, server, *_Input(), *_Output(), and render_* functions, etc.)."
  },
  {
    "objectID": "index.html#other-resources",
    "href": "index.html#other-resources",
    "title": "Shiny App-Packages",
    "section": "Other resources",
    "text": "Other resources\nExcellent resources have been written for Shiny, and it’s also worthwhile to consult the documentation on the core package development tools:\n\ndevtools\n\nusethis\n\nroxygen2"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Shiny App-Packages",
    "section": "",
    "text": "The ‘Converting an existing app’ chapter provides an example of converting a Shiny app into an R Package. However, many of the helpful package development tools aren’t available (i.e., roxygen2 tags, NAMESPACE imports/exports, tests, vignettes, etc.).↩︎\ngolem apps are built as packages. Still, EPGSA assumes the reader is ‘comfortable with building an R package.’ (if you’re familiar with package development, EPGSA is an excellent resource).↩︎\nThe terms ‘toolchain walkthrough’ are borrowed from the excellent paper, code::proof: Prepare for most weather conditions by Charles T. Gray (https://arxiv.org/abs/1910.06964).↩︎"
  },
  {
    "objectID": "intro.html#motivation",
    "href": "intro.html#motivation",
    "title": "Introduction",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nMastering Shiny & golem (a caveat)\n\n\n\n\n\n\nThis book was written because the transition from building Shiny applications to writing R packages is complicated and involves a shift in focus, skill set, and development practices.\nThe Packages chapter from Mastering Shiny gets ‘your toes into the water of package development’, but in my opinion, is probably not enough for you to get your shiny app project into an R package that’s ready to be shipped into most production environments.\nFor example, if you happened to download or clone the monthApp example from the Packages Chapter, you may have notice a few things:\n\nDESCRIPTION contains additional fields that are not addressed.1\nmonthApp.Rproj has been configured to work with package.2\ndevtools::build() (Ctrl/Cmd + Shift + B) has been configured to have additional behaviors.3\nDependency management is discussed briefly but not documented in the application.4\nmonthApp doesn’t have any help files5 or tests.6\n\nNone of the items above make the monthApp example from Mastering Shiny incomplete or incorrect–it’s been written for an audience with a particular experience level and skill-set. Mastering Shiny assumes the reader has relatively minimal experience with R package development,7 while Engineering Production-Grade Shiny Apps and the golem package assumes it’s readers “are comfortable with building an R package.”8\nCreating a resource that covers all shiny app-package considerations while taking into account the particulars of experience level and development environment is impossible. The contents of this book are intended to merely help close the gap between developing shiny apps and writing R packages."
  },
  {
    "objectID": "intro.html#packages-help-you",
    "href": "intro.html#packages-help-you",
    "title": "Introduction",
    "section": "Packages help you",
    "text": "Packages help you\nA guiding principle throughout this book is,\nShiny app projects that you’re sharing with others belong in an R package.\nI could extend this statement to ‘most R projects,’ but it’s especially true for shiny applications destined for deployment in a production environment.9\nThe first and obvious benefit to structuring your shiny app project as a package is that it simplifies file and folder management. If every shiny app project you develop is structured as a package, it removes the time you spend manually creating directories (or re-orienting yourself to each project’s structure).\nIf you’re using Posit Workbench, the package structure will give you access to a well-designed IDE for shiny applications. Posit Workbench has tools to help develop and debug functions, create and run unit tests, store internal and external data, manage dependencies, and write help files and long-form documentation."
  },
  {
    "objectID": "intro.html#packages-help-them",
    "href": "intro.html#packages-help-them",
    "title": "Introduction",
    "section": "Packages help them",
    "text": "Packages help them\n\n“a package [is] the fundamental unit of shareable, reusable, and reproducible R code.” - R Packages, 2ed\n\nIt’s safe to assume the code used to build shiny apps being deployed to a production environment will be seen (and hopefully used) by others. R packages make sharing your hard work with your colleagues easier because it removes their need to figure out where everything is, how it all fits together, and how it all (hopefully) works."
  },
  {
    "objectID": "intro.html#scalable",
    "href": "intro.html#scalable",
    "title": "Introduction",
    "section": "Scalable",
    "text": "Scalable\nGreat R packages define and solve common problems.\nSuppose you use R to perform analyses, design data visualizations, or build and run reports. If you currently use source() to load any utility functions to perform this work, I suggest putting those functions in a package. Doing this will help extend your mental model from the specific use cases (i.e., “X code performs task Y”) to a model for their more general uses (i.e., “X package performs tasks like Y”).\nThe beauty of an R package mental model is that you’ll inevitably notice the similarities across common problems. Creating packages that define and solve common problems in your workflow can sometimes be some of the most popular/valuable contributions (see datapasta and reprex)."
  },
  {
    "objectID": "intro.html#how-to-read-this-book",
    "href": "intro.html#how-to-read-this-book",
    "title": "Introduction",
    "section": "How to read this book",
    "text": "How to read this book\nThe chapters in this book (roughly) represent the steps of R package development, but from the lens of an existing shiny application.10 Each topic can (and should) be applied when creating new app-packages. Still, in my experience, many Shiny developers have existing applications they’d like to convert into an R package.\n\nCode examples\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s main branch\nThe code files for each chapter are stored in GitHub repositories. Major code changes are stored in Git branches. Whenever a new branch or repo is used, you’ll see the Git Branch icon with a link to the repo in the margin."
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introduction",
    "section": "",
    "text": "The DESCRIPTION file in monthApp contains fields not included in the arguments passed to usethis::use_description() (these were added separately), and a few arguments can be adapted or removed to save time.↩︎\nThe .Rproj file is the connection between the DESCRIPTION fields, the code in the R/ folder, and the IDE’s Build pane or “package development mode.” If you already have an .Rproj file in your shiny app project, you can activate these settings under Tools &gt; Project Options &gt; Build Tools.↩︎\nThe monthApp.Rproj file contains additional settings you can add with Tools &gt; Project Options &gt; Build Tools, then under Generate documentation with Roxygen, click Configure and select Install and Restart.↩︎\nThe NAMESPACE file is empty and the Imports field is missing from the DESCRIPTION (although the chapter discusses importing shiny).↩︎\nroxygen2 is mentioned, but it’s beyond the scope of Mastering Shiny, so for now just know roxygen2 syntax is placed in the code below R/ to create the help files and the NAMESPACE.↩︎\nmonthApp doesn’t have the testing infrastructure provided by testthat, but this can be quickly created using usethis::use_testthat() (and an entire chapter is dedicated to testing.↩︎\nMastering Shiny includes an example for converting an existing application with usethis::use_description(), but not creating a new app-package (i.e., with usethis::create_package()).↩︎\nMost of the pain points/barriers to adopting golem I’ve heard from developers are related to structuring their application as a package.↩︎\nDavid Neuzerling has a great post on the benefits of structuring your project as a package↩︎\nThe original code and data for the application in this book comes from the Building Web Applications with Shiny (BWAS) course.↩︎"
  },
  {
    "objectID": "whole_game.html#toy-app-package-monthapppkg",
    "href": "whole_game.html#toy-app-package-monthapppkg",
    "title": "Whole app game",
    "section": "Toy app-package: monthAppPkg",
    "text": "Toy app-package: monthAppPkg\nThe monthAppPkg example we’re going to be developing has been adapted from Mastering Shiny.2"
  },
  {
    "objectID": "whole_game.html#use_description",
    "href": "whole_game.html#use_description",
    "title": "Whole app game",
    "section": "use_description()",
    "text": "use_description()\nEvery package needs a DESCRIPTION–calling devtools::load_all() without a DESCRIPTION will result in an error. The quickest way to create a description file is with usethis::use_description().3\n\nusethis::use_description(\n  list(Package = 'monthAppPkg',\n       Title = 'An example app-pkg',\n       Version = '0.0.0.9000',\n       Description = 'A shiny application built inside an R package.',\n       \"Authors@R\" = NULL,\n       Author = utils::person(                     \n          given = \"Jane\", \n          family = \"Doe\", \n          role = c(\"aut\", \"cre\")),\n        Maintainer = utils::person(\n          given = \"Jane\", \n          family = \"Doe\",\n          email = \"Jane.Doeh@email.io\"),\n        License = \"GPL-3\"))\n\nI’ve provided values to the fields list so this file isn’t generated with the boilerplate contents. The documentation for use_description() mentions putting this in your .Rprofile if you develop a lot of R packages (or app-packages!)4\nEvery R package needs the following seven fields:\nPackage: monthAppPkg\nTitle: An example app-pkg\nVersion: 0.0.0.9000\nAuthor: Jane Doe [aut, cre]\nMaintainer: Jane Doe &lt;Jane.Doeh@email.io&gt;\nDescription: A shiny application built inside an R package.\nLicense: GPL-3\nWe get the following fields for free (they will be required for function documentation and dependency management).\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3"
  },
  {
    "objectID": "whole_game.html#use_data",
    "href": "whole_game.html#use_data",
    "title": "Whole app game",
    "section": "use_data()",
    "text": "use_data()\nTo include the stones data in monthAppPkg, we load it into the Global Environment and pass it to usethis::use_data():\n\nuse_data(stones)\n\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Setting LazyData to 'true' in 'DESCRIPTION'\n✔ Saving 'stones' to 'data/stones.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nData should be documented using roxygen2,5 which we’ll cover in the data chapter."
  },
  {
    "objectID": "whole_game.html#use_package",
    "href": "whole_game.html#use_package",
    "title": "Whole app game",
    "section": "use_package()",
    "text": "use_package()\nEvery Shiny app-package will need to import the shiny package as a dependency, which starts by listing it under the Imports field the DESCRIPTION file. We can do this using usethis::use_package().6\n\nusethis::use_package(\"shiny\")\n\n✔ Adding 'shiny' to Imports field in DESCRIPTION\n• Refer to functions with `shiny::fun()`\nWe’re advised to use explicit namespacing (i.e., pkg::fun()), but we can avoid this by importing Shiny’s functions into our package namespace.\nThe @import tag from roxygen2 can be used to import “the entire [shiny] namespace” into monthAppPkg.7"
  },
  {
    "objectID": "whole_game.html#load_all",
    "href": "whole_game.html#load_all",
    "title": "Whole app game",
    "section": "load_all()",
    "text": "load_all()\nShiny app development typically involves something like the following workflow:\n\nWrite UI code\n\nWrite server code\n\nClick Run App\n\nRinse, repeat\n\nWhen making the switch to app-package development, calling load_all() is somewhat analogous to clicking on the Run App icon–you’ll do it often (more than any other devtools or usethis function).\n\ndevtools::load_all()\n\nThe output we’re looking for from load_all() is straightforward:\nℹ Loading monthAppPkg\nload_all() is similar to calling library, but it’s specifically designed to be used during package development."
  },
  {
    "objectID": "whole_game.html#use_r",
    "href": "whole_game.html#use_r",
    "title": "Whole app game",
    "section": "use_r()",
    "text": "use_r()\nCreate new R files using use_r(), and the accompanying tests using use_test():\n\nusethis::use_r(\"monthFeedback\")\n\n✔ Setting active project to '/projects/apps/monthAppPkg'\n• Modify 'R/monthFeedback.R'\nBoth UI and server module functions are stored in R/monthFeedback.R and R/birthstone.R, but tests should be created for each function."
  },
  {
    "objectID": "whole_game.html#use_test",
    "href": "whole_game.html#use_test",
    "title": "Whole app game",
    "section": "use_test()",
    "text": "use_test()\nThe first time you run use_test(), it will detect if your package has the testthat infrastructure (and create the necessary files if you don’t).8\n\nusethis::use_test(\"monthFeedbackServer\")\n\nCalling use_test() will add the testthat package to the Suggests field in the DESCRIPTION and include the edition (which is currently 3).\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Adding '3' to Config/testthat/edition\nThe tests/ folder will hold the necessary testing folder and files:\n\ntests/\n├── testthat/\n│   ├── test-birthstoneServer.R\n│   └── test-monthFeedbackServer.R\n└── testthat.R\n\n2 directories, 3 files\n\nTests are covered in Mastering Shiny,9 on the Shiny website,10 and in various testing packages (like shinytest11 and shinytest212)"
  },
  {
    "objectID": "whole_game.html#new-app.r-file-contents",
    "href": "whole_game.html#new-app.r-file-contents",
    "title": "Whole app game",
    "section": "New app.R file contents",
    "text": "New app.R file contents\nThe contents of app.R have been converted to a standalone app function (monthApp()), which is stored in the R/ folder.\nThe new contents of app.R will only include a call to pkgload::load_all() and monthApp():\n\npkgload::load_all(\".\")\nmonthApp()\n\npkgload needs to be listed under Imports in the DESCRIPTION file (just like we did with shiny above).\n\nusethis::use_package(\"pkgload\")\n\n✔ Adding 'pkgload' to Imports field in DESCRIPTION\n• Refer to functions with `pkgload::fun()`\nBecause we’re only going to use load_all() from pkgload, we’ll use explicit namespacing (i.e., pkg::fun()).13\n\nuse_package_doc()\nThe use_package_doc() creates the R/[[name]-package].R file, which can be used as a single location for declaring the functions we’re importing and exporting from monthAppPkg:\n\nusethis::use_package_doc()\n\n✔ Setting active project to 'projects/apps/monthAppPkg'\n✔ Writing 'R/monthAppPkg-package.R'\n• Modify 'R/monthAppPkg-package.R'\nWe’ll use @importFrom to add only the load_all() function to the NAMESPACE.\n\n#' @keywords internal\n\"_PACKAGE\"\n\n## usethis namespace: start\n#' @importFrom pkgload load_all\n## usethis namespace: end\nNULL\n\n\n\nuse_build_ignore()\nR packages don’t typically have an app.R file in their root folder, so we’ll let devtools know this file should be ignored by creating a .Rbuildignore and include a pattern that excludes app.R whenever the package is built.\n\nusethis::use_build_ignore(\"app.R\")\n\n✔ Adding '^app\\\\.R$' to '.Rbuildignore'\nIt’s best to let use_build_ignore() handle excluding any files or folders from your package builds because it automatically writes the correct regular expression pattern."
  },
  {
    "objectID": "whole_game.html#license",
    "href": "whole_game.html#license",
    "title": "Whole app game",
    "section": "LICENSE",
    "text": "LICENSE\nIncluding a LICENSE file can be done with one of the usethis license functions.\nThe license file should match the License field in the DESCRIPTION file (in this case, it’s MIT). use_mit_license() will automatically include the LICENSE.md file in the root folder (and includes the necessary pattern in the .Rbuildignore to exclude it from the package builds).\n\nusethis::use_mit_license()\n\n✔ Adding 'MIT + file LICENSE' to License\n✔ Writing 'LICENSE'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'"
  },
  {
    "objectID": "whole_game.html#document",
    "href": "whole_game.html#document",
    "title": "Whole app game",
    "section": "document()",
    "text": "document()\nAll of the files below R/ should include roxygen2 documentation. You can include an Roxygen skeleton in the IDE by clicking on Code &gt; Insert Roxygen Skeleton, or using the keyboard shortcut:\nOption/⌥ + Shift⇧ + Ctrl/Cmd + R\nAfter writing the documentation for the data, modules, and standalone app function, calling devtools::document()() will generate the .Rd files and NAMESPACE\n\ndevtools::document()\n\nThe output from document() tells me what files have been created (and if there were any errors in them).14\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nWriting NAMESPACE\nWriting NAMESPACE\nWriting birthstoneUI.Rd\nWriting birthstoneServer.Rd\nWriting monthApp.Rd\nWriting monthFeedbackUI.Rd\nWriting monthFeedbackServer.Rd\n\nNAMESPACE\nThe NAMESPACE file contains the exported functions from monthAppPkg, and the two imports (shiny and pkgload::load_all()):\n# Generated by roxygen2: do not edit by hand\n\nexport(birthstoneServer)\nexport(birthstoneUI)\nexport(monthApp)\nexport(monthFeedbackServer)\nexport(monthFeedbackUI)\nimport(shiny)\nimportFrom(pkgload,load_all)"
  },
  {
    "objectID": "whole_game.html#rproj",
    "href": "whole_game.html#rproj",
    "title": "Whole app game",
    "section": ".Rproj",
    "text": ".Rproj\nIn order to enable the Build pane and keyboard shortcuts in the IDE, we need to update our .Rproj file. We can edit this file using file.edit():\n\nfile.edit(\"monthAppPkg.Rproj\")\n\nIf monthAppPkg was initially built as an RStudio project (not a package), the following fields should be included at the bottom of monthAppPkg.Rproj:\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\nThese options are also available under Tools &gt; Project Options … &gt; Build Tools"
  },
  {
    "objectID": "whole_game.html#use_git",
    "href": "whole_game.html#use_git",
    "title": "Whole app game",
    "section": "use_git()",
    "text": "use_git()\nThis step is performed much earlier in R Packages, 2ed, but I’ve saved it for this step, because using Git will prompt the IDE to re-initialize to display the Git pane (and it will also read our new settings in the .Rproj file).\n✔ Setting active project to '/projects/apps/monthAppPkg'\n✔ Initialising Git repo\n✔ Adding '.Rproj.user', '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'\nThere are 12 uncommitted files:\n* '.gitignore'\n* '.Rbuildignore'\n* 'app.R'\n* 'data/'\n* 'DESCRIPTION'\n* 'LICENSE'\n* 'LICENSE.md'\n* 'man/'\n* 'monthAppPkg.Rproj'\n* 'NAMESPACE'\n* ...\nIs it ok to commit them?\n\n1: Absolutely not\n2: Not now\n3: Absolutely\nI’ll agree to commit these files to Git:\nSelection: 3\n✔ Adding files\n✔ Making a commit with message 'Initial commit'\n• A restart of RStudio is required to activate the Git pane\nRestart now?\n\n1: Not now\n2: Negative\n3: Absolutely\nRestarting RStudio will activate the Git and Build panes:\n\n\n\nGit Pane\n\n\n\n\n\nBuild Pane\n\n\nThis will also activate the devtools keyboard shortcuts:\n\ndevtools keyboard shortcuts\n\n\n\nload_all()\nShift + Ctrl/Cmd + L\n\n\ndocument()\nShift + Ctrl/Cmd + D\n\n\n\n\ninstall()\nShift + Ctrl/Cmd + B\n\n\ntest()\nShift + Ctrl/Cmd + T"
  },
  {
    "objectID": "whole_game.html#install-1",
    "href": "whole_game.html#install-1",
    "title": "Whole app game",
    "section": "install()",
    "text": "install()\nNow we’re ready to install monthAppPkg with devtools::install(), which produces see the following output in the Build pane:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating monthAppPkg documentation\nℹ Loading monthAppPkg\nDocumentation completed\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source monthAppPkg\n\n* installing to library ‘/path/to/Library/R/x86_64/4.2/library’\n* installing *source* package ‘monthAppPkg’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (monthAppPkg)\nBack in the Console, RStudio will restart and call library(monthAppPkg):\nRestarting R session...\n\n&gt; library(monthAppPkg)\nWe can now launch the app using monthApp()\n\nmonthApp()\n\n\n\n\nmonthApp()"
  },
  {
    "objectID": "whole_game.html#additional-files",
    "href": "whole_game.html#additional-files",
    "title": "Whole app game",
    "section": "Additional files",
    "text": "Additional files\nThe following sections cover additional files you should include in your ap-package (but are not required).\n\nuse_readme_rmd()\nThe README.md file is usually the initial point of contact for users and contributors looking for information about your app-package. use_readme_rmd() will create a README.Rmd (i.e., the file you’ll edit), which serves as the source document for your README.md.\n\nusethis::use_readme_rmd()\n\nThe README.Rmd pattern is automatically added to the .Rbuildignore, and\n✔ Adding '^README\\\\.Rmd$' to '.Rbuildignore'\n✔ Writing '.git/hooks/pre-commit'\n\n\nuse_news_md()\nA NEWS.md is helpful for logging updates to your app-package and tracking release information.\n\nusethis::use_news_md()\n\nuse_news_md() will also prompt me to add and commit this file to the Git repository:\nThere is 1 uncommitted file:\n* 'NEWS.md'\nIs it ok to commit it?\n\n1: Negative\n2: Yeah\n3: Absolutely not\n\nSelection: 2\n✔ Adding files\n✔ Making a commit with message 'Add NEWS.md'\nThe contents of the NEWS.md are below:\n# monthAppPkg (development version)\n\n* Initial CRAN submission.\n\n\nuse_vignette()\nVignettes can be used to store detailed tutorials, explanations of core concepts, use-cases, FAQs and troubleshooting, integration with other packages, etc.\n\nuse_vignette(\"monthAppPkg\")\n\n✔ Adding 'knitr' to Suggests field in DESCRIPTION\n✔ Adding 'rmarkdown' to Suggests field in DESCRIPTION\n✔ Adding 'knitr' to VignetteBuilder\n✔ Adding 'inst/doc' to '.gitignore'\n✔ Creating 'vignettes/'\n✔ Adding '*.html', '*.R' to 'vignettes/.gitignore'\n\n\n\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the monthAppPkg repo’s main branch"
  },
  {
    "objectID": "whole_game.html#footnotes",
    "href": "whole_game.html#footnotes",
    "title": "Whole app game",
    "section": "",
    "text": "The example app comes from the Packages chapter of Mastering Shiny[^whole-game-month-app]↩︎\nI’ve stored the code for this application in the monthAppPkg repository (to avoid confusing it with the actual application repo for this chapter).↩︎\nThe Whole Game chapter of R Packages, 2ed begins with the usethis::create_package() function, which calls usethis::use_description() internally.↩︎\nAt the time this was written, there are over 4,000 hits with the boilerplate value for Description (i.e., \"What the package does\"), which is a sign of how much usethis has been adopted (and how often people forget to come back and edit their DESCRIPTION file).↩︎\nView the documented stones dataset here on GitHub.↩︎\nWhenever you use a function from another package, start by running usethis::use_package() to ensure it’s in the DESCRIPTION file.↩︎\nI’ve included @import shiny above the definition of our standalone app function (R/movies_app.R), which means I don’t need to add shiny:: when using Shiny functions belowR/.↩︎\nYou can also set up the testthat infrastructure by calling usethis::use_testthat()↩︎\nThe Testing chapter in Mastering Shiny covers unit tests with testthat, shiny::testServer(), and the shinytest package.↩︎\nSee the ‘Server Function Testing’ article on the Shiny website for more information on testServer()↩︎\nCheck the shinytest package website and video tutorial for more information on testing your app.↩︎\nshinytest2 is an updated verison of shinytest with excellent documentation and videos.↩︎\nWe typically call devtools::load_all(), but using pkgload reduces the number of dependencies included with devtools. Read more about pkgload in the ‘Conscious uncoupling’ of devtools.↩︎\nThe files created by document() rely on the roxygen2 package (and should not be edited manually).↩︎"
  },
  {
    "objectID": "shiny.html#shiny-programming",
    "href": "shiny.html#shiny-programming",
    "title": "Shiny",
    "section": "Shiny programming",
    "text": "Shiny programming\nReactivity is the underlying process that allows Shiny apps to update and respond to user interactions automatically. Developing Shiny apps involves harnessing the connection between inputs, reactivity, and outputs to control and predict the application’s behavior.\nShiny programming differs from regular R programming in several key aspects:\n\nAn Event-driven UI: Shiny apps require developers to design and develop a user interface (UI). User experience (UX) design is an entirely separate field, but as Shiny developers, we need to know enough to allow users to interact with and navigate our apps. The UI also captures each ‘event,’ meaning that the user’s actions (such as button clicks or input changes) trigger the application’s inputs, updates, or outputs.\n\nRegular R programming often involves executing predefined steps or functions without direct interaction or responses to user events.\n\nA Reactive Server: In Shiny, the application’s behavior is determined by the dependencies between reactive inputs (i.e., the inputIds), reactive values, and outputs (i.e., the outputIds), allowing for automatic updates and propagation of changes throughout the application.\n\nIn standard R programming, we typically define a series of sequential steps (i.e., functions) that operate on data to generate output to the console or a typesetting system for technical and scientific publications (model results, graphs, tables, etc.) without accounting for reactivity or downstream changes.\n\n\nLearning reactivity can be challenging when you start, but fortunately, there are excellent tutorials and articles to help you along the way!"
  },
  {
    "objectID": "shiny.html#new-shiny-app-projects",
    "href": "shiny.html#new-shiny-app-projects",
    "title": "Shiny",
    "section": "New shiny app projects",
    "text": "New shiny app projects\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s main branch\nIf you’re creating a new application using the New Project Wizard, you’ll see the following:\n\n\n\n\n\n(a) New shiny app\n\n\nFigure 3.1: New shiny app project\n\n\nSelect the location of your shiny app project, then pick a name and decide whether you want to use Git or renv (I’ll be using Git).\n\n\n\n\n\n(a) Shiny app info\n\n\nFigure 3.2: New shiny app project in a Git repository\n\n\nAfter clicking Create Project, a new session will open with your project files."
  },
  {
    "objectID": "shiny.html#shiny-app-project-contents",
    "href": "shiny.html#shiny-app-project-contents",
    "title": "Shiny",
    "section": "Shiny app project contents",
    "text": "Shiny app project contents\nNote that the only items in the new shiny app project are app.R and the shinyAppProj.Rproj file.\n\nshinyAppProj/\n    ├── app.R\n    └── shinyAppProj.Rproj\n\n1 directory, 2 files\n\n\napp.R\napp.R initially contains a boilerplate application, which we can launch by clicking on the Run App button:\n\n\n\n\n\nClick on Run App\n\n\n\n\n\n\n\n(a) Old Faithful geyser app\n\n\nFigure 3.3: Boilerplate Old Faithful geyser app in new shiny projects\n\n\nThe boilerplate ‘Old Faith Geyser Data’ app is a perfect example of what Shiny can do with a single app.R file, but we’ll want to exchange this code for a slightly more advanced application (because most shiny apps grow beyond an app.R file)."
  },
  {
    "objectID": "shiny.html#movie-review-data-app",
    "href": "shiny.html#movie-review-data-app",
    "title": "Shiny",
    "section": "Movie review data app",
    "text": "Movie review data app\nMost shiny applications move beyond a single app.R file. Knowing how to store any utility functions, data, documentation, and metadata will set you up for success as you transition to storing your app in an R package.\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s 02_movies-app branch\nI’m going to work through an example of some intermediate/advanced shiny app features using the application from the Building Web Applications with Shiny course. This app is a great use case for the following reasons:\n\nIt has multiple input types that are collected in the UI\nThe graph output can be converted to a utility function\nThe app loads an external data file when it’s launched\nThe code is accessible (and comes from a trusted source)\n\n\nApp\nThe code below replaces the boilerplate ‘Old Faith Geyser Data’ app in app.R:\n\napp.R\n\n\nshow/hide movie review shiny app\nui &lt;- shiny::fluidPage(\n  theme = shinythemes::shinytheme(\"spacelab\"),\n  shiny::sidebarLayout(\n    shiny::sidebarPanel(\n      shiny::selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n      shiny::selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n      shiny::sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.4\n      ),\n      shiny::sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 3\n      ),\n      shiny::textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n      shiny::actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n    shiny::mainPanel(\n      shiny::br(),\n      shiny::p(\n        \"These data were obtained from\",\n        shiny::a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        shiny::a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      shiny::p(\n        \"The data represent\",\n        nrow(movies),\n        \"randomly sampled movies released between 1972 to 2014 in the United States.\"\n      ),\n      shiny::plotOutput(outputId = \"scatterplot\"),\n      shiny::hr(),\n      shiny::p(shiny::em(\n        \"The code for this shiny application comes from\",\n        shiny::a(\"Building Web Applications with shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"\n        )\n      ))\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- shiny::reactive({\n    tools::toTitleCase(input$plot_title)\n  }) |&gt;\n    shiny::bindEvent(input$update_plot_title,\n      ignoreNULL = FALSE,\n      ignoreInit = FALSE\n    )\n\n\n  output$scatterplot &lt;- shiny::renderPlot({\n    scatter_plot(\n      df = movies,\n      x_var = input$x,\n      y_var = input$y,\n      col_var = input$z,\n      alpha_var = input$alpha,\n      size_var = input$size\n    ) +\n      ggplot2::labs(title = new_plot_title()) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n}\n\nshiny::shinyApp(ui = ui, server = server)\n\n\n\n\n\nUtility function\nI’ve added the scatter_plot() utility function in a new utils.R file:\n\nutils.R\n\n\nshow/hide scatter_plot()\nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\n\n\n\nData\nThe movies.RData dataset contains reviews from IMDB and Rotten Tomatoes\n\nmovies.RData\nYou can download these data here\n\n\n\nUpdated movies app project contents\nThe shinyAppProj project now contains the following files:\n\nshinyAppProj/\n  ├── app.R\n  ├── movies.RData\n  ├── shinyAppProj.Rproj\n  └── utils.R\n\n2 directories, 4 files\n\nTo run the movies app, we need to load the data and source the utils.R file by adding the code below to the top of the app.R file:\nAfter installing the packages below, add a comment (#) in front of these lines.\nI’ve placed the header below in the top of the app.R file:\n\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# data -----------------------------------------\nload(\"movies.RData\")\n\n# utils ----------------------------------------\nsource(\"utils.R\")\n\n\n1\n\nComment out these lines after installing pkgs\n\n\n\n\nClicking on Run App displays the movie review app:\n\n\n\n\n\n\n(a) movies app\n\n\nFigure 3.4: Movie review app"
  },
  {
    "objectID": "shiny.html#project-folders",
    "href": "shiny.html#project-folders",
    "title": "Shiny",
    "section": "Project folders",
    "text": "Project folders\nNow that we have a slightly more complex application in app.R, I’ll add a few project folders we can include in our project that have unique built-in behaviors. These folders will help organize your files and make additional resources available to your app.\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s 03_proj-app branch\n\nR/\nIf your shiny app relies on utility or helper functions (outside the app.R file), you can place this code in an R/ folder. Any .R files in the R/ folder will be automatically sourced when the application is run.\n\n\n\n\n\n\nPlace utils.R in R/ folder\n\n\n\n\n\nI’ve moved the utils.R file into the R/ folder in shinyAppProj:\n\nshinyAppProj/\n     └── R/\n         └── utils.R\n\n1 directory, 1 file\n\n\n\n\nThe function that makes this process (i.e., sourcing any .R files in an R/ folder) possible is loadSupport(). We’ll return to this function in a later chapter, because the R/ folder has a similar behavior (but different function) in R packages.1\n\n\nwww/\nWhen you run a shiny application, any static files (i.e., resources) under a www/ directory will automatically be made available within the application. This folder stores images, CSS or JavaScript files, and other static resources.\n\n\n\n\n\n\nCreate www/ folder and download image\n\n\n\n\n\nI’ve downloaded the shiny logo (shiny.png) and stored it in the www/ folder.\n\nshinyAppProj/\n     └── www/\n           └── shiny.png\n\n1 directory, 1 file\n\nIn the section below, we’ll reference shiny.png directly in the UI.\n\n\n\nFollowing the conventional folder structure will also help set you up for success when/if you decide to convert it into an app-package."
  },
  {
    "objectID": "shiny.html#project-files",
    "href": "shiny.html#project-files",
    "title": "Shiny",
    "section": "Project files",
    "text": "Project files\n\nREADME.md\nIncluding a README.md file in your root folder is a good practice for any project. README.md should contain relevant documentation for running app.R.\n\n\n\n\n\n\nCreate README.md\n\n\n\n\n\nI’ve included the content below in the README.md file\n# movies app\n\nThe original code and data for this shiny app comes from the [Building Web Applications with Shiny](https://rstudio-education.github.io/shiny-course/) course. It's been converted to use [shiny modules](https://shiny.posit.co/r/articles/improve/modules/). \n\nView the code for this application in the [`shinyAppProj` branches](https://github.com/mjfrigaard/shinyAppProj/branches/all).\n\n\n\n\n\nDESCRIPTION\nDESCRIPTION files play an essential role in R packages, but they are also helpful in Shiny projects if I want to deploy the app in showcase mode.\n\n\n\n\n\n\nCreate DESCRIPTION\n\n\n\n\n\nI’ve included the content below in DESCRIPTION:\n\nType: shiny\nTitle: movies app\nAuthor: John Smith\nDisplayMode: Showcase                                                 \n                                                                      \n\n\n\n\n\n\n\nIt’s always a good idea to leave at least one &lt;empty final line&gt; in your DESCRIPTION file.\n\nAfter adding README.md and a DESCRIPTION file (listing DisplayMode: Showcase), the movies app will display the code and documentation when the app launches.2"
  },
  {
    "objectID": "shiny.html#project-code",
    "href": "shiny.html#project-code",
    "title": "Shiny",
    "section": "Project code",
    "text": "Project code\nThe following two items are considered best practices because they make your app more scalable by converting app.R into functions.\n\nModules\nShiny modules are a ‘pair of UI and server functions’ designed to compartmentalize input and output IDs into distinct namespaces,\n\n‘…a namespace is to an ID as a directory is to a file…’ - shiny::NS() help file.\n\nModule UI functions typically wrap the layout, input, and output functions in shiny::tagList(). Module server functions typically contain the ‘backend’ code in a shiny server function. Both the UI and server module functions are linked by an id argument, which is created using shiny::NS() (namespace) in the UI function and called in the server function with shiny::moduleServer().\n\nVariable inputs module\nmod_var_input_ui() creates a dedicated namespace for the inputIds with shiny::NS(): ##### R/mod_var_input.R\n\n\nshow/hide mod_var_input_ui()\nmod_var_input_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::selectInput(\n1      inputId = ns(\"y\"),\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n    shiny::selectInput(\n2      inputId = ns(\"x\"),\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics Score\" = \"critics_score\",\n        \"Audience Score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"imdb_rating\"\n    ),\n    shiny::selectInput(\n3      inputId = ns(\"z\"),\n      label = \"Color by:\",\n      choices = c(\n        \"Title Type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA Rating\" = \"mpaa_rating\",\n        \"Critics Rating\" = \"critics_rating\",\n        \"Audience Rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    ),\n    shiny::sliderInput(\n4      inputId = ns(\"alpha\"),\n      label = \"Alpha:\",\n      min = 0, max = 1, step = 0.1,\n      value = 0.5\n    ),\n    shiny::sliderInput(\n5      inputId = ns(\"size\"),\n      label = \"Size:\",\n      min = 0, max = 5,\n      value = 2\n    ),\n    shiny::textInput(\n6      inputId = ns(\"plot_title\"),\n      label = \"Plot title\",\n      placeholder = \"Enter plot title\"\n    )\n  )\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\nmod_var_input_server() returns these values in a reactive list with shiny::reactive():\n\n\nshow/hide mod_var_input_server()\nmod_var_input_server &lt;- function(id) {\n\n  shiny::moduleServer(id, function(input, output, session) {\n    return(\n        reactive({\n          list(\n1            \"y\" = input$y,\n2            \"x\" = input$x,\n3            \"z\" = input$z,\n4            \"alpha\" = input$alpha,\n5            \"size\" = input$size,\n6            \"plot_title\" = input$plot_title\n          )\n        })\n    )\n  })\n}\n\n\n\n1\n\ny axis numeric variable\n\n2\n\nx axis numeric variable\n\n3\n\nz axis categorical variable\n\n\n4\n\nalpha numeric value for points\n\n\n5\n\nsize numeric value for size\n\n\n6\n\nplot_title text\n\n\n\n\n\n\nScatter-plot display module\nmod_scatter_display_ui() creates a dedicated namespace for the plot outputId (as \"scatterplot\"), along with some help text:\n\nR/mod_scatter_display.R\n\n\nshow/hide mod_scatter_display_ui()\nmod_scatter_display_ui &lt;- function(id) {\n  ns &lt;- shiny::NS(id)\n  shiny::tagList(\n    shiny::tags$br(),\n    shiny::tags$blockquote(\n      shiny::tags$em(\n        shiny::tags$h6(\"The data for this application comes from the \",\n        shiny::tags$a(\"Building web applications with Shiny\",\n          href = \"https://rstudio-education.github.io/shiny-course/\"),\n                      \"tutorial\"))\n      ),\n1    shiny::plotOutput(outputId = ns(\"scatterplot\"))\n  )\n}\n\n\n\n1\n\nNamespaced module id for plot in UI\n\n\n\n\nThe code to render the output$scatterplot is contained in the nested call to shiny::moduleServer() in mod_scatter_display_server():\nAfter 1) loading the movies data, 2) assembling the returned values from mod_var_input_server(), and creating the input() reactive, 3) the scatter_plot() utility function creates the plot object and adds the plot_title() and theme:\n\n\nshow/hide mod_scatter_display_server()\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n    \n1    load(\"movies.RData\")\n\n2    inputs &lt;- shiny::reactive({\n      plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n    })\n3    output$scatterplot &lt;- shiny::renderPlot({\n      plot &lt;- scatter_plot(\n        df = movies,\n        x_var = inputs()$x,\n        y_var = inputs()$y,\n        col_var = inputs()$z,\n        alpha_var = inputs()$alpha,\n        size_var = inputs()$size\n      )\n4      plot +\n        ggplot2::labs(\n          title = inputs()$plot_title,\n          x = stringr::str_replace_all(\n                  tools::toTitleCase(\n                      inputs()$x),\n                  \"_\", \" \"),\n          y = stringr::str_replace_all(\n                  tools::toTitleCase(\n                    inputs()$y),\n                \"_\", \" \")\n        ) + \n5        ggplot2::theme_minimal() +\n        ggplot2::theme(legend.position = \"bottom\")\n    })\n  })\n}\n\n\n\n1\n\nloading the movies data\n\n2\n\nassembling the returned values from mod_var_input_server(), and creating the input() reactive\n\n3\n\nscatter_plot() utility function creates the plot object\n\n4\n\nadds the plot_title()\n\n5\n\nadd theme to layers\n\n\n\n\nBoth UI and server module functions are combined into a single .R file, and all modules are placed in the R/ folder so they are sourced when the application is run.\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n └── utils.R\n\n\n\n\n\nStandalone app function\nBoth module functions are combined in the ui and server arguments of shiny::shinyApp(). The id arguments (\"vars\" and \"plot\") connect the UI functions to their server counterparts, and the output from mod_var_input_server() is the var_inputs argument in mod_scatter_display_server().\nThe call to shiny::shinyApp() is wrapped in the movies_app() function and placed in app.R.\n\napp.R\n\n\nshow/hide movies_app() in app.R\n# install ------------------------------------\n# after installing, comment this out\n1pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\ninstall.packages(pkgs, verbose = FALSE)\n\n# packages ------------------------------------\n2library(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\nmovies_app &lt;- function() { \n  shiny::shinyApp(\n    ui = shiny::fluidPage(\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n3          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n4          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    ),\n    server = function(input, output, session) {\n      \n5      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n6      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n    }\n  )\n}\nmovies_app()\n\n\n\n1\n\nHeader (comment this out after the packages are installed)\n\n2\n\nLoad packages\n\n\n3\n\nVariable input UI module\n\n4\n\nGraph display UI module\n\n5\n\nVariable input server module\n\n6\n\nGraph display server module\n\n\n\n\nNow, I can run the app with movies_app().\n\n\n\n\n\n\n(a) Movie reviews app\n\n\nFigure 3.5: View a deployed version here.\n\n\n\nThe deployed files of shinyAppProj are below:\n\nshinyAppProj/ # 03_proj-app branch\n├── DESCRIPTION\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── shinyAppProj.Rproj\n├── rsconnect/\n│   └── shinyapps.io/\n│       └── user/\n│           └── shinyAppProj.dcf\n└── www/\n    └── shiny.png\n\n6 directories, 10 files\n\n\n\nThe rsconnect/ folder has been removed from the 03_proj-app branch."
  },
  {
    "objectID": "shiny.html#additional-features",
    "href": "shiny.html#additional-features",
    "title": "Shiny",
    "section": "Additional features",
    "text": "Additional features\nBelow are two additional ‘optional’ features that can be included with your shiny application (I consider these ‘optional’ because they’re use depends on the specific needs and environment for each application).\n\nGlobal variables/functions with global.R\nPlacing a global.R file in your root folder (or in the R/ directory) causes this file to be sourced only once when the Shiny app launches, rather than each time a new user connects to the app. global.R is commonly used for initializing variables, loading libraries, loading large data sets and/or performing initial calculations.\n\n\n\n\n\n\nUsing global.R\n\n\n\n\n\nI could place the header from app.R in global.R to ensure these packages are loaded before the application launches:\n\n\nshow/hide contents of R/global.R\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n\nglobal.R can be placed in the R/ folder\n\nR/\n├── global.R\n├── mod_scatter_display.R\n├── mod_var_input.R\n└── utils.R\n\n1 directory, 4 files\n\nOr in the project root folder\n\n├── DESCRIPTION\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── global.R\n├── man\n├── movies.RData\n├── shinyAppProj.Rproj\n└── www\n    └── shiny.png\n\n4 directories, 10 files\n\nIn both locations, it will be sourced before launching the application.\n\n\n\nglobal.R can be used to maintain efficiency and consistency across application sessions.\n\n\nProject dependencies with renv\nIf you use renv, keep track of your dependencies by regularly running renv::status() and renv::snapshot().\n\n\n\n\n\n\nUsing renv\n\n\n\n\n\nStart by initiating renv with renv::init(), then run renv::status() to check which packages have been added to the lockfile:\n\nrenv::status()\n\n\n\nshow/hide example renv::status() output\nThe following package(s) are in an inconsistent state:\n\n package      installed recorded used\n colorspace   y         n        y   \n fansi        y         n        y   \n farver       y         n        y   \n ggplot2      y         n        y   \n gtable       y         n        y   \n isoband      y         n        y   \n labeling     y         n        y   \n lattice      y         n        y   \n MASS         y         n        y   \n Matrix       y         n        y   \n mgcv         y         n        y   \n munsell      y         n        y   \n nlme         y         n        y   \n pillar       y         n        y   \n pkgconfig    y         n        y   \n RColorBrewer y         n        y   \n scales       y         n        y   \n shinythemes  y         n        y   \n tibble       y         n        y   \n utf8         y         n        y   \n vctrs        y         n        y   \n viridisLite  y         n        y   \n\n\nTake a ‘snapshot’ to capture the current package dependencies:\n\nrenv::snapshot()\n\n\n\nshow/hide example renv::snapshot() output\nThe following package(s) will be updated in the lockfile:\n\n# CRAN --------------------------------------------------\n- lattice        [* -&gt; 0.21-8]\n- MASS           [* -&gt; 7.3-60]\n- Matrix         [* -&gt; 1.5-3]\n- mgcv           [* -&gt; 1.8-42]\n- nlme           [* -&gt; 3.1-162]\n- vctrs          [* -&gt; 0.6.3]\n\n# RSPM --------------------------------------------------\n- colorspace     [* -&gt; 2.1-0]\n- fansi          [* -&gt; 1.0.4]\n- farver         [* -&gt; 2.1.1]\n- ggplot2        [* -&gt; 3.4.2]\n- gtable         [* -&gt; 0.3.3]\n- isoband        [* -&gt; 0.2.7]\n- labeling       [* -&gt; 0.4.2]\n- munsell        [* -&gt; 0.5.0]\n- pillar         [* -&gt; 1.9.0]\n- pkgconfig      [* -&gt; 2.0.3]\n- RColorBrewer   [* -&gt; 1.1-3]\n- scales         [* -&gt; 1.2.1]\n- shinythemes    [* -&gt; 1.2.0]\n- tibble         [* -&gt; 3.2.1]\n- utf8           [* -&gt; 1.2.3]\n- viridisLite    [* -&gt; 0.4.2]\n\nDo you want to proceed? [Y/n]: y\n\n- Lockfile written to '~/path/to/shinyAppProj/renv.lock'."
  },
  {
    "objectID": "shiny.html#recap",
    "href": "shiny.html#recap",
    "title": "Shiny",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some differences between developing shiny apps and regular R programming, creating new shiny projects in Posit Workbench, and some practices to adopt that can make the transition to app-packages a little easier. The code used in this chapter is stored in the shinyAppProj repository.\n\n\n\n\n\n\nRecap\n\n\n\n\n\n\n\nPlacing utility or helper files in an R/ folder removes the need to call source() in app.R.\nImages, CSS, JavaScript, and other static resources can be stored in www/ and Shiny will serve these files when the application is run.\nREADME.md files can document the application’s description, purpose, requirements, etc.\nDESCRIPTION files provide metadata and include fields that affect application deployment (i.e., DisplayMode: Showcase)\nConverting the application code into functions (modules and standalone app functions) creates a ‘division of labor’ for each component, which makes it easier to think about and work on them independently.\nFinally, if you’re using renv, run renv::status() and renv::snapshot() to manage dependencies\n\n\n\n\n\nIn the next chapter, I’ll cover what makes a package a package, and some do’s and don’ts when converting a developed shiny application into an R package."
  },
  {
    "objectID": "shiny.html#footnotes",
    "href": "shiny.html#footnotes",
    "title": "Shiny",
    "section": "",
    "text": "Shiny introduced these features in version 1.3.2.9001, and you can read more about them in the section titled, ‘The R/ directory’ in App formats and launching apps↩︎\nRead more about showcase mode here↩︎"
  },
  {
    "objectID": "packages.html#projects-packages-and-app-packages",
    "href": "packages.html#projects-packages-and-app-packages",
    "title": "Packages",
    "section": "Projects, packages, and app-packages",
    "text": "Projects, packages, and app-packages\nBefore we start, we should establish some operational definitions of what is meant by the terms ‘project’, ‘package’, and ‘app-package’.\n\n\nI’ll use color to differentiate Shiny app projects, R packages, and Shiny app-packages\n\nShiny App Projects: I consider a Shiny app project to be any directory of files requiring R (the binary downloaded from CRAN with a version number and neat names like, ‘R 4.3.1 “Beagle Scouts” released on …’) to execute with an RStudio/Posit workbench project file (.Rproj) and an application (contained in an app.R file or ui.R/server.R files).\nR Package: I’ll use the term R package to describe a directory of functions, documentation, or data that can be installed and loaded into an R session. An R package includes the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench.\nShiny app-packages: A shiny app-package (which you have probably already guessed) is an R package containing a shiny application. shiny app-packages have all of the functionality of a standard R package but also contain the files and folders required to successfully develop, run, and deploy a shiny app.\n\n\nMotivation\nThere are multiple reasons for deciding to develop a shiny app-package: your shiny app project might need to be in an R package structure due to specific organizational practices around deploying applications, or maybe you’ve been convinced it will improve the shareability/reproducibility of your shiny app project.\nRegardless of the reason, you’ve likely found yourself in one of two circumstances:\n\nYou want to develop a new app, but want it structured as an R package.\nYou’ve already developed a shiny app project, but now you need to convert it to a shiny app-packages\n\nThe previous chapter covered a few practices to adopt during shiny development that improve the extensibility of your shiny app project to an shiny app-package.1\n\n\n\n\n\n\nR Packages & Posit Workbench\n\n\n\n\n\n\nPosit Workbench (formerly RStudio) is a popular integrated development environment (IDE) that streamlines many R package development tasks. I’ve purposely connected Posit Workbench to the definitions above for R package and Shiny app-packages–specifically, the package development tools provided in the Build pane and devtools.\nHowever, developing R packages in Posit Workbench (or using .Rproj files) is not required. There are alternative package development tools and processes outside of Posit Workbench, and many developers employ these setups.\nPackage development outside Posit Workbench would look almost identical to development in the IDE:\n\nCreate the package structure (R/ folder for .R scripts, man/ folder for documentation, data/ folder for datasets, etc.)\nAdd DESCRIPTION and NAMESPACE files, etc.\nEnsure the package can be installed and loaded into an R session.\n\nIt’s also possible to use many of the development workflow functions we’ll cover here outside of the IDE (roxygen2::roxygenize(), devtools::check(), devtools::install(), etc.).\n\n\n\n\n\n\nR packages vs. Shiny app projects\nBelow is are folder trees with some of the typical files and folders found in R packages (on the left) and the files that currently exist in shinyAppProj (on the right), our shiny app project.\n\n\n\n&lt;R package&gt;/\n    ├── DESCRIPTION\n    ├── &lt;R package&gt;.Rproj\n    ├── LICENSE \n    ├── LICENSE.md \n    ├── NAMESPACE \n    ├── NEWS.md\n    ├── README.Rmd\n    ├── README.md\n    ├── renv.lock\n    ├── R/\n    ├── man/\n    ├── tests/\n    ├── data/ \n    ├── data-raw/ \n    ├── vignettes/ \n    ├── inst/ \n    └── renv/\n  \n\n\nshinyAppProj/\n├── DESCRIPTION\n├── shinyAppProj.Rproj\n├── R/\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n└── www/\n    └── shiny.png\n\n4 directories, 9 files\n\n\n\nR packages can be easily shared, reused, and reproduced because they all have a familiar structure, and each folder and file plays an essential role in extending R’s capabilities.2\nThis chapter will cover the minimum requirements for an R package, so you can handle both creating new shiny app-packages and converting existing shiny projects into shiny app-packages."
  },
  {
    "objectID": "packages.html#what-makes-an-r-package",
    "href": "packages.html#what-makes-an-r-package",
    "title": "Packages",
    "section": "What makes an R package?",
    "text": "What makes an R package?\nIf you’ve done some research on R packages, you’ve probably encountering one (or both) of the following statements,\n\n‘Every package must have a DESCRIPTION. In fact, it’s the defining feature of a package (RStudio and devtools consider any directory containing DESCRIPTION to be a package)’ - R Packages, 2ed (Chapter 9, DESCRIPTION)\n‘all a project needs to be a package is a directory of R/ files and a DESCRIPTION file.’ - Mastering Shiny (Chapter 20, Packages)\n\nThe information above should be confusing if you’ve been following along with the code in shinyAppProj.\nWe’ve created a shiny app project (shinyAppProj) with a DESCRIPTION file and an R/ directory, but it’s not a functioning R package.\nAs we noted above, a functioning R package can be installed and loaded into an R session and has access to the Build pane in the IDE.\n\nCan we load it with devtools?\nPackage development kicks off with the load_all() function from devtools, which is similar to calling library() (we’ll cover this function extensively in the devtools chapter). However, when we attempt to load the code in the R/ folder with load_all(), we see the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n(a) Load All Error\n\n\nFigure 4.1: devtools is looking for the Package field in our DESCRIPTION file\n\n\n\n\nWhere is the ‘Build’ pane?\nWhen opened, functioning R packages have access to the Build pane, which allows developers to quickly load, install, and test their packages.\nBut when shinyAppProj is opened, the Build pane is not displayed in the IDE:\n\n\n\n\n\n\n(a) shinyAppProj IDE\n\n\nFigure 4.2: Project IDE panes\n\n\n\nAs we’ve just learned, the presence of the DESCRIPTION file and an R/ folder are insufficient to turn a shiny app project into a functioning R package (or a shiny app-packages)."
  },
  {
    "objectID": "packages.html#what-really-makes-an-r-package",
    "href": "packages.html#what-really-makes-an-r-package",
    "title": "Packages",
    "section": "What really makes an R package?",
    "text": "What really makes an R package?\n\n“A project needs a DESCRIPTION file with specific fields, a directory of R/ files, and a properly configured .Rproj file to be a functioning R package.”\n\nLet’s see how each of these requirements work together to convert the contents of shinyAppProj from a shiny app project into a shiny app-package.\n\nDESCRIPTION fields\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s 04_description branch\nThe official R documentation3 lists the following required fields for the DESCRIPTION in R packages:\n\nThe ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and ‘Maintainer’ fields are mandatory.\n\nBelow is an example DESCRIPTION file for shinyAppProj with the mandatory fields:4\n\nPackage: shinyAppProj\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\n\n\n\n\nAuthor and Maintainer fields\n\n\n\n\n\nNote that the Author and Maintainer fields require additional information beyond first and last name (i.e., John Smith). These can be created with the utils::person() function:\n\n# Author\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  role = c(\"aut\", \"cre\"))\n## [1] \"John Smith [aut, cre]\"\n# Maintainer\nutils::person(\n  given = \"John\", \n  family = \"Smith\", \n  email = \"John.Smith@email.io\")\n## [1] \"John Smith &lt;John.Smith@email.io&gt;\"\n\n\n\n\nAfter adding the mandatory fields to the DESCRIPTION file, devtools::load_all() runs without the previous error, but the IDE still doesn’t display the Build pane:\n\n\n\n\n\n\n(a) shinyAppProj IDE\n\n\nFigure 4.3: Where is the Build pane?\n\n\n\n\n\nProject Options…\n(i.e., the .Rproj file)\n.Rproj files are plain text files with various settings for the IDE. We were able to run devtools::load_all() above without the presence of the Build pane because the IDE displays the Build pane after reading the fields in the .Rproj file.\nThe quickest way to access the fields in the .Rproj file is under Tools &gt; Project Options….\n\nDefault options\nTools &gt; Project Options… provide access to the project-level options. For example, fields 2 - 4 are available under General, 5 - 8 affect the Code options, and the final two fields deal with Sweave.\n\n\n\n\n\n(a) shinyAppProj.Rproj fields\n\n\nFigure 4.4: Field settings from shinyAppProj.Rproj file\n\n\nThe default settings were created when we selected the shiny app project from the New Project Wizard in the last chapter.\n\n\nBuild tools\nI’ve placed the .Rproj file from shinyAppPkg with the example .Rproj file from R Packages, (2ed) side-by-side so you can compare them below:5\n\n\n\n\n\n(a) .Rproj files\n\n\nFigure 4.5: Comparison of shinyAppProj.Rproj file and .Rproj file in R Packages, 2ed\n\n\nI’ve circled the fields in the .Rproj file that illustrate it’s configured to work with an R package. Note that in shinyAppProj, the Project build tools are initially set to (None) under Build Tools:\n\n\n\n\n\n(a) shinyAppProj.Rproj build tools\n\n\nFigure 4.6: Build tool settings in shinyAppProj.Rproj file\n\n\nChanging the Project build tools option to Package will set the default Build Tools options:6\n\n\n\n\n\n(a) Default package build tools\n\n\nFigure 4.7: Default build tool settings\n\n\nThe links between the Build Tools options and fields in shinyAppProj.Rproj are in the figure below:\n\n\n\n\n\n(a) shinyAppProj.Rproj build tool fields\n\n\nFigure 4.8: Default build tool settings in shinyAppProj.Rproj file\n\n\n\nBuildType: Package tells the IDE shinyAppProj is an R package and triggers the Build pane.\nPackageUseDevtools: Yes links the options in the Build pane to the devtools package.\nThe PackageInstallArgs are complicated, but I’ve included some information about them in the callout block below (and you can read more in the official R documentation)\nThe fourth option (PackageRoxygenize) is available under Generate documentation with Roxygen &gt; Use roxygen to generate:\n\nThese options affect the documentation in an R package. To match the example from R Packages, 2ed above, make sure Rd files, Collate field, and NAMESPACE file are selected and click OK.\n\n\n\n\n\n\n\n(a) PackageRoxygenize in .Rproj file\n\n\nFigure 4.9: roxygen2 build settings\n\n\nAfter clicking OK, the IDE will automatically reboot, and the additional fields will be added to the bottom of the shinyAppProj.Rproj:\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s 05_rproj branch\n\nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\nPackageRoxygenize: rd,collate,namespace\n1\n\n\n1\n\nAlways leave an empty final line in the DESCRIPTION\n\n\n\n\n\n\n\n\n\n\nWhat is --no-multiarch --with-keep.source?\n\n\n\n\n\n\n\n--no-multiarch: refers to the option for the package installer to only compile the package for the architecture of the current R session. By default, R tries to compile packages for 32-bit and 64-bit architectures if running in a 64-bit R session on Windows. This flag can help avoid problems if a package can only be compiled on one architecture. Read more here.\n--with-keep.source: In R, when a function is created, its body can be stored in two ways: 1) as a parsed but unevaluated expression and 2) as a character string containing the function’s source code. By default, only the parsed expression is kept. If –with-keep.source is specified, R will also keep the source code as a character string, which can be helpful for debugging and tools that analyze or modify source code. Read more here.\n\n\n\n\n\n\n\nBuild pane\nWhen the new session starts, the new project-level options activate the Build pane in the IDE.\n\n\n\n\n\n\n(a) Build pane in IDE\n\n\nFigure 4.10: Build pane triggered from project-level settings\n\n\n\nWhen the IDE reboots, I can see the Build pane has been added, and I can check the R package functionality by loading the code with Build &gt; Load All\n\n\n\n\n\n(a) Load the code in the R/ folder\n\n\nFigure 4.11: Identical to running devtools::load_all()\n\n\nI should see the following in the Console:\nℹ Loading shinyAppProj\nThere you have it–shinyAppProj is a functional R package!"
  },
  {
    "objectID": "packages.html#functional-r-packages",
    "href": "packages.html#functional-r-packages",
    "title": "Packages",
    "section": "Functional R packages",
    "text": "Functional R packages\n\n\n\n\n\n\n(a) shiny app-package (with DESCRIPTION and Build pane)\n\n\nFigure 4.12: Fully functional shiny app-package\n\n\n\nIn a functional R package:\n\nThe DESCRIPTION file contains the seven mandatory fields (Package, Version, License, Description, Title, Author, and Maintainer), making running the necessary devtools functions possible.\nThe .Rproj file contains the three package configuration fields (BuildType: Package, PackageUseDevtools: Yes, and PackageInstallArgs: --no-multiarch --with-keep.source), which makes the Build pane accessible and functional.\n\nThe items above will create a functional R package, but these are the first steps (we haven’t developed anything yet!) on our way to a shiny app-package.\nThink of the two items above as a two-part process: the DESCRIPTION requires specific fields,7 and the IDE requires .Rproj fields to trigger the Build pane.8"
  },
  {
    "objectID": "packages.html#creating-shiny-app-packages-with-create_package",
    "href": "packages.html#creating-shiny-app-packages-with-create_package",
    "title": "Packages",
    "section": "Creating shiny app-packages with create_package()",
    "text": "Creating shiny app-packages with create_package()\nThe Posit documentation9 lists the following ways to create R packages,10\n\n\nCall usethis::create_package().\nIn RStudio, do File &gt; New Project &gt; New Directory &gt; R Package. This ultimately calls usethis::create_package(), so really there’s just one way.\n\n\ncreate_package() is a great option if you’re looking for a way to quickly create or convert your shiny app project into a shiny app-package.11 In the following sections I’ll cover some suggestions for using create_package().\n\nNew shiny app-packages\nIf you haven’t written any code and want to create a new shiny app-package, create_package() is the quickest way to get started.\nFirst, install devtools:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\ndevtools automatically loads usethis\nLoading required package: usethis\nAssuming your current working directory is where you want your new shiny app-package, call usethis::create_package() with the path argument set to getwd()\n\nusethis::create_package(path = getwd())\n\nThis call launches a series of actions:\n\nFirst, the active project is set to whatever was given to the path argument.\n✔ Setting active project to 'path/to/newApp'\nThe R/ folder and DESCRIPTION/ file are created:\n✔ Creating 'R/'\n✔ Writing 'DESCRIPTION'\nThe NAMESPACE and .Rproj files are created:\n✔ Writing 'NAMESPACE'\n✔ Writing 'newApp.Rproj'\nThe .Rproj is added to the .Rbuildignore file, the .Rproj.user folder is added to the .gitignore and .Rbuildignore files.\n✔ Adding '^newApp\\\\.Rproj$' to '.Rbuildignore'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\nA new session is opened from the new .Rproj file:\n✔ Opening 'path/to/newApp/' in new RStudio session\n\nWhen the new session opens, newApp has the following contents:\n\nnewApp/\n  ├── .Rbuildignore\n  ├── .Rproj.user/\n  ├── .gitignore\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  └── newApp.Rproj\n\nYou’re now free to develop newApp. Store and document any .R files in the R/ folder, edit the DESCRIPTION file with details about the application, read through R Packages and Mastering Shiny, and add the shiny code to complete your shiny app-package.\n\n\nConverting existing shiny app projects\nIf you already have a shiny app project that needs to be converted into a shiny app-package (like the app files stored in the 03_proj-app branch), you can also use create_package(path = getwd()) in your root folder, but I recommend using the following arguments:\n\nDESCRIPTION arguments\n\nfields: these are arguments passed to usethis::use_description(). If the fields argument is empty, a boilerplate DESCRIPTION file is created (similar to this one).\n\nThese boilerplate fields in the DESCRIPTION work, but I’ve found some of the fields are unnecessary (i.e., I’ve never needed Authors@R: or ORCID) and inevitably require revision, so I’d prefer to handle this during the creation process (and remove the risk of forgetting to change it later).\nAll fields should be passed in a list() as field = 'value' pairs.\n\n\nusethis::use_description(\n    list(Package = 'shinyAppProj',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"))\n\n\nA few fields require specially formatted values (see the utils::person() examples below).\n\nutils::person(\"John\", \"Smith\", \n              email = \"John.Smith@email.io\", \n              role = c(\"aut\", \"cre\"))\n\n[1] \"John Smith &lt;John.Smith@email.io&gt; [aut, cre]\"\n\n\n\nTwo additional arguments from use_description() are passed to create_package():\n\ncheck_name: verifies your shiny app-package name is valid for CRAN, so we can set this to FALSE (unless you’re planning on submitting to CRAN)\nroxygen2: is TRUE by default and adds the fields required to use roxygen2 (which I won’t cover here because we’ll cover documentation in-depth in a future chapter).\n\n\n\n\n\n\n\n\nWARNING: Don’t use usethis::create_package('.')!\n\n\n\n\n\n\nWhen converting your existing shiny app project into a shiny app-package with usethis::create_package(), don’t use '.' in the path argument:\nusethis::create_package('.')\nThis will return the following warning about creating nested projects, and ask if you want to proceed anyway:\nNew project 'shinyAppProj' is nested inside an existing project\n'./', which is rarely a good idea. If this is unexpected, \nthe here package has a function,\n`here::dr_here()` that reveals why './' is regarded as a\nproject.\n  \nDo you want to create anyway?\n\n1: Yes\n2: No way\n3: Not now\nWe can avoid this warning altogether by passing getwd() to the path argument, so I recommend cancelling the project creation:\nSelection: 2\nError: Cancelling project creation.\n\n\n\n\n\n\nIDE arguments\n\nrstudio: adds the necessary Build Tools fields in the .Rproj file (leave as TRUE)\nopen: can be set to FALSE because we don’t need RStudio/Posit Workbench to open in a new session\n\n\nusethis::create_package(\n  path = getwd(),\n  fields = list(Package = 'shinyAppProj',\n         Version = '0.0.0.9000',\n         Title = 'movies app',\n         Description = 'A movie-review shiny application.',\n         \"Authors@R\" = NULL,\n         Author = utils::person(\n            given = \"John\", \n            family = \"Smith\", \n            email = \"John.Smith@email.io\", \n            role = c(\"aut\", \"cre\")),\n          Maintainer = utils::person(\n            given = \"John\", \n            family = \"Smith\",\n            email = \"John.Smith@email.io\"),\n          License = \"GPL-3\"),\n  roxygen = TRUE,\n  check_name = FALSE, \n  rstudio = TRUE,\n  open = FALSE)\n\nAfter running usethis::create_package() with the arguments above, the IDE will present us with a few prompts to confirm:\nOverwrite pre-existing file 'DESCRIPTION'?\nOverwrite pre-existing file 'shinyAppProj.Rproj'?\nThe shiny app-package structure is below:\n\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   ├── mod_scatter_display.R\n│   ├── mod_var_input.R\n│   └── utils.R\n├── README.md\n├── app.R\n├── movies.RData\n├── shinyAppProj.Rproj\n└── www\n    └── shiny.png\n\n3 directories, 10 files\n\nThe DESCRIPTION file (shown below) has a few additional fields (Encoding, Roxygen, and RoxygenNote) we didn’t include when we converted shinyAppProj above, but we will cover these in the upcoming chapters.\n\nPackage: shinyAppProj\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith &lt;John.Smith@email.io&gt; [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s 06_create-package branch"
  },
  {
    "objectID": "packages.html#recap",
    "href": "packages.html#recap",
    "title": "Packages",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered the mandatory fields in the DESCRIPTION file and the R package configuration fields in .Rproj. We also covered creating and converting shiny app projects using the usethis::create_package() function.\n\n\n\n\n\n\nRecap: Packages!\n\n\n\n\n\n\n\nThe DESCRIPTION file ultimately controls whether you have a functional shiny app-package.\n\nThe mandatory fields are Package, Version, License, Description, Title, Author, and Maintainer.\n\nusethis::create_package() can be used to create a new R package and to convert an existing shiny project into a shiny app-package.\nThe IDE reads RStudio (.Rproj) files and determines R session settings at the project-level (i.e., working directory, workspace, history, code formatting, etc.)\n\nPackage development settings can be accessed via Project Options &gt; Build Tools.\n\n\n\n\n\n\nIn the next chapter, I’ll cover how you can quickly Load, Document, and Install your package!\nend packages.qmd"
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "Packages",
    "section": "",
    "text": "Shiny app project features are covered in the Project Folders section of the Shiny apps chapter.↩︎\nFortunately, shiny app-packages don’t require all the files and folders displayed in the folder tree to gain the functionality and benefits of an R package.↩︎\nThe mandatory fields are covered in Writing R Extensions, ‘The DESCRIPTION file’↩︎\nAlways leave empty final line in the DESCRIPTION file.↩︎\n.Rproj files are covered in the What makes an RStudio Project? section of R Packages (2 ed)↩︎\nThe initial Build Tools settings (i.e., (None)) should help explain the absence of any R package development fields in the shinyAppProj.Rproj when we compared it to the version in R Packages, 2ed (i.e., BuildType, PackageUseDevtools, PackageInstallArgs, and PackageRoxygenize).↩︎\nThe mandatory fields prevent the devtools error we encountered above.↩︎\nIf you’d like to learn more about the topics in this chapter, you should read Writing R Extensions (the official documentation for creating R packages) and R Packages, 2ed.↩︎\nThis information comes from the Writing R Packages documentation for Posit Workbench.↩︎\nWe now know it’s possible to create an R package with the DESCRIPTION file fields and configuring the Project Build Tools.↩︎\nusethis::create_package() is covered in the ‘Fundamental development workflows’ chapter of R Packages, 2ed↩︎"
  },
  {
    "objectID": "development.html#developing-packages-with-devtools",
    "href": "development.html#developing-packages-with-devtools",
    "title": "Development",
    "section": "Developing packages with devtools",
    "text": "Developing packages with devtools\n\n“One package to rule them all.” - Not the devtools development team\n\nIf you’re new to package development, having a little background on the devtools package is helpful. Earlier versions of devtools contained most of the functions used for package development. In version 2.0, devtools went under a conscious uncoupling, which means there was a “division of labor” for its core functionality:\n\nThe usethis package contains the functions for creating package folders and files (.R files, tests, vignettes, etc.). usethis is also automatically loaded when you call library(devtools).\nLoading and building your app-package is handled by pkgload and pkgbuild\nFor app-packages destined for CRAN, the R CMD check is handled by rcmdcheck and revdepcheck\nInstalling packages from non-CRAN repositories (i.e., install_github()) is handled by remotes\n\nYou don’t have to install all of these packages (they will be loaded with devtools), but the information is essential because it affects the dependencies in your app-package:\n\n‘Package developers who wish to depend on devtools features should also pay attention to which package the functionality is coming from and depend on that rather than devtools. In most cases, packages should not depend on devtools directly.’ - devtools 2.0.0, tidyverse blog\n\nWe will cover this topic more in the dependencies chapter."
  },
  {
    "objectID": "development.html#shinyappproj",
    "href": "development.html#shinyappproj",
    "title": "Development",
    "section": "shinyAppProj",
    "text": "shinyAppProj\nLet’s assume we’re continuing with the app project we converted manually in the 04_description branch of shinyAppProj (the files and folders are below).\n\n\n\n\n\n\nGit Branch\n\n\nshinyAppProj repo’s 04_description branch\n\n\nshinyAppProj/ # 04_description branch\n  ├── DESCRIPTION\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── shinyAppProj.Rproj\n  └── www\n      └── shiny.png\n\n4 directories, 9 files\n\nWe’re backing up to the branch we created by manually editing the DESCRIPTION file to show the connection between the devtools functions and specific fields in the DESCRIPTION file.1\n\nDESCRIPTION\nThe version of shinyAppProj in this branch has a DESCRIPTION file with the seven mandatory fields:\n\n# in Terminal\n$ cat DESCRIPTION \nPackage: shinyAppProj\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\n1\n\n\n1\n\nLeave an empty final line in the DESCRIPTION\n\n\n\n\n\n\nshinyAppProj.Rproj\nHowever, the .Rproj file is still configured to work with a shiny project:2\n\n# in Terminal\n$ cat shinyAppProj.Rproj \nVersion: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: XeLaTeX"
  },
  {
    "objectID": "development.html#package-development-habits",
    "href": "development.html#package-development-habits",
    "title": "Development",
    "section": "Package development habits",
    "text": "Package development habits\nThe differences between developing an R package and a shiny app can be boiled down to a handful habits, each of which calls a devtools function:\n\n\nI’ll use bold to indicate each devtools habit and accompanying function.\n\nLoad all the functions and data in your app-package with load_all()\nDocument the app-package functions and data with document()\nInstall the app-package with install()\n\nIn the sections below, I’ll cover each function and my opinion about how it should be used when your shiny app becomes an app-package.3\n\n\n\n\n\n\nKeyboard shortcuts\n\n\n\n\n\n\nI strongly recommend using the keyboard shortcuts for each devtools function. Shortcuts reduce typing and bundle all those keystrokes into a single action. They also create a kind of ‘muscle memory’ for each step.\n\n\n\n\n\nLoad\nInstall devtools\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\n\nusethis is automatically loaded/attached with devtools.\nLoading required package: usethis\n\n‘load_all() removes friction from the development workflow and eliminates the temptation to use workarounds that often lead to mistakes around namespace and dependency management’ - Benefits of load_all(), R Packages, 2ed\n\nload_all() is the most common devtools function we’ll use during development because we should load the package when anything changes in the R/ folder.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\n\ndevtools::load_all()\n\nUsing load_all() is similar to calling library(shinyAppProj) because it loads the code in R/ along with any data files. load_all() is also designed for iteration (unlike using source()), and when it’s successful, the output is a single informative message:\nℹ Loading shinyAppProj\n\n\nDocument\nThe document() function from devtools serves two purposes:\n\nWriting the package NAMESPACE file\nCreates the help files in the man/ folder\n\ndevtools is smart enough to recognize the first time document() is called, so when I initially run it in the Console, it prompts me that the roxygen2 version needs to be set in the DESCRIPTION file:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\ndevtools::document()\n\nℹ Updating shinyAppProj documentation\nFirst time using roxygen2. Upgrading automatically...\nSetting `RoxygenNote` to \"7.2.3\"\ndevtools relies on roxygen2 for package documentation, so the RoxygenNote field is required in the DESCRIPTION. You may have noticed calling document() also calls load_all(), which scans the loaded package contents for special documentation syntax before writing the NAMESPACE file (we’ll cover the NAMESPACE in the chapter on Dependencies).\nℹ Loading shinyAppProj\nWriting NAMESPACE\nIf we open the NAMESPACE file, we see it’s empty (and that we shouldn’t edit this file by hand).\n\n\n\n\n\n(a) NAMESPACE\n\n\nFigure 5.1: Initial NAMESPACE file\n\n\nThe last few output lines warn us to include the Encoding field in the DESCRIPTION. devtools won’t automatically add Encoding (like it did with RoxygenNote above), so we’ll need to add it to the DESCRIPTION file manually:\nWarning message:\nroxygen2 requires Encoding: \"UTF-8\"\nℹ Current encoding is NA \n\nPackage: shinyAppProj\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\n1Encoding: UTF-8\n2\n\n\n1\n\nThe Encoding value shouldn’t include quotes like the warning message above (i.e., UTF-8)\n\n\n2\n\nAlways leave an empty final line in the DESCRIPTION\n\n\n\n\nAfter adding the required fields to the DESCRIPTION file,4 we’ll document() the package again using the keyboard shortcut:\nIn the Build pane, we see the following:\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating shinyAppProj documentation\nℹ Loading shinyAppProj\nDocumentation completed\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\n\n\nInstall\nThe final package development habit to adopt is regularly installing the package with devtools::install().\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n\ndevtools::install()\n\ninstall() will prompt the following output in the Build pane:\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source shinyAppProj\n\n* installing to library ‘/path/to/local/install/shinyAppProj-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘shinyAppProj’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\nNo man pages found in package  ‘shinyAppProj’ \n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (shinyAppProj)\nThere are a few connections worth making in this initial install() output:\n\nThe first line in the output should look familiar–we saw both of these settings in the shinyAppProj.Rproj file from the previous chapter\nPackageInstallArgs: --no-multiarch --with-keep.source\nNo man pages found in package 'shinyAppProj' tells us none of the code in R/ has adequately been documented (which we’ll cover in the roxygen2 chapter)\ninstall() attempts to install the package from the *source* files and a ‘bundle’ or source tarball file (i.e., .tar.gz)\nhelp files are built, along with other documentation (like vignettes)\nDONE (shinyAppProj) means shinyAppProj was successfully installed!\n\nInstall a package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppProj repo’s 06_devtools branch\n\n\nCheck?\ndevtools::check() performs a series of checks to ensure a package meets the standards set by CRAN. You can consider check() as a ‘quality control’ function for documentation, NAMESPACE dependencies, unnecessary or non-standard folders and files, etc. R Packages recommends using check() often, but I agree with the advice in Mastering Shiny on using check() with app-packages,\n\n‘I don’t recommend that you [call devtools::check()] the first time, the second time, or even the third time you try out the package structure. Instead, I recommend that you get familiar with the basic structure and workflow before you take the next step to make a fully compliant package.’\n\nHowever, I’ve included an example of running check() on shinyAppProj in the callout box below to demonstrate how it works.\n\n\n\n\n\n\nRunning devtools::check()\n\n\n\n\n\n\ndevtools::check()\n\nThe output from check() can be rather lengthy (it’s pretty comprehensive!), and it provides feedback on each item in the form of a note (N), warning (W), or error (E).\n==&gt; devtools::check()\n\nDuration: 15.3s\n\nN  checking top-level files\n   Non-standard files/directories found at top level:\n     ‘app.R’ ‘movies.RData’\n\nW  checking dependencies in R code ...\n   '::' or ':::' imports not declared from:\n     ‘ggplot2’ ‘shiny’ ‘stringr’\n\nN  checking R code for possible problems (3.1s)\n   mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n     variable ‘movies’\n   scatter_plot: no visible binding for global variable ‘.data’\n   Undefined global functions or variables:\n     .data movies\n\nW  checking for missing documentation entries ...\n   Undocumented code objects:\n     ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n     ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n   All user-level objects in a package should have documentation entries.\n   See chapter ‘Writing R documentation files’ in the ‘Writing R\n   Extensions’ manual.\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nA summary of each item is below:\n\nchecking top-level files: This note refers to the two non-standard (i.e., not typically found in an R package) files, app.R and movies.RData.\nchecking dependencies in R code: This warning tells I need to namespace functions from add-on packages (in this case, ggplot2, shiny, and stringr)\nchecking R code for possible problems: This item refers to the call to load the movies data in the module server function (mod_scatter_display_server).\nchecking for missing documentation entries: This is warning me that the module functions aren’t properly documented and refers me to the official R documentation.\n\nEach of these items is also printed under the ── R CMD check results heading:\nDuration: 15.3s\n\n❯ checking dependencies in R code ... WARNING\n  '::' or ':::' imports not declared from:\n    ‘ggplot2’ ‘shiny’ ‘stringr’\n\n❯ checking for missing documentation entries ... WARNING\n  Undocumented code objects:\n    ‘mod_scatter_display_server’ ‘mod_scatter_display_ui’\n    ‘mod_var_input_server’ ‘mod_var_input_ui’ ‘scatter_plot’\n  All user-level objects in a package should have documentation entries.\n  See chapter ‘Writing R documentation files’ in the ‘Writing R\n  Extensions’ manual.\n\n❯ checking top-level files ... NOTE\n  Non-standard files/directories found at top level:\n    ‘app.R’ ‘movies.RData’\n\n❯ checking R code for possible problems ... NOTE\n  mod_scatter_display_server : &lt;anonymous&gt;: no visible binding for global\n    variable ‘movies’\n  scatter_plot: no visible binding for global variable ‘.data’\n  Undefined global functions or variables:\n    .data movies\n\n0 errors ✔ | 2 warnings ✖ | 2 notes ✖\nIf you’re submitting your app-package to CRAN (or want to use check() for other reasons), follow the suggested workflow for check():\n\nThe workflow for checking a package is simple, but tedious:\n\nRun devtools::check() or press Shift + Ctrl/Cmd + E\nFix the first problem.\nRepeat until there are no more problems.’\n\n\nI’ve found a good habit for when to check() to be:\nAfter adding a bug fix or feature, check a package and keep any notes, warnings, or errors from accumulating.\n\n\n\n\n\nRecap\nCreating an app-package involves adopting some new devtools habits, and the initial contents of shinyAppProj hopefully helped demonstrate the purpose of each function.\n\n\n\n\n\n\nRecap: Package development habits\n\n\n\n\n\n\nAfter installing and loading devtools:\n\nLoad the package whenever changes occur in the R/ folder.\n\nCtrl/Cmd + Shift + L load all the code in the package.\n\nDocument the package whenever changes are made to any roxygen2 syntax (or settings).\n\nCtrl/Cmd + Shift + D record the documentation and dependencies.\n\nInstall the package after the initial setup, after major changes to the code, documentation, or dependencies, and before committing or sharing.\n\nCtrl/Cmd + Shift + B confirms the package can be installed.\n\n\nHabits require repetition to develop, and I hope the workflow above can be applied to your shiny app-packages, provided you’re using devtools and Posit workbench.\n\n\n\n\nThe following section will cover documenting functions with roxygen2"
  },
  {
    "objectID": "development.html#footnotes",
    "href": "development.html#footnotes",
    "title": "Development",
    "section": "",
    "text": "If you create or convert your shiny app project with usethis::create_package(), a few fields (i.e., Roxygen and RoxygenNote) are added automatically without explaining their role or purpose.↩︎\nIf you created your shiny app using the New Project Wizard, your .Rproj file has been configured to work with project, not a package.↩︎\nThe topics covered in this section shouldn’t be considered a replacement for the ‘Whole Game’ chapter in R packages (2 ed) or the ‘Workflow’ section of Mastering Shiny (and I highly recommend reading both).↩︎\nAlways leave an empty final line in the DESCRIPTION file.↩︎"
  },
  {
    "objectID": "app_packages.html#introduction-review-chapters-1---3",
    "href": "app_packages.html#introduction-review-chapters-1---3",
    "title": "App-packages",
    "section": "Introduction (Review Chapters 1 - 3)",
    "text": "Introduction (Review Chapters 1 - 3)\nLet’s briefly review what we’ve covered in the last three chapters:\n\nWhole app game (Chapter 1)\nThe Whole app game chapter walks through the ‘whole game’ of the app-package development workflow. The application in this example comes from the Packages chapter of Mastering Shiny.\n\n\n\n\n\n\nChapter 1: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 1 (Whole app game) is stored in the following repository:\n\nmonthAppPkg\n\n\n\n\n\n\n\nShiny apps (Chapter 2)\nThe Shiny apps Chapter covered shiny projects and some ‘pre-package practices’ to adopt for your shiny app that can make the transition to working with app-packages easier.\n\n\n\n\n\n\nChapter 2: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 2 (Shiny apps) is stored in the following branches:\n\nmain: Contains a new shiny app project created from the New Project Wizard (with Old Faithful Geyser Data)\n02_movies-app: The boilerplate app in app.R is replaced with the code for the movie review application, and the scatter_plot() utility function is added to utils.R and movies.RData is added to the project.\n03_proj-app contains an ‘fully developed’ shiny app project with the following contents:\n\nDESCRIPTION file\n\nREADME.md file\n\nR/ folder\n\nModules: two module files are created in the R/ folder (mod_var_input.R and mod_scatter_display.R)\n\nStandalone app function: the code in app.R is converted to a standalone app function: movies_app()\nUtility function: Move utils.R into the R/ folder\n\n\nThe www/ folder contains the image file (shiny.png)\n\nDeployment: The rsconnect/ folder contains files for deploying to shinyapps.io\n\n\n\n\n\n\n\n\nPackages (Chapter 3)\nPackages illustrated what separates projects from R packages. This chapter also covered 1) how to create a new shiny app-package or 2) convert an existing shiny project into an app-package.\n\n\n\n\n\n\nChapter 3: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 3 (Projects) is stored in the following branches:\n\n03_proj-app is an ‘advanced’ package from the previous chapter\n04_description is a branch from 03_proj-app and adds the seven mandatory DESCRIPTION fields.\n05_rproj is a branch from 04_description and manually converts the shiny app project to a shiny app-package using the .Rproj file.\n06_create-package is a branch from 03_proj-app and creates a package using usethis::create_package()\n\n\n\n\n\n\n\nDevelopment (Chapter 4)\nDevelopment introduced the devtools package and its core functions (load_all(), document(), and install()).\n\n\n\n\n\n\nChapter 4: GitHub Repository & Branches\n\n\n\n\n\n\nThe code for Chapter 4 (devtools) is stored in the following branch:\n\n06_devtools is a branch from the manually converted app-package in 05_rproj\n\n\n\n\n\nWe’re now at a point that we’ve converted a Shiny project (shinyAppProj) into a package. The package conversions live in the 06_devtools and 06_create-package branches:\n\nIn the 06_devtools branch, shinyAppProj was converted to a package by manually adding the required fields to the DESCRIPTION file, then running the key devtools development functions (load_all(), document(), and install())\n\nPackage: shinyAppProj\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\n1\n\n\n1\n\nAlways leave an empty line in the DESCRIPTION\n\n\n\n\nIn the 06_create-package branch, we used the usethis::create_package() function to convert shinyAppProj into a package.\n\nPackage: shinyAppProj\nTitle: movies app\nVersion: 0.0.0.9000\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nDescription: A movie-review shiny application.\nLicense: GPL-3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.2.3\n\n\nThe only difference between these two branches lies in the DESCRIPTION files–in the 06_create-package branch, the Roxygen: list(markdown = TRUE) field was added (which we will cover in the upcoming Documentation chapter)."
  },
  {
    "objectID": "app_packages.html#app-packages-chapters-5---10",
    "href": "app_packages.html#app-packages-chapters-5---10",
    "title": "App-packages",
    "section": "App-packages (Chapters 5 - 10)",
    "text": "App-packages (Chapters 5 - 10)\nThe following three sections will continue with app-package development, emphasizing developing a shiny application within a package structure. We’ll be using the code stored in the shinyAppPkg repository.\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s main branch\n\n\n\n\n\n\nGitHub [shinyAppPkg]:[main]\n\n\n\n\n\n\nThe code for the next section can be found in the main branch of the shinyAppPkg repo.\nThe main branch of shinyAppPkg is identical to the 06_create-package branch from the shinyAppProj repository from the previous section:\nshinyAppPkg/ # 06_create-package\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man\n  ├── movies.RData\n  ├── shinyAppPkg.Rproj\n  └── www\n      └── shiny.png\n  \n  4 directories, 10 files\nThe rsconnect/ folder has been removed because we’ll cover deploying shinyAppPkg in future sections.\n\n\n\n\nA preview of the topics covered in the following chapters is provided below.\n\nDocumentation (Chapter 5)\n\nroxygen2 basics:\n\nRequired tags\n\n@title, @description, @details, @param, @return, and @examples\n\n\nApp-package considerations for modules and standalone app functions:\n\n@seealso, @family, and @section\n\n\n\n\n\nDependencies (Chapter 6)\n\nExporting functions from your package namespace\n\n@export/export()\n\n\nImporting functions from add-on packages into your package namespace\n\n@import/import(), @importFrom/importFrom()\n\n\nThe Imports field in the DESCRIPTION\n\n\n\nLaunch (Chapter 7)\n\nWhat goes in app.R?\n\nshinyApp() vs. runApp()\n\n\n\n\nData (Chapter 8)\n\nDocumenting data with\n\nroxygen2: @format, \\describe, \\item\n\n\nLocation of data files: data/ vs. data-raw/ vs. inst/extdata/\n\n\n\nExternal files (Chapter 9)\n\ninst/ & www/\nsystem.file()\naddResourcePath()\n\n\n\nTests (Chapter 10)\n\nUser specifications, feature requirements, functional requirements\nUnit tests with testthat\nModule server function tests with testServer()\nEnd-to-end/system tests with shinytest2"
  },
  {
    "objectID": "document.html#roxygen2-basics",
    "href": "document.html#roxygen2-basics",
    "title": "Documentation",
    "section": "roxygen2 basics",
    "text": "roxygen2 basics\n\n\n\n\n\n\nGit Branch\n\n\nshinyAppPkg repo’s main branch\n\nroxygen2 connects the package code (i.e., the .R files in the R/ folder) to its documentation files (i.e., the .Rd files in the man/ folder):\n\n\n\n\n\n(a) roxygen2\n\n\nFigure 6.1: roxygen2 creates man/ documentation\n\n\nThe two pieces of roxygen2 syntax to know are comment blocks and tags:\n\nComment blocks are any lines beginning with #'\n#' \n#' \n#' \nTags begin with @\n#' \n#' @tag\n#' \n\nWhen documenting functions, roxygen2 tags and comment blocks are placed directly above any functions stored in R/.\n#' \n#' @tag\n#' \nmy_fun &lt;- function() {\n  \n}\nIn the following sections, we’ll cover roxygen2 basics using examples for the scatter_plot() function found in R/utils.R.\n\n\n\n\n\n\nInserting roxygen2 skeletons\n\n\n\n\n\n\nYou can insert an roxygen2 skeleton into your function using Code &gt; Insert Roxygen Skeleton\n\n\n\nStandard roxygen2 skeleton\n\n\n\n\n\n\n\nmarkdown = TRUE\nWhen we created our app-package with usethis::create_package(), support for markdown formatting in package help files is automatically included by adding Roxygen: list(markdown = TRUE) to the DESCRIPTION file:\n\nPackage: shinyAppPkg\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nDisplayMode: Showcase\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\n1\n\n\n1\n\nAlways leave at least one empty final line in your DESCRIPTION file.\n\n\n\n\n\n\n@title & @description\nThe first two sections of roxygen2 documentation are the title and description. These sections don’t require tags–roxygen2 will detect each section as long as there is at least one #' line separating them (and their contents don’t extend past the length indicated in parentheses below):\n#' function title (one line)\n#'\n#' A short description... (one paragraph)\n#' \nThe @title and @description for the scatter_plot() function stored in R/utils.R might look like this:\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `shinyAppPkg()`.\n#' \n\n\n\n\n\n\nFunction @description and @details\n\n\n\n\n\nIf the contents in the @description for a function requires more complicated formatting than a single paragraph (i.e., multiple paragraphs, lists, etc.), you can use the @details tag:\n#' Create scatter plot  \n#' \n#' @description\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `shinyAppPkg()`.\n#' \n#' @details\n#' `scatter_plot()` is a custom `ggplot2` function written to handle string arguments from reactive inputs (i.e., `input$x` or `input$y`). \n\n\n\n\n\n@param & @return\nDocument function arguments and outputs with @param and @return:\n\n@param: should include the name and description of each function input (i.e., their type and what they do)\n#' @param name description of its action\n\nRead more here\n\n@return: these describe the type (or class) and structure of the function output\n#' @return type/structure of the output\n\nRead more here\n\n\nBelow are examples for @param and @return in the scatter_plot() function stored in R/utils.R:\n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\nTo view how the roxygen2 syntax will appear in the .Rd file, I’ll document shinyAppPkg:\n\n\nTo reduce the amount of repetitive code, I’ll just be showing the keyboard shortcuts for each devtools function from this point forward\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\nI can see the scatter_plot.Rd file is written to the man/ folder:\nℹ Updating shinyAppPkg documentation\nℹ Loading shinyAppPkg\nWriting scatter_plot.Rd\nDocumentation completed\nR documentation (.Rd) files have a formatting style similar to (La)TeX (but roxygen2 saves us from having to learn this syntax). When we open man/scatter_plot.Rd, we see it contains the following:\n\n\n\n\n\n\n(a) .Rd file\n\n\nFigure 6.2: R documentation file\n\n\n\n\n\n\n\n\n\n.Rd file syntax\n\n\n\n\n\n\nroxygen2 graciously generates the scatter_plot.Rd file (and warns us not to edit it by hand).\n\n\n\nroxygen2 tag syntax in .Rd file\n\n\nNote the following items were added without needing tags:\n\n\\name: the name of the function (as it appears in the index)\n\\alias: used to group ‘topics’ and provides a look-up in the package index\n\\arguments: function arguments (header)\n\n\\item: description of argument\n\n\nThe following two items are a result of the markdown syntax we used:\n\n\\href: used for hyperlinks\n\\code: code formatting\n\n\n\n\n\nTo view the help file, I can enter ?scatter_plot in the console:\n\n?scatter_plot\n\nAnd an informative message tells me that the development version scatter_plot.Rd is being rendered:\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n\n(a) .Rd file\n\n\nFigure 6.3: Help file\n\n\n\nPreviewing the development documentation is a great way to verify the content in each .Rd file meets expectations.\n\n\n@examples\n@examples are unique because they include executable code demonstrating how a function works. In the Posit Workbench IDE, @examples are especially helpful because they come with a ‘single click’ hyperlink (the @examples from ggplot2::aes() are below):\n\n\n\n\n\n\n\n\n(a) Run examples hyperlink\n\n\n\n\n\n\n\n\n\n(b) Executed @examples code\n\n\n\n\nFigure 6.4: Run examples in help files\n\n\n\nThe syntax to create an example for scatter_plot() is below:\n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n\n\n\n\n\n\nTab-completion for @tags\n\n\n\n\n\n\nIf you’re documenting your package functions in Posit Workbench, tab-completion is your friend! The help text displayed with each tag ensures you’re including the correct version (see @example vs. @examples below).\n\n\n\nTab completion for @example\n\n\n\n\n\nTab completion for @examples\n\n\nRead more here.\n\n\n\n\nTo preview the @examples in the help file, I’ll document() and open the development .Rd file:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n?scatter_plot\nℹ Rendering development documentation for \"scatter_plot\"\n\n\n\n\n\n\n\n(a) @examples in .Rd preview\n\n\nFigure 6.5: Preview of examples\n\n\n\nThe Run examples hyperlink won’t be active in the .Rd file preview, but reviewing the code in @examples allows me to correct any errors or typos early.\nThe scatter_plot() function has a documented Title, Description, Usage, Arguments, Value, and Examples. I consider these tags the minimum documentation to include for functions I’m making available to other users."
  },
  {
    "objectID": "document.html#documenting-app-functions",
    "href": "document.html#documenting-app-functions",
    "title": "Documentation",
    "section": "Documenting app functions",
    "text": "Documenting app functions\nYour app-package will likely contain at least two functions specific to shiny: modules and a standalone app function. roxygen2 has a few tags that can make the documentation for these functions more informative for readers.\n\nDocumenting modules\nBelow are a few things to consider when documenting module functions:\n\nModules typically have two functions in a single .R file: one for the UI and a counterpart in the server.\nEvery module function will include at least one @param for the shared id.\nReturned objects are critical in shiny’s reactive context, so I recommend extending the description to include whether or not the returned output is reactive.\nIf the returned output is an input (i.e. @param) for another function, link to that documentation functions with @seealso or @family.\n\nBelow are some examples from the shinyAppPkg modules.\n\n\n@seealso\nWhen documenting modules, think of the audience as someone looking to understand the execution path through the application. In shinyAppPkg(), the inputs are collected with the var_input module and then passed to the scatter_display module.\nI use @seealso to connect mod_var_input_ui() to its server function counterpart. The hyperlink to mod_var_input_server() from mod_var_input_ui() is created by placing the destination function in square brackets [fun()]:\n#' Variable input module (UI)\n#' \n#' @description\n#' `var_input` collects the following graph inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'\n#' @param id UI module id\n#'\n#' @return module UI (HTML)\n#' \n#' @seealso [mod_var_input_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n@seealso creates a hyperlink readers can use to open the next module in the execution path.\n\n\n\n\n\n(a) @seealso link\n\n\nFigure 6.6: Link values from var_input to scatter_display\n\n\nIn mod_var_input_server(), a link can be made to mod_scatter_display_server() (the module function collecting the returned values) using the square brackets in the @return section (without @seealso):\n#' Variable input module (server)\n#'\n#' @param id server module id\n#' \n#' @seealso [mod_var_input_ui()]\n#'\n#' @return reactive inputs are returned in a `list()`: \n#'  * `\"y\" = input$y`\n#'  * `\"x\" = input$x`\n#'  * `\"z\" = input$z`\n#'  * `\"alpha\" = input$alpha`\n#'  * `\"size\" = input$size`\n#'  * `\"plot_title\" = input$plot_title`\n#'  \n#' These become in the `var_inputs()` argument in [mod_scatter_display_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) @seealso in mod_var_input_ui()\n\n\n\n\n \n\n\n\n\n\n(b) @seealso in mod_var_input_server()\n\n\n\n\nFigure 6.7: Link values from var_input to scatter_display\n\n\n\n\n\n@family\nModule functions can also be grouped into families using @family {\"description\"}. Below is an example of grouping the “scatter plot module functions” into a family:\n#' Scatter plot display module (UI)\n#'\n#' @param id UI module id\n#' \n#'\n#' @return module UI (HTML)\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n@section\nThe @section tag will create a level two header (##/&lt;h2&gt;&lt;/h2&gt;) section, which can help organize topics (like how to use an input or argument).\n@seealso can also be used to link back to the scatter_plot() utility function:\n#' Scatter plot display module (server)\n#' \n#'\n#' @param id server module id \n#' @param var_inputs returned reactive list from [mod_var_input_server()].\n#' \n#' @section Referring to `var_inputs`: \n#' Refer to the reactive returned values from `mod_var_input_server()` as:\n#'  * `var_inputs()$x`\n#'  * `var_inputs()$y`\n#'  * `var_inputs()$z`\n#'  * `var_inputs()$alpha`\n#'  * `var_inputs()$size`\n#'  * `var_inputs()$plot_title`\n#' \n#'\n#' @return rendered plot and title output from [scatter_plot()]\n#' \n#' @family {\"scatter plot module functions\"}\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@family in mod_var_input_server()\n\n\n\n\n\n\n\n@seealso in mod_scatter_display_server()\n\n\n\n\n\n\nThe figure above shows how the @seealso links can create a path for the graph parameters through the var_input and scatter_display modules. It also demonstrates how @family groups the scatter_display UI and server functions.\nThe scatter_plot() utility function should also include a @seealso tag for the module function it’s used in.\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `shinyAppPkg()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@seealso in mod_scatter_display_server()\n\n\n\n\n\n\n\n@seealso in scatter_plot()\n\n\n\n\n\n\nThe goal when cross-referencing functions in your app-package is for anyone reading your documentation to follow the links and better understand any modules, their inputs, reactive values, and outputs.\nIn this case, linking to the scatter_plot() function gives readers an interactive example to preview the output.\n\n\nStandalone app functions\nSplitting the code in app.R into separate functions has multiple benefits:\n\nDeveloping and loading a function is easier if stored in the R/ folder.\nHaving a dedicated UI, server, and app function means we can develop them independently.\nA standalone app function makes storing multiple applications in the same app-package possible.\n\nI’ve split the UI and server from movies_app() into separate movies_ui() and movies_server() below.\n\nUI & Server functions\nThe movies_ui() doesn’t have any arguments–the only change is wrapping the shiny::fluidPage() in shiny::tagList():\n\nmovies_ui &lt;- function() {\n  shiny::tagList(\n    shiny::fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      shiny::titlePanel(\n        shiny::div(\n          shiny::img(\n            src = \"shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movies Reviews\"\n        )\n      ),\n      shiny::sidebarLayout(\n        shiny::sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        shiny::mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\nmovies_server() is written to be passed to the server argument in shinyApp():\n\nmovies_server &lt;- function(input, output, session) {\n\n      selected_vars &lt;- mod_var_input_server(\"vars\")\n\n      mod_scatter_display_server(\"plot\", var_inputs = selected_vars)\n      \n}\n\n\nusage\nI’ll explicitly describe the use of movies_ui() and set @usage to NULL (note the use of a code block). I’ll also use @section to describe each module UI function (and link to the server functions with @seealso).\n#' Movies UI function\n#' \n#' UI function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#'  \n#' ```\n#' shinyApp(ui = movies_ui, server = movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in `movies_ui()`    \n#'  * server is stored in [movies_server()]\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_ui()] is used to collect the following inputs:\n#'  * `input$x`\n#'  * `input$y`\n#'  * `input$z`\n#'  * `input$alpha`\n#'  * `input$size`\n#'  * `input$plot_title`\n#'  \n#' @seealso [mod_var_input_server()]\n#' \n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_ui()] displays the graph output using [scatter_plot()]\n#' \n#' @seealso [mod_scatter_display_server()]\n#'\n#' @return `ui` argument in `shiny::shinyApp()` \n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_ui()\n\n\n\nThe documentation for movies_server() is very similar to the Ui function–each module server function is documented in it’s own @section.\nStill, I’ll include a @section for Communication that describes how values are passed between mod_var_input_server() and mod_scatter_display_server().\n#' Movies server function\n#' \n#' Server function for standalone app function \n#' \n#' @usage NULL\n#' \n#' @details\n#' The [movies_app()] function is as a wrapper for `shiny::shinyApp()`: \n#' \n#' ```\n#' shinyApp(movies_ui, movies_server)\n#' ```\n#' \n#' In [movies_app()]:\n#'  * UI is stored in [movies_ui()]   \n#'  * server is stored in `movies_server()`\n#'  \n#' @section `var_input` module: \n#' [mod_var_input_server()] returns following reactive values:\n#'  * `x`\n#'  * `y`\n#'  * `z`\n#'  * `alpha`\n#'  * `size`\n#'  * `plot_title`\n#' \n#' @seealso [mod_var_input_ui()]\n#' \n#' @section `scatter_display` module: \n#' [mod_scatter_display_server()] displays the `ggplot2` graph with the [scatter_plot()] function.\n#' \n#' @seealso [mod_scatter_display_ui()]\n#' \n#' @section Communication: \n#' The output from [mod_var_input_server()] should be supplied to the \n#' `var_inputs` argument of [mod_scatter_display_server()].\n#\n#' @return `server` argument in `shiny::shinyApp()`\n#' \n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_server()\n\n\n\n\n\n\nmovies_app()\nThe standalone app function (movies_app()) automatically calls shinyApp(), with the movies_ui and movies_server functions supplied to ui and server (without parentheses).\n\nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nThe documentation for the standalone app function can be minimal–as long as it provides links to the UI and server.\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n\n\n\n\nmovies_app()\n\n\n\nI’ll change the contents of app.R to the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nNow that we’ve documented everything in R/, we’ll run load(), document(), and install():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\ndevtools::load_all(\".\")\nℹ Loading shinyAppPkg\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating shinyAppPkg documentation\nℹ Loading shinyAppPkg\nDocumentation completed\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source shinyAppPkg\n\n* installing to library ‘/path/to/local/install/shinyAppPkg-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘shinyAppPkg’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (shinyAppPkg)\nIn the Console, we should see the following:\nRestarting R session...\n\n&gt; library(shinyAppPkg)\nThe roxygen2 documentation for shinyAppPkg is saved in the 02-roxygen branch. As we can see, calling devtools::document() generates the .Rd files in the man/ folder for each function in the R/ folder:\n\n\n\nR/\n ├── mod_scatter_display.R\n ├── mod_var_input.R\n ├── movies_app.R\n ├── movies_server.R\n ├── movies_ui.R\n └── utils.R\n\n1 directory, 6 files\n\n\nman/\n  ├── mod_scatter_display_server.Rd\n  ├── mod_scatter_display_ui.Rd\n  ├── mod_var_input_server.Rd\n  ├── mod_var_input_ui.Rd\n  ├── movies_app.Rd\n  ├── movies_server.Rd\n  ├── movies_ui.Rd\n  └── scatter_plot.Rd\n\n1 directory, 8 files\n\n\n\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 02_roxygen2 branch"
  },
  {
    "objectID": "document.html#recap",
    "href": "document.html#recap",
    "title": "Documentation",
    "section": "Recap",
    "text": "Recap\nGood documentation aims to make it as easy as possible for others (and future you) to understand what your function does and how to use it.\nBelow is a recap of the topics covered in this chapter.\n\n\n\n\n\n\nroxygen2 recap\n\n\n\n\n\n\nThis chapter covered:\n\nFunction @title and @description: The @title should be a short one-line description of the function, followed by a more detailed paragraph @description. These tags should give users an idea of what the function does (you can also use @details)\nArguments (@param) and outputs (@return): List all function arguments with @param. Include the argument type (e.g., integer, character, etc.) and a brief description of what the argument does. Be sure to mention any default or optional arguments. Function outputs should be listed with @return and describe the type or class of the object, whether or not it’s reactive, and mention any related functions.\nExamples: @examples provide executable R code that captures how the function is used in your app-package. These are incredibly valuable for new users trying to understand how a function (and your app-package) works.\n\nApp-package specific considerations:\n\nConnect functions with@seealso and @family: Use @seealso to provide links to related functions (i.e., modules) so users can click through a ‘guided tour’ of your application’s code–group similar functions using @family {description}.\nGive more info with @sections: Use @section to give in-depth explanations and specific details about how a function works, including any information about the @usage or its @params.\n@usage: This field will be automatically generated by roxygen2, but in some circumstances, it makes sense to set it to NULL and describe a function’s use explicitly.\n\n\n\n\n\nIn the next section, we’ll use roxygen2 to manage our app-package dependencies."
  },
  {
    "objectID": "document.html#footnotes",
    "href": "document.html#footnotes",
    "title": "Documentation",
    "section": "",
    "text": "The main branch of shinyAppPkg is identical to the 06_create-package branch of shinyAppProj.↩︎"
  },
  {
    "objectID": "dependencies.html#shinyapppkg",
    "href": "dependencies.html#shinyapppkg",
    "title": "Dependencies",
    "section": "shinyAppPkg",
    "text": "shinyAppPkg\nWe will use the 02_roxygen2 branch of shinyAppPkg from the end of the previous chapter. Below is a folder tree of its contents:\n\nshinyAppPkg/\n  ├── DESCRIPTION\n  ├── NAMESPACE\n  ├── R/\n  │   ├── mod_scatter_display.R\n  │   ├── mod_var_input.R\n  │   ├── movies_app.R\n  │   ├── movies_server.R\n  │   ├── movies_ui.R\n  │   └── utils.R\n  ├── README.md\n  ├── app.R\n  ├── man/\n  │   ├── mod_scatter_display_server.Rd\n  │   ├── mod_scatter_display_ui.Rd\n  │   ├── mod_var_input_server.Rd\n  │   ├── mod_var_input_ui.Rd\n  │   ├── movies_app.Rd\n  │   ├── movies_server.Rd\n  │   ├── movies_ui.Rd\n  │   └── scatter_plot.Rd\n  ├── movies.RData\n  ├── shinyAppPkg.Rproj\n  └── www/\n      └── shiny.png\n\n4 directories, 21 files\n\n\nWhen in doubt…\nLoad, document, and install\nWhile developing your app-package, you might lose track of which devtools function you ran last (I know I do). If this happens, I’ve found loading, documenting, and installing help re-orient me to the current state of the package.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L\n\n\n\n\n\n\n\nℹ Loading shinyAppPkg\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + D\n\n\n\n\n\n\n\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating shinyAppPkg documentation\nℹ Loading shinyAppPkg\nDocumentation completed\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + B\n\n\n\n\n\n\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source shinyAppPkg\n\n* installing to library ‘/path/to/local/install/shinyAppPkg-090c61fc/R-4.2/x86_64-apple-darwin17.0’\n* installing *source* package ‘shinyAppPkg’ ...\n** using staged installation\n** R\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE (shinyAppPkg)\n\nRestarting R session...\n\n&gt; library(shinyAppPkg)\nIt’s also satisfying to see all three functions execute without any errors!"
  },
  {
    "objectID": "dependencies.html#identifying-dependencies",
    "href": "dependencies.html#identifying-dependencies",
    "title": "Dependencies",
    "section": "Identifying dependencies",
    "text": "Identifying dependencies\nThe first step in managing dependencies is identifying which add-on packages shinyAppPkg relies on.1 Our goal is to limit the dependencies to only those critical to the functioning of our app, because each additional dependency is a potential point of failure (should this package become unavailable or significantly change).\n\nRunning movies_app()\nIn the last chapter, we moved and documented the standalone app function (movies_app()) in the R/ folder. The app.R file now only contains the following:\n\n# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n# packages ------------------------------------\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rlang)\n\n# movies_app ------------------------------------\nmovies_app()\n\nIdeally, we’ll want to replace these calls to libary(), but first we have to make sure the functions we’re using in these packages will be available in shinyAppPkg.\nWhen we run the contents of app.R, we see the following:\n&gt; library(shinyAppPkg)\n&gt; # pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n&gt; # install.packages(pkgs, quiet = TRUE)\n&gt; \n&gt; # packages ------------------------------------\n&gt; library(shiny)\n&gt; library(shinythemes)\n&gt; library(stringr)\n&gt; library(ggplot2)\n&gt; library(rlang)\n&gt; \n&gt; # movies_app ------------------------------------\n&gt; movies_app()\nError in movies_app() : could not find function \"movies_app\"\nWhy can’t R find the \"movies_app\" function in app.R?\nLet’s recap what we’ve done so far:\n\n\n\n\napp.R\n\napp.R loads the necessary packages and calls movies_app()\n\n\n\n\nshinyAppPkg/\n    └── app.R\n\n\n\n\n\n\nR/\n\nThe R/movies_app.R file contains the code and documentation for movies_app()\n\n\n\n\nshinyAppPkg/\n    └── R/\n        └── movies_app.R\n\n\n\n\n\n\nman/\n\nroxygen2 is generating the man/movies_app.Rd file\n\n\n\n\nshinyAppPkg/\n    └── man/\n          └── movies_app.Rd\n\n\n\nThe error tells me that despite having documentation for movies_app() in R/ and generating the corresponding .Rd file in man/, the movies_app() function isn’t being exported from shinyAppPkg."
  },
  {
    "objectID": "dependencies.html#exports",
    "href": "dependencies.html#exports",
    "title": "Dependencies",
    "section": "Exports",
    "text": "Exports\nThe exact cause of the error above becomes more apparent when we try to explicitly namespace movies_app() from shinyAppPkg:\n\nshinyAppPkg::movies_app()\n\nError: 'movies_app' is not an exported object from 'namespace:shinyAppPkg'\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 03_pkg-exports branch\nTo make the movies_app() function available to users of our package, we need to export it. We export functions by including the @export tag in the roxygen2 comment block (above the function we want to export):\n\n@export: The function name (my_func) is not required.\n\n#' @export my_func \n#' my_func &lt;- function() {\n#' \n#' }\n\n\nRead more here\n\n\n\nExporting movies_app()\nLet’s start by exporting the movies_app() function from shinyAppPkg by placing the @export tag above the function in R/movies_app.R:\n\n#' Movies app standalone function\n#'\n#' Wrapper function for `shiny::shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#'\n#' @export\n#' \nmovies_app &lt;- function() {\n  shiny::shinyApp(ui = movies_ui, server = movies_server)\n}\n\nIn app.R, we’ll replace the calls to library() with a single call to library(shinyAppPkg)\n\n# packages ------------------------------------\nlibrary(shinyAppPkg)\n\n# movies_app ------------------------------------\nmovies_app()\n\nWe’ll load, document, and install the package to generate the NAMESPACE changes:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nNow, when we run the code app.R, we see the following:\n\n\n\nmovies_app()\n\n\n\n\nWe’ve lost the shiny icon (www/shiny.png) in the UI, but we’ll address this in the inst/ & www/ chapter.\nmovies_app() launches our application!\n\n\nThe NAMESPACE file now contains a single export (movies_app), and when we enter shinyAppPkg:: in the Console, we see the movies_app() function help file in the tab completion.\n\n\n\n\n\n\n\n\n(a) updated NAMESPACE\n\n\n\n\n\n\n\n(b) shinyAppPkg namespace\n\n\n\n\nFigure 7.1: The movies_app() is now part of the shinyAppPkg namespace\n\n\n\n\n\nWhat @export does\nWe’ll pause here to notice a few things about what @export does. After loading, documenting, and installing shinyAppPkg, the NAMESPACE is updated with export(movies_app), and the Console automatically calls library(shinyAppPkg).\nls() returns “the names of the objects in the specified environment, so we can use it to confirm the movies_app() function is the only export from shinyAppPkg:\n\nls(name = \"package:shinyAppPkg\")\n\n[1] \"movies_app\"\n\nThe search() list\nlibrary(shinyAppPkg) attaches shinyAppPkg to the search list. We can view all the attached packages in the string returned from search():\n\"package:shinyAppPkg\" %in% search()\n[1] TRUE\nWhat about the functions from add-on packages movies_app() relies on, like ggplot2?\nLet’s check to see if ggplot2 is also attached to the search() list:\n\nc(\"package:ggplot2\") %in% search()\n\n[1] FALSE\nWhy does this matter? Because if these packages aren’t attached to the search() list, we can’t call their functions the way we would if we’d used library().\nFor example, if we try to use ggplot2 to build a plot (similar to the one we have in the app), we see the following:\n\nggplot(data = mtcars, \n  aes(x = disp, y = mpg)) + \n  geom_point()\n\nError in ggplot(data = mtcars, \n              aes(x = disp, y = mpg)) : \n  could not find function \"ggplot\"\nIf we want to use functions from the packages shinyAppPkg relies on, we need to explicitly namespace these functions from their original package namespaces (i.e., pkg::fun()):\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nWe can use ggplot2 if we explicitly namespace it’s functions\n\n\n\n\n\n\n\n\n\n\n\nAccessing add-on package functions\n\n\n\n\n\n\nWhen a user loads shinyAppPkg with library(shinyAppPkg), any add-on package functions used in exports are available to users if they use pkg::fun() (or if they load the package themselves with library()).\n\n\n\n\nAccess to add-on package functions has implications for the other functions in shinyAppPkg–for example, the scatter_plot() function uses ggplot2 functions. But we’re not exporting scatter_plot(), so when we attempt to run the examples, we see the following error:\n\n\n\n\n\n\n\n\n(a) Examples in scatter_plot()\n\n\n\n\n\n\n\n(b) Error in scatter_plot() examples\n\n\n\n\nFigure 7.2: Examples in scatter_plot() function without exporting\n\n\n\nExamples for ‘shinyAppPkg::scatter_plot’\nThe message at the top of the Help pane is informative because it tells us that despite scatter_plot() being functional when we run movies_app(), it’s not part of the package namespace (and thus, not accessible to users in the help file).\n\n\nExporting scatter_plot()\nShiny apps often contain utility functions in helper.R or utils.R files. Storing non-shiny code in these files isn’t a bad practice (in fact, it’s encouraged in Mastering Shiny). However, if we’re following the advice in R Packages, we should rename R/utils.R as we transition to an app-package,\n\n‘most of our packages have a utils.R file (Section 6.1) that contains small utility functions that are useful internally, but aren’t part of the core purpose of those packages. We don’t export such functions.’\n\n\n\n\n\n\n\nR/utils.R &gt;&gt; R/scatter_plot.R\n\n\n\n\n\n\nFrom now on, I’ve renamed R/utils.R to R/scatter_plot.R, so it aligns with the naming conventions in other R packages.\nFor a deep dive on R/utils.R files in R packages, I recommend reading Dissecting R Package “Utility Belts”\n\n\n\n\nLet’s add the @export tag to R/scatter_plot.R so it’s exported from shinyAppPkg.\n\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `shinyAppPkg()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n#' @export\n#' \n\nAfter loading, documenting, and installing shinyAppPkg, the NAMESPACE is updated with the export() directive:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nThe contents of the updated NAMESPACE file are below (and shinyAppPkg:: in the Console now displays the scatter_plot() help file in the tab completion):\n\n\n\n\n\n\n\n\n(a) @export the scatter_plot function\n\n\n\n\n\n\n\n(b) shinyAppPkg::scatter_plot()\n\n\n\n\nFigure 7.3: scatter_plot() is now part of the shinyAppPkg namespace\n\n\n\nBelow, we confirm users can access the help file for scatter_plot() and run the examples:\n\n\n\n\n\n(a) scatter_plot() examples\n\n\nFigure 7.4: Running examples in ?scatter_plot\n\n\n\n\nloadedNamespaces()\nWe’ve already confirmed that ggplot2 isn’t attached with shinyAppPkg (and hence, it is not included in the search() list)\n\nc(\"package:ggplot2\") %in% search()\n\n[1]  FALSE\nHowever, we can access the functions we used the pkg::fun() syntax with because those functions are included in the loaded namespaces (which we can view with loadedNamespaces())\n\nc(\"ggplot2\") %in% loadedNamespaces()\n\n[1] TRUE\n\n\n\nWhat to @export\n“When a user calls library(shinyAppPkg), what functions do I want to be available?”\nWhen determining which functions to export, consider the question above. R Packages, 2ed also offers the following advice on what shouldn’t be exported:\n\n‘We believe that packages that have a wide audience should strive to do one thing and do it well. All functions in a package should be related to a single problem (or a set of closely related problems). Any functions not related to that purpose should not be exported.’ - What to export, R Packages, 2ed\n\nThere are multiple ways to interpret the advice above in the context of a shiny app-package:\n\nIf we take a narrow view of the word ‘problem’ to mean ‘create a way to visualize relationships in movie review data’, then maybe we’d consider it solved by only exporting the standalone app function.\nIf the ‘problem’ shinyAppPkg solves is ‘creating a shiny movies app’, we might also want to export any functions that perform distinct tasks with potentially reusable functionality (i.e., generate specific UI components, perform data processing tasks, etc.).\nExtending the ‘problem’ statement to the broadest possible definition would assume users will want access to all the functions in shinyAppPkg–this would allow them to customize, extend, or integrate the contents of shinyAppPkg with other tools. You’ll rarely want to export everything from your app-package, but it can be helpful if your primary audience is other developers within your organization.\n\nMy advice on exports is to balance simplicity and utility when deciding on exported functions.\n\n\n\n\n\n\nLow-key @exports with @keywords internal\n\n\n\n\n\n\nIf you’d like function to be exported, but not listed in the package index, you can combine @export with @keywords internal. These should be used in combination,\n#' @export\n#' \n#' @keywords internal\nFor example, adding @export and @keywords internal to R/scatter_plot.R will make the function accessible to users:\n\n\n\n\n\nAnd include the help file:\n\n\n\n\n\nHowever, if a user were to click on the Index for shinyAppPkg (at the bottom of the help file)\n\n\n\n\n\nscatter_plot is not listed:"
  },
  {
    "objectID": "dependencies.html#imports",
    "href": "dependencies.html#imports",
    "title": "Dependencies",
    "section": "Imports",
    "text": "Imports\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 04_pkg-imports branch\nHanding imports is slightly more involved than package exports because imported dependencies can live in DESCRIPTION and the NAMESPACE.\nThe DESCRIPTION file handles package-level dependencies, specifying which packages shinyAppPkg uses. These packages are installed whenever a user installs shinyAppPkg.\nOn the other hand, the NAMESPACE directives manage function-level access, importing functions from other packages to be used in shinyAppPkg and–as we’ve seen above–exporting functions from shinyAppPkg for others to use.\nWhen shinyAppPkg is documented (i.e., Ctrl/Cmd + Shift + D), roxygen2 tags update the NAMESPACE with any imports or exports. However, the DESCRIPTION file must be edited independently:\n\n\n\nCtrl/Cmd + Shift + D updates the NAMESPACE, but it doesn’t change anything in the DESCRIPTION file.\n\n\n\n\n\n\n(a) roxygen2 does not connect the NAMESPACE to the DESCRIPTION\n\n\nFigure 7.5: roxygen2 & NAMESPACE = function-level access vs. DESCRIPTION = package-level dependencies\n\n\n\nImporting dependencies\nFirst we’ll list each add-on package to the Imports field in the DESCRIPTION using usethis::use_package() (below is the output for ggplot2):\nusethis::use_package(\"ggplot2\")\n✔ Setting active project to '/path/to/shinyAppPkg'\n✔ Adding 'ggplot2' to Imports field in DESCRIPTION\n• Refer to functions with `ggplot2::fun()`\nWe’re already using pkg::fun() in most of the functions in shinyAppPkg, so we need to remove them from shiny functions (and add @import).\n\nReplace the explicit namespacing from all calls to shiny functions (i.e., shiny::) with the @import tag in R/movies_app.R:\n\n\n\nshow/hide @import in movies_app()\n#' Movies app standalone function\n#'\n#' Wrapper function for `shinyApp()`\n#'\n#' @return shiny app\n#' \n#' \n#' @seealso [mod_var_input_ui()], [mod_var_input_server()], [mod_scatter_display_ui()], [mod_scatter_display_server()]\n#' \n#' @import shiny\n#'\n#' @export\n#' \nmovies_app &lt;- function() {\n  shinyApp(ui = movies_ui, server = movies_server)\n}\n\n\n\nInclude @importFrom for the use of .data in R/scatter_plot.R:\n\n\n\nshow/hide @importFrom in scatter_plot()\n#' Create scatter plot \n#'\n#' Custom [`ggplot2`](https://ggplot2.tidyverse.org/) function for building scatter plots in `shinyAppPkg()`.\n#' \n#' \n#' @param df `data.frame` or `tibble`\n#' @param x_var string variable mapped to `x` axis\n#' @param y_var string variable mapped to `y` axis\n#' @param col_var string variable mapped to `color`\n#' @param alpha_var number for point `alpha`\n#' @param size_var number for point `size` \n#' \n#' @return A `ggplot2` plot object\n#' \n#' \n#' @examples\n#' scatter_plot(mtcars, \n#'     x_var = \"mpg\", \n#'     y_var = \"disp\", \n#'     col_var = \"cyl\", \n#'     alpha_var = 0.5, \n#'     size_var = 3)\n#'     \n#' @seealso [mod_scatter_display_server()]\n#' \n#' @importFrom rlang .data\n#' \n#' @export\n#' \nscatter_plot &lt;- function(df, x_var, y_var, col_var, alpha_var, size_var) {\n    ggplot2::ggplot(data = df,\n      ggplot2::aes(x = .data[[x_var]],\n          y = .data[[y_var]],\n          color = .data[[col_var]])) +\n      ggplot2::geom_point(alpha = alpha_var, size = size_var)\n\n}\n\n\nAfter adding all add-on packages to the DESCRIPTION with usethis::use_package(), then deciding if/where to use @importFrom and @import, we’ll load, document, and install shinyAppPkg:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nAnd we should review the updated NAMESPACE and DESCRIPTION files:\n\n\n\n\n\n\n\n(a) Updated NAMESPACE with Imports and `importFrom\n\n\n\n\n\n\n\n(b) Updated DESCRIPTION with all Imports\n\n\n\n\nFigure 7.6: roxygen2 will update the NAMESPACE, but usethis::use_package() is needed to update the DESCRIPTION\n\n\nWhen we run movies_app(), we see the application launches and we can still run the scatter_plot() examples:\n\n\n\n\n\n\n\n(a) movies_app() works\n\n\n\n\n\n\n\n(b) Examples in ?scatter_plot\n\n\n\n\nFigure 7.7: Confirming we still have full functionality in shinyAppPkg\n\n\n\n\nWhat happened in shinyAppPkg?\nFirst, let’s confirm we’re still only exporting movies_app() and scatter_plot() from shinyAppPkg:\n\nls(name = \"package:shinyAppPkg\")\n\n[1] \"movies_app\"   \"scatter_plot\"\nGreat. Now we’ve listed five packages in the Imports field of the DESCRIPTION file:\nImports: \n    ggplot2,\n    rlang,\n    shiny,\n    shinythemes,\n    stringr\n\nThe search() list\nAre these packages on the search list?\n\npkgs &lt;- c(\"package:ggplot2\", \"package:rlang\", \n          \"package:shiny\", \"package:shinythemes\", \n          \"package:stringr\")\npkgs %in% search()\n\n[1] FALSE FALSE FALSE FALSE FALSE\nThis demonstrates that none of these packages are attached with shinyAppPkg. However, the rlang and shiny packages are included in the loadedNamespaces() (because we included them with @import/@importFrom).\n\npkgs &lt;- c(\"ggplot2\", \"rlang\", \"shiny\", \n          \"shinythemes\", \"stringr\")\npkgs %in% loadedNamespaces()\n\n[1] FALSE  TRUE  TRUE FALSE FALSE\nWe can still access the add-on package functions in shinyAppPkg using the pkg::fun() syntax:\n\n\n\nggplot2::ggplot(data = mtcars, \n  ggplot2::aes(x = disp, y = mpg)) + \n  ggplot2::geom_point()\n\n\n\n\n\nggplot2 functions are still available if we explicitly namespace"
  },
  {
    "objectID": "dependencies.html#more-info-on-imports",
    "href": "dependencies.html#more-info-on-imports",
    "title": "Dependencies",
    "section": "More info on imports",
    "text": "More info on imports\nThe differences between the dependencies listed in the NAMESPACE directives and the Imports field in the DESCRIPTION file can be a common point of confusion, 2 which is understandable if you’ve consulted Writing R Extensions (specifically the sections on dependencies 3 and namespaces4).\nI’ve attempted to distill and consolidate the advice I’ve found when I’ve gone looking for (and had trouble finding) answers to the following questions:\n\nWhen and why should I import add-on packages/functions?\nHow should I be importing add-on functions and packages?\nWhat happens when a package or function is imported?\n\nI’ve also emphasized the parts I’ve found worth committing to memory.\n\nDESCRIPTION\n\n\n\nWhen\n\nI recommend starting to manage dependencies in the DESCRIPTION because this is where R will look during installation.\n\n\nYou’ll almost always list dependencies under Imports because these are the packages needed to use your app-package.5\n\n\n\n\nWhy\n\nListing packages in Imports ensures they will be installed when shinyAppPkg is installed (i.e. with install.packages(\"shinyAppPkg\")).\n\n\nUsers of shinyAppPkg won’t automatically have access to the packages listed under Imports (unless they’re already installed).\n\n\n\n\n\n\n\n\nHow\n\nusethis::use_package() automatically adds a package in the Imports section, and had options for specifying the minimum version.\n\n\n\n\nWhat\n\nlibrary(shinyAppPkg) loads the namespace of imported packages, but they are not attached to the search() path.6\n\n\n\n\n\n\npkg::fun()\n\n\n\nWhen\n\nDefault to using pkg::fun() for all add-on package functions used below R/\n\n\nThe exceptions to this are shiny functions (which we’ll cover below in NAMESPACE) and operators that can’t be accessed with ::\n\n\n\n\nWhy\n\nUsing pkg::fun() makes calls to add-on packages explicit and easy to differentiate from the native functions developed in shinyAppPkg\n\n\npkg::fun() is also recommended for all code below R/ in R Packages, 2ed7\n\n\n\n\n\n\n\n\nHow\n\nThe best advice for determining how to use pkg::fun() comes from the roxygen2 documentation\n\n\n“If the repetition of the package name becomes annoying you can @importFrom and drop the [pkg::fun()]”\n\n“if you are using just a few functions from another package, we recommending adding the package to the Imports: field of the DESCRIPTION file and calling the functions explicitly using ::, e.g., pkg::fun()”\n\n\n\n\nWhat\n\nUsing pkg::fun() loads pkg without attaching pkg (unless it was already loaded) \n\n\n\n\n\n\nNAMESPACE\n\n\n\nWhen\n\nUse @importFrom more often than @import, but try to avoid using both (if possible)8 9\n\n\n@importFrom should be used if 1) we can’t use pkg::fun(), or 2) if removing the :: makes code easier to read (not easier to write)\n\n@import should only be used if a substantial number of calls are made in the code below R/ from a particular package (i.e., like the shiny in app-packages)10\n\n\n\n\nWhy\n\nManaging the NAMESPACE ensures shinyAppPkg works when it’s installed and loaded on another machine (regardless of other installed and attached packages)\n\n\nR reads the package namespaces to find the functions and objects it uses11\n\n\n\n\n\n\n\n\nHow\n\nPlace the @importFrom pkg fun tag directly above the code using the add-on function or call usethis::use_import_from().12\n\n\n\nWhat\n\nImports are described briefly in R Packages, 2ed13 and covered in-depth in Advanced R, 2ed14\n\n\n“Each namespace has an imports environment that can contain bindings to functions used by the package that are defined in another package.\n\nThe imports environment is controlled by the package developer with the NAMESPACE file. Specifically, directives such as importFrom() and imports() populate this environment.“\n\n\n\n\n\nIn order for shinyAppPkg to work, users needs to have access to any of the add-on packages that are called in the code below shinyAppPkg/R/. Knowing when, why, how and what happens to imports is important because it helps you decide how to fit these habits into your package development workflow."
  },
  {
    "objectID": "dependencies.html#checking-dependencies",
    "href": "dependencies.html#checking-dependencies",
    "title": "Dependencies",
    "section": "Checking dependencies",
    "text": "Checking dependencies\nWith all the moving parts in dependency management, it can be easy to forget if you’ve documented everything correctly. So far we haven’t covered using devtools::check() as part of your app-package habits (which is fine), but this is one area it’s particularly helpful.\nFor example, if I had listed shiny as an import using the @import tag (resulting in the import(shiny) directive in the NAMESPACE), devtools::check() would produce the following error:\n── R CMD check results ────────────────────────── shinyAppPkg 0.0.0.9000 ────\nDuration: 7.4s\n\n❯ checking package dependencies ... ERROR\n  Namespace dependency missing from DESCRIPTION Imports/Depends entries: ‘shiny’\n  \n  See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’\n  manual.\n\n1 error ✖ | 0 warnings ✔ | 0 notes ✔\nError: R CMD check found ERRORs\nExecution halted\n\nExited with status 1."
  },
  {
    "objectID": "dependencies.html#recap",
    "href": "dependencies.html#recap",
    "title": "Dependencies",
    "section": "Recap",
    "text": "Recap\nBelow are the main takeaways from managing the imports and exports from your app-package:\n\n\n\n\n\n\nDependencies recap\n\n\n\n\n\n\nThis chapter covered:\n\nExports: Aim for a balance between simplicity and utility when deciding which functions to export (i.e., what functions should be available to users who install your package). Export objects from using @export\nImports: Use pkg::fun() syntax when you use add-on package functions and include them in the Imports field of the DESCRIPTION file. App-packages use so many shiny functions it makes sense to include @import shiny to 1) ensure all of these functions are available, and 2) you won’t need to use pkg::fun().\n\nDESCRIPTION Imports This field lists the packages your app-package uses. All add-on packages used in the R/ folder must be listed in the Imports field. These functions can be called using the pkg::fun() syntax (or with @importFrom()). Functions from these packages will be available for your package, but not for the user unless they use the :: operator or load the package themselves with library().\nNAMESPACE imports: The @import/@importFrom tags make the functions from add-on packages available to your package. Favor using @importFrom over @import for add-on package functions (the only exception being shiny, which you’d want to use @import).\n\n\nThe Imports field in the DESCRIPTION handles package-level dependencies (and it is managed manually or with usethis::use_package()), while the NAMESPACE handles function-level access (with @export and @import/@importFrom).\n\n\n\n\nIn the next section, we’ll cover how the ensure the app.R file runs our application!"
  },
  {
    "objectID": "dependencies.html#footnotes",
    "href": "dependencies.html#footnotes",
    "title": "Dependencies",
    "section": "",
    "text": "I’ve made this process somewhat easier by explicitly namespacing all of the add-on package functions in shinyAppPkg (i.e., with pkg::fun()).↩︎\nSee the section titled, ‘Confusion about Imports’ in R Packages, 2ed, “Listing a package in Imports in DESCRIPTION does not ‘import’ that package.”↩︎\nSee section 1.1.3 Package Dependencies in Writing R Extensions↩︎\nSee section 1.5, Package namespaces in Writing R Extensions↩︎\nPackages used for developing or testing shinyAppPkg can be included under Suggests, because these are not installed along with shinyAppPkg. Packages in Depends will be installed and attached to the search list when shinyAppPkg is installed.↩︎\nUsers can access functions from add-on packages with the pkg::fun syntax.↩︎\n“Our recommended default is to call external functions using the package::function() syntax” - R Packages, 2ed↩︎\n“Using importFrom selectively rather than Imports is good practice and recommended notably when importing from packages with more than a dozen exports and especially from those written by others (so what they export can change in future).” - Specifying imports and exports.↩︎\n“Specifically, we recommend that you default to not importing anything from [add-on packages] into your namespace. This makes it very easy to identify which functions live outside of your package, which is especially useful when you read your code in the future. This also eliminates any concerns about name conflicts between [add-on packages] and your package.” - R Packages, 2ed↩︎\n“…for Shiny apps, I recommend using @import shiny to make all the functions in the Shiny package easily available. (Using @import is not generally considered best practice, but it makes sense here). Mastering Shiny, R CMD check”↩︎\nThe namespace controls the search strategy for variables used by functions in the package. If not found locally, R searches the package namespace first, then the imports, then the base namespace and then the normal search path (so the base namespace precedes the normal search rather than being at the end of it). - Writing R Extensions↩︎\nYou can also consolidate all @import and @importFrom tags into a single package doc file (i.e., R/[shinyAppPkg]-package.R) by calling usethis::use_package_doc().↩︎\nSee the Function lookup inside a package Section of R Packages, 2ed↩︎\nSee the Package environments and the search path of Advanced R, 2ed↩︎"
  },
  {
    "objectID": "data.html#app-package-data",
    "href": "data.html#app-package-data",
    "title": "Data",
    "section": "App-package data",
    "text": "App-package data\nThere are three folders used to store data in R packages: data/, data-raw/, and inst/extdata/. The folder you’ll use will depend on the format, accessibility, and intended purpose of the data file in your app-package.1"
  },
  {
    "objectID": "data.html#the-data-folder",
    "href": "data.html#the-data-folder",
    "title": "Data",
    "section": "The data/ folder",
    "text": "The data/ folder\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 06_data branch\nThe primary location for app-package data is the data/ folder. Data objects in the data/ folder are available in the package namespace when it’s installed and loaded, and can be accessed with the package::data syntax. See the example below:\n\nlibrary(dplyr)\nhead(dplyr::storms)\n## # A tibble: 6 × 13\n##   name   year month   day  hour   lat  long status\n##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; \n## 1 Amy    1975     6    27     0  27.5 -79   tropi…\n## 2 Amy    1975     6    27     6  28.5 -79   tropi…\n## 3 Amy    1975     6    27    12  29.5 -79   tropi…\n## 4 Amy    1975     6    27    18  30.5 -79   tropi…\n## 5 Amy    1975     6    28     0  31.5 -78.8 tropi…\n## 6 Amy    1975     6    28     6  32.4 -78.7 tropi…\n## # ℹ 5 more variables: category &lt;dbl&gt;, wind &lt;int&gt;,\n## #   pressure &lt;int&gt;,\n## #   tropicalstorm_force_diameter &lt;int&gt;,\n## #   hurricane_force_diameter &lt;int&gt;\n\n\nLazyData: true\nFiles in data/ should be in the .rda or .RData format. Data files become part of a package when they’re added to the data/ folder and LazyData: true is added to the DESCRIPTION file.\n\nLazyData: true: the data is only loaded into memory if it is explicitly accessed by the user or a function in the package. Until then, only the dataset names is loaded. This practice user-friendly and is the default for most R packages.\nLazyData: false (or omitted): accessing a data file from the package requires explicitly loading it using the data() function.\n\nBelow are the steps for adding movies to shinyAppPkg:\n\nMove the movies.RData file into a newly created the data/ folder:\n\n\nshinyAppPkg/\n    └──data/\n        └── movies.RData\n\n\nInclude LazyData: true in the DESCRIPTION file (I’ve added it above Imports:):\n\n\nPackage: shinyAppPkg\nVersion: 0.0.0.9000\nType: Package\nTitle: movies app\nDescription: A movies data shiny application.\nAuthor: John Smith [aut, cre]\nMaintainer: John Smith &lt;John.Smith@email.io&gt;\nLicense: GPL-3\nRoxygenNote: 7.2.3\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nLazyData: true\nImports:\n  shiny,\n  ggplot2,\n  rlang,\n  stringr,\n  tools\n\n\nLoad, document, and install.\n\nCtrl/Cmd + Shift + L\nℹ Loading shinyAppPkg\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating shinyAppPkg documentation\nℹ Loading shinyAppPkg\nDocumentation completed\nCtrl/Cmd + Shift + B\nIn the Build pane, you’ll notice a few new ** data lines of output after adding data:\n** data\n*** moving datasets to lazyload DB\n** byte-compile and prepare package for lazy loading\nWe can check to see if movies has been included in shinyAppPkg using the package::data syntax:\n\n\n\n\n\n(a) roxygen2\n\n\nFigure 8.1: movies is now part of shinyAppPkg\n\n\n\n\nusethis::use_data()\nIf you’d prefer to store data using the .rda format, the usethis package has the use_data() function that will automatically store an object in data/ in the .rda format.\nTo use usethis::use_data(), we can load the movies data into the global environment with load(\"movies.RData\"), then run usethis::use_data(movies):\n\nusethis::use_data(movies)\n\n✔ Setting active project to '/path/to/shinyAppPkg'\n✔ Adding 'R' to Depends field in DESCRIPTION\n✔ Creating 'data/'\n✔ Saving 'movies' to 'data/movies.rda'\n• Document your data (see 'https://r-pkgs.org/data.html')\nThe Depends: field is added to the DESCRIPTION file with an R version (this ensures the data files will be loaded)\nDepends: \n    R (&gt;= 2.10)\n(this function will also add LazyData: true to the DESCRIPTION)\n\n\nDocumenting data/\nDocumenting data can be tedious, but it’s worth the effort if you’ll be sharing your application with collaborators. There are multiple ways to store the documentation for datasets. For example, we could create a data.R file in the R/ folder.\n\nfs::file_create(\"R/data.R\")\n\nIn data.R, we provide a @title, @description, and @details for the data (with or without the tags), followed by @format:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming)   \n#'\n#' @format\n\n\n@format\nThe text following @format is a one-sentence description of the data (with it’s dimensions).\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#' \n#' @format A data frame with [] rows and [] variables:\n\n\n\n\\describe & \\item\nEach variable (column) in the data is documented with a combination of \\describe and \\item (pay close attention to the curly brackets):\n\n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n\nAfter closing the curly brackets in \\describe, place the name of the data in quotes (\"movies\") on the following line.\nBelow is the documentation for the first five columns in the movies dataset:\n\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#' }\n#'\n\"movies\"\n\nIf we load and document shinyAppPkg, we can see a preview of the help file:\nCtrl/Cmd + Shift + L\nℹ Loading shinyAppPkg\nCtrl/Cmd + Shift + D\n==&gt; devtools::document(roclets = c('rd', 'collate', 'namespace'))\n\nℹ Updating shinyAppPkg documentation\nℹ Loading shinyAppPkg\nWriting movies.Rd\nDocumentation completed\n\n?movies\n\n\n\n\n\n\n(a) The movies help file\n\n\nFigure 8.2: Documentation for the movies dataset\n\n\nI’ve provided documentation for the full movies dataset below.\n\n\nshow/hide full movies data documenation\n#' @title IMDB movies data \n#'\n#' @description\n#' Movie review data. Note: these data come from the [Building Web Applications with shiny course](https://rstudio-education.github.io/shiny-course/). \n#' \n#' @details\n#' Read more about acquiring these data in the ['Web Scraping and programming' section of Data science in a box](https://datasciencebox.org/02-exploring-data#web-scraping-and-programming) \n#'\n#' @format A data frame with 651 rows and 34 variables:\n#' \\describe{\n#'  \\item{title}{movie title}\n#'  \\item{title_type}{type, fct (Documentary, Feature Film, TV Movie)}\n#'  \\item{genre}{movie genre, fct (Action & Adventure, Animation, etc.}\n#'  \\item{runtime}{movie length in minutes, num, avg = 106, sd = 19.4}\n#'  \\item{mpaa_rating}{movie rating, fct (G, NC-17, PG, PG-13, R, Unrated)}\n#'  \\item{studio}{name of studio, chr}\n#'  \\item{thtr_rel_date}{Theatre release date, POSIXct, min = 1970-05-19 21:00:00, max = 2014-12-24 21:00:00}\n#'  \\item{thtr_rel_year}{Theatre release year, num, min = 1970, max = 2014}\n#'  \\item{thtr_rel_month}{Theatre release month, num, min = 1, max =12}\n#'  \\item{thtr_rel_day}{Theatre release day, num, min = 1, max =31}\n#'  \\item{dvd_rel_date}{DVD release date, POSIXct, min = 1991-03-27 21:00:00, max = 2015-03-02 21:00:00}\n#'  \\item{dvd_rel_year}{DVD release year, num, min = 1991, max = 2015}\n#'  \\item{dvd_rel_month}{DVD release month, num, min = 1, max = 12}\n#'  \\item{dvd_rel_day}{DVD release day, num, min = 1, max = 31}\n#'  \\item{imdb_rating}{Internet movie database rating, avg = 6.49, sd = 1.08}\n#'  \\item{imdb_num_votes}{Internet movie database votes, avg = 57533, sd = 112124}\n#'  \\item{critics_rating}{Rotten tomatoes rating, fct (Certified Fresh, Fresh, Rotten)}\n#'  \\item{critics_score}{Rotten tomatoes score, avg = 57.7, sd = 28.4}\n#'  \\item{audience_rating}{Audience rating, fct (Spilled, Upright)}\n#'  \\item{audience_score}{Audience score, avg = 62.4, sd = 20.2}\n#'  \\item{best_pic_nom}{Best picture nomination, fct (no, yes)}\n#'  \\item{best_pic_win}{Best picture win, fct (no, yes)}\n#'  \\item{best_actor_win}{Best actor win, fct (no, yes)}\n#'  \\item{best_actress_win}{Best actress win, fct (no, yes)}\n#'  \\item{best_dir_win}{Best director win, fct (no, yes)}\n#'  \\item{top200_box}{Top 20 box-office, fct (no, yes)}\n#'  \\item{director}{Name of director, chr}\n#'  \\item{actor1}{Name of leading actor, chr}\n#'  \\item{actor2}{Name of supporting actor, chr}\n#'  \\item{actor3}{Name of #3 actor, chr}\n#'  \\item{actor4}{Name of #4 actor, chr}\n#'  \\item{actor5}{Name of #5 actor, chr}\n#'  \\item{imdb_url}{IMDB URL}\n#'  \\item{rt_url}{Rotten tomatoes URL}\n#' }\n#'\n\"movies\"\n\n\n\n\n\nUsing movies\nAfter documenting the movies data in data.R, we’ll remove the call to load() in the mod_scatter_display_server() function and replace it with a direct call to the dataset:\n\nmod_scatter_display_server &lt;- function(id, var_inputs) {\n  shiny::moduleServer(id, function(input, output, session) {\n\n  inputs &lt;- reactive({\n    plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n      list(\n        x = var_inputs()$x,\n        y = var_inputs()$y,\n        z = var_inputs()$z,\n        alpha = var_inputs()$alpha,\n        size = var_inputs()$size,\n        plot_title = plot_title\n      )\n  })\n  output$scatterplot &lt;- renderPlot({\n    plot &lt;- scatter_plot(\n      # data -------------------------\n      df = movies,\n      x_var = inputs()$x,\n      y_var = inputs()$y,\n      col_var = inputs()$z,\n      alpha_var = inputs()$alpha,\n      size_var = inputs()$size\n    )\n    plot +\n      ggplot2::labs(\n        title = inputs()$plot_title,\n        x = stringr::str_replace_all(tools::toTitleCase(inputs()$x), \"_\", \" \"),\n        y = stringr::str_replace_all(tools::toTitleCase(inputs()$y), \"_\", \" \")\n      ) +\n      ggplot2::theme_minimal() +\n      ggplot2::theme(legend.position = \"bottom\")\n  })\n})\n}\n\nAfter loading, documenting, and installing the package, we see the following application:\n\n\n\n\n\n\n(a) movies_app() with movies data file\n\n\nFigure 8.3: shinyAppPkg::movies in movies_app()\n\n\n\n\nMore data/ examples\nTo illustrate other options for data documentation, we’ll use the dplyr package. dplyr stores its data in the data/ folder:\ndata/\n├── band_instruments.rda\n├── band_instruments2.rda\n├── band_members.rda\n├── starwars.rda\n└── storms.rda\nThe documentation for the datasets in dplyr are stored in R/ using a data- prefix:\nR/\n├── data-bands.R\n├── data-starwars.R\n└── data-storms.R\nThe three band_ datasets have documented in a single file, data-bands.R:\n\n\nshow/hide documentation for dplyr::band_ datasets\n# from the dplyr github repo: \n# https://github.com/tidyverse/dplyr/blob/main/R/data-bands.R\n# \n#' Band membership\n#'\n#' These data sets describe band members of the Beatles and Rolling Stones. They\n#' are toy data sets that can be displayed in their entirety on a slide (e.g. to\n#' demonstrate a join).\n#'\n#' `band_instruments` and `band_instruments2` contain the same data but use\n#' different column names for the first column of the data set.\n#' `band_instruments` uses `name`, which matches the name of the key column of\n#' `band_members`; `band_instruments2` uses `artist`, which does not.\n#'\n#' @format Each is a tibble with two variables and three observations\n#' @examples\n#' band_members\n#' band_instruments\n#' band_instruments2\n\"band_members\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments\"\n\n#' @rdname band_members\n#' @format NULL\n\"band_instruments2\"\n\n\nIn the example above, note that two of the datasets (band_instruments and band_instruments2) have the @format set to NULL, and define the help search name with @rdname. The @examples tag can be used to view the dataset when users click ‘Run Examples’\nEither method works–what’s important is that each dataset in your package has documentation.\n\n\n\n\n\n\nDocumenting data in data/\n\n\n\n\n\nDocumenting data requires the following roxygen2 structure:\n#' \n#' @title single-sentence describing [data]\n#' \n#' @description\n#' Single-paragraph describing [data]\n#' \n#' @format [data] number of rows and columns:\n#' \\describe{\n#'  \\item{variable}{description}\n#'  \\item{variable}{description}\n#' }\n#'\n\"[data]\"\nReplace [data] with the name of your dataset."
  },
  {
    "objectID": "data.html#the-data-raw-folder",
    "href": "data.html#the-data-raw-folder",
    "title": "Data",
    "section": "The data-raw/ folder",
    "text": "The data-raw/ folder\nThe data-raw folder is not an official directory in the standard R package structure, but it’s a common location for any data processing or cleaning scripts, and the raw data file for datasets stored in data/.2\n\n\n\n\n\n\nScripts for creating movies data\n\n\n\n\n\n\nThe code used to produce the movies dataset in the data/ directory might* come from this GitHub repo. If so, the data-raw folder is where the data processing and preparation scritps would be stored (along with a copy of the data in .csv format) before saving a copy in the data/ folder.\n*I say ‘might’ because it’s not clear if the movies.RData is the output from these .R files (although many of the column names match).\n\n\n\n\n\nMore data-raw/ examples\nIf we look at the data in the dplyr package again, we can see the data-raw/ folder contains a combination of .R and .csv files:\ndata-raw/\n├── band_members.R\n├── starwars.R\n├── starwars.csv\n└── storms.R\n\n1 directory, 4 files\nIn this example, the starwars.R script downloads & prepares starwars, then saves a .csv copy of the data in data-raw."
  },
  {
    "objectID": "data.html#the-instextdata-folder",
    "href": "data.html#the-instextdata-folder",
    "title": "Data",
    "section": "The inst/extdata/ folder",
    "text": "The inst/extdata/ folder\nThe extdata folder (inside inst/) can be used for external datasets in other file formats (.csv, .tsv, .txt, .xlsx, etc).3 The data files in inst/extdata/ aren’t directly loadable using the package::data syntax or the data() function like with the data/ directory. These files can be imported using the file path accessor function, system.file().\nFor example, if we create the inst/extdata/ and save a copy of movies as a .fst file:\n\nlibrary(fs)\nlibrary(tibble)\nlibrary(fst)\n\n\nfst package v0.9.8\n\n\nfs::dir_create(\"inst/extdata/\")\nfst::write_fst(\n  x = movies, \n  path = \"inst/extdata/movies.fst\", \n  compress = 75)\n\n\nfstcore package v0.9.14\n(OpenMP was not detected, using single threaded mode)\n\nThen load, document, and install shinyAppPkg:\nCtrl/Cmd + Shift + L / D / B\nWe can import movies.fst using system.file() to create a path to the file:\n\ntibble::as_tibble(\n  fst::read_fst(path = \n      system.file(\"extdata/\", \"movies.fst\", package = \"shinyAppPkg\")\n    )\n  )\n\n# A tibble: 651 × 34\n   title  title_type genre runtime mpaa_rating studio thtr_rel_date      \n   &lt;chr&gt;  &lt;fct&gt;      &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;  &lt;dttm&gt;             \n 1 Filly… Feature F… Drama      80 R           Indom… 2013-04-18 21:00:00\n 2 The D… Feature F… Drama     101 PG-13       Warne… 2001-03-13 21:00:00\n 3 Waiti… Feature F… Come…      84 R           Sony … 1996-08-20 21:00:00\n 4 The A… Feature F… Drama     139 PG          Colum… 1993-09-30 21:00:00\n 5 Malev… Feature F… Horr…      90 R           Ancho… 2004-09-09 21:00:00\n 6 Old P… Documenta… Docu…      78 Unrated     Shcal… 2009-01-14 21:00:00\n 7 Lady … Feature F… Drama     142 PG-13       Param… 1985-12-31 21:00:00\n 8 Mad D… Feature F… Drama      93 R           MGM/U… 1996-11-07 21:00:00\n 9 Beaut… Documenta… Docu…      88 Unrated     Indep… 2012-09-06 21:00:00\n10 The S… Feature F… Drama     119 Unrated     IFC F… 2012-03-01 21:00:00\n# ℹ 641 more rows\n# ℹ 27 more variables: thtr_rel_year &lt;dbl&gt;, thtr_rel_month &lt;dbl&gt;,\n#   thtr_rel_day &lt;dbl&gt;, dvd_rel_date &lt;dttm&gt;, dvd_rel_year &lt;dbl&gt;,\n#   dvd_rel_month &lt;dbl&gt;, dvd_rel_day &lt;dbl&gt;, imdb_rating &lt;dbl&gt;,\n#   imdb_num_votes &lt;int&gt;, critics_rating &lt;fct&gt;, critics_score &lt;dbl&gt;,\n#   audience_rating &lt;fct&gt;, audience_score &lt;dbl&gt;, best_pic_nom &lt;fct&gt;,\n#   best_pic_win &lt;fct&gt;, best_actor_win &lt;fct&gt;, best_actress_win &lt;fct&gt;, …\n# ℹ Use `print(n = ...)` to see more rows\nWe’ll cover inst/ and system.file() in more detail in the next chapter."
  },
  {
    "objectID": "data.html#recap",
    "href": "data.html#recap",
    "title": "Data",
    "section": "Recap",
    "text": "Recap\nIt’s common for shiny apps to require data, so knowing how to store and access these files in your app-package will make it easier to load and reproducible in other environments. Here are a few other things to consider when including data in your app-package:\n\n\n\n\n\n\nRecap: Package data files\n\n\n\n\n\n\n\ndata/: All data files stored in data/ will be ‘lazy loaded’ (see below) when the package is installed and loaded.\nLoading: include the LazyData: true field in the DESCRIPTION file so the data is only loaded when it’s used (and it increases package loading speed).\nSize: large data files can inflate the size of your app-package, making it harder for users to download and install. CRAN also has a size limit for packages (if you plan on submitting your app-package).\nFormat: data files in data/ must be either .rda or .RData format.\nDocumentation: document the data/ files in either a single R/data.R file or individual .R files. Documentation should include the following roxygen2 format:\n#' \n#' @title \n#' \n#' @description\n#' \n#' @format \n#' \\describe{\n#'  \\item{variable}{description}\n#' }\n#'\n'data'\ninst/extdata/: Store external data in the inst/extdata/ directory and access it using system.file(). This can be helpful if your app-package needs access to data files that are not R objects. For faster loading, consider the fst or feather formats."
  },
  {
    "objectID": "data.html#footnotes",
    "href": "data.html#footnotes",
    "title": "Data",
    "section": "",
    "text": "Read more about the data folder in the ‘Data in packages’ section of Writing R Extenstions and the ‘Data’ chapter of R Packages, 2ed.↩︎\nRead more about the data-raw folder in R Packages, 2ed↩︎\nRead more about the inst/extdata/ folder in R Packages, 2ed↩︎"
  },
  {
    "objectID": "launch.html#app.r",
    "href": "launch.html#app.r",
    "title": "Launch",
    "section": "app.R",
    "text": "app.R\nIn the current branch of shinyAppPkg, the app.R file loads our package and runs the standalone app function:\n\n\n\n\n\n\nGit Branch\n\n\nshinyAppPkg repo’s 04_pkg-imports branch\n\n\n\nshow/hide app.R\n1# pkgs &lt;- c(\"shiny\", \"shinythemes\", \"stringr\", \"ggplot2\", \"rlang\")\n# install.packages(pkgs, quiet = TRUE)\n\n2# packages ------------------------------------\nlibrary(shinyAppPkg)\n\n3# movies_app ------------------------------------\nmovies_app()\n\n\n\n1\n\nInstall packages (if needed)\n\n\n2\n\nLoad package\n\n\n3\n\nCall standalone app function\n\n\n\n\nmovies_app() is a wrapper function for shinyApp(), where it passes movies_ui() and movies_server() to the ui and server arguments.\n\nClicking ‘Run App’\nAs we can see in the image below, the Run App icon is available in the Source pane:\n\n\n\n\n\n(a) app.R in main branch\n\n\nFigure 9.1: Run App icon in app.R of main branch\n\n\nIf we load the code in R/ with load_all(), then click on Run App, we see this calls runApp() in the Console, but this also produces a warning:\n\n\n\n\n\n(a) Calling runApp() in main\n\n\nFigure 9.2: The application is launched (with the loadSupport() warning)"
  },
  {
    "objectID": "launch.html#app.r-02_roxygen2-branch",
    "href": "launch.html#app.r-02_roxygen2-branch",
    "title": "Launch",
    "section": "app.R (02_roxygen2 branch)",
    "text": "app.R (02_roxygen2 branch)\nLet’s jump back to the 02_roxygen2 branch of shinyAppPkg. This is the first version of shinyAppPkg with movies_app() in the R/ folder (i.e., in R/movies_app.R).\n\n\n\n\n\n\nGit Branch\n\n\nshinyAppPkg repo’s 02_roxygen2 branch\n\n\nR/\n├── mod_scatter_display.R\n├── mod_var_input.R\n1├── movies_app.R\n├── movies_server.R\n├── movies_ui.R\n└── utils.R\n\n1 directory, 6 files\n\n\n1\n\nThe movies_app() standalone function\n\n\n\n\nBy moving the call to shinyApp() into the R/ folder, we no longer have the Run App icon in the app.R file:\n\n\n\n\n\n(a) app.R in 02_roxygen2 branch\n\n\nFigure 9.3: No Run App icon in app.R of 02_roxygen2 branch\n\n\nIn the 02_roxygen2 branch, the movies_app() function hasn’t been exported, so we should expect the following error when we run the contents of app.R:\nError in movies_app() : could not find function \"movies_app\"\nHowever, calling runApp() from the Console will launch the app.\n\nCalling runApp()\nThis behavior might be surprising to you–runApp() can launch the application in shinyAppPkg, even without the standalone app function exported from the package namespace (but it still produces the loadSupport() warning).\n\n\n\n\n\n(a) runApp() with 02_roxygen2 branch\n\n\nFigure 9.4: Calling runApp() in the Console of 02_roxygen2 branch\n\n\n\n\nloadSupport()–feature or bug?\nThe warning in the Console is telling us loadSupport()1 has detected that shinyAppPkg is a package, but it’s still sourcing the R/ subdirectory.\n\n\n\n\n\n\nWarning in loadSupport\n\n\n\n\n\n\n\nshiny::runApp()\n\n\nWarning in loadSupport(appDir, renv = sharedEnv, globalrenv = NULL):\n  Loading R/ subdirectory for Shiny application, but this directory \n  appears to contain an R package. \n  Sourcing files in R/ may cause unexpected behavior.\n\n\n\n\n\nThe examples above demonstrate the differences between calling shinyApp() and runApp(), and the tensions between having a standalone app function in an R package vs. having an app.R file in a Shiny project.\nIn the following sections, we’ll compare shinyApp(), shinyAppDir(), and runApp() to determine which one to use in R/movies_app.R and the app.R file."
  },
  {
    "objectID": "launch.html#launching-your-shiny-app",
    "href": "launch.html#launching-your-shiny-app",
    "title": "Launch",
    "section": "Launching your shiny app",
    "text": "Launching your shiny app\n\nshinyApp(), shinyAppDir(), or runApp()\nDuring development, the Posit Workbench IDE provides the Run App icon for launching the application.\n\n\n\nThe Run App icon in the Source pane calls runApp())\n\n\nAs we’ve seen, Run App calls runApp(), even when we have a call to shinyApp() in the app.R file. This might make you wonder,\n“Why even include a call to shinyApp() if the app is being launched with runApp()?”\nLet’s review what happens when we call shinyApp(), shinyAppDir(), and runApp():\n\nshinyApp()\n\n\n\n\n\n\nshinyApp()\n\n\n\n\n\n\n\n\n\nshinyApp(): Creates and launches an app defined inline within the call itself (or with UI and server functions passed as arguments).\n\n\nshinyApp(\n  ui = fluidPage(\n    # UI elements\n  ),\n  server = function(input, output) {\n    # Server logic\n  }\n)\n\n\n\n\n\n\n\nOne of the key features of shinyApp() is the creation of the shiny.appobj (a shiny app object):\n\napp &lt;- shinyApp(ui = movies_ui, \n                server = movies_server)\nstr(app)\n\nIf we look at the structure of the returned object from shinyApp(), we see the shiny.appobj includes the appDir under appOptions:\n\nList of 5\n $ httpHandler     :function (req)  \n $ serverFuncSource:function ()  \n $ onStart         : NULL\n $ options         : list()\n $ appOptions      :List of 2\n1  ..$ appDir       : chr \"/path/to/shinyAppPkg\"\n  ..$ bookmarkStore: NULL\n2 - attr(*, \"class\")= chr \"shiny.appobj\"\n\n\n1\n\nappDir is the first argument of runApp()\n\n\n2\n\nA shiny app object\n\n\n\n\nThis is why runApp() works with any .R file creating a shiny app object.\n\n\nshinyAppDir()\n\n\n\n\n\n\nshinyAppDir()\n\n\n\n\n\n\n\n\n\nshinyAppDir(): Launches an app from a directory (with an app.R or ui.R/server.R files).\n\n\nshinyAppDir(\n  appDir = \"path/to/app/\", \n  options = list())\n\n\n\n\n\n\n\nshinyAppDir() is similar to shinyApp(), but is designed to use a “path to directory that contains a Shiny app.”\nIn practice, we can use shinyAppDir() with a returned object from shinyApp():\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server\n      )\napp$appOptions$appDir\n\n\n[1] \"path/to/shinyAppPkg\"\n\nThis path can be passed to the appDir argument (along with any shiny options).\n\nshinyAppDir(\n  appDir = app$appOptions$appDir,\n  options(test.mode = TRUE)\n)\n\n\n\nrunApp()\n\n\n\n\n\n\nrunApp()\n\n\n\n\n\n\n\n\n\nrunApp(): A generalized way to launch your app–it can run apps defined inline, or from a directory.\n\n\nrunApp(\n  appDir = \"path/to/app/\",\n  test.mode = TRUE/FALSE)\n\n\n\n\n\n\n\nThe reason we’re able to call runApp() in the Console to launch both applications above is because it’s versatile:\n\n\n\nrunApp()\nCan launch an app from a directory (i.e., from ui.R/server.R, or a app.R):\n\n\nIn shinyAppPkg\n# In console\nrunApp()\n\n\n\n\nWorks with a path to an .R file that creates a shiny.appobj:2\n\n\nrunApp(appDir = \"path/to/shinyAppPkg\")\n\n\n\n\nCan also use a shiny.appobj directly:\n\n\napp &lt;- shinyApp(\n        ui = movies_ui,\n        server = movies_server)\nrunApp(appDir = app)\n\n\n\nThis final method does not produce the loadSupport() warning because a Shiny object (shiny.appobj) has already been created, and runApp() is essentially calling print(app) in the Console.\n\nRecap\nshinyApp() is typically used to create apps within an interactive R session, while shinyAppDir() runs a Shiny app stored in a directory (containing an app.R file (or ui.R and server.R files). runApp() also launches apps in a directory, but it’s versatility makes it suitable for running apps in various formats, either defined inline or in separate directories.3"
  },
  {
    "objectID": "launch.html#app-launch-options",
    "href": "launch.html#app-launch-options",
    "title": "Launch",
    "section": "App launch options",
    "text": "App launch options\nBelow I’ll cover two options to consider when writing a standalone app function (and what you’ll include in app.R).\n\nif (interactive())\nThe first thing we should include is a check to see if there is a “human operator to interact with” with base::interactive():\n\nif (interactive()) {\n  \n} else {\n   \n}\n\nYou have probably seen control flow like this in shiny help file examples (like flowLayout() below):\n\n\n\n\n\n(a) if (interactive()) in flowLayout() example\n\n\nFigure 9.5: Running examples ‘interactively’ let’s us see the app demo beneath the code\n\n\nif (interactive()) allows us to distinguish between launching the app from a Posit Workbench session (i.e., during development) and deploying the application (i.e., publishing the application on Posit Connect).\n\n\ntest.mode\nOne of the shiny options to consider including is the ability to control the application’s behavior with test.mode:\n\n‘Should the application be launched in test mode? This is only used for recording or running automated tests. Defaults to the shiny.testmode option, or FALSE if the option is not set.’\n\nThe test.mode argument lets us export values from our application when we’re running tests (which we’ll cover in-depth in the testing chapter).\nWe’ll make test an logical argument (defaulting to FALSE) in our updated movies_app() function.\n\nif (test) {\n1  shinyApp(\n2    ui = movies_ui,\n    server = movies_server,\n3    options = list(test.mode = TRUE)\n  )\n} else {\n  shinyApp(\n    ui = movies_ui,\n    server = movies_server, \n    options = list(test.mode = FALSE)\n  )\n}\n\n\n1\n\nWe don’t need to explicitly namespace shiny functions (i.e., with shiny::) because we’re using #' @import shiny in the R/movies_app.R file\n\n\n2\n\nBuild the shiny app object with movies_ui and movies_server\n\n\n3\n\nInclude option for test.mode\n\n\n\n\n\n\nshinyViewerType\nI’ve written display_type() helper function to control where the Shiny app is displayed. The run argument in display_type() takes the following options:\n\n\"p\" = Viewer Pane\n\n\"w\" = IDE Window\n\n\"b\" = External browser\n\nThe option to access configuration is shiny.launch.browser:4\n\ndisplay_type &lt;- function(run = \"w\") {\n  if (run == \"p\") {\n    options(shiny.launch.browser = .rs.invokeShinyPaneViewer)\n  } else if (run == \"b\") {\n    options(shiny.launch.browser = .rs.invokeShinyWindowExternal) \n  } else if (run == \"w\") {\n    options(shiny.launch.browser = .rs.invokeShinyWindowViewer) \n  } else {\n    options(shiny.launch.browser = NULL)\n  }\n    shinyViewerType &lt;- getOption('shiny.launch.browser') |&gt; \n                        attributes() |&gt; \n                        unlist() |&gt; \n                        unname()\n    cli::cli_alert_info(\"shinyViewerType set to {shinyViewerType}\")\n}\n\n\nSet option\n\nGet option\n\nPrint option to console\n\nThe roxygen2 documentation for display_type() is below:\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nThe cli package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('cli').\n\n\n\n\n\n\nshow/hide roxygen2 for R/display_type.R\n#' Shiny app display mode helper\n#'\n#' @param run where to launch app: \n#'  * `\"p\"` = launch in viewer pane \n#'  * `\"b\"` = launch in external browser  \n#'  * `\"w\"` = launch in window (default)\n#'\n#' @return notification of `shinyViewerType` option\n#' \n#' @export\n#'"
  },
  {
    "objectID": "launch.html#updated-movies_app",
    "href": "launch.html#updated-movies_app",
    "title": "Launch",
    "section": "Updated movies_app()",
    "text": "Updated movies_app()\nIn movies_app(), I’ll add the interactive() check, display_type(), and test.mode option:\n\nmovies_app &lt;- function(test = FALSE, run = \"w\") {\n  \n1  if (interactive()) {\n      \n      # App launched from interactive session\n2      display_type(run = run)\n      \n      if (isTRUE(test)) { \n3        shinyApp(\n          ui = movies_ui,\n          server = movies_server,\n          options = list(test.mode = TRUE)\n        )\n      } else {  \n4        shinyApp(\n          ui = movies_ui,\n          server = movies_server,\n          options = list(test.mode = FALSE)\n        )\n      }\n    \n  } else {\n    \n    # App deployed \n    shinyApp(ui = movies_ui(),\n             server = movies_server)\n    \n  }\n}\n\n\n1\n\nCheck if interactive (Workbench) launch\n\n\n2\n\nSet shinyViewerType option with display_type()\n\n\n3\n\nLaunch app in test mode\n\n\n4\n\nLaunch app\n\n\n\n\nAfter loading, documenting, and installing the package, I can test my new standalone app function:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\n\n\n\n\n(a) updated movies_app() function\n\n\nFigure 9.6: movies_app() launches the application without the loadSupport() warning.\n\n\nNow we can see movies_app() is launching the application without the loadSupport() warning. We can also adjust the test and run arguments to see make sure these are implemented correctly:\n\n\n\n\n\n(a) test and run arguments in movies_app()\n\n\nFigure 9.7: Testing the options in movies_app()"
  },
  {
    "objectID": "launch.html#updated-app.r",
    "href": "launch.html#updated-app.r",
    "title": "Launch",
    "section": "Updated app.R",
    "text": "Updated app.R\nBelow are a few options to consider including in your app.R file. There are multiple ways to launch an application from this file, so of these options are required (but you might find them helpful!).\n\nif (!interactive())\n\n\nWhat if the session isn’t interactive (i.e., !interactive() == TRUE)?\nIn this case, we’ll divert all regular output to the standard error stream.\n\n\nstderr()\nThe sink() function “diverts R output to a connection”, so the code below sends the output that would normally print to the console to the where error messages are written.\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n} else {\n   \n}\n\nThis is useful in a non-interactive settings if we want to re-direct the error output for the console text-mode connection.\n\n\ntryCatch()\ntryCatch() is used for ‘catching conditions’ during the execution of an expression (expr =):\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(shinyAppPkg)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   \n}\n\nIn this case, if library(shinyAppPkg) throws an error, the function specified after error = is executed (i.e., pkgload::load_all()).5\nWritten this way, in a non-interactive R session, app.R will re-direct the error output and attempt to load and attach shinyAppPkg, and if this fails, app.R will attempt to load all the files in the R/ folder.\n\n\n\npkgload\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nThe pkgload package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('pkgload').\n\n\n\n\nIf the session is interactive (i.e., !interactive() == FALSE), we want app.R to load all the code in the R/ folder with pkgload::load_all().6\n\nif (!interactive()) {\n   sink(stderr(), type = \"output\")\n   tryCatch(expr = {\n      library(shinyAppPkg)\n   }, error = function(e) {\n      pkgload::load_all()\n   })\n} else {\n   pkgload::load_all()\n}\n\n\n\nwithr\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nThe withr package is imported as part the devtools/usethis workflow, otherwise we’d want to add it the Imports field of the DESCRIPTION with usethis::use_package('withr').\n\n\n\n\nThe withr package is designed to ‘run code with safely and temporarily modified global state’, and it comes in handy when launching shiny apps. For example, I want to turn off the loadSupport() behavior when launching the app from app.R.7\nI can use withr::with_options() to accomplish this using the following new and code arguments\n\nnew: a named list of the new options and their values\n\ncode: the ’Code to execute in the temporary environment\n\nI want to place the withr::with_options() at the top of app.R and pass contents of app.R into the code argument. Just to be sure no options for shiny.autoload.r previously exist, I’ll also set this option to NULL before executing the rest of the code.\n\n# reset loadSupport()\noptions(shiny.autoload.r = NULL)\n# set option to turn off loadSupport() ----\nwithr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        # load package ----\n        library(shinyAppPkg)\n      },\n      error = function(e) {\n        # load R/ folder ----\n        pkgload::load_all()\n      }\n    )\n    # create shiny object ----\n    shiny::shinyApp(\n      ui = movies_ui,\n      server = movies_server\n    )\n  } else {\n    # load R/ folder ----\n    pkgload::load_all()\n    # create shiny object ----\n    shiny::shinyApp(\n      ui = movies_ui,\n      server = movies_server\n    )\n  }\n})\n\nNow that we’ve updated the app.R account for the app-package structure, we should load, document, and install shinyAppPkg and run it’s contents:\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B"
  },
  {
    "objectID": "launch.html#running-app.r",
    "href": "launch.html#running-app.r",
    "title": "Launch",
    "section": "Running app.R",
    "text": "Running app.R\nWhen we send the contents of app.R to the Console, the loadSupport() options are applied before running the app:\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 05_launch-app branch\n\n\n\n\n\n(a) Sending app.R to Console\n\n\nFigure 9.8: The application is launched without the loadSupport() warning\n\n\n\n\n\n\n\n\nR/_disable_autoload.R\n\n\n\n\n\n\nIn the documentation for loadSupport(), you’ll find a second option for removing the R/ directory sourcing behavior: placing a _disable_autoload.R file in the R/ directory (this is also one of the behaviors of the golem framework, which we will cover in the following chapters).\nBoth methods work–this chapter demonstrates a way to remove the loadSupport() warning without having to add this file."
  },
  {
    "objectID": "launch.html#deploying-the-app",
    "href": "launch.html#deploying-the-app",
    "title": "Launch",
    "section": "Deploying the app",
    "text": "Deploying the app\nTo deploy the app, I can click on the Publish icon:\n\n\n\n\n\n(a) Click on the Publish icon\n\n\nFigure 9.9: Send app.R to Console and click Publish\n\n\nMake sure all the files in the package are selected, then click Publish\n\n\n\n\n\n(a) Publishing apps to shinyapps.io\n\n\nFigure 9.10: Publish the entire package to shinyapps.io\n\n\nThe Deploy pane will open and you’ll see a deployment log as your application is sent to the server:\n\n\nshow/hide deployment log\n── Preparing for deployment ────────────────────────────────────────────────────\nℹ Creating application on server...\n✔ Created application with id 10026672\nℹ Bundling 24 files: .Rbuildignore, app.R, DESCRIPTION, launch.R, movies.RData, NAMESPACE, README.md, www/shiny.png, man/display_type.Rd, man/mod_scatter_display_server.Rd, man/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, man/mod_var_input_ui.Rd, man/movies_app.Rd, man/movies_server.Rd, man/movies_ui.Rd, man/scatter_plot.Rd, R/display_mode.R, …, R/movies_ui.R, and R/scatter_plot.R\nℹ Capturing R dependencies with renv\n✔ Found 63 dependencies\n✔ Created 258,028b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 7740376\n── Deploying to server ─────────────────────────────────────────────────────────\nWaiting for task: 1340526445\n  building: Parsing manifest\n  building: Building image: 9212796\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9212796\n  deploying: Starting instances\n  rollforward: Activating new instances\n  unstaging: Stopping old instances\n── Deployment complete ─────────────────────────────────────────────────────────\n✔ Successfully deployed to &lt;https://yourusername.shinyapps.io/shinyap-run-app/&gt;\nDeployment completed: https://yourusername.shinyapps.io/shinyap-run-app/\n\n\nYou can view a deployed version of this application here."
  },
  {
    "objectID": "launch.html#recap-1",
    "href": "launch.html#recap-1",
    "title": "Launch",
    "section": "Recap",
    "text": "Recap\nThis chapter has covered some options for launching your app within your app-package. We went over what to include in the standalone app function and the app.R file, the differences between shinyApp(), shinyAppDir() and runApp(), but it’s worth exploring these topics further (especially if you plan on having more than one apps in your package).\n\n\n\n\n\n\nRecap: launching your app\n\n\n\n\n\n\nshinyApp():\n\nshinyApp() doesn’t care about file structure, so it’s useful for quick prototyping or if the app is in a single .R script. It’s also more portable because you can share your app with a single .R script.\n\nIt’s possible to bundle shinyApp() in a wrapper function to integrate within an R package (like we’ve done with movies_app()).\nshinyApp() returns a shiny app object, which can be useful if you want to explore the app structure programmatically (i.e., testing).\n\n\nshinyAppDir():\n\nshinyAppDir() launches an app from a directory, and is useful if an app is spread across multiple files and folders.\n\nrunApp()\n\nrunApp() a more generalized way to launch an app. It works with:\n\napps contained in a directory (i.e., runApp('path/to/app')\napps in separate ui.R and server.R files (or a single app.R file)\na shiny app object (passed to the appDir argument).\n\nClicking on Run App will run the application with runApp() if is detects a file (or files) that creates a shiny object.\n\n\n\n\n\nIn the following chapter, we’re going to cover how to ensure movies.Data becomes part of the shinyAppPkg namespace."
  },
  {
    "objectID": "launch.html#footnotes",
    "href": "launch.html#footnotes",
    "title": "Launch",
    "section": "",
    "text": "If you recall, we covered the loadSupport() function in Chapter 1.↩︎\nShiny’s examples are run using runApp()↩︎\nIt’s worthwhile to read the documentation on shinyApp(), shinyAppDir(), and runApp().↩︎\nThe shiny.launch.browser options are covered in this blog post by Garrick Aden-Buie, and I’ve combined them into a run argument in movies_app()↩︎\npkgload is part of the conscious uncoupling of the devtools package we learned about back in Chapter 3.↩︎\npkgload::load_all() is the function that’s actually called when we run devtools::load_all() (or use Ctrl/Cmd + Shift + L), and this is somewhat analogous to running library(shinyAppPkg)↩︎\nYou can read more about the shiny.autoload.r option and loadSupport() in this article↩︎"
  },
  {
    "objectID": "external.html#what-happened-to-our-iconimage",
    "href": "external.html#what-happened-to-our-iconimage",
    "title": "External files",
    "section": "What happened to our icon/image?",
    "text": "What happened to our icon/image?\nWhen we launch our app using the standalone app function (movies_app()), we see the following:\n\n\n\n\n\n\n(a) movies_app() without logo\n\n\nFigure 10.1: The shiny.png in www is not accessible when we launch the app\n\n\n\nThe shiny.png logo in www/ is not being loaded into the UI when the application is launched. This is a common problem developers encounter when converting shiny app into app-packages.1 In the sections below, I’ll cover where the contents of www/ belong in an R package (and how to add them to your application)."
  },
  {
    "objectID": "external.html#your-app-package",
    "href": "external.html#your-app-package",
    "title": "External files",
    "section": "Your app-package",
    "text": "Your app-package\nWhile developing, we get used to interacting with our app-package from the Files pane, or via the file explorer on your native operating system (Finder on macOS, or the File Explorer on Windows):\n\n\n\n\n\n\nGit Branch\n\n\nshinyAppPkg repo’s 06_data branch\n\n\n\n\n\n\n\n‘Source’ files shinyAppPkg in Files pane\n\n\n\n\n \n\n\n\n\n\n‘Source’ files shinyAppPkg in Finder (macOS)\n\n\n\n\n\nHowever, when we run install() (or use Ctrl/Cmd + Shift + B), the output in the Build pane gives us the location of our installed package:\n\n==&gt; R CMD INSTALL --preclean --no-multiarch --with-keep.source shinyAppPkg\n\n1* installing to library ‘/path/to/installed/package/shinyAppPkg/’\n* installing *source* package ‘shinyAppPkg’ ...\n** using staged installation\n** R\n** data\n*** moving datasets to lazyload DB\n** inst\n** byte-compile and prepare package for lazy loading\n** help\n*** installing help indices\n** building package indices\n** testing if installed package can be loaded from temporary location\n** testing if installed package can be loaded from final location\n** testing if installed package keeps a record of temporary installation path\n* DONE \n\n\n1\n\nThis is the location of the installed version of shinyAppPkg"
  },
  {
    "objectID": "external.html#your-app-package-installed",
    "href": "external.html#your-app-package-installed",
    "title": "External files",
    "section": "Your app-package … installed",
    "text": "Your app-package … installed\nIf we add shinyAppPkg/ to the path above, it allows us to view the contents of the installed package (I’m using the tree command in the Terminal, but the fs::dir_tree() function will also print a folder tree):2\n\n/path/to/installed/package/shinyAppPkg/\n1  ├── DESCRIPTION\n  ├── INDEX\n  ├── Meta/\n  │   ├── Rd.rds\n  │   ├── data.rds\n  │   ├── features.rds\n  │   ├── hsearch.rds\n  │   ├── links.rds\n  │   ├── nsInfo.rds\n  │   └── package.rds\n2  ├── NAMESPACE\n3  ├── R/\n  │   ├── shinyAppPkg\n  │   ├── shinyAppPkg.rdb\n  │   └── shinyAppPkg.rdx\n4  ├── data/\n  │   ├── Rdata.rdb\n  │   ├── Rdata.rds\n  │   └── Rdata.rdx\n5  ├── extdata/\n  │   └── movies.fst\n6  ├── help/\n  │   ├── AnIndex\n  │   ├── aliases.rds\n  │   ├── paths.rds\n  │   ├── shinyAppPkg.rdb\n  │   └── shinyAppPkg.rdx\n  └── html/\n      ├── 00Index.html\n      └── R.css\n\n\n1\n\nCopied over from source files (with a Built field added)\n\n\n2\n\nDirectly copied over from source files\n\n\n3\n\nR/ copied over from source files (.R files converted)\n\n\n4\n\ndata/ copied over from source files (.RData and .rda files converted)\n\n5\n\ninst/ sub-folder in source files\n\n\n6\n\nThe contents of the man/ folder (.Rd files converted)\n\n\n\n\nThe installed version of shinyAppPkg has many of the same files as the ‘source’ version we’ve been working with (i.e., NAMESPACE and DESCRIPTION). It also might surprise you to see that many of the source files aren’t included in the installed version of shinyAppPkg (.R, .Rd files. etc.).\nViewing the contents of an installed package should 1) demystify what happens when a package is installed and 2) give you an idea of how system.file() works. There are a few folder names we have to avoid using in inst/:3\n\n“The contents of the inst/ subdirectory will be copied recursively to the installation directory. Subdirectories of inst/ should not interfere with those used by R (currently, R/, data/, demo/, exec/, libs/, man/, help/, html/ and Meta/, and earlier versions used latex/, R-ex/).” - Writing R extensions, Package subdirectories"
  },
  {
    "objectID": "external.html#system.file",
    "href": "external.html#system.file",
    "title": "External files",
    "section": "system.file()",
    "text": "system.file()\nsystem.file() gives us access to the package files on installation (i.e., the files we saw in the folder tree above). In the previous chapter, we used system.file() to access the movies.fst file in inst/extdata/:\n\nfst::read_fst(\n  path = system.file(\"extdata/\", \"movies.fst\", \n                     package = \"shinyAppPkg\")\n  )\n\nAs we can see, the movies.fst has two locations: the ‘source’ package location, and the ‘installed’ package location.\n\n\n\nSource package files\ninst/\n  └── extdata/\n        └── movies.fst\n\n\nInstalled package files\n└── extdata/\n      └── movies.fst\n\n\n\nsystem.file() is accessing movies.fst from the installed location.4\nTo include the contents of www/ in our app-package, we’ll need to use isnt/ folder, system.file(), and the shiny::addResourcePath() function."
  },
  {
    "objectID": "external.html#addresourcepath",
    "href": "external.html#addresourcepath",
    "title": "External files",
    "section": "addResourcePath()",
    "text": "addResourcePath()\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 07_inst-www branch\nThe addResourcePath() function will add a “directory of static resources to Shiny’s web server.” In shinyAppPkg, want to add the www directory that includes the shiny.png file.5\nIf we want to continue keeping external resources in the www/ folder, we can move www/ and it’s contents into inst/:\n\n\n\nCurrent www location\n├── inst\n│   └── extdata\n│       └── movies.fst\n└── www\n    └── shiny.png\n\n\n \n\n\nNew www location\ninst/\n  ├── extdata/\n  │   └── movies.fst\n  └── www/\n      └── shiny.png\n\n\n\nIn R/movies_ui.R function, we’ll include the addResourcePath() at the top of the tagList() and reference the image in img() using only the subfolder in the path:\n\nmovies_ui &lt;- function() {\n  addResourcePath(\n1    prefix = 'www',\n2    directoryPath = system.file('www', package = 'shinyAppPkg'))\n  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n3            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ), \n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n} \n\n\n1\n\nPrefix (or folder name) of installed location\n\n\n2\n\nPath to installed package files\n\n\n3\n\nReference to installed package image file\n\n\n\n\nAfter loading, documenting, and installing, the application now includes the image file.\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\nlibrary(shinyAppPkg)\nmovies_app()\n\n\n\n\n\n\n\n(a) movies_app() with logo\n\n\nFigure 10.2: inst/www accessible with addResourcePath()"
  },
  {
    "objectID": "external.html#app-versions-with-inst",
    "href": "external.html#app-versions-with-inst",
    "title": "External files",
    "section": "App versions with inst/",
    "text": "App versions with inst/\nThe inst/ folder can also be used to store files we’re using in alternate versions of our application. This can include alternate images, CSS styling, JS scripts, data files, or even entirely different apps!\n\nwww/ versions\nWe can store inst/ alternative external files and configure our UI function to test different layouts. In the example below, I’ve included an optional UI layout from the bslib package.\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 07_inst-bslib branch\nThe bslib argument in the movies_ui() includes an alternate image file (stored in inst/www/bootstrap.png):\n\n\n\n\n\n\nDependency watch!\n\n\n\n\n\n\nRemember to include the bslib and sass packages to your DESCRIPTION with usethis::use_package().\n\n\n\n\n\n\nshow/hide movies_ui()\nmovies_ui &lt;- function(bslib = FALSE) {\n1  addResourcePath(\n    prefix = 'www',\n    directoryPath = system.file('www', package = 'shinyAppPkg'))\n  if (isFALSE(bslib)) {\n2  tagList(\n    fluidPage(\n      theme = shinythemes::shinytheme(\"spacelab\"),\n      titlePanel(\n        div(\n          img(\n            src = \"www/shiny.png\",\n            height = 60,\n            width = 55,\n            style = \"margin:10px 10px\"\n            ),\n         \"Movie Reviews\"\n        )\n      ),\n      sidebarLayout(\n        sidebarPanel(\n          mod_var_input_ui(\"vars\")\n        ),\n        mainPanel(\n          mod_scatter_display_ui(\"plot\")\n        )\n      )\n    )\n  )\n3  } else {\n    tagList(\n      bslib::page_fillable(\n        title = \"Movie Reviews (bslib)\",\n        theme = bslib::bs_theme(\n          bg = \"#101010\",\n          fg = \"#F6F5F5\",\n          primary = \"#EE6F57\",\n          secondary = \"#32E0C4\",\n          success = \"#FF4B5C\",\n          base_font = sass::font_google(\"Ubuntu\"),\n          heading_font = sass::font_google(\"Ubuntu\")\n        ),\n        bslib::layout_sidebar(\n          sidebar = bslib::sidebar(\n            mod_var_input_ui(\"vars\")\n          ),\n          bslib::card(\n            full_screen = TRUE,\n                bslib::card_header(\n                  tags$img(\n4                  src = \"www/bootstrap.png\",\n                  height = 80,\n                  width = 100,\n                  style = \"margin:10px 10px\"\n                )\n              ),\n             bslib::card_body(\n              mod_scatter_display_ui(\"plot\")\n            )\n          )\n        )\n      )\n    )\n  }\n} \n\n\n\n1\n\nInclude inst/www resources\n\n\n2\n\nStandard fluidPage()\n\n\n3\n\nbslib layout\n\n\n4\n\nReference to alternate image (bootstrap.png)\n\n\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nThis alternate version of movies_app() uses the same modules and utility functions as the previous versions, but when bslib = TRUE, the app displays the alternate UI layout:\n\nshinyAppPkg::movies_app(test = FALSE, bslib = TRUE)\n\n\n\n\n\n\n\n(a) movies_app() with logo\n\n\nFigure 10.3: inst/www/bootstrap.png image from movies_ui()\n\n\n\nThe example above was a simple, but using inst/ to hold alternate features (i.e., images or custom .html, .css, .sass, .js code) that can be easily displayed with an optional argument is a great tool for demonstrating features to users and stakeholders.\n\n\ndev/ versions\nIt’s not uncommon to be working on multiple ‘development’ versions of an application in the same package. In these situations, we might want to begin developing our application in the inst/dev folder:\n\ninst/dev/\n  ├── app.R\n  ├── tidy_movies.fst\n  └── imdb.png\n\n1 directory, 3 files\n\n\ndev data\nThe ‘development’ application in shinyAppPkg uses a tidy version of the ggplot2movies::movies data, which we created in the data-raw/tidy_movies.R file.6\n\n\nshow/hide data-raw/tidy_movies.R\n## code to prepare `ggp2movies` dataset goes here\n# pkgs &lt;- c('ggplot2movies', 'tidyr', 'dplyr', 'stringr', 'fst')\n# install.packages(pkgs, quiet = TRUE)\n\n# load packages --------------------\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(fst)\n\n# tidy_movies\ntidy_movies &lt;- ggplot2movies::movies |&gt;\n  tidyr::pivot_longer(c(Action:Short),\n    names_to = \"genre_key\",\n    values_to = \"genre_value\"\n  ) |&gt;\n  dplyr::mutate(genre_value = as.logical(genre_value)) |&gt;\n  dplyr::select(\n    title, genre_key, genre_value, length,\n    year, budget, avg_rating = rating, votes, mpaa\n  ) |&gt;\n  dplyr::filter(genre_value == TRUE) |&gt;\n  dplyr::group_by(title) |&gt;\n  dplyr:::mutate(\n    genres = paste0(genre_key, collapse = \", \")\n  ) |&gt;\n  dplyr::select(\n    title, genres, length, year,\n    budget, avg_rating, votes, mpaa\n  ) |&gt;\n  dplyr::ungroup() |&gt;\n  dplyr::distinct(.keep_all = TRUE) |&gt;\n  dplyr::mutate(\n    genres = dplyr::na_if(x = genres, \"\"),\n    genre = dplyr::case_when(\n                stringr::str_detect(genres, \",\") ~ 'Multiple genres',\n                TRUE ~ genres),\n    genre = factor(genre),\n    mpaa = dplyr::na_if(x = mpaa, y = \"\"),\n    mpaa = factor(mpaa,\n      levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n      labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"))\n    ) |&gt; \n  dplyr::select(-genres)\n# save to inst/dev/\nfst::write_fst(x = tidy_movies, path = \"inst/dev/tidy_movies.fst\")\n\n\n\n\ndev modules\nIn inst/dev/, we’ve placed the application modules in an app.R file:\n\ndev_mod_vars_ui() contains choices for the names in the tidy_movies data:\n\n\n\nshow/hide dev_mod_vars_ui()\ndev_mod_vars_ui &lt;- function(id) {\n      ns &lt;- NS(id)\n      tagList(\n        textInput(\n          inputId = ns(\"plot_title\"),\n          label = \"Plot title\",\n          placeholder = \"Enter plot title\"\n        ),\n        selectInput(\n          inputId = ns(\"y\"),\n          label = \"Y-axis:\",\n          choices = c(\n            \"Year\" = \"year\",\n            \"Length\" = \"length\",\n            \"Budget\" = \"budget\",\n            \"Rating\" = \"avg_rating\",\n            \"Votes\" = \"votes\"\n          ),\n          selected = \"budget\"\n        ),\n        selectInput(\n          inputId = ns(\"x\"),\n          label = \"X-axis:\",\n          choices = c(\n            \"Year\" = \"year\",\n            \"Length\" = \"length\",\n            \"Budget\" = \"budget\",\n            \"Rating\" = \"avg_rating\",\n            \"Votes\" = \"votes\"\n          ),\n          selected = \"year\"\n        ),\n        selectInput(\n          inputId = ns(\"z\"),\n          label = \"Color by:\",\n          choices = c(\n            \"MPAA\" = \"mpaa\",\n            \"Genre\" = \"genre\"\n          ),\n          selected = \"mpaa\"\n        ),\n        sliderInput(\n          inputId = ns(\"alpha\"),\n          label = \"Alpha:\",\n          min = 0, max = 1, step = 0.1,\n          value = 0.4\n        ),\n        sliderInput(\n          inputId = ns(\"size\"),\n          label = \"Size:\",\n          min = 0, max = 5, step = 0.5,\n          value = 2.5\n        )\n      )\n  }\n\n\n\nThe dev_ versions of the display module imports the tidy_movies.fst data file and includes an option for removing missing values.\n\n\n\nshow/hide dev_mod_scatter_ui()\ndev_mod_scatter_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    tags$br(),\n    tags$blockquote(\n      tags$em(\n        tags$h6(\n1        \"The data for this application comes from the \",\n          tags$a(\"ggplot2movies\",\n          href = \"https://github.com/hadley/ggplot2movies\"\n          ),\n          \"package\"\n        )\n      )\n    ),\n    tags$div(\n2      checkboxInput(\n        inputId = ns(\"missing\"),\n        label = \"Remove missing\",\n        value = TRUE\n      ),\n      plotOutput(outputId = ns(\"scatterplot\"))\n      )\n    )\n}\n\n\n\n1\n\nAlternate help text for ggplot2movies data\n\n\n2\n\nCheck-box to remove missing values\n\n\n\n\n\n\nshow/hide dev_mod_scatter_server()\ndev_mod_scatter_server &lt;- function(id, var_inputs) {\n    moduleServer(id, function(input, output, session) {\n      # load alternate data\n      all_data &lt;- fst::read_fst(\"tidy_movies.fst\")\n  \n      \n1      graph_data &lt;- reactive({\n        if (input$missing) {\n          graph_data &lt;- tidyr::drop_na(data = all_data)\n        } else {\n          graph_data &lt;- all_data\n        }\n2      }) |&gt;\n        bindEvent(input$missing)\n  \n      inputs &lt;- reactive({\n        plot_title &lt;- tools::toTitleCase(var_inputs()$plot_title)\n        list(\n          x = var_inputs()$x,\n          y = var_inputs()$y,\n          z = var_inputs()$z,\n          alpha = var_inputs()$alpha,\n          size = var_inputs()$size,\n          plot_title = plot_title\n        )\n      })\n  \n3      observe({\n        output$scatterplot &lt;- renderPlot({\n          plot &lt;- shinyAppPkg::scatter_plot(\n            df = graph_data(),\n            x_var = inputs()$x,\n            y_var = inputs()$y,\n            col_var = inputs()$z,\n            alpha_var = inputs()$alpha,\n            size_var = inputs()$size\n          )\n          plot +\n            ggplot2::labs(\n              title = inputs()$plot_title,\n              x = stringr::str_replace_all(\n                        tools::toTitleCase(inputs()$x), \"_\", \" \"),\n              y = stringr::str_replace_all(\n                        tools::toTitleCase(inputs()$y), \"_\", \" \")\n            ) +\n            ggplot2::theme_minimal() +\n            ggplot2::theme(legend.position = \"bottom\")\n        })\n      }) |&gt;\n        bindEvent(graph_data(), inputs())\n    })\n  }\n\n\n\n1\n\nBuild reactive data based on missing checkbox input\n\n\n2\n\nBind missing input to update when UI changes\n\n\n3\n\nBind plot output to update with variable inputs and ‘missing’ checkbox output\n\n\n\n\nAny of the functions from shinyAppPkg can be used in the dev modules with explicit namespacing (i.e., shinyAppPkg::scatter_plot()).\n\n\ndev UI and server\napp.R also contains development app UI and server functions.\nIn devUI(), development modules are paired with package modules (dev_mod_vars_ui() and shinyAppPkg::mod_var_input_server()), and we’ve include an alternate image (bootstrap.png).7\n\n\nshow/hide devUI()\ndevUI &lt;- function() {\n1    addResourcePath(\n      prefix = \"dev\",\n      directoryPath = system.file(\"dev\",\n                                  package = \"shinyAppPkg\")\n    )\n  tagList(\n    bslib::page_fillable(\n      title = \"Movie Reviews (ggplot2movies)\",\n      theme = bslib::bs_theme(\n        bg = \"#043b67\",\n        fg = \"#ffffff\",\n        primary = \"#ffcf22\",\n        secondary = \"#38B44A\",\n        success = \"#32E0C4\",\n        base_font = sass::font_google(\"Ubuntu\"),\n        heading_font = sass::font_google(\"Ubuntu\")\n      ),\n      bslib::layout_sidebar(\n        sidebar = bslib::sidebar(\n2          dev_mod_vars_ui(\"vars\")\n        ),\n        bslib::card(\n          full_screen = TRUE,\n          bslib::card_header(\n              tags$div(\n                tags$img(\n3                  src = \"dev/imdb.png\",\n                  height = 80,\n                  width = 110,\n                  style = \"margin:10px 10px\"\n                )\n              )\n            ),\n          bslib::card_body(\n4            dev_mod_scatter_ui(\"plot\")\n          )\n        )\n      )\n    )\n  )\n}\n\n\n\n1\n\nAdd alternate path to include image file\n\n2\n\nDevelopment variable input module (UI)\n\n\n3\n\nRefer to alternate image\n\n\n4\n\nDevelopment scatter-plot display module (UI)\n\n\n\n\n\n\nshow/hide devServer()\ndevServer &lt;- function(input, output, session) {\n  \n1  selected_vars &lt;- shinyAppPkg::mod_var_input_server(\"vars\")\n\n2  dev_mod_scatter_server(\"plot\", var_inputs = selected_vars)\n  \n}\n\n\n\n1\n\nmod_var_input_server() exported from shinyAppPkg’s R/ folder\n\n2\n\nDefined in dev/inst/app.R\n\n\n\n\n\n\nLaunching inst/dev/\nFinally, the development app is launched with it’s own standalone function (stored in R/ggp2_movies_app.R). The ggp2_movies_app() function is similar to movies_app(), but appDir is set to the location of the development files (which we provide with system.file()).\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 07_inst-ggp2movies branch\n\n\nshow/hide R/ggp2_movies_app.R\n#' Development `ggplot2movies` app standalone function\n#'\n#' Wrapper function for `shinyAppDir()`\n#' \n#' @param test logical, run in `test.mode`? Defaults to `TRUE`.\n#' \n#' @return shiny app\n#' \n#'\n#' @export\nggp2_movies_app &lt;- function(test = TRUE, run = \"w\") {\n  if (interactive()) {\n    display_type(run = run)\n\n    if (isTRUE(test)) {\n      shinyAppDir(\n        appDir = system.file(\"dev\",\n          package = \"shinyAppPkg\"\n        ),\n        options(test.mode = TRUE)\n      )\n    } else {\n      shinyAppDir(\n        appDir = system.file(\"dev\",\n          package = \"shinyAppPkg\"\n        ),\n        options(test.mode = FALSE)\n      )\n    }\n  } else {\n    shinyAppDir(appDir = system.file(\"dev\",\n      package = \"shinyAppPkg\"\n    ))\n  }\n}\n\n\n\nAfter loading, documenting, and installing shinyAppPkg, we can run the development version using ggplot2movies_app():\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) ggplot2movies_app()\n\n\nFigure 10.4: inst/dev/ app with dev_movies_ui()\n\n\n\nYou may have noticed that I’ve used a different color and theme for the two development examples above. I’ve found this can be a quick and easy way to differentiate ‘development’ and ‘production’ versions of an application.\n\n\n\nprod/ versions\nIt’s also possible to have a folder dedicated for deploying your application in your app-package.\n\nprod/app/ data\nThis folder can be named something like inst/prod/ or inst/deploy, and it will contain the ‘production’ ready versions of UI and server functions in a single app.R file:\n\ninst/\n  └── prod/\n      └── app\n          └── app.R\n          \n2 directories, 1 file\n\n\n\nprod/app/app.R data\nIn the app.R file, include only a call to shinyApp() with the ui and server function (explicitly namespaced from your app-package):\n\n\nshow/hide prod/app/app.R\nshinyApp(\n  ui = shinyAppPkg::movies_ui(bslib = TRUE), \n  server = shinyAppPkg::movies_server)\n\n\nI used the bslib version, just to differentiate it from the other applications in shinyAppPkg.\n\n\nDeploying inst/prod/app/\nBack in the root app.R file, we’ll use shinyAppDir() and system.file() to return the app object from prod/app/app.R:\n\n\nshow/hide app.R\n# set option to turn off loadSupport() ----\nwithr::with_options(new = list(shiny.autoload.r = FALSE), code = {\n  if (!interactive()) {\n    sink(stderr(), type = \"output\")\n    tryCatch(\n      expr = {\n        # load package ----\n        library(shinyAppPkg)\n      },\n      error = function(e) {\n        # load R/ folder ----\n        pkgload::load_all()\n      }\n    )\n    # create shiny object from prod/app ----\n    shinyAppDir(appDir = \n        system.file(\"prod/app\", package = \"shinyAppPkg\"))\n  } else {\n    # load R/ folder ----\n    pkgload::load_all()\n    # create shiny object ----\n    shiny::shinyApp(\n      ui = movies_ui,\n      server = movies_server\n    )\n  }\n})\n\n\n\n\n\n\n\n\n\n\nCtrl/Cmd + Shift + L / D / B\n\n\n\n\n\n\n\nTo deploy the app, call rsconnect::deployApp() in the console.\n\nrsconnect::deployApp()\n\nThe deployment log will look something like this:\n── Preparing for deployment ────────────────────────────────────────────\n✔ Re-deploying \"shinyapppkg\" to \"server: shinyapps.io / username: yourusername\"\nℹ Looking up application with id \"10047601\"...\n✔ Found application &lt;https://mjfrigaard.shinyapps.io/shinyapppkg/&gt;\nℹ Bundling 35 files: .Rbuildignore, app.R, data/movies.rda, data/movies.RData,\n  data-raw/tidy_movies.R, DESCRIPTION, inst/dev/app.R, inst/dev/imdb.png, \n  inst/dev/tidy_movies.fst, inst/extdata/movies.fst, inst/prod/app/app.R, \n  inst/www/bootstrap.png, inst/www/shiny.png, man/display_type.Rd, \n  man/ggp2_movies_app.Rd, man/mod_scatter_display_server.Rd, \n  man/mod_scatter_display_ui.Rd, man/mod_var_input_server.Rd, …, \n  R/scatter_plot.R, and README.md\nℹ Capturing R dependencies with renv\n✔ Found 72 dependencies\n✔ Created 1,179,590b bundle\nℹ Uploading bundle...\n✔ Uploaded bundle with id 7749936\n── Deploying to server ────────────────────────────────────────────────────────────────────\nWaiting for task: 1341341295\n  building: Parsing manifest\n  building: Building image: 9226179\n  building: Fetching packages\n  building: Installing packages\n  building: Installing files\n  building: Pushing image: 9226179\n  deploying: Starting instances\n  rollforward: Activating new instances\n  terminating: Stopping old instances\n── Deployment complete ───────────────────────────────────────────\n✔ Successfully deployed to &lt;https://mjfrigaard.shinyapps.io/shinyapppkg/&gt;\nYou can see a deployed version of this application here\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 07_inst-prod branch\n\n\n\n\n\n\nUses of inst/ in other packages\n\n\n\n\n\n\nYou can explore the structure of other installed packages to see how they work ‘under the hood’ to gain insight into how they use the inst/ folder.\n\nFor example, the inst/extdata/ folder in the readr package holds a variety of datasets:\n/path/to/install/Library/R/x86_64/4.2/library/readr/\n\nextdata/\n  ├── challenge.csv\n  ├── chickens.csv\n  ├── epa78.txt\n  ├── example.log\n  ├── fwf-sample.txt\n  ├── massey-rating.txt\n  ├── mini-gapminder-africa.csv\n  ├── mini-gapminder-americas.csv\n  ├── mini-gapminder-asia.csv\n  ├── mini-gapminder-europe.csv\n  ├── mini-gapminder-oceania.csv\n  ├── mtcars.csv\n  ├── mtcars.csv.bz2\n  ├── mtcars.csv.zip\n  └── whitespace-sample.txt\n\n1 directory, 15 files\nThese files are used in readr::readr_example()):\n#' Get path to readr example\n#'\n#' readr comes bundled with a number of sample files in its `inst/extdata`\n#' directory. This function make them easy to access\n#'\n#' @param file Name of file. If `NULL`, the example files will be listed.\n#' @export\n#' @examples\n#' readr_example()\n#' readr_example('challenge.csv')\nreadr_example &lt;- function(file = NULL) {\n  if (is.null(file)) {\n    dir(system.file('extdata', package = 'readr'))\n  } else {\n    system.file('extdata', file, package = 'readr', mustWork = TRUE)\n  }\n}"
  },
  {
    "objectID": "external.html#recap",
    "href": "external.html#recap",
    "title": "External files",
    "section": "Recap",
    "text": "Recap\nThis chapter had covered how to include external files and resources (i.e., what was previously stored in the www/ folder of a regular shiny app project) in your app-package with addResourcePath() and system.file().\nWe’ve also covered how to use the inst/ folder to include alternative files, development and production/deployment versions of your app. You can now launch the following applications from shinyAppPkg:\nStandard application in test mode\n\nlibrary(shinyAppPkg)\nmovies_app(test = TRUE)\n# or \nmovies_app(test = FALSE)\n\nblisb application in test mode\nlibrary(shinyAppPkg)\nmovies_app(test = TRUE, bslib = TRUE)\n# or \nmovies_app(test = FALSE, bslib = TRUE) \nggplot2movies data application with/without test mode\n\nlibrary(shinyAppPkg)\nggp2_movies_app(test = TRUE)\n# or \nggp2_movies_app(test = FALSE)\n\nprod/ application\n\nlibrary(shinyAppPkg)\nrsconnect::deployApp()\n\nIn the next chapter, we’re going to cover testing the code in your shiny app-package.\n\n\n\n\n\n\nRecap: inst & www folders\n\n\n\n\n\n\n\ninst/: the inst/ folder is installed with your app-package and will be accessible to users, so it’s a great location for files you want to contained in your app, but don’t fit into the standard R package structure.\nsystem.file(): constructs a path to files or folders within installed packages and is especially useful when working with external datasets (i.e., inst/extdata/) or other external resources included with your app-package (i.e., inst/www/).\nwww: used for external static resources in shiny apps. shiny will automatically serve files under the www/ directory, but in app-packages we need to explicitly set this location with shiny::addResourcePath()\naddResourcePath(): create a prefix (path) for a directoryPath of static files to accessible in shiny’s web server:\n# file location\ninst/\n  └── www/\n        └── shiny.png\n# add path\naddResourcePath('www', system.file('www', package='shinyAppPkg'))\n# use path\nshiny::img(src = 'www/shiny.png')"
  },
  {
    "objectID": "external.html#footnotes",
    "href": "external.html#footnotes",
    "title": "External files",
    "section": "",
    "text": "See this popular thread on Posit Community.↩︎\nUsing fs::path_packcage(package = \"shinyAppPkg\") will also return the path to your installed package.↩︎\nRead more about sub-directories to avoid in inst/ in R Packages, 2ed.↩︎\nThe key takeaway here is that the inst/ subfolders and files are available unchanged in the installed version (with the inst/ folder omitted.).↩︎\nYou can read more about adding external resources in the documentation for addResourcePath().↩︎\nWe covered the data-raw/ folder in the Data chapter, and you can read more about it here in R packages, 2ed↩︎\nThis requires exporting mod_var_input_server() with @export in the R/ folder.↩︎"
  },
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "Tests",
    "section": "",
    "text": "User Specifications & Requirements\nWhen you begin developing a Shiny app-package, you’ll be faced with two questions:\nApplications should have accompanying resources to help address these questions, the most common being a software requirements specification (SRS) document. The SRS typically breaks down an application’s intended purpose (i.e., the problem it’s designed to solve) into three general areas: user specifications, feature requirements, and functional requirements:\nThese guidelines direct the development process, albeit from slightly different perspectives. Understanding the interplay between user specifications, functional requirements, and feature requirements is essential for helping developers know if the application meets the technical standards and satisfies the user’s needs.\nI’ll use shinyAppPkg to illustrate a brief example of each in the sections below:\nMultiple strategies exist for writing tests. For example, if you’ve adopted test-driven development (TDD),15 you’ll write tests before developing utility functions, modules, or a standalone app function.\nRegardless of the testing strategy you choose, I recommend setting up the testing infrastructure in our app-package with the testthat package:\nBehavior-driven development (BDD) (or behavior-driven testing) is a methodology that involves collaboration between developers, users, and domain experts to define requirements and write tests using domain-specific language. The BDD approach emphasizes writing human-readable descriptions of the application’s behavior, which is then converted into a series of tests.\nBehavior-driven testing can be performed using a testthat’s describe() and it() functions.17 Below is an example of how these might look for the US1 user specification in shinyAppPkg:\nTest fixtures are various resources used to ensure a consistent, well-defined environment. Fixtures can be input data, database connections, R options, environment variables, or anything else needed to create a repeatable infrastructure (even when the test is run on different environments or setups).\nA good test fixture also ‘cleans itself up’ after the test has been run to make sure any changes made during the test doesn’t persist or interfere with other tests in your app-package.19\nIn R/ packages, test fixtures are stored in the tests/testthat/fixtures/ folder:\ntests/\n├── testthat/\n1│   └── fixtures/\n└── testthat.R\n\n\n1\n\nThe name ‘fixtures’ isn’t required (you can name this folder anything)\nTest helpers are functions code that make creating and running tests easier.\nIf we wanted to confirm the scatter_plot() function returns a ggplot2 object (i.e., with is.ggplot()) the describe() andit() code would look something like this:\ntestthat::describe(description = \"FE1: interactive scatter plot\", code = {\n  \n  testthat::it(description = \"FR1: data source\", code = {\n    \n      p &lt;- scatter_plot(movies,\n        x_var = var_inputs()$x,\n        y_var = var_inputs()$y,\n        col_var = var_inputs()$z,\n        alpha_var = var_inputs()$alpha,\n        size_var = var_inputs()$size\n      )\n    testthat::expect_true(object = ggplot2::is.ggplot(p))\n    \n  })\n  \n})\nThis test answers the question, ‘does the plot generate without producing an error,’21 which is appropriate because this is a test of the data source (movies), not necessarily the graph output.\nWe can also use a nested describe() chunk to load and test a second data source (i.e., the ggplot2movies::movies data):22\n1testthat::describe(description = \"US1: scatter plot data visualization\", code = {\n  \n2  testthat::describe(description = \"FR1: data source (movies)\", code = {\n    \n    testthat::it(description = \"T1: movies data source\", code = { \n3      p &lt;- scatter_plot(movies,\n        x_var = var_inputs()$x,\n        y_var = var_inputs()$y,\n        col_var = var_inputs()$z,\n        alpha_var = var_inputs()$alpha,\n        size_var = var_inputs()$size\n      )\n      expect_true(object = ggplot2::is.ggplot(p))\n    })\n    \n  })\n  \n4  testthat::describe(description = \"FR1: data source (ggp2_movies)\", code = {\n    \n    testthat::it(description = \"T2: ggp2_movies.rds data source\", code = {\n5      ggp2_movies &lt;- readRDS(test_path(\"fixtures\", \"ggp2_movies.rds\"))\n6      p &lt;- scatter_plot(ggp2_movies,\n        x_var = ggp2_inputs()$x,\n        y_var = ggp2_inputs()$y,\n        col_var = ggp2_inputs()$z,\n        alpha_var = ggp2_inputs()$alpha,\n        size_var = ggp2_inputs()$size\n      )\n      expect_true(object = ggplot2::is.ggplot(p))\n    })\n    \n  })\n  \n})\n\n\n1\n\nUser specification\n\n\n2\n\nmovies data component\n\n\n3\n\nTest movies data with var_inputs() helper\n\n\n4\n\nggp2_movies data component\n\n\n5\n\nLoad ggp2_movies.rds test fixture with testthat::test_path()\n\n\n6\n\nTest ggp2_movies data with ggp2_inputs() helper\nIf the expected output we’re interesting in testing is cumbersome to describe programmatically, we can consider using a snapshot tests. Examples of this include UI elements (which are mostly HTML created by Shiny’s UI layout and input/output functions) and data visualizations.23\nWriting tests for graph outputs can be difficult because the “correctness” of a graph is somewhat subjective and requires human judgment.\nIn cases like this, a snapshot test might be warranted. The vdiffr package allows us to perform a ‘visual unit test’ by saving by capturing the expected output as a snapshot that we can compare with future versions.\nThe BDD functions also allow us to combine tests for reactive interactions with testServer(), which means we can include tests to verify the inputs, outputs, and returned values from module server functions.\nFor example, functional requirement #2 (FR2) is a user created behavior.\nTo confirm the user-inputs are updating in the application, we need to test three changes:\nlist of graph inputs from mod_var_input_server(), we can build the list of inputs, then pass identical values to session$setInputs() and confirm the returned object with session$returned():\nshiny::testServer(app = mod_var_input_server, expr = {\n  test_vals &lt;- list(\n                  y = \"audience_score\",\n                  x = \"imdb_rating\",\n                  z = \"genre\",\n                  alpha = 0.5,\n                  size = 2,\n                  plot_title = \"example title\"\n                )\n  session$setInputs(\n                  y = \"audience_score\",\n                  x = \"imdb_rating\",\n                  z = \"genre\",\n                  alpha = 0.5,\n                  size = 2,\n                  plot_title = \"example title\"\n                )\n  test_logger(start = \"returned(var_input)\", msg = \"var_input structure\")\n  testthat::expect_equal(\n    object = session$returned(),\n    expected = test_vals\n  )\n})\nThis confirms the structure of the returned object from mod_var_input_server().\nComparisons are the backbone of testing. Exploring the mechanics of how tests perform these comparisons (i.e., the underlying package(s)) can save you from surprising results.\nFor example, testthat::expect_equal() compares whatever is passed to the observed and expected arguments with the waldo package, with some help from diffobj.\nlibrary(waldo)\nlibrary(diffobj)\nlibrary(tibble)"
  },
  {
    "objectID": "tests.html#user-specifications",
    "href": "tests.html#user-specifications",
    "title": "Tests",
    "section": "User Specifications",
    "text": "User Specifications\nUser Specifications are what the end-user (in this case, a film analyst) wants to achieve with the application.7\n\n\n\n\n\n\nScatter plot user specification\n\n\n\n\n\n\nUS1: ‘As an film analyst, I want to view an interactive scatter plot in a dashboard that consolidates movie reviews from multiple sources so that I can compare and analyze trends and outliers in movie ratings quickly.’"
  },
  {
    "objectID": "tests.html#feature-requirements",
    "href": "tests.html#feature-requirements",
    "title": "Tests",
    "section": "Feature Requirements",
    "text": "Feature Requirements\nThe feature requirement translates the end user’s expectation into specific language describing an application capability (i.e., display a scatter plot), phrased to satisfy a specific end-user need outlining in the specifications.8\n\n\n\n\n\n\nScatter plot feature requirements\n\n\n\n\n\n\nFE1: ‘Given that movie reviews are available on multiple websites, when the user selects a rating metric from the application display, the interactive scatter plot should allow for comparisons from at least two data sources (i.e., IMDb, Rotten Tomatoes), and include options for selecting other variables of interest (i.e., audience scores, runtime, etc.).’"
  },
  {
    "objectID": "tests.html#functional-requirements",
    "href": "tests.html#functional-requirements",
    "title": "Tests",
    "section": "Functional Requirements",
    "text": "Functional Requirements\nThe Functional Requirements are written for the developer and provide technical details on how the feature (i.e., the scatter plot) should behave and what it needs to do. These requirements are written for developers and represent where the end-users’ expectations come into direct contact with code.9\n\n\n\n\n\n\nScatter plot functional requirements\n\n\n\n\n\n\n\nFR1: The system will display movie reviews from IMDb and Rotten Tomatoes collected from their respective APIs.\nFR2: The scatter plot will be displayed on the dashboard and updated with new user inputs.\nFR3: Each data point on the scatter plot will represent a movie and be color-coded based on the following categories: MPAA ratings, genre, title type, critics rating, and audience rating.\nFR4: The scatter plot will have labeled axes, a legend to differentiate between data sources, and a customizable title."
  },
  {
    "objectID": "tests.html#traceability-matrix",
    "href": "tests.html#traceability-matrix",
    "title": "Tests",
    "section": "Traceability matrix",
    "text": "Traceability matrix\nA traceability matrix is a table that ‘traces’ the user specifications to features and functional requirements (and the tests they give rise to) to verify that the application has been developed correctly. Package vignettes are a great place to store a draft of the traceability matrix, and they can be quickly created using usethis::use_vignette():\n\n\n\n\n\nGit Branch\n\n\nThis section’s code is in the shinyAppPkg repo’s 08_tests-specs branch\n\nusethis::use_vignette(\"test-specs\")\n\nAdding our first vignette to the vignettes/ folder does the following:\n\nAdds the knitr and rmarkdown packages to the Suggests field in DESCRIPTION10\nSuggests: \n    knitr,\n    rmarkdown\nAdds knitr to the VignetteBuilder field11\nVignetteBuilder: knitr\nAdds inst/doc to .gitignore and *.html, *.R to vignettes/.gitignore12\n\nWe want to use the traceability matrix to ensure the tests cover all the functionalities (i.e., the code) and address the user specifications and that every user need corresponds to a functionality that’s been tested.\n\nUser specs & features\nWe’ll start with the user specifications. The language used for these descriptions is non-technical but should provide a basis for deriving the more technical (but still high-level) feature requirements.13\n\n\n\n\n\n\n  \n    \n    \n      User Specification\n      Feature Requirement\n      Functional Requirements\n    \n  \n  \n    US1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, drop-down variable options)\n-\n  \n  \n  \n\n\n\n\n\n\nFunctional requirements\nA single feature often produces multiple functional requirements.\n\n\n\n\n\n\n  \n    \n    \n      User Specification\n      Feature Requirement\n      Functional Requirements\n    \n  \n  \n    US1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, drop-down variable options)\nFR1: data source\n    -\n-\nFR2: user-input updating\n    -\n-\nFR3: color-coded data points\n    -\n-\nFR4: plot axis, legend & title\n  \n  \n  \n\n\n\n\n\n\nTests\nAfter translating the user needs into technical requirements, we can quickly identify what needs to be tested.\n\n\n\n\n\n\n  \n    \n    \n      User Specification\n      Feature Requirement\n      Functional Requirements\n      Tests\n    \n  \n  \n    US1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, drop-down variable options)\nFR1: data source\nT1\n    -\n-\nFR2: user-input updating\nT2\n    -\n-\nFR3: color-coded data points\nT3\n    -\n-\nFR4: plot axis, legend & title\nT4\n  \n  \n  \n\n\n\n\nThe matrix allows us to ensure:\n\nThe user specifications have accompanying feature requirements.\nEach feature has been broken down into precise, measurable, and testable functional requirements.\nTests have been written for each functional requirement.\n\nIf you’d like, you can include additional columns to track whether the test has passed:\n\n\n\n\n\n\n  \n    \n    \n      User Specification\n      Feature Requirement\n      Functional Requirements\n      Tests\n      Test Status\n    \n  \n  \n    US1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, drop-down variable options)\nFR1: data source\nT1\nFR1 test status: \n    -\n-\nFR2: user-input updating\nT2\nFR2 test status: \n    -\n-\nFR3: color-coded data points\nT3\nFR3 test status: \n    -\n-\nFR4: plot axis, legend & title\nT4\nFR4 test status: \n  \n  \n  \n\n\n\n\nVignettes are a great place to store this information because it’s self-contained and travel with the package whenever the code is updated.14\nThe following section covers setting up tests with testthat, the structure of unit tests, and additional elements you should consider using in your app-package."
  },
  {
    "objectID": "tests.html#use_testthat",
    "href": "tests.html#use_testthat",
    "title": "Tests",
    "section": "use_testthat()",
    "text": "use_testthat()\nIn packages using devtools, the testing infrastructure can be built with usethis::use_testthat():\n\nusethis::use_testthat()\n\n\nIn the DESCRIPTION file, testthat (&gt;= 3.0.0) is listed under Suggests and Config/testthat/edition: 3 is used to specify the testthat edition\n\nSuggests: \n    testthat (&gt;= 3.0.0)\nConfig/testthat/edition: 3\n\nA new tests/ folder is created, with a testthat/ subfolder. The testthat.R file is created (which is sometimes referred to as the ‘test runner,’ because it runs all our tests).\n\n\ntests/\n  ├── testthat/\n1  └── testthat.R\n\n2 directories, 1 file\n\n\n1\n\nTest runner\n\n\n\n\n\nuse_test() unit tests\nNew tests are created with usethis::use_test().16\n\nusethis::use_test(\"scatter_plot\")\n\n\ntest- files\n\nTest files: the IDE will automatically create and open the new test file:\n\n✔ Writing 'tests/testthat/test-scatter_plot.R'\n• Modify 'tests/testthat/test-scatter_plot.R'\n\n\ntest_that() tests\n\nTests: Each new test file contains a boilerplate test_that() test, with desc (the test context) and code arguments (supplied in curly brackets).\n\n\ntest_that(desc = \"multiplication works\", code = { \n \n})\n\n\n\nexpect_ations\n\nExpectations: most expectation have two parts: an observed object, and an expected object. The observed object is an artifact of some code you’ve written, and it’s being compared against an expected result.\n\n\n1expect_equal(\n2  object = 2 * 2,\n3  expected = 4\n  ) \n\n\n1\n\nThe test expectation\n\n2\n\nWhat is observed (i.e., the value or object)\n\n3\n\nWhat was expected (i.e., the predefined criteria for success)\n\n\n\n\n\n\nRunning tests\n\nRunning tests: Another devtools habit to adopt is regularly writing and running tests. If you’re using Posit Workbench and have devtools installed, you can test your app-package using the Build pane or the keyboard shortcut:\n\n\n\nCtrl/Cmd + Shift + T\n\n\n\nFigure 13.1: devtools::test() (run all tests in your tests/ folder)\n\n\nWhen the test is run, you’ll see feedback on whether it passes or fails (and some encouragement):\n\ntest_that(\"multiplication works\", { \n  expect_equal( \n    object = 2 * 2, \n    expected = 4 \n    ) \n})\n## Test passed 😀\n\nNow that we have our testing framework and the traceability matrix to guide development, I will cover a slightly different approach to testing that I’ve found helpful with app-packages (and has excellent support in testthat)."
  },
  {
    "objectID": "tests.html#describe",
    "href": "tests.html#describe",
    "title": "Tests",
    "section": "describe()",
    "text": "describe()\nThe testthat::describe() function follows a BDD format and ‘specifies a larger component or function and contains a set of specifications’\nIn describe(), I’ll reference the feature I’m testing (FE1):\n\n\n\n\n\n\n  \n    \n    \n      User Specification\n      Feature Requirement\n    \n  \n  \n    US1: scatter plot data visualization\nFE1: interactive scatter plot (two data sources, drop-down variable options)\n  \n  \n  \n\n\n\n\n\ntestthat::describe(description = \"FE1: interactive scatter plot\", code = {\n  \n\n})"
  },
  {
    "objectID": "tests.html#it",
    "href": "tests.html#it",
    "title": "Tests",
    "section": "it()",
    "text": "it()\nInside describe(), we can include multiple it() blocks which “functions as a test and is evaluated in its own environment.”\nIn the example below, I use it() blocks to test each functional requirement:18\n\n\n\n\n\n\n  \n    \n    \n      Feature Requirement\n      Functional Requirements\n    \n  \n  \n    FE1: interactive scatter plot (two data sources, drop-down variable options)\nFR1: data source\n    -\nFR2: user-input updating\n    -\nFR3: color-coded data points\n    -\nFR4: plot axis, legend & title\n  \n  \n  \n\n\n\n\n\ntestthat::describe(description = \"FE1: interactive scatter plot\", code = {\n  \n  testthat::it(description = \"FR1: data source\", code = {\n    # test code \n    testthat::expect_equal(object = , expected = )\n  })\n\n  testthat::it(description = \"FR2: user-input updating\", code = {\n    # test code \n    testthat::expect_equal(object = , expected = )\n  })\n\n  testthat::it(description = \"FR3: color-coded data points\", code = {\n    # test code \n    testthat::expect_equal(object = , expected = )\n  })\n  \n  testthat::it(description = \"FR4: plot axis, legend & title\", code = {\n    # test code \n    testthat::expect_equal(object = , expected = )\n  })\n})\n\nNext we’re going to cover two additional testing tools (fixtures and helpers) you can include in your test suite to make testing your app-package a little easier."
  },
  {
    "objectID": "tests.html#test-data",
    "href": "tests.html#test-data",
    "title": "Tests",
    "section": "Test data",
    "text": "Test data\nThe code used to create test data files should also be stored in tests/testthat/fixtures/ with a clear naming convention. I’ve provided the code used to tidy ggplot2movies::movies as an example data fixture below:20\n\n\nshow/hide make-ggp2-movies.R\n# pkgs &lt;- c('ggplot2movies', 'tidyr', 'dplyr', 'stringr', 'purrr')\n# install.packages(pkgs, quiet = TRUE)\n\n# load packages --------------------\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(purrr)\n\nggp2movies &lt;- ggplot2movies::movies |&gt;\n  pivot_longer(c(Action:Short),\n    names_to = \"genre_key\",\n    values_to = \"genre_value\"\n  ) |&gt;\n  dplyr::mutate(genre_value = as.logical(genre_value)) |&gt;\n  dplyr::select(\n    title, genre_key, genre_value, length,\n    year, budget, avg_rating = rating, votes, mpaa\n  ) |&gt;\n  dplyr::filter(genre_value == TRUE) |&gt;\n  group_by(title) |&gt;\n  dplyr:::mutate(\n    genres = paste0(genre_key, collapse = \", \")\n  ) |&gt;\n  dplyr::select(\n    title, genres, length, year,\n    budget, avg_rating, votes, mpaa\n  ) |&gt;\n  dplyr::ungroup() |&gt;\n  dplyr::distinct(.keep_all = TRUE) |&gt;\n  dplyr::mutate(\n    genres = dplyr::na_if(x = genres, \"\"),\n    genres = factor(genres),\n    mpaa = dplyr::na_if(x = mpaa, y = \"\"),\n    mpaa = factor(mpaa,\n      levels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"),\n      labels = c(\"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\")\n    )\n  ) |&gt; \n  tidyr::drop_na()\n# save to tests/testthat/fixtures/\nsaveRDS(object = ggp2movies, file = \"tests/testthat/fixtures/ggp2_movies.rds\") \n\n\n\ntests/\n  └── testthat/\n      └── fixtures/\n1            ├── ggp2_movies.rds\n            └── make-ggp2-movies.R\n       \n3 directories, 2 files\n\n\n1\n\nThe code used to create the test data (make-ggp2-movies.R) is stored in the same location as the output it creates (i.e., ggp2_movies.rds):"
  },
  {
    "objectID": "tests.html#app-input-helpers",
    "href": "tests.html#app-input-helpers",
    "title": "Tests",
    "section": "App input helpers",
    "text": "App input helpers\nThe var_inputs() function below is a test fixture we can use to create inputs for the scatter_plot() utility function:\n\nvar_inputs &lt;- function() {\n  list(\n    y = \"audience_score\",\n    x = \"imdb_rating\",\n    z = \"mpaa_rating\",\n    alpha = 0.5,\n    size = 2,\n    plot_title = \"Enter plot title\"\n  )\n}\nvar_inputs()$x\n## [1] \"imdb_rating\"\n\nWe can also create a helper for the tidy ggplot2movies::movies data:\n\nggp2_inputs &lt;- function() {\n    list(\n      x = \"avg_rating\",\n      y = \"length\",\n      z = \"mpaa\",\n      alpha = 0.75,\n      size = 3,\n      plot_title = \"Enter plot title\"\n    )\n}\nggp2_inputs()$x\n## [1] \"avg_rating\"\n\nUsing a function to derive test inputs is especially helpful when testing module server function because we don’t need to change the way we refer to reactive inputs (as you’ll see below).\nFunctions like var_inputs() and ggp2_inputs() can be stored in tests/testthat/helper.R, which is automatically loaded with devtools::test():\n\ntests/\n  └── testthat/\n1      ├── fixtures/\n      │   ├── make-ggp2-movies.R\n      │   └── ggp2_movies.rds\n2      ├── helper.R\n3      └── test-scatter_plot.R\n\n\n1\n\nTest data script and .rds file\n\n\n2\n\nvar_inputs() and ggp2_inputs() functions\n\n\n3\n\nTest file\n\n\n\n\nThe next section demonstrates how to use test fixtures and helpers with testthat’s behavior-driven development functions (describe() and it()) and the contents of the traceability matrix."
  },
  {
    "objectID": "tests.html#shinytest2",
    "href": "tests.html#shinytest2",
    "title": "Tests",
    "section": "shinytest2",
    "text": "shinytest2"
  },
  {
    "objectID": "tests.html#covr",
    "href": "tests.html#covr",
    "title": "Tests",
    "section": "covr",
    "text": "covr"
  },
  {
    "objectID": "tests.html#covrpage",
    "href": "tests.html#covrpage",
    "title": "Tests",
    "section": "covrpage",
    "text": "covrpage"
  },
  {
    "objectID": "tests.html#waldo",
    "href": "tests.html#waldo",
    "title": "Tests",
    "section": "waldo",
    "text": "waldo\nIf you’d like a preview of a comparison before writing a formal test, you can pass the your observed and expected objects to waldo::compare()27\nFor example, suppose we have two objects: old and new\n\nold\n## # A tibble: 3 × 3\n##   chr     num fct  \n##   &lt;chr&gt; &lt;dbl&gt; &lt;ord&gt;\n## 1 B         1 L    \n## 2 C         2 M    \n## 3 D         3 H\n\n\nnew\n## # A tibble: 3 × 3\n##   CHR     num fct  \n##   &lt;chr&gt; &lt;int&gt; &lt;fct&gt;\n## 1 B         1 low  \n## 2 C         2 med  \n## 3 D         3 high\n\nThe outputs below are example outputs from waldo::compare():\n\n\n\ncompare(\n1  x = old,\n  y = old)\n## ✔ No differences\n\n\n1\n\nComparing identical objects\n\n\n\n\n\ncompare(\n1  x = old,\n  y = new)\n## `class(old)`: \"tbl_df\" \"tbl\" \"data.frame\"\n## `class(new)`:                \"data.frame\"\n## \n## `names(old)`: \"chr\" \"num\" \"fct\"\n## `names(new)`: \"CHR\" \"num\" \"fct\"\n## \n## `old$chr` is a character vector ('B', 'C', 'D')\n## `new$chr` is absent\n## \n## `old$num` is a double vector (1, 2, 3)\n## `new$num` is an integer vector (1, 2, 3)\n## \n## `class(old$fct)`: \"ordered\" \"factor\"\n## `class(new$fct)`:           \"factor\"\n## \n## `levels(old$fct)`: \"L\"   \"M\"   \"H\"   \n## `levels(new$fct)`: \"low\" \"med\" \"high\"\n## \n## `old$CHR` is absent\n## `new$CHR` is a character vector ('B', 'C', 'D')\n\n\n1\n\nComparing different objects\n\n\n\n\n\n\ncompare() displays the differences in classes, names, and any individual value differences."
  },
  {
    "objectID": "tests.html#diffobj",
    "href": "tests.html#diffobj",
    "title": "Tests",
    "section": "diffobj",
    "text": "diffobj\nIf you’re using Posit Workbench, the diffobj package has a colorful display for making comparisons in the IDE.\nThe differences can be displayed vertically with diffobj::diffObj():\n\n\n\ndiffObj(\n  old, \n  new)\n\n\n\n\n\nFigure 23.1: Viewer ouput from diffobj::diffObj()\n\n\n\n\n\nIf you want to view the structure (str()) differences, you can use diffobj::diffStr():\n\n\n\ndiffStr(\n  old, \n  new)\n\n\n\n\n\nFigure 23.2: Viewer ouput from diffobj::diffStr()\n\n\n\n\n\nAfter viewing the old vs new comparisons with waldo and diffobj, you should notice similarities and differences in the results from testthat28\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]\n\n── Failure (test-old_vs_new.R:17:3): old vs. new ───────────────────────────────\n`new` (`actual`) not equal to `old` (`expected`).\n\n`class(actual)`:   \"data.frame\"                   \n`class(expected)`: \"tbl_df\"     \"tbl\" \"data.frame\"\n\n`names(actual)`:   \"CHR\" \"num\" \"fct\"\n`names(expected)`: \"chr\" \"num\" \"fct\"\n\n`actual$CHR` is a character vector ('B', 'C', 'D')\n`expected$CHR` is absent\n\n`class(actual$fct)`:   \"factor\"          \n`class(expected$fct)`: \"ordered\" \"factor\"\n\n`levels(actual$fct)`:   \"low\" \"med\" \"high\"\n`levels(expected$fct)`: \"L\"   \"M\"   \"H\"   \n\n`actual$chr` is absent\n`expected$chr` is a character vector ('B', 'C', 'D')\n[ FAIL 1 | WARN 0 | SKIP 0 | PASS 0 ]"
  },
  {
    "objectID": "tests.html#footnotes",
    "href": "tests.html#footnotes",
    "title": "Tests",
    "section": "",
    "text": "The ‘Reactivity - An overview’ article gives an excellent description (and mental module) of reactive programming.↩︎\nRead more about behavior-driven development↩︎\nUnit tests are covered extensively in R Packages, 2ed and the testthat documentation↩︎\nshinytest2 has excellent documentation (and videos), and I highly recommend reading through those resources.↩︎\nMastering shiny dedicates an entire Chapter to Testing, which covers unit tests and testServer(), and also includes some tips for using JavaScript with shinytest (not to be confused with shinytest2)↩︎\nThe testServer() documentation is sparse, so I’ll provide a few tips and tricks I’ve learned for testing module server functions.↩︎\nUser Specifications are sometimes referred to as “user stories,” “use cases,” or “general requirements”↩︎\n“Feature requirements” and “functional requirements” are sometimes used interchangeably, but they refer to different aspects of the software. Feature requirements are the desired high-level characteristics the application should have, and often capture a collection of smaller functionalities (which are broken down into specific functional requirements).↩︎\nFunctional requirements are precise, measurable, and testable.↩︎\nWe briefly covered the Suggests field in Dependencies, but in this case it specifically applies to “packages that are not necessarily needed. This includes packages used only in examples, tests or vignettes…” - Writing R Extensions, Package Dependencies↩︎\nThe documentation on VignetteBuilder gives a great description of why knitr and rmarkdown below in Suggests, “Note that if, for example, a vignette has engine knitr::rmarkdown, then knitr provides the engine but both knitr and rmarkdown are needed for using it, so both these packages need to be in the VignetteBuilder field and at least suggested (as rmarkdown is only suggested by knitr, and hence not available automatically along with it).”↩︎\nWe covered the inst/ folder in the External Files chapter, and you might recall that docs/ was one of the folders we shouldn’t create inside inst/.↩︎\nWhen building tables in vignettes, I highly suggest using the Visual Markdown mode (especially when building tables).↩︎\nDocumenting the traceability matrix in vignettes are great for developers, but it’s also a good idea use an issue-tracking system with version control, like GitHub Projects or Azure DevOps.↩︎\nRead more about Test-driven development↩︎\nIdeally there is a file named for every function in the R/ folder, and a corresponding test file (with the test- prfix) in the tests/testthat/ folder]↩︎\nRead more about describe() and it() in the testthat documentation.↩︎\nEach it() block contains the expectations (or what you would traditionally include in test_that()).↩︎\nTest fixtures are described in-depth in R Packages, 2ed and in the testthat documentation↩︎\nCreating a tidied version of ggplot2movies::movies would be costly to re-create with every test, so it’s advised to store it as an static test fixture.↩︎\nSnapshot tests would be more appropriate for answering the question, ‘Is the plot visually correct?’.↩︎\nIf the data in tests/testthat/fixtures/ are going to be used repeatedly, it might also make sense to store it in inst/extdata/ or data-raw/.↩︎\nMastering Shiny covers creatng a snapshot file to test UI elements, but also notes this is probably not the best approach.↩︎\nIf you like verbose logging outputs, check out the logger package↩︎\nselected_vars are the reactive plot values returned from mod_var_input_server() we confirmed test-mod_var_input_server.R.↩︎\nWe’ll cover using browser() and the IDE’s debugger in a future chapter.↩︎\nBe mindful of the difference in arguments between expectation functions (i.e., expect_equal()) and waldo::compare()↩︎\nThe results from testthat don’t include the differences between old$num and new$num. This is due to the tolerance argument, which can be adjusted in both functions.↩︎"
  },
  {
    "objectID": "frameworks.html",
    "href": "frameworks.html",
    "title": "Frameworks",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\ngolem:\nleprechaun:\nrhino:\nend frameworks.qmd"
  },
  {
    "objectID": "golem.html#footnotes",
    "href": "golem.html#footnotes",
    "title": "golem",
    "section": "",
    "text": "If your shiny apps have modules, you’re (at least) an ‘intermediate’ developer.↩︎\nIf you’ve written a package and successfully shared it with others, you’re (at least) an ‘intermediate’ package developer.↩︎"
  },
  {
    "objectID": "leprechaun.html",
    "href": "leprechaun.html",
    "title": "leprechaun",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nleprechaun stuff\n\n\nCode\ninstall.packages(\"leprechaun\")\nlibrary(leprechaun)\n\n\nend leprechaun.qmd"
  },
  {
    "objectID": "rhino.html",
    "href": "rhino.html",
    "title": "rhino",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nrhino stuff\n\n\nCode\ninstall.packages(\"rhino\")\nlibrary(rhino)\n\n\nend rhino.qmd"
  },
  {
    "objectID": "special_topics.html",
    "href": "special_topics.html",
    "title": "Special topics",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nAll the other stuff…\nend special_topics.qmd"
  },
  {
    "objectID": "debugging.html#strategies",
    "href": "debugging.html#strategies",
    "title": "Debugging",
    "section": "Strategies",
    "text": "Strategies"
  },
  {
    "objectID": "debugging.html#debugging-modules",
    "href": "debugging.html#debugging-modules",
    "title": "Debugging",
    "section": "Debugging modules",
    "text": "Debugging modules"
  },
  {
    "objectID": "debugging.html#debugging-apps",
    "href": "debugging.html#debugging-apps",
    "title": "Debugging",
    "section": "Debugging apps",
    "text": "Debugging apps"
  },
  {
    "objectID": "css.html",
    "href": "css.html",
    "title": "CSS",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend css.qmd"
  },
  {
    "objectID": "js.html",
    "href": "js.html",
    "title": "JavaScript",
    "section": "",
    "text": "ALERT!\n\n\n\n\n\n\nThis section is currently under development. Thank you for your patience.\n\n\n\n\nend js.qmd"
  },
  {
    "objectID": "code_tools.html#styler-lintr",
    "href": "code_tools.html#styler-lintr",
    "title": "Code tools",
    "section": "styler & lintr",
    "text": "styler & lintr\nThe styler and lintr packages in R serve related but distinct purposes and have different focuses in their functionality. The primary difference between lintr and styler is that styler can automatically fix any stylistic issues it identifies in your code (rather than just reporting them).\nlintr: lintr is a static code analysis tool used to identify syntax errors, semantic issues, and violations of stylistic guidelines in your code. The package contains a list of ‘linters’ for various potential problems and can be customized according to your needs. lintr is designed to help improve your code’s quality and readability by generating reports in the ‘markers’ pane. Running lintr won’t automatically correct the identified issues (you’ll need to fix the linting issues it reports manually).\nstyler: On the other hand, the purpose of styler is to ensure consistency in the code formatting, which is crucial if you’re working in a team or contributing to open-source projects (like tidyverse packages). The styler package will change your code’s format according to specified style guidelines. These changes include indentation, spaces, and line breaks that adhere to your style guidelines.\nWhile there is some overlap (both packages can help enforce coding style guidelines), lintr is a more general tool for code quality, spotting potential issues and bugs. At the same time, styler focuses on code formatting and can automatically apply fixes. Many developers find combining both can help catch potential issues and ensure a consistent, readable coding style."
  },
  {
    "objectID": "code_tools.html#sinew",
    "href": "code_tools.html#sinew",
    "title": "Code tools",
    "section": "sinew",
    "text": "sinew\nThe sinew package also warrants mentioning because it can help ensure you’re namespacing functions from add-on packages.\nend code_tools.qmd"
  },
  {
    "objectID": "glossary.html#shiny-apps",
    "href": "glossary.html#shiny-apps",
    "title": "Appendix A — Glossary of terms",
    "section": "Shiny apps",
    "text": "Shiny apps\n\nUtility/helper functions\n\n\nExternal resources\n\n\nModule\n\n\nStandalone app function"
  },
  {
    "objectID": "glossary.html#packages",
    "href": "glossary.html#packages",
    "title": "Appendix A — Glossary of terms",
    "section": "Packages",
    "text": "Packages\n\nProject\nAny directory of R executable files with an RStudio/Posit workbench project file (.Rproj).\n\n\nPackage\nA directory of functions, documentation, and/or data can be installed and loaded into an R session. Packages include the necessary dependency management (NAMESPACE) and metadata files (DESCRIPTION) and has access to the package development tools in RStudio/Posit Workbench.\n\n\nApp-package\nAn app-package is a package containing a shiny application. App-packages have all of the functionality of a standard R package, but also contain the files and folders required to successfully develop, run, and deploy a shiny application."
  },
  {
    "objectID": "glossary.html#devtools",
    "href": "glossary.html#devtools",
    "title": "Appendix A — Glossary of terms",
    "section": "devtools",
    "text": "devtools\nend glossary.qmd"
  },
  {
    "objectID": "github.html#shinyappproj",
    "href": "github.html#shinyappproj",
    "title": "Appendix B — GitHub",
    "section": "shinyAppProj",
    "text": "shinyAppProj\nThe shinyAppProj repo is a shiny application built outside of a package structure. It was initially created using the New Project Wizard (with a Git repo initialized).\nIf you’re new to GitHub, the steps below will walk you through setting up Git and GitHub from RStudio using the Git pane. The initial files in the project are below:\nshinyAppProj/\n  ├── app.R\n  └── shinyAppProj.Rproj\n\n1 directory, 2 files\nAfter creating the project, head over to GitHub and create am empty repo. You’ll see the following options:\n\n\n\n\n\n\n(a) New repository on GitHub\n\n\nFigure B.1: Empty GitHub repository options\n\n\n\nWe’re interested in the second option, “…push an existing repository from the command line”, but we’re going to use Posit Workbench’s Git pane.\n\nCommit\nCommit these initial changes to the repo using the Commit icon in the Git pane\n\n\n\n\n\n(a) Commit changes\n\n\n\n\n\n(b) First commit\n\n\nFigure B.2: Click on Commit to open the Git window. Stage all the files, add a commit message, and click Commit\n\n\nAdd a commit message and click Commit. This is the equivalent of entering the following commands in the Terminal:\ngit commit -m 'first commit'\n\n\n\n\n\n\nCommit changes in your repository with a specific message\n\n\n\n\n\n\ngit commit -m 'first commit'\n\ngit commit: This command captures a snapshot of the changes in your project’s tracked files and directories. By committing, you’re saving the current state of those files in the Git repository.\n-m: This flag indicates that a commit message will be provided directly from the command line.\n'first commit': This is the commit message associated with this commit. Commit messages are useful for documenting the changes you’ve made, making it easier for others (and your future self) to understand the evolution and purpose of changes in the project.\n\nWhen you run git commit -m 'first commit', you are committing your staged changes (i.e., changes you’ve previously added to the staging area using git add) with the message ‘first commit’.\nThis message is then stored in the Git history, allowing anyone who looks at the commit logs to see a brief description of what was done in that particular commit.\n\n\n\n\nReview the output from the commit.\n\n\n\n\n\n(a) First commit output\n\n\nFigure B.3: The .gitignore, app.R, and shinyAppProj.Rproj files have been committed to main\n\n\nThis shows the contents of shinyAppProj are part of the main branch. Now we need to make sure the local branch has a remote (on GitHub at https://github.com/&lt;username&gt;/shinyAppProj.git).\n\n\n\n\n\n\nRename the currently checked-out branch to main\n\n\n\n\n\n\nThe command git branch -M main is used to rename the currently checked-out branch to main.\nHere’s a breakdown of the command:\n\ngit branch: This command without any arguments would list all the local branches in the current repository. But, with certain options (like -M), you can perform other branch-related operations.\n-M: This option stands for ‘move/rename’ and forcibly renames the branch. If a branch named main already exists, it will be overwritten because of the forceful nature of the -M option. If you want to avoid accidentally overwriting an existing branch, you could use -m (lowercase) instead. The lowercase -m will rename only if the target name doesn’t already exist.\nmain: This is the new name for the currently checked-out branch.\n\nThe command became more common after the industry started transitioning from using master to main as the default branch name for new repositories. Running git branch -M main is a way to rename the master branch to main in existing repositories.\n\n\n\n\n\n\nAdding remotes\nClick the New Branch icon in the Git pane and create a new main branch. Then click on Add Remote… and name the remote origin.\n\n\n\n\n\n(a) Add branch and remote name\n\n\n\n\n\n(b) Add remote URL\n\n\nFigure B.4: Create new main branch to track origin\n\n\nThe Remote URL is the link from the Quick Setup above. After clicking Add and Create, you’ll be asked to checkout or overwrite the existing main branch. In this case, we can select Overwrite (because we’re already on the main branch).\n\n\n\n\n\n\nAdd a new remote to your Git repository\n\n\n\n\n\n\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n\ngit remote: used to manage and set remotes (‘remote repositories’) for your project\nadd: specifies that you want to add a new remote.\norigin: a convention widely used in the Git community is to name the primary remote repository origin.\nhttps://github.com/&lt;username&gt;/&lt;repo&gt;.git: This is the URL to the Git repository (hosted on GitHub). Replace &lt;username&gt; with the GitHub username of the repository owner and &lt;repo&gt; with the name of the repository.\n\nSo, when you run this command, you’re telling Git: ‘I want to add a new remote called origin, and the URL for this remote is https://github.com/&lt;username&gt;/&lt;repo&gt;.git'.’\nAfter executing this command, you can then push to and pull from the repository using this remote by referring to its name (origin). For instance, git push origin master would push your local master branch to the master branch on the origin remote.\n\n\n\n\n\n\n\n\n\n(a) Overwrite main\n\n\n\n\n\n(b) branch main set up to track origin/main\n\n\nFigure B.5: main will now track the remote (origin)\n\n\n\n\n\n\n\n\nPush a local branch (main) to a remote (origin), and set local branch to track remote branch\n\n\n\n\n\n\ngit push -u origin main\n\ngit push: used to push commits from your local repository to a remote repository.\norigin: name of the remote repository you want to push to. When you clone a repo or add a remote using git remote add, it’s common to name the main remote origin (though it could technically be any name).\nmain: name of the branch you’re pushing to the remote repository.\n-u or --set-upstream: When this option is used, it sets a tracking relationship between the local and upstream remote branches. This means that in the future, using git pull or git push doesn’t require specifying the remote or branch (Git will know you’re referring to the origin/main branch).\n\nIn essence, git push -u origin main is saying: ‘Push my ’main’ branch to the ‘origin’ remote, and also set my local ‘main’ branch to track the ‘main’ branch on ‘origin’.\nThe common workflow for setting up Git from the command line is below:\n# make changes \ngit add .\ngit commit 'first commit'\n# set remote on GitHub\ngit remote add origin https://github.com/&lt;username&gt;/&lt;repo&gt;.git\n# rename the current branch to main\ngit branch -M main\n# push and set upstream to origin (remote)\ngit push -u origin main"
  },
  {
    "objectID": "create.html",
    "href": "create.html",
    "title": "Appendix C — Appendix: Creating packages in Posit Workbench",
    "section": "",
    "text": "“Can the .Rproj file convert an R project into an R package?”\nThe technical answer is no, because the .Rproj only activates the Build pane in the IDE. The tools in the Build pane are directly connected to the devtools package (hence the PackageUseDevtools: Yes in the .Rproj file).\nFor example, if the mandatory fields are added to the DESCRIPTION, but the .Rproj file doesn’t have any of the package configuration fields, then the Build pane will not be displayed:\n\n\n Mandatory DESCRIPTION fields with package configuration in .Rproj file\nFigure C.1: ?(caption)\n\n\nConversely, changing the Project build tools to Package will add the package development fields in the .Rproj file without having the mandatory fields in the DESCRIPTION will trigger the Build pane:\n\n\n\n\n\n\n(a) DESCRIPTION\n\n\nFigure C.2: Unchanged DESCRIPTION file after changing shinyAppProj.Rproj\n\n\n\nHowever, if we install devtools and try to load the code in the R/ folder with Build &gt; Load All, we will get the following error:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::load_all()\n\n\n\n\n\n\n(a) Build pane tools\n\n\nFigure C.3: Attempt to load_all() code in R/ folder\n\n\nThe image above demonstrates why setting the Project build tools in your Project Options is insufficient to convert a project into a package. The directory must include a DESCRIPTION file containing the mandatory fields and an .Rproj file with the package configuration fields listed above to be a functional R package.\nRead more about DESCRIPTION file fields in R Packages, 2ed\n\n\n\n\n\n\nRStudio project files\n\n\n\n\n\n\nYou can read more about the benefits of using RStudio projects to configuring project-level options here.\n\n\n\n\n\nTerminate\nTo get the IDE to re-read the .Rproj file, you can terminate the session (Session &gt; Terminate R… &gt; Yes)\n\n\n\n\n\n\n\n(a) Session &gt; Terminate\n\n\n\n\n\n\n\n(b) Click Yes\n\n\n\n\nFigure C.4: Terminate your R session"
  }
]