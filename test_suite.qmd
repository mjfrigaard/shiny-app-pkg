# Test suite {#sec-tests-suite}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(testthat)
library(withr)
library(logger)
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = "minimal",
  header = "Caution",
  contents = "This chapter is under review.",
  fold = FALSE
)
```

This chapter covers setting up the `testthat`’s infrastructure for unit tests and commonly used functions while writing tests. I'll also introduce an alternative approach to test development that combines the contents of our traceability matrix and behavior-driven development (BDD) to ensure the user's specifications are met (and the app's features are implemented correctly).

```{r}
#| label: co_box_tldr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", look = "minimal",
  header = "![](img/testthat.png){width='8%'} &emsp; TLDR",
  fold = TRUE,
  contents = "
  
#### `testthat`
  
**Workflow:**
  
- `use_testthat()`: setup testing infrastructure in your app-package\n
  
  - Include edition (i.e., `use_testthat(3)`)\n
  
- `use_test()`: creates new test files (with `test-` prefix)\n
  
  - Each file under `R/` should a corresponding `test-` file\n
  
- `test_active_file()`: runs tests in the current open test file\n
  
- `test_coverage_active_file()`: test coverage for the current open test file\n
  
**Behavior-driven development functions:**
  
- `describe()`: provides context (user specification or feature) for tests and test code\n

- `it()`: used to test functional requirement (i.e., expectation functions).\n
  
  "
)
```


## [`testthat`]{style="font-size: 1.05em;"} framework

`testthat` is the standard package for testing in R packages and one of the most widely used and supported packages on CRAN. Its widespread adoption is likely due to its ability to simplify the setup, creation, and execution of unit tests.

In our app-packages, we'll use `testthat` unit tests to ensure the underlying logic (i.e., non-reactive utility functions) behaves correctly. Combining Shiny's `testServer()` function and the `shinytest2` package with testthat provides a comprehensive testing suite for our app-package.


## [Set up with `use_testthat()`]{style="font-size: 0.95em;"}

The `testthat` package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it's the third):[^tests-testthat-edition]

[^tests-testthat-edition]: Read more about changes to the third edition to `testthat` in [R Packages, 2ed](https://r-pkgs.org/testing-basics.html#introducing-testthat)

```{r}
#| eval: false 
#| code-fold: false
usethis::use_testthat(3)
```

Setting up your testing infrastructure with `use_testthat()` does the following (`3` is the edition):

- [x]   In the `DESCRIPTION` file, `testthat (>= 3.0.0)` is listed under `Suggests`

- [x]   `Config/testthat/edition: 3` is also listed in the  `DESCRIPTION` to specify the `testthat` edition
    
- [x]   A new `tests/` folder is created, with a `testthat/` subfolder

- [x]   The `tests/testthat/testthat.R` file is created 

We now have a `tests/` folder to store our `testthat` tests.

```{bash}
#| eval: false
#| code-fold: false
tests/
  ├── testthat/
  └── testthat.R #<1>

2 directories, 1 file
```
1. Referred to as the 'test runner,' because it runs all our tests (do not edit this file).

## Creating unit tests

The standard workflow for writing `testthat` unit tests consists of the following:

- [x]   **New tests** are created with `usethis::use_test()`:

```{r}
#| eval: false
#| code-fold: false
usethis::use_test("scatter_plot") 
```
  -   `testthat` recommends having a corresponding test file in `tests/testthat/` (with the `test-` prefix) for the files in `R/`.

### [`test-`]{style="font-size: 0.95em;"} files

- [x]   **Test files**: the IDE will automatically create and open the new test file: 

```{verbatim}
#| eval: false
#| code-fold: false
✔ Writing 'tests/testthat/test-scatter_plot.R'
• Modify 'tests/testthat/test-scatter_plot.R'
```

### [`test_that()`]{style="font-size: 0.95em;"} tests 

- [x]   Each new test file contains a boilerplate `test_that()` **test**: 

```{r}
#| eval: false
#| code-fold: false 
test_that(desc = "multiplication works", code = { # <1>
 
})
```
1. `desc` is the test context (supplied in `"quotes"`), and `code` is the test code (supplied in `{curly brackets}`).

### [`expect_`]{style="font-size: 0.95em;"}ations 

- [x]   **Expectation** typically have two parts: an `observed` object, and an `expected` object:

```{r}
#| eval: false
#| code-fold: false 
#| collapse: true
expect_equal( # <1> 
  object = 2 * 2, # <2> 
  expected = 4 # <3> 
  ) 
```
1. A `testthat` expectation function  
2. The output or behavior being tested  
3. A predefined output or behavior    

  -   The `observed` object is an artifact of some code we've written, and it's being compared against an `expected` result.

### Running tests

- [x]   Another [`devtools`](development.qmd) habit to adopt is regularly writing and **running tests**. If you're using Posit Workbench and have `devtools` installed, you can test your app-package using the **Build** pane or the keyboard shortcut: [<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>]{style="font-size: 0.90em"}

:::{.column-margin}

![Run all tests](img/11_tests_build_pane_test.png){width='100%'}

:::

### Keyboard shortcuts 

R Packages, 2ed also [suggests](https://r-pkgs.org/testing-basics.html#run-tests) binding `test_active_file()` and `test_coverage_active_file()` to keyboard shortcuts. I **highly** recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.

::: {layout="[54, -1, 45]" layout-valign="bottom"}

#### `devtools` function

[`test()`]{style="font-weight: bold; font-size: 0.95em"}

#### Keyboard shortcut

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-size: 0.80em"}

:::

::: {layout="[54, -1, 45]" layout-valign="bottom"}

[`test_active_file()`]{style="font-weight: bold; font-size: 0.95em"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-size: 0.80em"} 

:::

::: {layout="[54, -1, 45]" layout-valign="bottom"}

[`test_coverage_active_file()`]{style="font-weight: bold; font-size: 0.95em"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd>]{style="font-weight: bold; font-size: 0.80em"} 

:::


When the test is run, we'll see feedback on whether it passes or fails (and occasionally some encouragement):

```{r}
#| eval: true
#| code-fold: false
#| echo: true 
#| collapse: true
test_that("multiplication works", { 
  expect_equal( 
    object = 2 * 2, 
    expected = 4 
    ) 
})
```

The section below introduces `testthat`'s BDD functions. 

## Behavior-driven development

In behavior-driven development (BDD) (or behavior-driven testing), users and developers work together to understand, define and express an application's behaviors using non-technical language.

> "*Using conversation and examples to specify how you expect a system to behave is a core part of BDD*" - [BDD in Action, 2ed](https://www.manning.com/books/bdd-in-action-second-edition)

By placing an emphasis on writing human-readable examples of an application's behavior, tests can be developed with a focus on executable specifications.[^tests-gherkin]

[^tests-gherkin]:  In a [BDD process](https://en.wikipedia.org/wiki/Behavior-driven_development), scenarios are written in [Gherkin](https://cucumber.io/docs/gherkin/reference/) and stored in a text file called a feature file.

### Test-driven vs. behavior-driven

In test-driven development, application for the `movies_app()` might look like the following:

1.  Gather requirements:
    a.  Develop an app to explore movie reviews from IMDB and Rotten Tomatoes. 
    b. Include a dropdown for displaying continuous variables (i.e., 'critics score' and 'audience score') and categorical variables (i.e., 'MPAA' ) in a scatter plot. 

2. Write Tests: 
    a. Using `testthat` and `testServer()`, ensure a scatter plot displays points for the relationship between a default set of continuous and categorical variables when the app launches. 

3. Run Tests: 
    a. Before writing any code, this test will fail. 
    
4. Develop Features: 
    a. Write the UI and server functions, including dropdowns and scatter plot output. 
    
5. Rerun Tests: 
    a. If the scatter plot has been implemented correctly, the test should pass. 
    
6. Write more Tests:  
    a. Add tests for specific functionalities, e.g., dropdowns or controls for point size and opacity. 

7. Continuous Integration (CI):  
    a. To ensure app reliability throughout development, incorporate all tests into a CI pipeline. 
    
Starting with a test and writing just enough code to pass the test often results in developing less (but better) code. One drawback to this approach is its strict focus on the function being tested and not the overall objective of the application.[^tests-tdd-bdd]

In BDD, implementing a feature requires users and developers to work together to define scenarios focused on the expected *behavior* of the feature from a user's perspective. 

Below is an example scenario for the scatter plot in `movies_app()`:

```{verbatim}
#| eval: false 
#| code-fold: false
Feature: Movie Review Data Exploration App
  
  As a film data analyst
  I want to explore movie review data from IMDB and Rotten Tomatoes
  So that I can analyze relationships between movie reivew metrics 
  
  Background:
    Given I have launched the Movie Reviews Data Visualization App
    And I have movie review data from IMDB and Rotten Tomatoes
    And the data contains continuous variables like '_scores' 
    And the data contains categorical variables like 'MPAA'

  Scenario: Initial App Launch
    Given I have launched the movie review exploration app,
    When I view the scatter plot,
    Then I should see points representing values for a default
         set of continuous and categorical columns.
```

As you can see, the feature above is written in plain language, so it's accessible to both developers and users (or other non-technical stakeholders).

[^tests-tdd-bdd]: For an excellent description on the relationships between behavior-driven development, test-driven development, and domain-driven design, I highly recommend [BDD in Action, 2ed](https://www.manning.com/books/bdd-in-action-second-edition) by John Ferguson Smart and Jan Molack.

### BDD and `testthat`

> "*Use `describe()` to verify that you implement the right things and use [`it()`] to ensure you do the things right.*" - `testthat` [documentation](https://testthat.r-lib.org/reference/describe.html)

`testthat`'s BDD functions (`describe()` and `it()`) allow us add scenarios to our test files, ensuring the application remains user-centric while meeting the technical specifications. [^tests-bdd-readmore]

[^tests-bdd-readmore]: Read more about [behavior-driven development](https://en.wikipedia.org/wiki/Behavior-driven_development)

#### [`describe()`]{style="font-size: 0.95em;"} a feature

We can use the language from our traceability matrix to write a feature and scenario, then include this in the `description` argument of `describe()`:

```{r}
#| eval: false 
#| code-fold: false
testthat::describe(
  description = 
  "Feature: Movie Review Data Exploration App
  
   As a film data analyst
   I want to explore movie review data from IMDB and Rotten Tomatoes
   So that I can analyze relationships between movie reivew metrics", code = {
  
})
```

We can also nest `describe()` calls, which means we can include the `Background` (or other relevant information): 

```{r}
#| eval: false 
#| code-fold: false
testthat::describe( # <1>
  "Feature: Movie Review Data Exploration App
  
   As a film data analyst
   I want to explore movie review data from IMDB and Rotten Tomatoes
   So that I can analyze relationships between movie reivew metrics", 
  code = { # <1>
    
  testthat::describe(# <2>
    "Background:
       Given I have launched the Movie Reviews Data Visualization App
       And I have movie review data from IMDB and Rotten Tomatoes
       And the data contains continuous variables like '_scores' 
       And the data contains categorical variables like 'MPAA'", 
    code = {   
               
      })       # <2>
    
  }) # <1>
```
1. BDD Feature (**title and description**)    
2. Background (preexisting conditions **before each scenario**)  

#### Confirm [`it()`]{style="font-size: 0.95em;"} with a test

Inside `describe()`, we can include multiple `it()` blocks which "*functions as a test and is evaluated in its own environment.*" 

In the example below, we'll use an `it()` block to test the example scenario from above:[^tests-it-blocks]

```{r}
#| eval: false 
#| code-fold: false
testthat::describe( # <1>
"Feature: Movie Review Data Exploration App

 As a film data analyst
 I want to explore movie review data from IMDB and Rotten Tomatoes
 So that I can analyze relationships between movie reivew metrics", 
  code = { # <1>
  
  testthat::describe(# <2>
    "Background:
       Given I have launched the Movie Reviews Data Visualization App
       And I have movie review data from IMDB and Rotten Tomatoes
       And the data contains continuous variables like '_scores' 
       And the data contains categorical variables like 'MPAA'", 
      code = { # <2>
      
    testthat::it( # <3>
    "Scenario: Initial App Launch
       Given I have launched the movie review exploration app,
       When I view the scatter plot,
       Then I should see points representing values for a default
            set of continuous and categorical columns.", # <3>
        code = { # <3>
          # test code # <4>
        }) # <3>
      
    }) # <2>
  
}) # <1>
```
1. BDD Feature (**title and description**)    
2. Background (preexisting conditions **before each scenario**) 
3. Scenario (a **concrete examples that illustrates a feature**)
4. Test code  

[^tests-it-blocks]: Each [`it()`](https://testthat.r-lib.org/reference/describe.html) block contains the expectations (or what you would traditionally include in `test_that()`).

In the scenario above, `Then` contains the information required for the `testthat` expectation. This could be `expect_snapshot_file()` or `vdiffr::expect_doppelganger()`--whichever makes sense from the user's perspective.

This is an generic example, but I hope it demonstrates the connection between the user specification, feature, scenario, and test. It also  allows us to fill in the **Test** column in the traceability matrix.

```{r}
#| label: co_box_bdd_trace_all
#| echo: false
#| code-fold: false
#| include: true
trace_matrix <- tibble::tibble(
  Specification = c(
    "US1"
  ),
  Features = c(
    "F1.1"
  ),
  Requirements = c(
    "FR 1.1"
  ),
  Test = c(
    "test-scatter_plot.R"
  ),
) 
trace_matrix |> 
  gt::gt(auto_align = TRUE) |> 
  gt::sub_missing(
  columns = gt::everything(),
  rows = gt::everything(),
  missing_text = "-"
)
```


The traceability matrix and `testthat`'s BDD functions make it possible to know what code needs to be tested (even before it's developed).[^tests-bdd-describe] 

[^tests-bdd-describe]: Read more about `describe()` and `it()` in the [`testthat` documentation.](https://testthat.r-lib.org/reference/describe.html) and in the [appendix.](bdd.qmd)

## Recap

Hopefully the example tests in the upcoming chapters convey how helpful and expressive the BDD functions can be (or they inspire you to properly implement what I'm attempting to do in your own app-packages).

In the next chapter, we're going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to reduce code executed *outside* of your tests (i.e., placed above the call to `test_that()` or `it()`).[^tests-self-sufficient]

[^tests-self-sufficient]: For more on this topic, consult the ['Self-sufficient tests'](https://r-pkgs.org/testing-design.html#self-sufficient-tests) section in [R Packages, 2ed](https://r-pkgs.org/)

```{r}
#| label: co_box_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", 
  look = "minimal", 
  size = "0.95", hsize = "1.10",
  header = "RECAP &emsp; ![](img/testthat.png){width='8%'}",
  fold = FALSE,
  contents = "
  
###### `testthat` setup
  
- `use_testthat()`: sets up testing infrastructure in your app-package\n
  
###### Test files
  
- `use_test()`: creates new test files (with `test-` prefix). The test file names should *generally* match the file names be below` R/`.\n
  
###### Running tests
  
- `test_active_file()`: runs tests in the current open test file\n
  
- `test_coverage_active_file()`: test coverage for the current open test file\n
  
###### Behavior-driven development functions:
  
- `describe()`: *'specifies a larger component or function and contains a set of specifications'*. Include feature descriptions and any relevant background information the `describe()` blocks\n

- `it()`: contains the test code or expectations. These are use to test each functional requirement (or `Then` statements from scenarios).\n
  
- Use the traceability matrix to track the user specifications, features, functional requirements, and tests. 
  
  "
)
```



