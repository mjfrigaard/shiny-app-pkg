# Test suite {#sec-tests-suite}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(testthat)
library(withr)
library(logger)
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = "minimal",
  header = "Caution",
  contents = "This section is still being developed--it's contents are subject to change.",
  fold = FALSE
)
```

This chapter covers setting up the `testthat`'s infrastructure for unit tests and commonly used functions while writing tests. I'll also introduce an alternative approach to test development that combines the contents of our traceability matrix and behavior-driven development (BDD) with a traceability matrix to ensure the user's specifications are met (and the app's features are implemented correctly).

```{r}
#| label: co_box_tldr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", look = "minimal",
  header = "![](img/testthat.png){width='8%'} &emsp; TLDR",
  fold = TRUE,
  contents = "
  
#### `testthat`
  
**Workflow:**
  
- `use_testthat()`: setup testing infrastructure in your app-package\n
  
  - Include edition (i.e., `use_testthat(3)`)\n
  
- `use_test()`: creates new test files (with `test-` prefix)\n
  
  - Each file under `R/` should a corresponding `test-` file\n
  
- `test_active_file()`: runs tests in the current open test file\n
  
- `test_coverage_active_file()`: test coverage for the current open test file\n
  
**Behavior-driven development functions:**
  
- `describe()`: provides context (user specification or feature) for tests and test code\n

- `it()`: used to test functional requirement (i.e., expectation functions).\n
  
  "
)
```


## [`testthat`]{style="font-size: 1.05em;"} framework

```{r}
#| label: git_box_10a_tests-specs
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  fig_pw = '65%', 
  branch = "10a_tests-specs", 
  repo = 'shinyAppPkg')
```

`testthat` is the standard package for testing in R packages and one of the most widely used and supported packages on CRAN. Its widespread adoption is likely due to its ability to simplify the setup, creation, and execution of unit tests.

In our app-packages, we'll use `testthat` unit tests to ensure the underlying logic (i.e., non-reactive utility functions) behaves correctly. Combining Shiny's `testServer()` function and the `shinytest2` package with testthat provides a comprehensive testing suite for our app-package.


## [Set up with `use_testthat()`]{style="font-size: 0.95em;"}

The `testthat` package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it's the third):[^tests-testthat-edition]

[^tests-testthat-edition]: Read more about changes to the third edition to `testthat` in [R Packages, 2ed](https://r-pkgs.org/testing-basics.html#introducing-testthat)

```{r}
#| eval: false 
#| code-fold: false
usethis::use_testthat(3)
```

Setting up your testing infrastructure with `use_testthat()` does the following (`3` is the edition):

- [x]   In the `DESCRIPTION` file, `testthat (>= 3.0.0)` is listed under `Suggests`

- [x]   `Config/testthat/edition: 3` is also listed in the  `DESCRIPTION` to specify the `testthat` edition
    
- [x]   A new `tests/` folder is created, with a `testthat/` subfolder

- [x]   The `tests/testthat/testthat.R` file is created 

We now have a `tests/` folder to store our `testthat` tests.

```{bash}
#| eval: false
#| code-fold: false
tests/
  ├── testthat/
  └── testthat.R #<1>

2 directories, 1 file
```
1. Referred to as the 'test runner,' because it runs all our tests (do not edit this file).

## Creating unit tests

The standard workflow for writing `testthat` unit tests consists of the following:

- [x]   **New tests** are created with `usethis::use_test()`:

```{r}
#| eval: false
#| code-fold: false
usethis::use_test("scatter_plot") 
```
  -   `testthat` recommends having a corresponding test file in `tests/testthat/` (with the `test-` prefix) for the files in `R/`.

### [`test-`]{style="font-size: 0.95em;"} files

- [x]   **Test files**: the IDE will automatically create and open the new test file: 

```{verbatim}
#| eval: false
#| code-fold: false
✔ Writing 'tests/testthat/test-scatter_plot.R'
• Modify 'tests/testthat/test-scatter_plot.R'
```

### [`test_that()`]{style="font-size: 0.95em;"} tests 

- [x]   Each new test file contains a boilerplate `test_that()` **test**: 

```{r}
#| eval: false
#| code-fold: false 
test_that(desc = "multiplication works", code = { # <1>
 
})
```
1. `desc` is the test context (supplied in `"quotes"`), and `code` is the test code (supplied in `{curly brackets}`).

### [`expect_`]{style="font-size: 0.95em;"}ations 

- [x]   **Expectation** typically have two parts: an `observed` object, and an `expected` object:

```{r}
#| eval: false
#| code-fold: false 
#| collapse: true
expect_equal( # <1> 
  object = 2 * 2, # <2> 
  expected = 4 # <3> 
  ) 
```
1. A `testthat` expectation function  
2. The output or behavior being tested  
3. A predefined output or behavior    

  -   The `observed` object is an artifact of some code we've written, and it's being compared against an `expected` result.

### Running tests

- [x]   Another [`devtools`](development.qmd) habit to adopt is regularly writing and **running tests**. If you're using Posit Workbench and have `devtools` installed, you can test your app-package using the **Build** pane or the keyboard shortcut: [<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>]{style="font-size: 0.90em"}

:::{.column-margin}

![Run all tests](img/11_tests_build_pane_test.png){width='100%'}

:::

### Keyboard shortcuts 

R Packages, 2ed also [suggests](https://r-pkgs.org/testing-basics.html#run-tests) binding `test_active_file()` and `test_coverage_active_file()` to keyboard shortcuts. I **highly** recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.

::: {layout="[54, -1, 45]" layout-valign="bottom"}

#### `devtools` function

[`test()`]{style="font-weight: bold; font-size: 0.95em"}

#### Keyboard shortcut

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-size: 0.80em"}

:::

::: {layout="[54, -1, 45]" layout-valign="bottom"}

[`test_active_file()`]{style="font-weight: bold; font-size: 0.95em"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-size: 0.80em"} 

:::

::: {layout="[54, -1, 45]" layout-valign="bottom"}

[`test_coverage_active_file()`]{style="font-weight: bold; font-size: 0.95em"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd>]{style="font-weight: bold; font-size: 0.80em"} 

:::


When the test is run, we'll see feedback on whether it passes or fails (and occasionally some encouragement):

```{r}
#| eval: true
#| code-fold: false
#| echo: true 
#| collapse: true
test_that("multiplication works", { 
  expect_equal( 
    object = 2 * 2, 
    expected = 4 
    ) 
})
```

The section below introduces `testthat`'s BDD functions. 

## Behavior-driven development

> "*Use `describe()` to verify that you implement the right things and use [`it()`] to ensure you do the things right.*" - `testthat` [documentation](https://testthat.r-lib.org/reference/describe.html)

Behavior-driven development (BDD) (or behavior-driven testing) emphasizes writing human-readable descriptions of the application's behavior, which are then converted into a series of tests. BDD recommends collaboration between users and developers to understand, define and express an application's behaviors using specific language:[^tests-gherkin]

```{bash}
#| eval: false 
#| code-fold: false 
Feature: # <1>
  # <1>
  Background: # <2>
    Given # <3> 
    
  Scenario: # <4>
    When # <5>
    And # <6> 
    Then # <7>
```
1. **High-level description** (title and description)  
2. Steps in the background 
3. Used to **describe the initial context** of the app    
4. A **concrete example that illustrates a business rule** 
5. Used to **describe an event, or an action**  
6. Combine events/actions   
7. Used to **verify an outcome that is observable for the user**  

Following these conventions will convert the specifications into testable requirements that prescribe how the application **should behave** and confirm that the delivered application **behaves as it should**.

We can apply BDD by combining the contents of a traceability matrix with `testthat`'s `describe()` and `it()` functions.

[^tests-gherkin]: In BDD, user stories are written in the [Gherkin syntax.](https://cucumber.io/docs/gherkin/reference/)

<!--

```{verbatim}
Feature: Scatter Plot Data Visualization of Movie Reviews

  As a movie enthusiast
  I want to visualize movie reviews on a scatter plot with various inputs
  So that I can analyze relationships between ratings and other movie attributes from IMDB and Rotten Tomatoes.

  Background:
    Given I have launched the Scatter Plot Data Visualization App
    And I have a dataset of movie reviews from IMDB and Rotten Tomatoes
    And the dataset contains continuous variables like "IMDB_Rating" and "RottenTomatoes_Rating"
    And the dataset has categorical variables like "genre" and "mpaa"
    
  Scenario: IMDB/Rotten Tomatoes data source
    When I launched the Scatter Plot Data Visualization
    Then column with the links to the original data source URLs for both IMDB 
      and Rotten Tomatoes should be verified.
  
  Scenario: Select x and y continuous variables for plotting
    When I select the variable "IMDB_Rating" for the x-axis
    And I select the variable "RottenTomatoes_Rating" for the y-axis
    Then the scatter plot should show "IMDB_Rating" on the x-axis
    And "RottenTomatoes_Rating" on the y-axis
  
  Scenario: Change color based on a categorical variable
    Given I have plotted "IMDB_Rating" on the x-axis and "RottenTomatoes_Rating" on the y-axis
    When I choose the categorical variable "Genre" for coloring
    Then the points on the scatter plot should be colored based on the movie genres
  
  Scenario: Adjust point size
    Given I have created a scatter plot with chosen variables
    When I adjust the point size to "10"
    Then the points on the scatter plot should appear with the specified size
  
  Scenario: Modify point opacity
    Given I have created a scatter plot with chosen variables
    When I set the point opacity to "0.5"
    Then the points on the scatter plot should appear with 50% opacity
  
  Scenario: Add an optional plot title
    Given I have created a scatter plot with chosen variables
    When I enter "Movie Rating Comparison" into the plot title input field
    Then the scatter plot should display the title "Movie Rating Comparison"
  
  Scenario: Remove the optional plot title
    Given the scatter plot is displaying the title "Movie Rating Comparison"
    When I clear the plot title input field
    Then the scatter plot should not display any title
  
  Scenario: Interacting with multiple inputs simultaneously
    Given the Shiny app is in its initial state
    When I select "IMDB_Rating" for the x-axis
    And I select "RottenTomatoes_Rating" for the y-axis
    And I choose "Genre" for coloring
    And I adjust the point size to "10"
    And I set the point opacity to "0.5"
    And I enter "Movie Rating Comparison" into the plot title input field
    Then the scatter plot should show "IMDB_Rating" on the x-axis
    And "RottenTomatoes_Rating" on the y-axis
    And points should be colored based on movie genres
    And the points should appear with the specified size
    And the points should appear with 50% opacity
    And the title "Movie Rating Comparison" should be displayed
```
-->

### [`describe()`]{style="font-size: 0.95em;"} a feature

The `testthat::describe()` function '*specifies a larger component or function and contains a set of specifications.*'

In `describe()`, we can use the language from our traceability matrix to reference the specification I'm testing in the `description` argument (**US1**):

```{r}
#| eval: false 
#| code-fold: false
testthat::describe(
  description = "US1: Shiny App Scatter Plot Data Visualization for Movie Review Explorer", code = {
  
})
```

We can also nest `describe()` functions, which means we can include the feature that follows the specification in the traceability matrix: 

```{r}
#| eval: false 
#| code-fold: false
testthat::describe( # <1>
  "US1: Shiny App Scatter Plot Data Visualization for 
   Movie Review Explorer", 
  code = { # <1>
    
  testthat::describe(# <2>
    "F1.1: IMDB and Rotten Tomatoes data with continuous 
    (i.e., scores) and categorical (i.e., mpaa) variables", 
    code = {   
               
      })       # <2>
    
  }) # <1>
```
1. User specification     
2. Feature     

### Confirm [`it()`]{style="font-size: 0.95em;"} with a test

Inside `describe()`, we can include multiple `it()` blocks which "*functions as a test and is evaluated in its own environment.*" 

In the example below, we'll use an `it()` block to test the first functional requirement:[^tests-it-blocks]

```{r}
#| eval: false 
#| code-fold: false
testthat::describe( # <1>
  "US1: Shiny App Scatter Plot Data Visualization for
   Movie Review Explorer", code = { # <1>
  
  testthat::describe(# <2>
    "F1.1: IMDB and Rotten Tomatoes data with continuous
    (i.e., scores) and categorical (i.e., mpaa) variables", 
    code = { # <2>
      
    testthat::it( # <3>
    "Test 1
      
     Scenario: IMDB/Rotten Tomatoes data source
        When I launched the scatter plot data visualization app
        Then a column with links to the original source URLs for
          both IMDB and Rotten Tomatoes should be verified.", # <3>
        code = { # <3>
          # test code # <4>
        }) # <3>
      
    }) # <2>
  
}) # <1>
```
1. User specification   
2. Feature   
3. Functional requirement/test scope  
4. Test code  

[^tests-it-blocks]: Each [`it()`](https://testthat.r-lib.org/reference/describe.html) block contains the expectations (or what you would traditionally include in `test_that()`).

This is a simplified example, but it demonstrates how connecting the user specifications to the functional requirements and tests allows us to fill in the **Test** column in the traceability matrix.

<!--
```{r}
#| eval: false
#| include: false  
#| code-fold: false
testthat::describe("US1: scatter plot data visualization", # <1>
  code = {
    testthat::describe("FE1: interactive scatter plot (two data sources, drop-down variable options)", # <2>
      code = {
        
      testthat::describe("FR1: data source", code = { # <3>
        testthat::it("T1: data source", # <4>
          code = { # <5>
            # test code # <5>
          }) # <4>
      }) # <3>

      testthat::describe("FR2: user-input updating", code = { # <6>
        testthat::it("T2: user-input updating", code = { # <7>
          # test code # <8>
        }) # <7>
      }) # <6>

      testthat::describe("FR3: color-coded data points", code = { # <9>
        testthat::it("T3: color-coded data points", code = { # <10>
          # test code # <11>
        }) # <10>
      }) # <9>

      testthat::describe("FR4: plot axis, legend & title", code = { # <12>
        testthat::it("T4: plot axis, legend & title", code = { # <13>
          # test code # <14>
        }) # <13>
      }) # <12>
        
    }) # <2>
    
}) # <1>
```
1. User specification scope (**US1**)  
2. Feature scope (**FE1**)  
3. Functional requirement scope (**FR1**)  
4. Test scope (**T1**)   
5. Test code (**T1**)     
6. Functional requirement scope (**FR2**)   
7. Test scope (**T2**)  
8. Test code (**T2**)  
9. Functional requirement scope (**FR3**)  
10. Test scope (**T3**)  
11. Test code (**T3**)  
12. Functional requirement scope (**FR4**)  
13. Test scope (**T4**)  
14. Test code (**T4**) 

-->

```{r}
#| label: co_box_bdd_trace_all
#| echo: false
#| code-fold: false
#| include: true
trace_matrix <- tibble::tibble(
  Specification = c(
    "US1: Shiny App Scatter Plot Data Visualization for Movie Review Explorer"
  ),
  Features = c(
    "F1.1: IMDB and Rotten Tomatoes data with continuous (i.e., scores) and categorical (i.e., mpaa) variables."
  ),
  Requirements = c(
    "FR 1.1: The app should display movie review data from IMDB and Rotten Tomatoes (accessed from appropriate APIs or data connectors) containing both continuous and categorical variables stored in a tabular format."
  ),
  Test = c(
    "T1"
  ),
) 
trace_matrix |> 
  gt::gt(auto_align = TRUE) |> 
  gt::sub_missing(
  columns = gt::everything(),
  rows = gt::everything(),
  missing_text = "-"
)
```


The traceability matrix and `testthat`'s BDD functions make it possible to know what code needs to be tested (even before it's developed).[^tests-bdd-describe] 

[^tests-bdd-describe]: Read more about `describe()` and `it()` in the [`testthat` documentation.](https://testthat.r-lib.org/reference/describe.html) and in the [appendix.](bdd.qmd)

## Recap

Hopefully the tests in the upcoming chapters convey how versatile and expressive the BDD functions can be (or they inspire you to properly implement what I'm attempting to do in your own app-packages).

```{r}
#| label: co_box_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", 
  look = "minimal", 
  size = "0.95", hsize = "1.10",
  header = "RECAP &emsp; ![](img/testthat.png){width='8%'}",
  fold = FALSE,
  contents = "
  
###### `testthat` setup
  
- `use_testthat()`: sets up testing infrastructure in your app-package\n
  
###### Test files
  
- `use_test()`: creates new test files (with `test-` prefix). The test file names should *generally* match the file names be below` R/`.\n
  
###### Running tests
  
- `test_active_file()`: runs tests in the current open test file\n
  
- `test_coverage_active_file()`: test coverage for the current open test file\n
  
###### Behavior-driven development functions:
  
- `describe()`: *'specifies a larger component or function and contains a set of specifications'*. Include user specifications and features in each `describe()` block\n

- `it()`: contains the test code and expectations. These are use to test each functional requirement.\n
  
- Use the traceability matrix to track the user specifications, features, functional requirements, and tests. 
  
  "
)
```

In the next chapter, we're going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to reduce code executed *outside* of your tests (i.e., placed above the call to `test_that()` or `it()`).[^tests-self-sufficient]

[^tests-self-sufficient]: For more on this topic, consult the ['Self-sufficient tests'](https://r-pkgs.org/testing-design.html#self-sufficient-tests) section in [R Packages, 2ed](https://r-pkgs.org/)

