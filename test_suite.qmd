# Test suite {#sec-tests-suite}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(testthat)
library(withr)
library(logger)
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = "minimal",
  header = "Caution",
  contents = "This section is still being developed--it's contents are subject to change.",
  fold = FALSE
)
```

This chapter covers setting up the `testthat` infrastructure for unit tests, as well as an alternative approach to developing tests in your app-package. 

I'll introduce some commonly used `testthat` functions and how to combine behavior-driven development (BDD) with a traceability matrix to ensure the user's needs are met (and the app's features are implemented correctly).

```{r}
#| label: co_box_tldr
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", look = "minimal",
  header = "![](img/testthat.png){width='8%'} &emsp; TLDR",
  fold = TRUE,
  contents = "
  
#### `testthat`
  
**Workflow:**
  
- `use_testthat()`: setup testing infrastructure in your app-package\n
  
  - Include edition (i.e., `use_testthat(3)`)\n
  
- `use_test()`: creates new test files (with `test-` prefix)\n
  
  - Each file under `R/` should a corresponding `test-` file\n
  
- `test_active_file()`: runs tests in the current open test file\n
  
- `test_coverage_active_file()`: test coverage for the current open test file\n
  
**Behavior-driven development functions:**
  
- `describe()`: provides context (user specification or feature) for tests and test code\n

- `it()`: used to test functional requirement (i.e., expectation functions).\n
  
  "
)
```


## [`testthat`]{style="font-size: 1.05em;"} framework

```{r}
#| label: git_box_10a_tests-specs
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  fig_pw = '65%', 
  branch = "10a_tests-specs", 
  repo = 'shinyAppPkg')
```

`testthat` is the standard package for testing in R packages, and it's one of the most widely used and supported packages on CRAN. `testthat` simplifies setting up the testing suite and creating and running tests. 

In app-packages, we'll use `testthat` unit tests to ensure the underlying logic (i.e., non-reactive utility functions) behave correctly. Combining Shiny's `testServer()` function and the  `shinytest2` package with `testthat` provides a comprehensive testing suite for our app-package.


## [Set up with `use_testthat()`]{style="font-size: 0.95em;"}

The `testthat` package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it's the third):[^tests-testthat-edition]

[^tests-testthat-edition]: Read more about changes to the third edition to `testthat` in [R Packages, 2ed](https://r-pkgs.org/testing-basics.html#introducing-testthat)

```{r}
#| eval: false 
#| code-fold: false
usethis::use_testthat(3)
```

Setting up your testing infrastructure with  does the following (`3` is the edition):

- [x]   In the `DESCRIPTION` file, `testthat (>= 3.0.0)` is listed under `Suggests`

- [x]   `Config/testthat/edition: 3` is also listed in the  `DESCRIPTION` to specify the `testthat` edition
    
- [x]   A new `tests/` folder is created, with a `testthat/` subfolder

- [x]   The `tests/testthat/testthat.R` file is created 

We now have a `tests/` folder to store our `testthat` tests.

```{bash}
#| eval: false
#| code-fold: false
tests/
  ├── testthat/
  └── testthat.R #<1>

2 directories, 1 file
```
1. Referred to as the 'test runner,' because it runs all our tests (do not edit this file).

## Creating unit tests

The standard workflow for writing `testthat` unit tests consists of the following:

- [x]   New tests are created with `usethis::use_test()`.

```{r}
#| eval: false
#| code-fold: false
usethis::use_test("scatter_plot") # <1>
```
1. In standard R packages, there is a file named for every function in the `R/` folder, and a corresponding test file (with the `test-` prefix) in the `tests/testthat/` folder

### [`test-`]{style="font-size: 0.95em;"} files

- [x]   **Test files**: the IDE will automatically create and open the new test file: 

```{verbatim}
#| eval: false
#| code-fold: false
✔ Writing 'tests/testthat/test-scatter_plot.R'
• Modify 'tests/testthat/test-scatter_plot.R'
```

### [`test_that()`]{style="font-size: 0.95em;"} tests 

- [x]   **Tests**: Each new test file contains a boilerplate `test_that()` test 

```{r}
#| eval: false
#| code-fold: false 
test_that(desc = "multiplication works", code = { # <1>
 
})
```
1. `desc` is the test context (supplied in `"quotes"`), and `code` is the test code (supplied in `{curly brackets}`).

## [`expect_`]{style="font-size: 0.95em;"}ations 

- [x]   **Expectations**: most expectation have two parts: an `observed` object, and an `expected` object. The `observed` object is an artifact of some code you've written, and it's being compared against an `expected` result.

```{r}
#| eval: false
#| code-fold: false 
#| collapse: true
expect_equal( # <1> 
  object = 2 * 2, # <2> 
  expected = 4 # <3> 
  ) 
```
1. A `testthat` expectation function  
2. The output or behavior being tested  
3. A predefined output or behavior    

### Running tests

- [x]   **Running tests**: Another `devtools` habit to adopt is regularly writing and running tests. If you're using Posit Workbench and have `devtools` installed, you can test your app-package using the **Build** pane or the keyboard shortcut: [<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>]{style="font-size: 0.90em"}

:::{.column-margin}

![Run all tests](img/11_tests_build_pane_test.png){width='100%'}

:::

### Keyboard shortcuts 

R Packages, 2ed also [suggests](https://r-pkgs.org/testing-basics.html#run-tests) binding `test_active_file()` and `test_coverage_active_file()` to keyboard shortcuts. I **highly** recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.

::: {layout="[60, -1, 39]" layout-valign="bottom"}

#### Function

[`devtools::test()`]{style="font-weight: bold; font-size: 0.90em"}

#### Shortcut

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-size: 0.80em"}

:::

::: {layout="[60, -1, 39]" layout-valign="bottom"}

[`devtools::test_active_file()`]{style="font-weight: bold; font-size: 0.90em"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-size: 0.80em"} 

:::

::: {layout="[60, -1, 39]" layout-valign="bottom"}

[`devtools::test_coverage_active_file()`]{style="font-weight: bold; font-size: 0.90em"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd>]{style="font-weight: bold; font-size: 0.80em"} 

:::


When the test is run, you'll see feedback on whether it passes or fails (and occasionally some encouragement):

```{r}
#| eval: true
#| code-fold: false
#| echo: true 
#| collapse: true
test_that("multiplication works", { 
  expect_equal( 
    object = 2 * 2, 
    expected = 4 
    ) 
})
```

In the sections below, I'll introduce several example tests using `testthat`'s BDD functions. Hopefully the following sections convey how versatile and expressive these functions can be (or they inspire you to properly implement what I'm attempting to do in your own app-packages).



## Behavior-driven development

> "*Use `describe()` to verify that you implement the right things and use [`it()`] to ensure you do the things right.*" - `testthat` [documentation](https://testthat.r-lib.org/reference/describe.html)

Behavior-driven development (BDD) (or behavior-driven testing) emphasizes writing human-readable descriptions of the application's behavior, which are then converted into a series of tests. 

We can apply BDD is easier by combining the contents of our traceability matrix with `testthat`'s `describe()` and `it()` functions.

### [`describe()`]{style="font-size: 0.95em;"} a feature

The `testthat::describe()` function follows a BDD format and '*specifies a larger component or function and contains a set of specifications.*'

In `describe()`, we can use the language from our traceability matrix to reference the specification I'm testing in the `description` argument (**US1**):

```{r}
#| eval: false 
#| code-fold: false
testthat::describe(
  description = "US1: scatter plot data visualization", code = {
  
})
```

We can also nest `describe()` functions, which means we can include the feature that follows the specification in the traceability matrix: 

```{r}
#| eval: false 
#| code-fold: false
testthat::describe("US1: scatter plot data visualization", # <1>
  code = { # <1>
    
  testthat::describe(# <2>
    "FE1: interactive scatter plot (two data sources, drop-down variable options)", # <2>
    code = {   # <2>
               # <2>
      })       # <2>
    
  }) # <1>
```
1. User specification     
2. Feature     

### Confirm [`it()`]{style="font-size: 0.95em;"} with a test

Inside `describe()`, we can include multiple `it()` blocks which "*functions as a test and is evaluated in its own environment.*" 

In the example below, we'll use an `it()` block to test the first functional requirement:[^tests-it-blocks]

```{r}
#| eval: false 
#| code-fold: false
testthat::describe("US1: scatter plot data visualization", code = { # <1>
  
  testthat::describe(# <2>
    "FE1: interactive scatter plot (two data sources, drop-down variable options)", # <2>
    code = { # <2>
      
      testthat::it("T1: test data source", # <3>
        code = { # <3>
          # test code # <4>
        }) # <3>
      
    }) # <2>
  
}) # <1>
```
1. User specification   
2. Feature   
3. Functional requirement/test scope  
4. Test code  

[^tests-it-blocks]: Each [`it()`](https://testthat.r-lib.org/reference/describe.html) block contains the expectations (or what you would traditionally include in `test_that()`).

If we've built a traceability matrix, we can use `describe()` and `it()` to scope all the tests in our app-package:

```{r}
#| eval: false 
#| code-fold: false
testthat::describe("US1: scatter plot data visualization", # <1>
  code = {
    testthat::describe("FE1: interactive scatter plot (two data sources, drop-down variable options)", # <2>
      code = {
        
      testthat::describe("FR1: data source", code = { # <3>
        testthat::it("T1: data source", # <4>
          code = { # <5>
            # test code # <5>
          }) # <4>
      }) # <3>

      testthat::describe("FR2: user-input updating", code = { # <6>
        testthat::it("T2: user-input updating", code = { # <7>
          # test code # <8>
        }) # <7>
      }) # <6>

      testthat::describe("FR3: color-coded data points", code = { # <9>
        testthat::it("T3: color-coded data points", code = { # <10>
          # test code # <11>
        }) # <10>
      }) # <9>

      testthat::describe("FR4: plot axis, legend & title", code = { # <12>
        testthat::it("T4: plot axis, legend & title", code = { # <13>
          # test code # <14>
        }) # <13>
      }) # <12>
        
    }) # <2>
    
}) # <1>
```
1. User specification scope (**US1**)  
2. Feature scope (**FE1**)  
3. Functional requirement scope (**FR1**)  
4. Test scope (**T1**)   
5. Test code (**T1**)     
6. Functional requirement scope (**FR2**)   
7. Test scope (**T2**)  
8. Test code (**T2**)  
9. Functional requirement scope (**FR3**)  
10. Test scope (**T3**)  
11. Test code (**T3**)  
12. Functional requirement scope (**FR4**)  
13. Test scope (**T4**)  
14. Test code (**T4**) 


This is a simplified example, because it's unlikely we'd want all of our tests in a single test file.[^tests-testthat-special-files] But it demonstrates how linking the user specifications to the specific tests allows us to add a **Test** column in the traceability matrix.

[^tests-testthat-special-files]: Ideally each file under `R/` has a corresponding test file in the [`tests/testthat/` folder](https://testthat.r-lib.org/articles/special-files.html).

```{r}
#| label: co_box_bdd_trace_all
#| echo: false
#| code-fold: false
#| include: true
trace_matrix <- tibble::tibble(
  `User Specification` = c(
    "US1: scatter plot data visualization",
    NA_character_,
    NA_character_,
    NA_character_
  ),
  `Feature Requirement` = c(
    "FE1: interactive scatter plot (two data sources, drop-down variable options)",
    NA_character_,
    NA_character_,
    NA_character_
  ),
  `Functional Requirements` = c(
    "FR1: data source",
    "FR2: user-input updating",
    "FR3: color-coded data points",
    "FR4: plot axis, legend & title"
  ),
  Test = c(
    "T1", "T2", "T3", "T4"
  ),
) 
trace_matrix |> 
  gt::gt(auto_align = TRUE) |> 
  gt::sub_missing(
  columns = gt::everything(),
  rows = gt::everything(),
  missing_text = "-"
)
```


By providing context, the traceability matrix and `testthat`'s BDD functions make it possible to know what code needs to be tested (even before it's developed).[^tests-bdd-describe] 

[^tests-bdd-describe]: Read more about `describe()` and `it()` in the [`testthat` documentation.](https://testthat.r-lib.org/reference/describe.html) 
Test-driven development (TDD) involves writing tests before developing utility functions, modules, or a standalone app function.

## Recap



```{r}
#| label: co_box_recap
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "b", 
  look = "minimal", 
  size = "0.95", hsize = "1.10",
  header = "RECAP &emsp; ![](img/testthat.png){width='8%'}",
  fold = FALSE,
  contents = "
  
###### `testthat` setup
  
- `use_testthat()`: sets up testing infrastructure in your app-package\n
  
###### Test files
  
- `use_test()`: creates new test files (with `test-` prefix). The test file names should *generally* match the file names be below` R/`.\n
  
###### Running tests
  
- `test_active_file()`: runs tests in the current open test file\n
  
- `test_coverage_active_file()`: test coverage for the current open test file\n
  
###### Behavior-driven development functions:
  
- `describe()`: *'specifies a larger component or function and contains a set of specifications'*. Include user specifications and features in each `describe()` block\n

- `it()`: contains the test code and expectations. These are use to test each functional requirement.\n
  
- Use the traceability matrix to track the user specifications, features, functional requirements, and tests. 
  
  "
)
```

In the next chapter, we're going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to reduce code executed *outside* of your tests (i.e., placed above the call to `test_that()`).[^tests-self-sufficient]

[^tests-self-sufficient]: For more on this topic, consult the ['Self-sufficient tests'](https://r-pkgs.org/testing-design.html#self-sufficient-tests) section in [R Packages, 2ed](https://r-pkgs.org/)

