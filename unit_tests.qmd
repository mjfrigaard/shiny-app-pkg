# Unit tests {#sec-tests-unit}

```{r}
#| eval: true 
#| echo: false 
#| include: false
source("_common.R")
library(testthat)
library(withr)
library(logger)
```

```{r}
#| label: co_box_dev
#| echo: false
#| results: asis
#| eval: true
co_box(
  color = "o", look = "minimal",
  header = "Caution",
  contents = "This section is still being developed--it's contents are subject to change.",
  fold = FALSE
)
```

In the following sections, I'll introduce methods that align our tests with current best practices or principles,[^tests-testthat-best-practices] but know that multiple strategies exist for writing tests. For example, if you've adopted test-driven development (TDD),[^tests-tdd] you'll write tests before developing utility functions, modules, or a standalone app function.

Regardless of your testing strategy, the infrastructure for storing and running tests in app-packages is identical to a standard R package.


[^tests-testthat-best-practices]: Most of these are described in the ['High-level principles for testing'](https://r-pkgs.org/testing-design.html#sec-testing-design-principles) section of [R Packages, 2ed](https://r-pkgs.org/).

[^tests-tdd]: Read more about [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development) 

## [`testthat`]{style="font-size: 1.05em;"} framework

```{r}
#| label: git_box_08_tests-specs
#| echo: false
#| results: asis
#| eval: true
git_margin_box(
  fig_pw = '65%', 
  branch = "10a_tests-specs", 
  repo = 'shinyAppPkg')
```

The `testthat` package has been around for over a decade and thus has undergone various changes that require us to specify the edition we intend to use (currently, it's the third).[^tests-testthat-edition]

[^tests-testthat-edition]: Read more about changes to the third edition to `testthat` in [R Packages, 2ed](https://r-pkgs.org/testing-basics.html#introducing-testthat)

## [Set up with `use_testthat()`]{style="font-size: 0.95em;"}

Setting up your testing infrastructure with `usethis::use_testthat(3)` does the following (`3` is the edition):

- [x]   In the `DESCRIPTION` file, `testthat (>= 3.0.0)` is listed under `Suggests`

- [x]   `Config/testthat/edition: 3` is also listed in the  `DESCRIPTION` to specify the `testthat` edition
    
- [x]   A new `tests/` folder is created, with a `testthat/` subfolder

- [x]   The `tests/testthat/testthat.R` file is created 

We now have a `tests/` folder to store our `testthat` tests.

```{bash}
#| eval: false
#| code-fold: false
tests/
  ├── testthat/
  └── testthat.R #<1>

2 directories, 1 file
```
1. Referred to as the 'test runner,' because it runs all our tests (do not edit this file).

### Creating unit tests

The standard workflow for writing `testthat` unit tests consists of the following:

- [x]   New tests are created with `usethis::use_test()`.

```{r}
#| eval: false
#| code-fold: false
usethis::use_test("scatter_plot") # <1>
```
1. In standard R packages, there is a file named for every function in the `R/` folder, and a corresponding test file (with the `test-` prefix) in the `tests/testthat/` folder

#### [`test-`]{style="font-size: 0.95em;"} files

- [x]   **Test files**: the IDE will automatically create and open the new test file: 

```{verbatim}
#| eval: false
#| code-fold: false
✔ Writing 'tests/testthat/test-scatter_plot.R'
• Modify 'tests/testthat/test-scatter_plot.R'
```

#### [`test_that()`]{style="font-size: 0.95em;"} tests 

- [x]   **Tests**: Each new test file contains a boilerplate `test_that()` test 

```{r}
#| eval: false
#| code-fold: false 
test_that(desc = "multiplication works", code = { # <1>
 
})
```
1. `desc` is the test context (supplied in `"quotes"`), and `code` is the test code (supplied in `{curly brackets}`).

#### [`expect_`]{style="font-size: 0.95em;"}ations 

- [x]   **Expectations**: most expectation have two parts: an `observed` object, and an `expected` object. The `observed` object is an artifact of some code you've written, and it's being compared against an `expected` result.

```{r}
#| eval: false
#| code-fold: false 
#| collapse: true
expect_equal( # <1> 
  object = 2 * 2, # <2> 
  expected = 4 # <3> 
  ) 
```
1. A `testthat` expectation function  
2. The output or behavior being tested  
3. A predefined output or behavior    

#### Running tests

- [x]   **Running tests**: Another `devtools` habit to adopt is regularly writing and running tests. If you're using Posit Workbench and have `devtools` installed, you can test your app-package using the **Build** pane or the keyboard shortcut.

:::{.column-margin}

![Run all tests](img/11_tests_build_pane_test.png){width='100%'}

:::

R Packages, 2ed also [suggests](https://r-pkgs.org/testing-basics.html#run-tests) binding `test_active_file()` and `test_coverage_active_file()` to keyboard shortcuts. I **highly** recommend using a shortcut while developing tests because it will improve your ability to iterate quickly.

::: {layout="[39, -1, 60]" layout-valign="bottom"}

#### Shortcut

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-style: italic; font-size: 0.80em"}

#### Function

[`devtools::test()`]{style="font-weight: bold; font-size: 0.90em"}

:::

::: {layout="[39, -1, 60]" layout-valign="bottom"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>T</kbd>]{style="font-weight: bold; font-style: italic; font-size: 0.80em"} 

[`devtools::test_active_file()`]{style="font-weight: bold; font-size: 0.90em"}

:::

::: {layout="[39, -1, 60]" layout-valign="bottom"}

[<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd>]{style="font-weight: bold; font-style: italic; font-size: 0.80em"} 

[`devtools::test_coverage_active_file()`]{style="font-weight: bold; font-size: 0.90em"}

:::


When the test is run, you'll see feedback on whether it passes or fails (and occasionally some encouragement):

```{r}
#| eval: true
#| code-fold: false
#| echo: true 
#| collapse: true
test_that("multiplication works", { 
  expect_equal( 
    object = 2 * 2, 
    expected = 4 
    ) 
})
```

In the sections below, I'll introduce several example tests using `testthat`'s BDD functions. Hopefully the following sections convey how versatile and expressive these functions can be (or they inspire you to properly implement what I'm attempting to do in your own app-packages).

## Behavior-driven development

Behavior-driven development (BDD) (or behavior-driven testing) emphasizes writing human-readable descriptions of the application's behavior, which are then converted into a series of tests.

> "*[BDD] encourages teams to use conversation and concrete examples to formalize a shared understanding of how the application should behave.*" - Behavior-driven development, Wikipedia[^tests-bdd-read-more]

We can apply BDD is easier by combining the contents of our traceability matrix with `testthat`'s `describe()` and `it()` functions.

[^tests-bdd-read-more]: Read more about [behavior-driven development](https://en.wikipedia.org/wiki/Behavior-driven_development)

### [`describe()`]{style="font-size: 0.95em;"} a feature

The `testthat::describe()` function follows a BDD format and '*specifies a larger component or function and contains a set of specifications*'

In `describe()`, we can use the language from our traceability matrix to reference the feature I'm testing in the `description` argument (**FE1**):

```{r}
#| eval: false 
#| code-fold: false
testthat::describe(
  description = "FE1: interactive scatter plot (two data sources, drop-down variable options",
  code = {
  
})
```

We can nest `describe()` functions, which means we could also include the user specification that precedes the feature in the traceability matrix: 

```{r}
#| eval: false 
#| code-fold: false
testthat::describe("US1: scatter plot data visualization", # <1>
  code = { 
  
  testthat::describe("FE1: interactive scatter plot (two data sources, drop-down variable options)", # <2>
    code = { # <2>
    # <2>
  }) # <2>
  
}) # <1>
```
1. User specification     
2. Feature requirement   

### Confirm [`it()`]{style="font-size: 0.95em;"} with a test

Inside `describe()`, we can include multiple `it()` blocks which "*functions as a test and is evaluated in its own environment.*" 

In the example below, I use an `it()` block to test the first functional requirement:[^tests-it-blocks]

```{r}
#| eval: false 
#| code-fold: false
  testthat::describe("FR1: data source", # <1>
    code = { 
    
    testthat::it("T1: data source", # <2>
      code = { # <3>
      # test code # <3>
    }) # <2>
    
  }) # <1>
```
1. Functional requirement   
2. Test scope  
3. Test code  

[^tests-it-blocks]: Each [`it()`](https://testthat.r-lib.org/reference/describe.html) block contains the expectations (or what you would traditionally include in `test_that()`).[^tests-bdd-describe] 

[^tests-bdd-describe]: Read more about `describe()` and `it()` in the [`testthat` documentation.](https://testthat.r-lib.org/reference/describe.html)

Preceding each `it()` call with `describe()` has the added benefit of removing any code that exists outside of our tests:

> "*Eliminating (or at least minimizing) top-level code outside of `test_that()` will have the beneficial effect of making your tests more hermetic. This is basically the testing analogue of the general programming advice that it's wise to avoid unstructured sharing of state.*"

If we've created a traceability matrix, nothing is stopping us from using `describe()` and `it()` to scope all the functional requirements: 

```{r}
#| eval: false 
#| code-fold: false
testthat::describe("US1: scatter plot data visualization", # <1>
  code = {
    testthat::describe("FE1: interactive scatter plot (two data sources, drop-down variable options)", # <2>
      code = {
        
      testthat::describe("FR1: data source", code = { # <3>
        testthat::it("T1: data source", # <4>
          code = { # <5>
            # test code # <5>
          }) # <4>
      }) # <3>

      testthat::describe("FR2: user-input updating", code = { # <6>
        testthat::it("T2: user-input updating", code = { # <7>
          # test code # <8>
        }) # <7>
      }) # <6>

      testthat::describe("FR3: color-coded data points", code = { # <9>
        testthat::it("T3: color-coded data points", code = { # <10>
          # test code # <11>
        }) # <10>
      }) # <9>

      testthat::describe("FR4: plot axis, legend & title", code = { # <12>
        testthat::it("T4: plot axis, legend & title", code = { # <13>
          # test code # <14>
        }) # <13>
      }) # <12>
        
    }) # <2>
    
}) # <1>
```
1. User specification scope (**US1**)  
2. Feature scope (**FE1**)  
3. Functional requirement scope (**FR1**)  
4. Test scope (**T1**)   
5. Test code (**T1**)     
6. Functional requirement scope (**FR2**)   
7. Test scope (**T2**)  
8. Test code (**T2**)  
9. Functional requirement scope (**FR3**)  
10. Test scope (**T3**)  
11. Test code (**T3**)  
12. Functional requirement scope (**FR4**)  
13. Test scope (**T4**)  
14. Test code (**T4**) 


Now we can add a **Test** column to the matrix and reference the tests from the `it()` calls:

```{r}
#| label: co_box_bdd_trace_all
#| echo: false
#| code-fold: false
#| include: true
trace_matrix <- tibble::tibble(
  `User Specification` = c(
    "US1: scatter plot data visualization",
    NA_character_,
    NA_character_,
    NA_character_
  ),
  `Feature Requirement` = c(
    "FE1: interactive scatter plot (two data sources, drop-down variable options)",
    NA_character_,
    NA_character_,
    NA_character_
  ),
  `Functional Requirements` = c(
    "FR1: data source",
    "FR2: user-input updating",
    "FR3: color-coded data points",
    "FR4: plot axis, legend & title"
  ),
  Test = c(
    "T1", "T2", "T3", "T4"
  ),
) 
trace_matrix |> 
  gt::gt(auto_align = TRUE) |> 
  gt::sub_missing(
  columns = gt::everything(),
  rows = gt::everything(),
  missing_text = "-"
)
```

`testthat`'s BDD functions provide context and reduce the need to place any code outside of our tests (or in this case, outside of `it()`):

## Recap

In the following sections we're going to cover various tools to improve the tests in your app-package. The overarching goal of these tools is to remove any additional code executed *outside* of your tests (i.e., placed above the call to `test_that()`).[^tests-self-sufficient]

[^tests-self-sufficient]: For more on this topic, consult the ['Self-sufficient tests'](https://r-pkgs.org/testing-design.html#self-sufficient-tests) section in [R Packages, 2ed](https://r-pkgs.org/)


The next section covers two important principles to keep in mind while writing tests for you app-package: 

1. Make sure to clean up any 'leftover' states between test executions  
2. Keep test scope logic defined to a single test (or all tests)

We'll introduce tools to ensure tests follow these principles--fixtures, helpers, and mocks--and introduce `testthat`'s `describe()` and `it()` functions.

